{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/author.jpg","path":"images/author.jpg","modified":0,"renderable":0},{"_id":"source/images/20180127210359151.png","path":"images/20180127210359151.png","modified":0,"renderable":0},{"_id":"source/images/2.png","path":"images/2.png","modified":0,"renderable":0},{"_id":"source/images/3.png","path":"images/3.png","modified":0,"renderable":0},{"_id":"source/images/1.png","path":"images/1.png","modified":0,"renderable":0},{"_id":"source/images/table.png","path":"images/table.png","modified":0,"renderable":0},{"_id":"source/images/mapperxml.png","path":"images/mapperxml.png","modified":0,"renderable":0},{"_id":"source/images/test.png","path":"images/test.png","modified":0,"renderable":0},{"_id":"source/images/vue2.png","path":"images/vue2.png","modified":0,"renderable":0},{"_id":"source/images/vue5.png","path":"images/vue5.png","modified":0,"renderable":0},{"_id":"source/images/vue6.png","path":"images/vue6.png","modified":0,"renderable":0},{"_id":"source/images/vue3.png","path":"images/vue3.png","modified":0,"renderable":0},{"_id":"source/images/vue4.png","path":"images/vue4.png","modified":0,"renderable":0},{"_id":"source/images/vue1.png","path":"images/vue1.png","modified":0,"renderable":0},{"_id":"source/images/String1.png","path":"images/String1.png","modified":0,"renderable":0},{"_id":"source/images/DomaticBind.png","path":"images/DomaticBind.png","modified":0,"renderable":0},{"_id":"source/images/stack.png","path":"images/stack.png","modified":0,"renderable":0},{"_id":"source/images/shiro2.png","path":"images/shiro2.png","modified":0,"renderable":0},{"_id":"source/images/WechatIMG11.jpeg","path":"images/WechatIMG11.jpeg","modified":0,"renderable":0},{"_id":"source/images/shiro1.png","path":"images/shiro1.png","modified":0,"renderable":0},{"_id":"source/images/1578470657291.jpg","path":"images/1578470657291.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1577160919726},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1577160919726},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1577160919727},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1577160919727},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1577160919726},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1577160919732},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1577159630439},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1577160919727},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1577160919727},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1577160919727},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1577160919727},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1577160919727},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1577160919727},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1577160919728},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1577160919728},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1577160919728},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1577160919728},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1577160919728},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1577160919733},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1577160919728},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1577160919732},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1577160919732},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1577160919732},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1577160919732},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1577160919731},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1577160919731},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1577160919731},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1577160919731},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1577160919731},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1577160919731},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1577160919731},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1577160919731},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1577160919728},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1577160919729},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1577160919729},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1577160919729},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1577160919729},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1577160919729},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1577160919729},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1577160919729},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1577160919729},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1577160919730},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1577160919730},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1577160919733},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1577160919750},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1577160919751},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1577160919757},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1577160919751},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1577160919752},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1577160919751},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1577160919754},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1577160919752},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1577160919752},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1577160919755},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1577160919737},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1577160919757},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1577160919730},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1577160919730},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1577160919730},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1577160919730},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1577160919730},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1577160919730},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1577160919733},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1577160919733},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1577160919733},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1577160919734},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1577160919734},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1577160919735},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1577160919735},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1577160919735},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1577160919735},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1577160919735},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1577160919736},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1577160919737},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1577160919739},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1577160919740},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1577160919753},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1577160919753},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1577160919746},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1577160919753},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1577160919753},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1577160919754},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1577160919754},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1577160919745},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1577160919744},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1577160919750},{"_id":"public/2019/12/24/hello-world/index.html","hash":"fe0685d8397c8a18cd272b034decff57bb257809","modified":1577163273637},{"_id":"public/index.html","hash":"64677ced1b1503311b2b472823fba506941a0ac1","modified":1578648180090},{"_id":"public/archives/index.html","hash":"e4f1aaddc8662ce0d9f78a973f0db46f90de3af8","modified":1578648180090},{"_id":"public/archives/2019/index.html","hash":"143803d7b0f8f4e97239c5b3f0c96a8c2fbc6f91","modified":1578648180090},{"_id":"public/archives/2019/12/index.html","hash":"f1cf2a0ae98bf32322de913eb3cd572c7a8ed111","modified":1578648180090},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1577163273637},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1577163273637},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1577163273637},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1577163273637},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1577163273637},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1577163273637},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1577163273637},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1577163273637},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1577163273637},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1577163273637},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1577163273637},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1577163273637},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1577163273637},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1577163273637},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1577163273637},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1577163273637},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1577163273637},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1577163273637},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1577163273637},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1577163273637},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1577163273637},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1577163273637},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1577163273637},{"_id":"source/.DS_Store","hash":"46fa8f3199042d5bf89b2ec46c81ddf3e67c291a","modified":1578646774439},{"_id":"source/_posts/.DS_Store","hash":"6e70220de008d19d09974d06d9aa60baae1a40d8","modified":1578645889889},{"_id":"source/_posts/LoonyCoderBlog.md","hash":"1e6fb2c0e02d3749a6c586bd71a408dd79fec5af","modified":1577171599263},{"_id":"public/2019/12/24/LoonyCoderBlog/index.html","hash":"5ed753047678340ba9a98de7807ada96dee467c6","modified":1577174023888},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1577167056866},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1577167056866},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1577167056866},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1577167056866},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1577167056867},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1577167056867},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1577167056867},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1577167056867},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1577167056867},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1577167056867},{"_id":"themes/next/README.cn.md","hash":"263b74f1ac7c0f6f9424b8cced4b0b320ae61efc","modified":1577167056867},{"_id":"themes/next/_config.yml","hash":"482bff2d1cad1ef15f9e1cfae6cdb56a0c01c21a","modified":1578046130982},{"_id":"themes/next/README.md","hash":"287c7e6b7a6ddf75d815dda0df8bd228e3f285c5","modified":1577167056867},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1577167056868},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1577167056868},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1577167056884},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1577167056866},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1577167056866},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1577167056866},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1577167056866},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1577167056868},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1577167056868},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1577167056868},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1577167056868},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1577167056869},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1577167056869},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1577167056869},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1577167056869},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1577167056869},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1577167056869},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1577167056869},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1577167056869},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1577167056869},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f9f0ba24ffaa0028245de3da9525958d6715281c","modified":1577253520909},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1577167056869},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1577167056870},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1577167056870},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1577167056878},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1577167056878},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1577167056878},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1577167056878},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1577167056885},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1577167056878},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1577167056878},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1577167056879},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1577167056886},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1577167056940},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1577167056940},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1577167056940},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056905},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1577167056870},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1577167056870},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1577167056870},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1577167056870},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1577167056871},{"_id":"themes/next/layout/_macro/post.swig","hash":"b152ca6819b5ab126e39ba0d087638206cec8ec4","modified":1578128920555},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1577167056871},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1577167056871},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1577167056871},{"_id":"themes/next/layout/_partials/footer.swig","hash":"2b1aedc521b7cc12bf7a76a6cacfef781f453e3d","modified":1578046000214},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1577167056871},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1577167056872},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1577167056872},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1577167056872},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1577167056872},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1577167056873},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1577167056873},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1577167056874},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1577167056876},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1577167056876},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1577167056876},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1577167056877},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1577167056877},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1577167056877},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1577167056877},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1577167056886},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1577167056886},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1577167056887},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1577167056887},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1577167056887},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1577167056887},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1577167056888},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1577167056888},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1577167056888},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1577167056905},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1577167056905},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1577167056905},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1577167056905},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1577167056905},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1577167056905},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1577167056906},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1577167056906},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1577167056906},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1577167056906},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1577167056907},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1577167056906},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1577167056907},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1577167056907},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1577167056908},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1577167056908},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1577167056908},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1577167056908},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1577167056909},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1576588786000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1576588786000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056899},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056900},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056900},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056904},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056905},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1577167056872},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1577167056872},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1577167056872},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1577167056872},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1577167056872},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1577167056872},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1577167056872},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1577167056873},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1577167056873},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1577167056873},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1576588786000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1576588786000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1577167056874},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1577167056874},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1577167056874},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1577167056874},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1577167056874},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1577167056874},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1577167056875},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1577167056875},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1577167056875},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1577167056876},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1577167056877},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1577167056878},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1577167056878},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1577167056878},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"0f1cd21d5770e75518da48140a376e39e9ca6a97","modified":1578045222236},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1577167056900},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1577167056899},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1577167056900},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1577167056903},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1577167056904},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1577167056904},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1577167056904},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1577167056909},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1577167056909},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1577167056909},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1577167056909},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1577167056910},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1577167056910},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1577167056910},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1577167056910},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1577167056911},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1577167056912},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1577167056912},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1577167056917},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1577167056918},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1577167056915},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1577167056918},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1577167056921},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1577167056921},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1577167056921},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1577167056922},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1577167056922},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1577167056922},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1577167056922},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1577167056922},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1577167056921},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1577167056931},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1577167056931},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1577167056931},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1577167056932},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1577167056932},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1577167056932},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1577167056932},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1577167056933},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1577167056932},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1577167056933},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1577167056934},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1577167056935},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1577167056935},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1577167056935},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1577167056938},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1577167056939},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1577167056938},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1577167056939},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1577167056939},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1577167056931},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1577167056877},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1577167056877},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1577167056896},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1577167056898},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1577167056899},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1577167056899},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1577167056899},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1577167056899},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1577167056899},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1577167056899},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1577167056900},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1577167056900},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1577167056900},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1577167056900},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1577167056900},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3cf08d36232790e0470c9411c93eb1a1b1bd47ac","modified":1577174013887},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1577167056902},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1577167056911},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1577167056914},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1577167056913},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1577167056914},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1577167056920},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1577167056920},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1577167056920},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1577167056921},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1577167056921},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1577167056922},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1577167056923},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1577167056923},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1577167056937},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1577167056938},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1577167056914},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1577167056931},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1577167056939},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1577167056890},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1577167056890},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1577167056890},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1577167056890},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1577167056890},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1577167056891},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1577167056891},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1577167056891},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1577167056891},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1577167056891},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1577167056898},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1577167056902},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1577167056912},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1577167056912},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1577167056913},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1577167056913},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1577167056913},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1577167056919},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1577167056925},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1577167056929},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1577167056930},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1577167056926},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1577167056917},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1577167056937},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1577167056928},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1577167173083},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1577167173083},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1577167173083},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1577167173083},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1577167173083},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1577167173083},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1577167173083},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1577167173083},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1577167173083},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1577167173083},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1577167173083},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1577167173083},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1577167173083},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1577167173083},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1577167173083},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1577167173083},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1577167173083},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1577167173083},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1577167173083},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1577167173083},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1577167173083},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1577167173083},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1577167173083},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1577167173083},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1577167173083},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1577167173083},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1577167173083},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1577167173083},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1577167173083},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1577167173083},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1577167173083},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1577167173083},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1577167173083},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1577167173083},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1577167173083},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1577167173083},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1577167173083},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1577167173083},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1577167173083},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1577167173083},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1577167173083},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1577167173083},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1577167173083},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1577167173083},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1577167173083},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1577167173083},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1577167173083},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1577167173083},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1577167173083},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1577167173083},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1577167173083},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1577167173083},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1577167173083},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1577167173083},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1577167173083},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1577167173083},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1577167173083},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1577167173083},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1577167173083},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1577167173083},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1577167173083},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1577167173083},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1577167173083},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1577167173083},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1577167173083},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1577167173083},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1577167173083},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1577167173083},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1577167173083},{"_id":"public/lib/fastclick/README.html","hash":"b9e008af0866799103e596e2eda466a33d7dde18","modified":1577167173083},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"7eecc5e472416b9870580c53b7ed0c44474ed23a","modified":1577167173083},{"_id":"public/lib/jquery_lazyload/README.html","hash":"9c91bba4263a20004f2c10772d438cfa8312c308","modified":1577167173083},{"_id":"public/css/main.css","hash":"19b5e6767722577f889817bb048290cc989afe79","modified":1577167173083},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1577167173083},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1577167173083},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1577167173083},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1577167173083},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1577167173083},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1577167173083},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1577167173083},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1577167173083},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1577167173083},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1577167173083},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1577167173083},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1577167173083},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1577167173083},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1577167173083},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1577167173083},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1577167173083},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1577167173083},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1577167173083},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1577167173083},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1577167173083},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1577167173083},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1577167173083},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1577167173083},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1577167173083},{"_id":"themes/next/.DS_Store","hash":"72e190436ade083ff7f1539d627907a66d810757","modified":1578128865522},{"_id":"source/_posts/index.md","hash":"60369bd241e1e4d7538ae59b7f2bb3393b01c221","modified":1577175558143},{"_id":"themes/next/layout/.DS_Store","hash":"559387122597bbb38f733e864cf7595687a19920","modified":1578128877983},{"_id":"themes/next/source/.DS_Store","hash":"5d0cf79e65b50c60c54dd91f93d1068d1bb2a610","modified":1578128792965},{"_id":"public/2019/12/24/index/index.html","hash":"030e229432d4489fb3148489767b0f4c29f651da","modified":1577241719248},{"_id":"themes/next/layout/_scripts/.DS_Store","hash":"137b2b33df29f70c89991676eaa273572ab43828","modified":1578043972986},{"_id":"themes/next/source/css/.DS_Store","hash":"af3d9ae91208593aaeb2cae2b2548cef7afe9610","modified":1578128792964},{"_id":"themes/next/source/css/_schemes/.DS_Store","hash":"69cb863623e9e0a400e75e37175cd1b0877e4fea","modified":1577174282939},{"_id":"themes/next/source/css/_schemes/Muse/.DS_Store","hash":"d16a403c0d7ebc16e6589ed78ab6d7498c11a43a","modified":1577173807827},{"_id":"themes/next/source/css/_schemes/Mist/.DS_Store","hash":"94694524b02635304624ed506d64ebd71164a579","modified":1577174270266},{"_id":"source/_posts/blog.md","hash":"5c3da39ac9ec83c68f1fd5fc97d489d990c29267","modified":1577244811687},{"_id":"public/2019/12/24/blog/index.html","hash":"ed81b862596a9cf18eb9a7217d9d634e2dad7df0","modified":1577245069818},{"_id":"source/_posts/about/index.md","hash":"60369bd241e1e4d7538ae59b7f2bb3393b01c221","modified":1577175558143},{"_id":"public/2019/12/24/about/index/index.html","hash":"32afe66b9fbd3d50dc08d03b0bf8396d3e771ae5","modified":1577240791418},{"_id":"source/_posts/index/.DS_Store","hash":"881857a47ee12476811d89432479c1c00026259b","modified":1577240778444},{"_id":"source/_posts/about/.DS_Store","hash":"a906525de297e8b40766c156e6b9aa874c5ffa79","modified":1577240720589},{"_id":"source/_posts/index/blog.md","hash":"1e6fb2c0e02d3749a6c586bd71a408dd79fec5af","modified":1577171599263},{"_id":"public/2019/12/24/index/blog/index.html","hash":"ae813f568fa15d241af673259655e92ac1f80abf","modified":1577240791418},{"_id":"source/about/.DS_Store","hash":"a906525de297e8b40766c156e6b9aa874c5ffa79","modified":1577240720589},{"_id":"source/about/index.md","hash":"62004f50b75976b16efaa0927ed3c89c2cd9dd0e","modified":1577244549327},{"_id":"source/index/blog.md","hash":"1e6fb2c0e02d3749a6c586bd71a408dd79fec5af","modified":1577171599263},{"_id":"source/index/.DS_Store","hash":"881857a47ee12476811d89432479c1c00026259b","modified":1577240778444},{"_id":"public/about/index.html","hash":"e1346b115a252b08c407144d379b0de22fcc093d","modified":1578648180090},{"_id":"public/index/blog.html","hash":"e0b6b86369ef918de7646677b79c581472587e4e","modified":1577241719248},{"_id":"source/_posts/blog2_index.md","hash":"9d106aff94c2d00bec0ef9950fa2af3e0741b4d3","modified":1577708611886},{"_id":"source/_posts/blog_index.md","hash":"54b0172c2f9f3082b5a964763f19c793db7158a8","modified":1577708430769},{"_id":"public/2019/12/24/blog2_index/index.html","hash":"1f387df7d54add3b6fd00e120c88a663f051f91a","modified":1577708365996},{"_id":"public/2019/12/24/blog_index/index.html","hash":"63518d0c447fd5867e1c9a298b10aebd951412d9","modified":1577708544285},{"_id":"source/categories/blog_index.md","hash":"32a651c3bfd5a3de19ed2eaf79dcc97501e8fbfc","modified":1577246083571},{"_id":"source/categories/index.md","hash":"e9e615282832f88d8f4750494baa0cb0e8b3e023","modified":1577254032125},{"_id":"source/tags/index.md","hash":"10386ed21a0554d390c73e5425d86f146fe2bd24","modified":1577254440531},{"_id":"source/tags/blog_index.md","hash":"32a651c3bfd5a3de19ed2eaf79dcc97501e8fbfc","modified":1577246083571},{"_id":"source/tags/.DS_Store","hash":"45673a8ec47535550c1655fb6f129816c4bf94f9","modified":1577249074694},{"_id":"public/categories/index.html","hash":"429f49c6c81cf2ff0baee162fcdcb8c96ddc94ef","modified":1578648180090},{"_id":"public/tags/index.html","hash":"074e99b14744cbecd119fe02258671adb65be9fd","modified":1578648180090},{"_id":"public/categories/blog_index.html","hash":"a056fa3f12b722544d4709394a472d4347b11917","modified":1577249095275},{"_id":"public/tags/blog_index.html","hash":"fa3e16b1b2b1e62349ae8a62d355cea981b052d7","modified":1577249095275},{"_id":"source/categories/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1577249180368},{"_id":"public/2019/12/25/blog2_index/index.html","hash":"c7964eb2cfdf2301490ee0b895aa916d32e59c3d","modified":1577708634354},{"_id":"public/categories/web前端/index.html","hash":"768ec1fce19d3b7f29c8a1e0b6deef7b9f6758cc","modified":1577708544285},{"_id":"public/tags/web/index.html","hash":"59382b7e3b8024fd075f0d40d6f9797ccc1d2880","modified":1577708544285},{"_id":"public/tags/hexo/index.html","hash":"10359e7e25fdd5bfca532b64cb44c6dd7215b1d0","modified":1577708544285},{"_id":"public/tags/github/index.html","hash":"671dd3a4c4f1a78d06255c22704193294417527a","modified":1577708544285},{"_id":"source/images/author.jpg","hash":"bf13ddca01c2e6aec062848c81aa256f3a45c8b9","modified":1577255793277},{"_id":"public/images/author.jpg","hash":"bf13ddca01c2e6aec062848c81aa256f3a45c8b9","modified":1577256016811},{"_id":"source/_posts/JavaBasic.md","hash":"f4dc36d6c4182994f6611c6ede208ad3c9e70b5e","modified":1578128942196},{"_id":"source/images/20180127210359151.png","hash":"b328ce766e5d959221b06df896ae2d2559e961ac","modified":1577705348278},{"_id":"public/categories/Java/index.html","hash":"1d5c808a9515cc2f03bebd62caf6694a6cd4457e","modified":1578648180090},{"_id":"public/tags/Java/index.html","hash":"0e6c87a8023f69e4cfe6916c7785474bfe90b40d","modified":1578648180090},{"_id":"public/tags/Java基础/index.html","hash":"1686e2bb16ddab6165bc784fcb222e8a50131a0a","modified":1578648180090},{"_id":"public/2019/12/24/JavaBasic/index.html","hash":"42ee62862d01d5f919dec985218139126b9c76d6","modified":1577708365996},{"_id":"public/images/20180127210359151.png","hash":"b328ce766e5d959221b06df896ae2d2559e961ac","modified":1577708123240},{"_id":"public/2019/12/30/JavaBasic/index.html","hash":"b47d528b358968ded923935e4703cb11ff88ee92","modified":1578302681339},{"_id":"source/_posts/MybatisDemo.md","hash":"2b384ebf9663ed19b5b52d7f3871cad4bea80ff1","modified":1578648162320},{"_id":"source/images/2.png","hash":"813b2e528a9395cdd427da48a5ce2a0d3b830a6c","modified":1578041694100},{"_id":"source/images/3.png","hash":"2aa599677842864f1c5d006393a7cd8bb44ea174","modified":1578041708744},{"_id":"source/images/1.png","hash":"dbaa036550e513533d58e64467adb126c6875146","modified":1578041671922},{"_id":"source/images/test.png","hash":"2b4606ba3e36b0bb37dd46cdaf830fb48d43c217","modified":1578043236266},{"_id":"source/images/mapperxml.png","hash":"9db12bf3362ac599f886a4979465ab915f8b6c9f","modified":1578042997488},{"_id":"source/images/table.png","hash":"2677c09ef110a2eb201e6f5b59423a78da3b093c","modified":1578042157595},{"_id":"public/categories/Java/数据库/index.html","hash":"1bcd1eb80f2d91fbf0b3ebdc54516fe2b5d9475b","modified":1578646612232},{"_id":"public/archives/2019/01/index.html","hash":"da77aa2c51ce3ecec9b467b90e42479e088088fd","modified":1578043544355},{"_id":"public/tags/Java框架/index.html","hash":"4cf5e20ca0d97c0ddf458dd3e26d980083f4f460","modified":1578646612232},{"_id":"public/2019/01/03/MybatisDemo/index.html","hash":"76d6da589a0dbbef61d4af5a680d18fbed98fb02","modified":1578043544355},{"_id":"public/images/2.png","hash":"813b2e528a9395cdd427da48a5ce2a0d3b830a6c","modified":1578043544355},{"_id":"public/images/test.png","hash":"2b4606ba3e36b0bb37dd46cdaf830fb48d43c217","modified":1578043544355},{"_id":"public/images/mapperxml.png","hash":"9db12bf3362ac599f886a4979465ab915f8b6c9f","modified":1578043544355},{"_id":"public/images/3.png","hash":"2aa599677842864f1c5d006393a7cd8bb44ea174","modified":1578043544355},{"_id":"public/images/1.png","hash":"dbaa036550e513533d58e64467adb126c6875146","modified":1578043544355},{"_id":"public/images/table.png","hash":"2677c09ef110a2eb201e6f5b59423a78da3b093c","modified":1578043544355},{"_id":"public/archives/2020/01/index.html","hash":"e13e7165c1a88a19c6be3147208e0615414d2d63","modified":1578648180090},{"_id":"public/archives/2020/index.html","hash":"6f225cd04411833dc91f31c348722b287f1ace76","modified":1578648180090},{"_id":"public/2020/01/03/MybatisDemo/index.html","hash":"a52f349498b81f5fe11d9a00a0e35d91d66a687b","modified":1578648180090},{"_id":"themes/next/scripts/.DS_Store","hash":"c23e8992957e272a90ddbb470965ec82706443ce","modified":1578128439635},{"_id":"source/_posts/Vue.md","hash":"7f7987b7859756aaf6dc51dabc366a0e4ce2ae32","modified":1578647633045},{"_id":"source/images/vue2.png","hash":"243d7ccf2b2a0162218d269f2ae5c9a0ba7a0229","modified":1578278602307},{"_id":"source/images/vue5.png","hash":"c83cb6f0dac95e114a5b2707452ace8ea4ff034e","modified":1578278922750},{"_id":"source/images/vue6.png","hash":"7f16bda0e86a7497ad8cf8b151061f4a0e83bbac","modified":1578279674830},{"_id":"source/images/vue3.png","hash":"0891de9363a546dd806f5e5fe837d3082a27565b","modified":1578278655753},{"_id":"source/images/vue4.png","hash":"1f7e4ea318bc779b25bf441aef2d7f257f4363cb","modified":1578278769965},{"_id":"source/images/vue1.png","hash":"3f8b94381119e0e93753bae326c2eb500f2333a0","modified":1578278367933},{"_id":"public/2020/01/06/Vue/index.html","hash":"477f938d5934e76f6c7313c80b7806b08a25ebc6","modified":1578648180090},{"_id":"public/tags/前端框架/index.html","hash":"e099ab478b3c06ff0989a275e6cbb48a5100e774","modified":1578648180090},{"_id":"public/categories/Web前端/index.html","hash":"9dcd79c25fa38c1748dc1bf289c2d73ec0e307e6","modified":1578648180090},{"_id":"public/images/vue2.png","hash":"243d7ccf2b2a0162218d269f2ae5c9a0ba7a0229","modified":1578281381124},{"_id":"public/images/vue5.png","hash":"c83cb6f0dac95e114a5b2707452ace8ea4ff034e","modified":1578281381124},{"_id":"public/images/vue6.png","hash":"7f16bda0e86a7497ad8cf8b151061f4a0e83bbac","modified":1578281381124},{"_id":"public/images/vue3.png","hash":"0891de9363a546dd806f5e5fe837d3082a27565b","modified":1578281381124},{"_id":"public/images/vue4.png","hash":"1f7e4ea318bc779b25bf441aef2d7f257f4363cb","modified":1578281381124},{"_id":"public/images/vue1.png","hash":"3f8b94381119e0e93753bae326c2eb500f2333a0","modified":1578281381124},{"_id":"source/_posts/JavaBasic2.md","hash":"68632d2f3d9c4e96a77ced328d89d764be9f246b","modified":1578647512485},{"_id":"source/images/String1.png","hash":"afc6a1eaabbf745686d9da1572fd7bbb842dcb70","modified":1578303346593},{"_id":"source/images/DomaticBind.png","hash":"cd7fbcd97376eafbb224edcadb690799f45c645c","modified":1578304386792},{"_id":"source/images/stack.png","hash":"44730d0212fada434d90c74a9d91a9e8f882962b","modified":1578303662507},{"_id":"source/_posts/JavaBasic1.md","hash":"9f0267cb007374fc6b2e69ac941e92f9e0981423","modified":1578647397953},{"_id":"public/2019/12/30/JavaBasic2/index.html","hash":"7967e1d5eb3a07264e93611a694176fd187ce230","modified":1578648180090},{"_id":"public/2019/12/30/JavaBasic1/index.html","hash":"a5b5e0e03362193f0f0d7ce3e5b843ab3a3376e4","modified":1578648180090},{"_id":"public/images/String1.png","hash":"afc6a1eaabbf745686d9da1572fd7bbb842dcb70","modified":1578304725057},{"_id":"public/images/DomaticBind.png","hash":"cd7fbcd97376eafbb224edcadb690799f45c645c","modified":1578304725057},{"_id":"public/images/stack.png","hash":"44730d0212fada434d90c74a9d91a9e8f882962b","modified":1578304725057},{"_id":"source/_posts/Shiro.md","hash":"ebc909035be0fd5d34a95aa7a5934f78911d3a4a","modified":1578647025726},{"_id":"source/images/shiro2.png","hash":"4f6181f77ddcb81619083bf96f57e85d80b39977","modified":1578646168070},{"_id":"source/images/WechatIMG11.jpeg","hash":"12b419a93c81473f9dcdbb23fdd68603d3e88656","modified":1578558608032},{"_id":"source/images/shiro1.png","hash":"5dcb3a6002f3005145da796cd6926a14f0358187","modified":1578646110972},{"_id":"source/images/1578470657291.jpg","hash":"333c926024e652c8a218b23c6035d85d48b1687d","modified":1578470681205},{"_id":"public/categories/Java框架/index.html","hash":"29ae73b6376796e6d4c84b8013298a062937920e","modified":1578648180090},{"_id":"public/tags/框架/index.html","hash":"33b6932ce7ab449c625d777824545f0b690e1509","modified":1578648180090},{"_id":"public/tags/权限框架/index.html","hash":"5a99e9effd7259f7fea4424b4e6e033d78b88af0","modified":1578648180090},{"_id":"public/2020/01/10/Shiro/index.html","hash":"041a7fe80bf6ebc01de1f8006331f65f9ba67a74","modified":1578648180090},{"_id":"public/images/shiro1.png","hash":"5dcb3a6002f3005145da796cd6926a14f0358187","modified":1578646612232},{"_id":"public/images/shiro2.png","hash":"4f6181f77ddcb81619083bf96f57e85d80b39977","modified":1578646612232},{"_id":"public/images/WechatIMG11.jpeg","hash":"12b419a93c81473f9dcdbb23fdd68603d3e88656","modified":1578646612232},{"_id":"public/images/1578470657291.jpg","hash":"333c926024e652c8a218b23c6035d85d48b1687d","modified":1578646612232},{"_id":"public/tags/Java框架-数据库/index.html","hash":"af3d4c4b49150cab0569a62b432d647fc936165c","modified":1578648180090}],"Category":[{"name":"web前端","_id":"ck4kwcxvg0001yt6k246pfyf4"},{"name":"Java","_id":"ck4seojjv0001h7s67lt40541"},{"name":"数据库","parent":"ck4seojjv0001h7s67lt40541","_id":"ck4xxfhf90002fs6kd64f4nma"},{"name":"Web前端","_id":"ck51vzg8z0001f96k47kf92dq"},{"name":"Java框架","_id":"ck57xfmeb0001d36kf2xdg6sh"}],"Data":[],"Page":[{"title":"序","date":"2019-12-24T06:40:40.000Z","tags":null,"_content":"\n<p style=\"text-align: center\">\n[喜欢数学和敲代码]\n</p>\n<p style=\"text-align: center\">\n[对新技术十分狂热]\n</p>\n<p style=\"text-align: center\">\n[有严重的代码洁癖]\n</p>\n<p style=\"text-align: center\">\n[2018年毕业的菜鸡]\n</p>\n<p style=\"text-align: center\">\n[初级Java开发工程师]\n</p>\n<p style=\"text-align: center\">\n[qq：212704353]\n</p>\n\n\n\n\n","source":"about/index.md","raw":"---\ntitle: 序\ndate: 2019-12-24 14:40:40\ntags: \n---\n\n<p style=\"text-align: center\">\n[喜欢数学和敲代码]\n</p>\n<p style=\"text-align: center\">\n[对新技术十分狂热]\n</p>\n<p style=\"text-align: center\">\n[有严重的代码洁癖]\n</p>\n<p style=\"text-align: center\">\n[2018年毕业的菜鸡]\n</p>\n<p style=\"text-align: center\">\n[初级Java开发工程师]\n</p>\n<p style=\"text-align: center\">\n[qq：212704353]\n</p>\n\n\n\n\n","updated":"2019-12-25T03:29:09.327Z","path":"about/index.html","_id":"ck4kom6ao00006r6k1yzn2wgg","comments":1,"layout":"page","content":"<p style=\"text-align: center\">\n[喜欢数学和敲代码]\n</p>\n<p style=\"text-align: center\">\n[对新技术十分狂热]\n</p>\n<p style=\"text-align: center\">\n[有严重的代码洁癖]\n</p>\n<p style=\"text-align: center\">\n[2018年毕业的菜鸡]\n</p>\n<p style=\"text-align: center\">\n[初级Java开发工程师]\n</p>\n<p style=\"text-align: center\">\n[qq：212704353]\n</p>\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p style=\"text-align: center\">\n[喜欢数学和敲代码]\n</p>\n<p style=\"text-align: center\">\n[对新技术十分狂热]\n</p>\n<p style=\"text-align: center\">\n[有严重的代码洁癖]\n</p>\n<p style=\"text-align: center\">\n[2018年毕业的菜鸡]\n</p>\n<p style=\"text-align: center\">\n[初级Java开发工程师]\n</p>\n<p style=\"text-align: center\">\n[qq：212704353]\n</p>\n\n\n\n\n"},{"title":"分类","date":"2019-12-25T06:05:28.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-12-25 14:05:28\ntype: \"categories\"\n---\n","updated":"2019-12-25T06:07:12.125Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck4kwcxv70000yt6kfhss6vnq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-12-25T06:13:27.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-12-25 14:13:27\ntype: \"tags\"\n---\n","updated":"2019-12-25T06:14:00.531Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck4kwl2zd0000356kgcuf5wqj","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Mybatis入门及搭建","date":"2020-01-02T16:00:00.000Z","_content":"\n很早之前看过Mybatis视频，但是无奈工作中没有用到，当自己练习搭建的时候发现问题很多，所以这次准备重新研究一下，一点点搭建Mybatis框架。\n\n---\n\n### 一、准备工作\n\n因为Mybatis是持久层框架，所以在此之前我们要做一些准备工作，首先我们要在Mysql中建好表并插入数据。\n此处的sql我就不提供了，我都是用navicat手动插入的。\n\n如图：\n![建表](/images/table.png)\n\n### 二、新建项目\n\n我们这里要新建一个maven项目。\n![创建Maven项目](/images/1.png)\n\n![创建Maven项目](/images/2.png)\n\n![创建Maven项目](/images/3.png)\n\n创建完成之后，我们打开pom.xml文件引入依赖。\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.loonycoder</groupId>\n    <artifactId>MybatisDemo</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <packaging>jar</packaging>\n    <dependencies>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.4.4</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.6</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n---\n\n### 三、创建表对象的映射实体类\n\n因为mybatis是一个ORM（Object Relational Mapping）框架，所以我们要准备一个和表字段一一对应的实体类。\n\n**注意**：\n**表中的字段名和实体类中的字段名字一定要一致！**\n**实体类一定要实现Serializable接口**\n\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\npublic class User implements Serializable {\n    private Integer id;\n    private String username;\n    private Date birthday;\n    private String address;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", birthday=\" + birthday +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n\n```\n\n--- \n\n### 四、新建dao接口\n\n这里直接上代码，我在此新建了一个查询所有的方法，此处记住方法名和返回值类型，后续会用到。\n\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.User;\n\nimport java.util.List;\n\npublic interface IUserDao {\n    List<User> findAll();\n}\n\n```\n\n---\n\n### 五、创建mybatis的主配置文件\n\n该配置文件需要放在/resources目录下，配置文件的名称在具有规范性的前提下是随意起的，我这里采用了默认的规范(我发现很多人都这么起)\n\nSqlMapConfig.xml\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<!--mybatis的主配置文件-->\n<configuration>\n    <!--配置环境-->\n    <environments default=\"mysql\">\n        <!--配置mysql的环境-->\n        <environment id=\"mysql\">\n            <!--配置事务类型-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置数据源(连接池)-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\" />\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/MybatisDemo/\" />\n                <property name=\"username\" value=\"root\" />\n                <property name=\"password\" value=\"20141016\" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件-->\n    <mappers>\n        <mapper resource=\"com/loonycoder/dao/IUserDao.xml\" />\n    </mappers>\n</configuration>\n```\n\n配置数据源的时候，把url、username、password 修改成你自己的数据库链接、用户名和密码即可。\n\n注意：\n**下方的mapper部分的配置我接下来会讲，后续按照你自己配置的路径配置即可。**\n\n---\n\n### 六、配置mapper文件\n\n前面虽然配置了mybatis主配置文件，但是我们在实际操作中如果存在多个对象的dao接口，主配置文件需要怎么准确找到该接口呢？\n我们就需要为每个dao配置一个独立的配置文件\n我习惯上把文件命名成 **xxxMapper.xml**，这里命名成xxxDao.xml是为了方便理解。\n文件存放目录为/resources目录下，与实体对象dao接口的包同级。\n![xml文件配置](/images/mapperxml.png)\n\n代码如下：\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace需要配置dao的全限定类名-->\n<mapper namespace=\"com.loonycoder.dao.IUserDao\">\n    <!--配置查询所有-->\n    <!--id一定要是方法的名称-->\n    <select id=\"findAll\" resultType=\"com.loonycoder.domain.User\">\n        select * from user;\n    </select>\n</mapper>\n```\n\n---\n\n### 七、引入log4j\n\n这个是可选操作，为了后期记录日志，我们可以采用log4j去实现。此处只是了解。\n将log4j.properties文件放在/resources目录下即可。\n\n```bash\n# Set root category priority to INFO and its only appender to CONSOLE.\n#log4j.rootCategory=INFO,CONSOLE             debug  info  warn  error  fatal\nlog4j.rootCategory=debug, CONSOLE, LOGFILE\n\n# Set the enterprise logger category to FATAL and its only appender to CONSOLE.\nlog4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE\n\n# CONSOLE is set to be a ConsoleAppender using a PatternLayout.\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n\n# LOGFILE is set to be a File appender using a PatternLayout.\nlog.appender.LOGFILE=org.apache.log4j.FileAppender\nlog.appender.LOGFILE.FILE=/usr/gmx/LearnWorkspace\nlog.appender.LOGFILE.Append=true\nlog.appender.LOGFILE.layout=org.apache.log4j.PatternLayout\nlog.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n```\n\n---\n\n### 八、测试案例\n\n如此，我们的mybatis就搭建完成了，我们接下来测试一下。\n在/test/java目录下新建一个test类\n如图：\n![test类](/images/test.png)\n\n代码如下：\n```bash\npackage com.loonycoder;\n\n\nimport com.loonycoder.dao.IUserDao;\nimport com.loonycoder.domain.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\n\nimport java.io.InputStream;\nimport java.util.List;\n\npublic class MybatisTest {\n\n    public static void main(String[] args) throws Exception{\n        //1.读取配置文件\n        InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        //2.创建SqlSessionFactory工厂\n        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);\n        //3.使用工厂创建SqlSession对象\n        SqlSession session = sqlSessionFactory.openSession();\n        //4.使用SqlSession创建dao接口的代理对象\n        IUserDao userDao = session.getMapper(IUserDao.class);\n        //5.使用代理对象执行方法\n        List<User> users= userDao.findAll();\n        for (User user: users) {\n            System.out.println(user);\n        }\n        //6.释放资源\n        session.close();\n        inputStream.close();\n    }\n}\n```\n\n---\n\n我们的第一个Mybatis入门案例就创建完了，但是这种方式还是十分复杂的，因为有太多的配置文件，后续我们会用更简便的注解的方式去实现它。","source":"_posts/MybatisDemo.md","raw":"---\ntitle: Mybatis入门及搭建\ncategories:\n    - Java\n    \ndate: 2020-01-03\ntags:\n\t- Java\n\t- Java框架\n    - 数据库\n\n---\n\n很早之前看过Mybatis视频，但是无奈工作中没有用到，当自己练习搭建的时候发现问题很多，所以这次准备重新研究一下，一点点搭建Mybatis框架。\n\n---\n\n### 一、准备工作\n\n因为Mybatis是持久层框架，所以在此之前我们要做一些准备工作，首先我们要在Mysql中建好表并插入数据。\n此处的sql我就不提供了，我都是用navicat手动插入的。\n\n如图：\n![建表](/images/table.png)\n\n### 二、新建项目\n\n我们这里要新建一个maven项目。\n![创建Maven项目](/images/1.png)\n\n![创建Maven项目](/images/2.png)\n\n![创建Maven项目](/images/3.png)\n\n创建完成之后，我们打开pom.xml文件引入依赖。\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.loonycoder</groupId>\n    <artifactId>MybatisDemo</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <packaging>jar</packaging>\n    <dependencies>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.4.4</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.6</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n---\n\n### 三、创建表对象的映射实体类\n\n因为mybatis是一个ORM（Object Relational Mapping）框架，所以我们要准备一个和表字段一一对应的实体类。\n\n**注意**：\n**表中的字段名和实体类中的字段名字一定要一致！**\n**实体类一定要实现Serializable接口**\n\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\npublic class User implements Serializable {\n    private Integer id;\n    private String username;\n    private Date birthday;\n    private String address;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", birthday=\" + birthday +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n\n```\n\n--- \n\n### 四、新建dao接口\n\n这里直接上代码，我在此新建了一个查询所有的方法，此处记住方法名和返回值类型，后续会用到。\n\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.User;\n\nimport java.util.List;\n\npublic interface IUserDao {\n    List<User> findAll();\n}\n\n```\n\n---\n\n### 五、创建mybatis的主配置文件\n\n该配置文件需要放在/resources目录下，配置文件的名称在具有规范性的前提下是随意起的，我这里采用了默认的规范(我发现很多人都这么起)\n\nSqlMapConfig.xml\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<!--mybatis的主配置文件-->\n<configuration>\n    <!--配置环境-->\n    <environments default=\"mysql\">\n        <!--配置mysql的环境-->\n        <environment id=\"mysql\">\n            <!--配置事务类型-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置数据源(连接池)-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\" />\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/MybatisDemo/\" />\n                <property name=\"username\" value=\"root\" />\n                <property name=\"password\" value=\"20141016\" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件-->\n    <mappers>\n        <mapper resource=\"com/loonycoder/dao/IUserDao.xml\" />\n    </mappers>\n</configuration>\n```\n\n配置数据源的时候，把url、username、password 修改成你自己的数据库链接、用户名和密码即可。\n\n注意：\n**下方的mapper部分的配置我接下来会讲，后续按照你自己配置的路径配置即可。**\n\n---\n\n### 六、配置mapper文件\n\n前面虽然配置了mybatis主配置文件，但是我们在实际操作中如果存在多个对象的dao接口，主配置文件需要怎么准确找到该接口呢？\n我们就需要为每个dao配置一个独立的配置文件\n我习惯上把文件命名成 **xxxMapper.xml**，这里命名成xxxDao.xml是为了方便理解。\n文件存放目录为/resources目录下，与实体对象dao接口的包同级。\n![xml文件配置](/images/mapperxml.png)\n\n代码如下：\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace需要配置dao的全限定类名-->\n<mapper namespace=\"com.loonycoder.dao.IUserDao\">\n    <!--配置查询所有-->\n    <!--id一定要是方法的名称-->\n    <select id=\"findAll\" resultType=\"com.loonycoder.domain.User\">\n        select * from user;\n    </select>\n</mapper>\n```\n\n---\n\n### 七、引入log4j\n\n这个是可选操作，为了后期记录日志，我们可以采用log4j去实现。此处只是了解。\n将log4j.properties文件放在/resources目录下即可。\n\n```bash\n# Set root category priority to INFO and its only appender to CONSOLE.\n#log4j.rootCategory=INFO,CONSOLE             debug  info  warn  error  fatal\nlog4j.rootCategory=debug, CONSOLE, LOGFILE\n\n# Set the enterprise logger category to FATAL and its only appender to CONSOLE.\nlog4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE\n\n# CONSOLE is set to be a ConsoleAppender using a PatternLayout.\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n\n# LOGFILE is set to be a File appender using a PatternLayout.\nlog.appender.LOGFILE=org.apache.log4j.FileAppender\nlog.appender.LOGFILE.FILE=/usr/gmx/LearnWorkspace\nlog.appender.LOGFILE.Append=true\nlog.appender.LOGFILE.layout=org.apache.log4j.PatternLayout\nlog.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n```\n\n---\n\n### 八、测试案例\n\n如此，我们的mybatis就搭建完成了，我们接下来测试一下。\n在/test/java目录下新建一个test类\n如图：\n![test类](/images/test.png)\n\n代码如下：\n```bash\npackage com.loonycoder;\n\n\nimport com.loonycoder.dao.IUserDao;\nimport com.loonycoder.domain.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\n\nimport java.io.InputStream;\nimport java.util.List;\n\npublic class MybatisTest {\n\n    public static void main(String[] args) throws Exception{\n        //1.读取配置文件\n        InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        //2.创建SqlSessionFactory工厂\n        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);\n        //3.使用工厂创建SqlSession对象\n        SqlSession session = sqlSessionFactory.openSession();\n        //4.使用SqlSession创建dao接口的代理对象\n        IUserDao userDao = session.getMapper(IUserDao.class);\n        //5.使用代理对象执行方法\n        List<User> users= userDao.findAll();\n        for (User user: users) {\n            System.out.println(user);\n        }\n        //6.释放资源\n        session.close();\n        inputStream.close();\n    }\n}\n```\n\n---\n\n我们的第一个Mybatis入门案例就创建完了，但是这种方式还是十分复杂的，因为有太多的配置文件，后续我们会用更简便的注解的方式去实现它。","slug":"MybatisDemo","published":1,"updated":"2020-01-10T09:22:42.320Z","_id":"ck4xxfhf10000fs6kdsf267ed","comments":1,"layout":"post","photos":[],"link":"","content":"<p>很早之前看过Mybatis视频，但是无奈工作中没有用到，当自己练习搭建的时候发现问题很多，所以这次准备重新研究一下，一点点搭建Mybatis框架。</p>\n<hr>\n<h3 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h3><p>因为Mybatis是持久层框架，所以在此之前我们要做一些准备工作，首先我们要在Mysql中建好表并插入数据。<br>此处的sql我就不提供了，我都是用navicat手动插入的。</p>\n<p>如图：<br><img src=\"/images/table.png\" alt=\"建表\"></p>\n<h3 id=\"二、新建项目\"><a href=\"#二、新建项目\" class=\"headerlink\" title=\"二、新建项目\"></a>二、新建项目</h3><p>我们这里要新建一个maven项目。<br><img src=\"/images/1.png\" alt=\"创建Maven项目\"></p>\n<p><img src=\"/images/2.png\" alt=\"创建Maven项目\"></p>\n<p><img src=\"/images/3.png\" alt=\"创建Maven项目\"></p>\n<p>创建完成之后，我们打开pom.xml文件引入依赖。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;project xmlns=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span></span><br><span class=\"line\">         xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">         xsi:schemaLocation=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;groupId&gt;com.loonycoder&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;MybatisDemo&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;3.4.4&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"三、创建表对象的映射实体类\"><a href=\"#三、创建表对象的映射实体类\" class=\"headerlink\" title=\"三、创建表对象的映射实体类\"></a>三、创建表对象的映射实体类</h3><p>因为mybatis是一个ORM（Object Relational Mapping）框架，所以我们要准备一个和表字段一一对应的实体类。</p>\n<p><strong>注意</strong>：<br><strong>表中的字段名和实体类中的字段名字一定要一致！</strong><br><strong>实体类一定要实现Serializable接口</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\">public class User implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private String username;</span><br><span class=\"line\">    private Date birthday;</span><br><span class=\"line\">    private String address;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(Integer id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getUsername</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUsername(String username) &#123;</span><br><span class=\"line\">        this.username = username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date <span class=\"function\"><span class=\"title\">getBirthday</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setBirthday(Date birthday) &#123;</span><br><span class=\"line\">        this.birthday = birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getAddress</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddress(String address) &#123;</span><br><span class=\"line\">        this.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"id=\"</span> + id +</span><br><span class=\"line\">                <span class=\"string\">\", username='\"</span> + username + <span class=\"string\">'\\'</span><span class=\"string\">' +</span></span><br><span class=\"line\"><span class=\"string\">                \", birthday=\" + birthday +</span></span><br><span class=\"line\"><span class=\"string\">                \", address='</span><span class=\"string\">\" + address + '\\'' +</span></span><br><span class=\"line\"><span class=\"string\">                '&#125;';</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"四、新建dao接口\"><a href=\"#四、新建dao接口\" class=\"headerlink\" title=\"四、新建dao接口\"></a>四、新建dao接口</h3><p>这里直接上代码，我在此新建了一个查询所有的方法，此处记住方法名和返回值类型，后续会用到。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IUserDao &#123;</span><br><span class=\"line\">    List&lt;User&gt; findAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"五、创建mybatis的主配置文件\"><a href=\"#五、创建mybatis的主配置文件\" class=\"headerlink\" title=\"五、创建mybatis的主配置文件\"></a>五、创建mybatis的主配置文件</h3><p>该配置文件需要放在/resources目录下，配置文件的名称在具有规范性的前提下是随意起的，我这里采用了默认的规范(我发现很多人都这么起)</p>\n<p>SqlMapConfig.xml</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span> ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Config 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--mybatis的主配置文件--&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;!--配置环境--&gt;</span><br><span class=\"line\">    &lt;environments default=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">        &lt;!--配置mysql的环境--&gt;</span><br><span class=\"line\">        &lt;environment id=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">            &lt;!--配置事务类型--&gt;</span><br><span class=\"line\">            &lt;transactionManager <span class=\"built_in\">type</span>=<span class=\"string\">\"JDBC\"</span>&gt;&lt;/transactionManager&gt;</span><br><span class=\"line\">            &lt;!--配置数据源(连接池)--&gt;</span><br><span class=\"line\">            &lt;dataSource <span class=\"built_in\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"driver\"</span> value=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"url\"</span> value=<span class=\"string\">\"jdbc:mysql://localhost:3306/MybatisDemo/\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"username\"</span> value=<span class=\"string\">\"root\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"password\"</span> value=<span class=\"string\">\"20141016\"</span> /&gt;</span><br><span class=\"line\">            &lt;/dataSource&gt;</span><br><span class=\"line\">        &lt;/environment&gt;</span><br><span class=\"line\">    &lt;/environments&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件--&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IUserDao.xml\"</span> /&gt;</span><br><span class=\"line\">    &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<p>配置数据源的时候，把url、username、password 修改成你自己的数据库链接、用户名和密码即可。</p>\n<p>注意：<br><strong>下方的mapper部分的配置我接下来会讲，后续按照你自己配置的路径配置即可。</strong></p>\n<hr>\n<h3 id=\"六、配置mapper文件\"><a href=\"#六、配置mapper文件\" class=\"headerlink\" title=\"六、配置mapper文件\"></a>六、配置mapper文件</h3><p>前面虽然配置了mybatis主配置文件，但是我们在实际操作中如果存在多个对象的dao接口，主配置文件需要怎么准确找到该接口呢？<br>我们就需要为每个dao配置一个独立的配置文件<br>我习惯上把文件命名成 <strong>xxxMapper.xml</strong>，这里命名成xxxDao.xml是为了方便理解。<br>文件存放目录为/resources目录下，与实体对象dao接口的包同级。<br><img src=\"/images/mapperxml.png\" alt=\"xml文件配置\"></p>\n<p>代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span> ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--namespace需要配置dao的全限定类名--&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IUserDao\"</span>&gt;</span><br><span class=\"line\">    &lt;!--配置查询所有--&gt;</span><br><span class=\"line\">    &lt;!--id一定要是方法的名称--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"findAll\"</span> resultType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        select * from user;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"七、引入log4j\"><a href=\"#七、引入log4j\" class=\"headerlink\" title=\"七、引入log4j\"></a>七、引入log4j</h3><p>这个是可选操作，为了后期记录日志，我们可以采用log4j去实现。此处只是了解。<br>将log4j.properties文件放在/resources目录下即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Set root category priority to INFO and its only appender to CONSOLE.</span></span><br><span class=\"line\"><span class=\"comment\">#log4j.rootCategory=INFO,CONSOLE             debug  info  warn  error  fatal</span></span><br><span class=\"line\">log4j.rootCategory=debug, CONSOLE, LOGFILE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span></span><br><span class=\"line\">log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span></span><br><span class=\"line\">log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\\n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># LOGFILE is set to be a File appender using a PatternLayout.</span></span><br><span class=\"line\">log.appender.LOGFILE=org.apache.log4j.FileAppender</span><br><span class=\"line\">log.appender.LOGFILE.FILE=/usr/gmx/LearnWorkspace</span><br><span class=\"line\">log.appender.LOGFILE.Append=<span class=\"literal\">true</span></span><br><span class=\"line\">log.appender.LOGFILE.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\\n</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"八、测试案例\"><a href=\"#八、测试案例\" class=\"headerlink\" title=\"八、测试案例\"></a>八、测试案例</h3><p>如此，我们的mybatis就搭建完成了，我们接下来测试一下。<br>在/test/java目录下新建一个test类<br>如图：<br><img src=\"/images/test.png\" alt=\"test类\"></p>\n<p>代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.dao.IUserDao;</span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\">import org.apache.ibatis.io.Resources;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSession;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MybatisTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception&#123;</span><br><span class=\"line\">        //1.读取配置文件</span><br><span class=\"line\">        InputStream inputStream = Resources.getResourceAsStream(<span class=\"string\">\"SqlMapConfig.xml\"</span>);</span><br><span class=\"line\">        //2.创建SqlSessionFactory工厂</span><br><span class=\"line\">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class=\"line\">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class=\"line\">        //3.使用工厂创建SqlSession对象</span><br><span class=\"line\">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">        //4.使用SqlSession创建dao接口的代理对象</span><br><span class=\"line\">        IUserDao userDao = session.getMapper(IUserDao.class);</span><br><span class=\"line\">        //5.使用代理对象执行方法</span><br><span class=\"line\">        List&lt;User&gt; users= userDao.findAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (User user: users) &#123;</span><br><span class=\"line\">            System.out.println(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //6.释放资源</span><br><span class=\"line\">        session.close();</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>我们的第一个Mybatis入门案例就创建完了，但是这种方式还是十分复杂的，因为有太多的配置文件，后续我们会用更简便的注解的方式去实现它。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很早之前看过Mybatis视频，但是无奈工作中没有用到，当自己练习搭建的时候发现问题很多，所以这次准备重新研究一下，一点点搭建Mybatis框架。</p>\n<hr>\n<h3 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h3><p>因为Mybatis是持久层框架，所以在此之前我们要做一些准备工作，首先我们要在Mysql中建好表并插入数据。<br>此处的sql我就不提供了，我都是用navicat手动插入的。</p>\n<p>如图：<br><img src=\"/images/table.png\" alt=\"建表\"></p>\n<h3 id=\"二、新建项目\"><a href=\"#二、新建项目\" class=\"headerlink\" title=\"二、新建项目\"></a>二、新建项目</h3><p>我们这里要新建一个maven项目。<br><img src=\"/images/1.png\" alt=\"创建Maven项目\"></p>\n<p><img src=\"/images/2.png\" alt=\"创建Maven项目\"></p>\n<p><img src=\"/images/3.png\" alt=\"创建Maven项目\"></p>\n<p>创建完成之后，我们打开pom.xml文件引入依赖。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;project xmlns=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span></span><br><span class=\"line\">         xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">         xsi:schemaLocation=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;groupId&gt;com.loonycoder&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;MybatisDemo&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;3.4.4&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"三、创建表对象的映射实体类\"><a href=\"#三、创建表对象的映射实体类\" class=\"headerlink\" title=\"三、创建表对象的映射实体类\"></a>三、创建表对象的映射实体类</h3><p>因为mybatis是一个ORM（Object Relational Mapping）框架，所以我们要准备一个和表字段一一对应的实体类。</p>\n<p><strong>注意</strong>：<br><strong>表中的字段名和实体类中的字段名字一定要一致！</strong><br><strong>实体类一定要实现Serializable接口</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\">public class User implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private String username;</span><br><span class=\"line\">    private Date birthday;</span><br><span class=\"line\">    private String address;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(Integer id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getUsername</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUsername(String username) &#123;</span><br><span class=\"line\">        this.username = username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date <span class=\"function\"><span class=\"title\">getBirthday</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setBirthday(Date birthday) &#123;</span><br><span class=\"line\">        this.birthday = birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getAddress</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddress(String address) &#123;</span><br><span class=\"line\">        this.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"id=\"</span> + id +</span><br><span class=\"line\">                <span class=\"string\">\", username='\"</span> + username + <span class=\"string\">'\\'</span><span class=\"string\">' +</span></span><br><span class=\"line\"><span class=\"string\">                \", birthday=\" + birthday +</span></span><br><span class=\"line\"><span class=\"string\">                \", address='</span><span class=\"string\">\" + address + '\\'' +</span></span><br><span class=\"line\"><span class=\"string\">                '&#125;';</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"四、新建dao接口\"><a href=\"#四、新建dao接口\" class=\"headerlink\" title=\"四、新建dao接口\"></a>四、新建dao接口</h3><p>这里直接上代码，我在此新建了一个查询所有的方法，此处记住方法名和返回值类型，后续会用到。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IUserDao &#123;</span><br><span class=\"line\">    List&lt;User&gt; findAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"五、创建mybatis的主配置文件\"><a href=\"#五、创建mybatis的主配置文件\" class=\"headerlink\" title=\"五、创建mybatis的主配置文件\"></a>五、创建mybatis的主配置文件</h3><p>该配置文件需要放在/resources目录下，配置文件的名称在具有规范性的前提下是随意起的，我这里采用了默认的规范(我发现很多人都这么起)</p>\n<p>SqlMapConfig.xml</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span> ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Config 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--mybatis的主配置文件--&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;!--配置环境--&gt;</span><br><span class=\"line\">    &lt;environments default=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">        &lt;!--配置mysql的环境--&gt;</span><br><span class=\"line\">        &lt;environment id=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">            &lt;!--配置事务类型--&gt;</span><br><span class=\"line\">            &lt;transactionManager <span class=\"built_in\">type</span>=<span class=\"string\">\"JDBC\"</span>&gt;&lt;/transactionManager&gt;</span><br><span class=\"line\">            &lt;!--配置数据源(连接池)--&gt;</span><br><span class=\"line\">            &lt;dataSource <span class=\"built_in\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"driver\"</span> value=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"url\"</span> value=<span class=\"string\">\"jdbc:mysql://localhost:3306/MybatisDemo/\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"username\"</span> value=<span class=\"string\">\"root\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"password\"</span> value=<span class=\"string\">\"20141016\"</span> /&gt;</span><br><span class=\"line\">            &lt;/dataSource&gt;</span><br><span class=\"line\">        &lt;/environment&gt;</span><br><span class=\"line\">    &lt;/environments&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件--&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IUserDao.xml\"</span> /&gt;</span><br><span class=\"line\">    &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<p>配置数据源的时候，把url、username、password 修改成你自己的数据库链接、用户名和密码即可。</p>\n<p>注意：<br><strong>下方的mapper部分的配置我接下来会讲，后续按照你自己配置的路径配置即可。</strong></p>\n<hr>\n<h3 id=\"六、配置mapper文件\"><a href=\"#六、配置mapper文件\" class=\"headerlink\" title=\"六、配置mapper文件\"></a>六、配置mapper文件</h3><p>前面虽然配置了mybatis主配置文件，但是我们在实际操作中如果存在多个对象的dao接口，主配置文件需要怎么准确找到该接口呢？<br>我们就需要为每个dao配置一个独立的配置文件<br>我习惯上把文件命名成 <strong>xxxMapper.xml</strong>，这里命名成xxxDao.xml是为了方便理解。<br>文件存放目录为/resources目录下，与实体对象dao接口的包同级。<br><img src=\"/images/mapperxml.png\" alt=\"xml文件配置\"></p>\n<p>代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span> ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--namespace需要配置dao的全限定类名--&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IUserDao\"</span>&gt;</span><br><span class=\"line\">    &lt;!--配置查询所有--&gt;</span><br><span class=\"line\">    &lt;!--id一定要是方法的名称--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"findAll\"</span> resultType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        select * from user;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"七、引入log4j\"><a href=\"#七、引入log4j\" class=\"headerlink\" title=\"七、引入log4j\"></a>七、引入log4j</h3><p>这个是可选操作，为了后期记录日志，我们可以采用log4j去实现。此处只是了解。<br>将log4j.properties文件放在/resources目录下即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Set root category priority to INFO and its only appender to CONSOLE.</span></span><br><span class=\"line\"><span class=\"comment\">#log4j.rootCategory=INFO,CONSOLE             debug  info  warn  error  fatal</span></span><br><span class=\"line\">log4j.rootCategory=debug, CONSOLE, LOGFILE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span></span><br><span class=\"line\">log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span></span><br><span class=\"line\">log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\\n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># LOGFILE is set to be a File appender using a PatternLayout.</span></span><br><span class=\"line\">log.appender.LOGFILE=org.apache.log4j.FileAppender</span><br><span class=\"line\">log.appender.LOGFILE.FILE=/usr/gmx/LearnWorkspace</span><br><span class=\"line\">log.appender.LOGFILE.Append=<span class=\"literal\">true</span></span><br><span class=\"line\">log.appender.LOGFILE.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\\n</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"八、测试案例\"><a href=\"#八、测试案例\" class=\"headerlink\" title=\"八、测试案例\"></a>八、测试案例</h3><p>如此，我们的mybatis就搭建完成了，我们接下来测试一下。<br>在/test/java目录下新建一个test类<br>如图：<br><img src=\"/images/test.png\" alt=\"test类\"></p>\n<p>代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.dao.IUserDao;</span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\">import org.apache.ibatis.io.Resources;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSession;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MybatisTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception&#123;</span><br><span class=\"line\">        //1.读取配置文件</span><br><span class=\"line\">        InputStream inputStream = Resources.getResourceAsStream(<span class=\"string\">\"SqlMapConfig.xml\"</span>);</span><br><span class=\"line\">        //2.创建SqlSessionFactory工厂</span><br><span class=\"line\">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class=\"line\">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class=\"line\">        //3.使用工厂创建SqlSession对象</span><br><span class=\"line\">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">        //4.使用SqlSession创建dao接口的代理对象</span><br><span class=\"line\">        IUserDao userDao = session.getMapper(IUserDao.class);</span><br><span class=\"line\">        //5.使用代理对象执行方法</span><br><span class=\"line\">        List&lt;User&gt; users= userDao.findAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (User user: users) &#123;</span><br><span class=\"line\">            System.out.println(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //6.释放资源</span><br><span class=\"line\">        session.close();</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>我们的第一个Mybatis入门案例就创建完了，但是这种方式还是十分复杂的，因为有太多的配置文件，后续我们会用更简便的注解的方式去实现它。</p>\n"},{"title":"初识Vue","date":"2020-01-05T16:00:00.000Z","_content":"\n### 什么是Vue.js\n\n+ Vue.js是目前很火的前端框架；与Angualr.js和React.js并称为前端三大主流框架。\n+ Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，\n+ 在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。\n\n---\n\n### 后端的MVC和前端的MVVM之间的区别\n\n+ MVC是后端的分层开发概念\n+ MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）\n\n+ Model： 页面需要展示的数据\n+ View: 视图、HTML\n+ VM: 数据（Model）和视图（View）之间的调度者\n\n**图解**\n![vue图解](/images/vue1.png)\n\n---\n\n### 入门案例\n\n```bash\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <!-- 插值表达式 -->\n    <p>{{ msg }}</p>\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: {     // data中存放的是el中需要的数据\n            msg: 'Hello Vue!'\n        }\n    });\n</script>\n\n</body>\n</html>\n```\n\n**解释**\n\n1、首先需要引入Vue.js\n2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到\n3、创建Vue实例，这个实例其实就是MVVM中的vm调度者\n4、el: 表示当时Vue实例的控制区域；data: 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。\n5、在指定Vue实例区域下，展示我们已经声明的元素msg，使用：即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）\n\n---\n\n### 常用指令\n\n#### v-cloak\n\n在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在vue.js还没有加载完毕时，视图层不会将识别为Vue中的插值表达式，而是作为字符串显示到页面上。\n为了解决这个问题，Vue.js提供了v-cloak指令，可以解决插值表达式闪烁的问题。\n\n```bash\n<p v-cloak>{{ msg }}</p>\n```\n\n**扩展**\n\n解决插值表达式闪烁问题，除了v-cloak指令，Vue还提供了v-text指令。\n\n```bash\n<p v-text=\"msg\"></p>\n```\n\n**v-cloak与v-text的区别**\nv-text默认会覆盖掉元素中原有的内容\nv-cloak不会覆盖掉原有的内容\n![vue2](/images/vue2.png)\n\n#### v-bind\n\n**在上面，我们了解了v-text输出Vue元素，但是如果我们需要显示的数据是一段HTML代码，v-text和都将无能为力，\n为此，Vue提供了专门渲染HTML数据的指令：v-html**\n\n![vue3](/images/vue3.png)\n\n上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用）这样可以吗？\n\n```bash\n<input type=\"button\" value=\"msg\"/>\n```\n\n回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。\n为了解决上述问题，Vue提供了v-bind:指令来绑定一些HTML属性：\n\n```bash\n<input type=\"button\" v-bind:value=\"msg\">\n```\n\n如上，被v-bind:绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外v-bind:还有一个简易写法：\n\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" value=\"msg\" />\n    <input type=\"button\" v-bind:value=\"msg\">\n    <input type=\"button\" :value=\"msg\">\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '戳我'\n        }\n    });\n</script>\n```\n\n效果如图：\n![vue4](/images/vue4.png)\n\n#### v-on\n\nVue提供了事件绑定机制的指令：v-on:；用其我们可以用来绑定一些常见的触发事件：click、mouseover ...\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" :value=\"msg\" v-on:click=\"show\">\n    <input type=\"button\" :value=\"msg\" v-on:mouseover=\"show\">\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '戳我'\n        },\n        methods: {\n            show: function(){\n                alert(\"hello\");\n            }\n        }\n    });\n</script>\n```\n\n其中methods是Vue内置的对象，用于存放一些自定义的方法函数\n\n**拓展**\n\n使用js内置的函数setInterval(定时器)，实现跑马灯效果：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" value=\"开始\" @click=\"action\">\n    <input type=\"button\" value=\"停止\" @click=\"stop\">\n    <p>{{msg}}</p>\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '嘻嘻，哈哈',\n            intervalId: null\n        },\n        methods: {\n            action(){\n                if(this.intervalId != null) return;\n\n                // 定时器\n                this.intervalId = setInterval(() => {\n                    // 截取首字符\n                    var start = this.msg.substring(0, 1);\n                    // 截取第一个字符后的所有字符\n                    var end = this.msg.substring(1);\n                    // 将后面的字符拼接到前面，实现循环的效果\n                    this.msg = end + start;\n                },400)\n            },\n            stop(){\n                // 停止定时器\n                clearInterval(this.intervalId)\n                // 每次清除定时器后需要将intervalId重新设置为null\n                this.intervalId = null;\n            }\n        }\n    });\n</script>\n```\n\n**解释**\n\n1、v-on:也有简写形式：@，用法如上。\n2、在视图层取VM中的数据我们可以使用或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：this.数据属性名（其中的this表示当前VM实例对象）。\n3、methodName:function(){}在ES6中有一个简便的写法：methodName(){}。 4、setInterval()和clearInterval()是js中内置的函数，用法如上。\n5、正常我们调用函数会写：name(function(){})，而ES6也提供了一个方式：methodName(() => {})，这种用法的好处就解决了this指向问题，因为如果元素定义在了函数内部，那么其中的this就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的=>。\n\n效果如图：\n![vue5](/images/vue5.png)\n\n\n#### 事件修饰符\n\n> .stop 阻止冒泡\n> .prevent 阻止默认事件\n> .capture 添加时间侦听器时使用时间捕获模式\n> .self 只当事件在该元素本身（比如不是子元素）触发时触发回调\n> .once 事件只触发一次\n\n用法：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <div @click=\"divClick\">\n        <input type=\"button\" value=\"戳我\" @click.stop=\"btnClick\">\n        <input type=\"button\" value=\"戳我\" @click.prevent=\"btnClick\">\n    </div>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '嘻嘻，哈哈',\n        },\n        methods: {\n            divClick() {\n                console.log(\"这是div的点击事件\");\n            },\n            btnClick() {\n                console.log(\"这是btn的点击事件\");\n            }\n        }\n    });\n</script>\n```\n\n#### v-model\n\n- 唯一的双向绑定指令：v-model\n- 单向绑定指令：v-bing\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"text\" v-model=\"msg\">\n    <p>{{msg}}</p>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: 'hello!',\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n---\n\n### Vue中的样式\n\n\n#### 外联样式\n- 数组\n```bash\n<h2 :class=\"['italic','color']\">LoonyCoder</h2>\n```\n其中的italic、color是自定义的类名，需在外部定义CSS样式\n\n- 数组中嵌套对象\n```bash\n<h2 :class=\"['italic',{'color': flag}]\">LoonyCoder</h2>\n```\n其中的flag是Vue绑定的变量，在data进行声明\n\n- 直接使用对象\n```bash\n<h2 :class=\"{italic:true, color:flag}\">LoonyCoder</h2>\n```\n\n实例：\n```bash\n<style>\n    .italic {\n        font-style: italic;\n    }\n\n    .color {\n        color: skyblue;\n    }\n</style>\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <h2 :class=\"['italic','color']\">LoonyCoder</h2>\n    <h2 :class=\"['italic', {'color':flag}]\">LoonyCoder</h2>\n    <h2 :class=\"{italic:false, color:flag}\">LoonyCoder</h2>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            flag: true\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### 内联样式\n\n- 将样式对象定义到data中，并在:style中引用\n```bash\n<h2 :style=\"styleObj\">LoonyCoder</h2>\n\ndata: {\n    styleObj: { 'color': 'red', 'font-weight': '200px'}\n}\n```\n\n- 在:style中通过数组，引用多个data上的样式对象\n```bash\n<h2 :style=\"[styleObj, styleObj2]\">LoonyCoder</h2>\n\ndata: {\n    styleObj: { 'color': 'red', 'font-weight': '200px'},\n    styleObj2: { 'font-style': 'italic' }\n}\n```\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <h2 :style=\"styleObj\">LoonyCoder</h2>\n    <h2 :style=\"[styleObj, styleObj2]\">LoonyCoder</h2>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            styleObj: { 'color': 'red', 'font-weight': '200px' },\n            styleObj2: { 'font-style': 'italic' }\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### v-for\n\nVue提供了遍历集合、数组的指令：v-for；用法: v-for=\"别名 in 集合名\"\n\n#### 迭代数组\n```bash\n<p v-for=\"item, i in list\">索引：{{i}} --- 值：{{item}}</p>\n\ndata: {\n    list: [1,2,3,4]\n}\n```\n**其中的i是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义**\n\n#### 迭代对象数组\n```bash\n<p v-for=\"item in list2\">id: {{item.id}} --- name: {{item.name}}</p>\n\ndata: {\n    list2: [\n            { id:1, name: '嘻嘻' },\n            { id:2, name: '哈哈' }\n        ],\n}\n```\n\n**迭代对象数组，通过 的方式，这个属性名就是对象数组中定义的元素属性名**\n\n#### 迭代对象\n```bash\n<p v-for=\"(val, key) in user\">键: {{key}} --- 值: {{val}}</p>\n\ndata: {\n    user: {\n            id: 1,\n            name: 'LoonyCoder'\n        }\n}\n```\n\n**迭代对象，迭代得到的是对象的value值和key值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。**\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <p v-for=\"item, i in list\">索引：{{i}} --- 值：{{item}}</p>\n    <p v-for=\"item in list2\">id: {{item.id}} --- name: {{item.name}}</p>\n    <p v-for=\"(val, key) in user\">键: {{key}} --- 值: {{val}}</p>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            list: [1,2,3,4], \n            list2: [\n                { id:1, name: '嘻嘻' },\n                { id:2, name: '哈哈' }\n            ],\n            user: {\n                id: 1,\n                name: 'LoonyCoder'\n            }\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### 注意\n在vue2.0+版本里，当使用v-for渲染数据，必须制定对应的key值（这里的key是一个属性，不是前面迭代的key值）。\n\n**用法：**\n```bash\n<p v-for=\"item in user\" :key=\"item.id\">\n```\n其中:key就说明了key属性必须是通过v-bind绑定的元素，而:key=\"\"中指定的值必须是string/number类型的值，比如此处使用的是item.id中ID是number值，并且是唯一的。\n**目的：**\n避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。\n\n#### v-show和v-if\n\nVue提供了两个指令来实现元素显示状态的切换：v-if v-show\n**区别**\n- v-if的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。\n- v-show的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的display:none样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" @click=\"flag=!flag\" value=\"toggle\">\n\n    <h3 v-if=\"flag\">这是v-if控制的元素</h3>\n    <h3 v-show=\"flag\">这是v-show控制的元素</h3>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            flag: false\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n效果如下：\n![vue6](/images/vue6.png)","source":"_posts/Vue.md","raw":"---\ntitle: 初识Vue\ncategories:\n    - Web前端\ndate: 2020-01-06\ntags:\n\t- 前端框架\n\t\n---\n\n### 什么是Vue.js\n\n+ Vue.js是目前很火的前端框架；与Angualr.js和React.js并称为前端三大主流框架。\n+ Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，\n+ 在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。\n\n---\n\n### 后端的MVC和前端的MVVM之间的区别\n\n+ MVC是后端的分层开发概念\n+ MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）\n\n+ Model： 页面需要展示的数据\n+ View: 视图、HTML\n+ VM: 数据（Model）和视图（View）之间的调度者\n\n**图解**\n![vue图解](/images/vue1.png)\n\n---\n\n### 入门案例\n\n```bash\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <!-- 插值表达式 -->\n    <p>{{ msg }}</p>\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: {     // data中存放的是el中需要的数据\n            msg: 'Hello Vue!'\n        }\n    });\n</script>\n\n</body>\n</html>\n```\n\n**解释**\n\n1、首先需要引入Vue.js\n2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到\n3、创建Vue实例，这个实例其实就是MVVM中的vm调度者\n4、el: 表示当时Vue实例的控制区域；data: 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。\n5、在指定Vue实例区域下，展示我们已经声明的元素msg，使用：即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）\n\n---\n\n### 常用指令\n\n#### v-cloak\n\n在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在vue.js还没有加载完毕时，视图层不会将识别为Vue中的插值表达式，而是作为字符串显示到页面上。\n为了解决这个问题，Vue.js提供了v-cloak指令，可以解决插值表达式闪烁的问题。\n\n```bash\n<p v-cloak>{{ msg }}</p>\n```\n\n**扩展**\n\n解决插值表达式闪烁问题，除了v-cloak指令，Vue还提供了v-text指令。\n\n```bash\n<p v-text=\"msg\"></p>\n```\n\n**v-cloak与v-text的区别**\nv-text默认会覆盖掉元素中原有的内容\nv-cloak不会覆盖掉原有的内容\n![vue2](/images/vue2.png)\n\n#### v-bind\n\n**在上面，我们了解了v-text输出Vue元素，但是如果我们需要显示的数据是一段HTML代码，v-text和都将无能为力，\n为此，Vue提供了专门渲染HTML数据的指令：v-html**\n\n![vue3](/images/vue3.png)\n\n上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用）这样可以吗？\n\n```bash\n<input type=\"button\" value=\"msg\"/>\n```\n\n回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。\n为了解决上述问题，Vue提供了v-bind:指令来绑定一些HTML属性：\n\n```bash\n<input type=\"button\" v-bind:value=\"msg\">\n```\n\n如上，被v-bind:绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外v-bind:还有一个简易写法：\n\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" value=\"msg\" />\n    <input type=\"button\" v-bind:value=\"msg\">\n    <input type=\"button\" :value=\"msg\">\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '戳我'\n        }\n    });\n</script>\n```\n\n效果如图：\n![vue4](/images/vue4.png)\n\n#### v-on\n\nVue提供了事件绑定机制的指令：v-on:；用其我们可以用来绑定一些常见的触发事件：click、mouseover ...\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" :value=\"msg\" v-on:click=\"show\">\n    <input type=\"button\" :value=\"msg\" v-on:mouseover=\"show\">\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '戳我'\n        },\n        methods: {\n            show: function(){\n                alert(\"hello\");\n            }\n        }\n    });\n</script>\n```\n\n其中methods是Vue内置的对象，用于存放一些自定义的方法函数\n\n**拓展**\n\n使用js内置的函数setInterval(定时器)，实现跑马灯效果：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" value=\"开始\" @click=\"action\">\n    <input type=\"button\" value=\"停止\" @click=\"stop\">\n    <p>{{msg}}</p>\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '嘻嘻，哈哈',\n            intervalId: null\n        },\n        methods: {\n            action(){\n                if(this.intervalId != null) return;\n\n                // 定时器\n                this.intervalId = setInterval(() => {\n                    // 截取首字符\n                    var start = this.msg.substring(0, 1);\n                    // 截取第一个字符后的所有字符\n                    var end = this.msg.substring(1);\n                    // 将后面的字符拼接到前面，实现循环的效果\n                    this.msg = end + start;\n                },400)\n            },\n            stop(){\n                // 停止定时器\n                clearInterval(this.intervalId)\n                // 每次清除定时器后需要将intervalId重新设置为null\n                this.intervalId = null;\n            }\n        }\n    });\n</script>\n```\n\n**解释**\n\n1、v-on:也有简写形式：@，用法如上。\n2、在视图层取VM中的数据我们可以使用或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：this.数据属性名（其中的this表示当前VM实例对象）。\n3、methodName:function(){}在ES6中有一个简便的写法：methodName(){}。 4、setInterval()和clearInterval()是js中内置的函数，用法如上。\n5、正常我们调用函数会写：name(function(){})，而ES6也提供了一个方式：methodName(() => {})，这种用法的好处就解决了this指向问题，因为如果元素定义在了函数内部，那么其中的this就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的=>。\n\n效果如图：\n![vue5](/images/vue5.png)\n\n\n#### 事件修饰符\n\n> .stop 阻止冒泡\n> .prevent 阻止默认事件\n> .capture 添加时间侦听器时使用时间捕获模式\n> .self 只当事件在该元素本身（比如不是子元素）触发时触发回调\n> .once 事件只触发一次\n\n用法：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <div @click=\"divClick\">\n        <input type=\"button\" value=\"戳我\" @click.stop=\"btnClick\">\n        <input type=\"button\" value=\"戳我\" @click.prevent=\"btnClick\">\n    </div>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '嘻嘻，哈哈',\n        },\n        methods: {\n            divClick() {\n                console.log(\"这是div的点击事件\");\n            },\n            btnClick() {\n                console.log(\"这是btn的点击事件\");\n            }\n        }\n    });\n</script>\n```\n\n#### v-model\n\n- 唯一的双向绑定指令：v-model\n- 单向绑定指令：v-bing\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"text\" v-model=\"msg\">\n    <p>{{msg}}</p>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: 'hello!',\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n---\n\n### Vue中的样式\n\n\n#### 外联样式\n- 数组\n```bash\n<h2 :class=\"['italic','color']\">LoonyCoder</h2>\n```\n其中的italic、color是自定义的类名，需在外部定义CSS样式\n\n- 数组中嵌套对象\n```bash\n<h2 :class=\"['italic',{'color': flag}]\">LoonyCoder</h2>\n```\n其中的flag是Vue绑定的变量，在data进行声明\n\n- 直接使用对象\n```bash\n<h2 :class=\"{italic:true, color:flag}\">LoonyCoder</h2>\n```\n\n实例：\n```bash\n<style>\n    .italic {\n        font-style: italic;\n    }\n\n    .color {\n        color: skyblue;\n    }\n</style>\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <h2 :class=\"['italic','color']\">LoonyCoder</h2>\n    <h2 :class=\"['italic', {'color':flag}]\">LoonyCoder</h2>\n    <h2 :class=\"{italic:false, color:flag}\">LoonyCoder</h2>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            flag: true\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### 内联样式\n\n- 将样式对象定义到data中，并在:style中引用\n```bash\n<h2 :style=\"styleObj\">LoonyCoder</h2>\n\ndata: {\n    styleObj: { 'color': 'red', 'font-weight': '200px'}\n}\n```\n\n- 在:style中通过数组，引用多个data上的样式对象\n```bash\n<h2 :style=\"[styleObj, styleObj2]\">LoonyCoder</h2>\n\ndata: {\n    styleObj: { 'color': 'red', 'font-weight': '200px'},\n    styleObj2: { 'font-style': 'italic' }\n}\n```\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <h2 :style=\"styleObj\">LoonyCoder</h2>\n    <h2 :style=\"[styleObj, styleObj2]\">LoonyCoder</h2>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            styleObj: { 'color': 'red', 'font-weight': '200px' },\n            styleObj2: { 'font-style': 'italic' }\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### v-for\n\nVue提供了遍历集合、数组的指令：v-for；用法: v-for=\"别名 in 集合名\"\n\n#### 迭代数组\n```bash\n<p v-for=\"item, i in list\">索引：{{i}} --- 值：{{item}}</p>\n\ndata: {\n    list: [1,2,3,4]\n}\n```\n**其中的i是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义**\n\n#### 迭代对象数组\n```bash\n<p v-for=\"item in list2\">id: {{item.id}} --- name: {{item.name}}</p>\n\ndata: {\n    list2: [\n            { id:1, name: '嘻嘻' },\n            { id:2, name: '哈哈' }\n        ],\n}\n```\n\n**迭代对象数组，通过 的方式，这个属性名就是对象数组中定义的元素属性名**\n\n#### 迭代对象\n```bash\n<p v-for=\"(val, key) in user\">键: {{key}} --- 值: {{val}}</p>\n\ndata: {\n    user: {\n            id: 1,\n            name: 'LoonyCoder'\n        }\n}\n```\n\n**迭代对象，迭代得到的是对象的value值和key值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。**\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <p v-for=\"item, i in list\">索引：{{i}} --- 值：{{item}}</p>\n    <p v-for=\"item in list2\">id: {{item.id}} --- name: {{item.name}}</p>\n    <p v-for=\"(val, key) in user\">键: {{key}} --- 值: {{val}}</p>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            list: [1,2,3,4], \n            list2: [\n                { id:1, name: '嘻嘻' },\n                { id:2, name: '哈哈' }\n            ],\n            user: {\n                id: 1,\n                name: 'LoonyCoder'\n            }\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### 注意\n在vue2.0+版本里，当使用v-for渲染数据，必须制定对应的key值（这里的key是一个属性，不是前面迭代的key值）。\n\n**用法：**\n```bash\n<p v-for=\"item in user\" :key=\"item.id\">\n```\n其中:key就说明了key属性必须是通过v-bind绑定的元素，而:key=\"\"中指定的值必须是string/number类型的值，比如此处使用的是item.id中ID是number值，并且是唯一的。\n**目的：**\n避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。\n\n#### v-show和v-if\n\nVue提供了两个指令来实现元素显示状态的切换：v-if v-show\n**区别**\n- v-if的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。\n- v-show的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的display:none样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" @click=\"flag=!flag\" value=\"toggle\">\n\n    <h3 v-if=\"flag\">这是v-if控制的元素</h3>\n    <h3 v-show=\"flag\">这是v-show控制的元素</h3>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            flag: false\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n效果如下：\n![vue6](/images/vue6.png)","slug":"Vue","published":1,"updated":"2020-01-10T09:13:53.045Z","_id":"ck51w70e80000ml6ke95j9hpg","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"什么是Vue-js\"><a href=\"#什么是Vue-js\" class=\"headerlink\" title=\"什么是Vue.js\"></a>什么是Vue.js</h3><ul>\n<li>Vue.js是目前很火的前端框架；与Angualr.js和React.js并称为前端三大主流框架。</li>\n<li>Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，</li>\n<li>在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。</li>\n</ul>\n<hr>\n<h3 id=\"后端的MVC和前端的MVVM之间的区别\"><a href=\"#后端的MVC和前端的MVVM之间的区别\" class=\"headerlink\" title=\"后端的MVC和前端的MVVM之间的区别\"></a>后端的MVC和前端的MVVM之间的区别</h3><ul>\n<li><p>MVC是后端的分层开发概念</p>\n</li>\n<li><p>MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）</p>\n</li>\n<li><p>Model： 页面需要展示的数据</p>\n</li>\n<li><p>View: 视图、HTML</p>\n</li>\n<li><p>VM: 数据（Model）和视图（View）之间的调度者</p>\n</li>\n</ul>\n<p><strong>图解</strong><br><img src=\"/images/vue1.png\" alt=\"vue图解\"></p>\n<hr>\n<h3 id=\"入门案例\"><a href=\"#入门案例\" class=\"headerlink\" title=\"入门案例\"></a>入门案例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- 插值表达式 --&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123;     // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'Hello Vue!'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<p>1、首先需要引入Vue.js<br>2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到<br>3、创建Vue实例，这个实例其实就是MVVM中的vm调度者<br>4、el: 表示当时Vue实例的控制区域；data: 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。<br>5、在指定Vue实例区域下，展示我们已经声明的元素msg，使用：即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）</p>\n<hr>\n<h3 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h3><h4 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h4><p>在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在vue.js还没有加载完毕时，视图层不会将识别为Vue中的插值表达式，而是作为字符串显示到页面上。<br>为了解决这个问题，Vue.js提供了v-cloak指令，可以解决插值表达式闪烁的问题。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>扩展</strong></p>\n<p>解决插值表达式闪烁问题，除了v-cloak指令，Vue还提供了v-text指令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-text=<span class=\"string\">\"msg\"</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>v-cloak与v-text的区别</strong><br>v-text默认会覆盖掉元素中原有的内容<br>v-cloak不会覆盖掉原有的内容<br><img src=\"/images/vue2.png\" alt=\"vue2\"></p>\n<h4 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h4><p><strong>在上面，我们了解了v-text输出Vue元素，但是如果我们需要显示的数据是一段HTML代码，v-text和都将无能为力，<br>为此，Vue提供了专门渲染HTML数据的指令：v-html</strong></p>\n<p><img src=\"/images/vue3.png\" alt=\"vue3\"></p>\n<p>上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用）这样可以吗？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"msg\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。<br>为了解决上述问题，Vue提供了v-bind:指令来绑定一些HTML属性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> v-bind:value=<span class=\"string\">\"msg\"</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，被v-bind:绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外v-bind:还有一个简易写法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"msg\"</span> /&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> v-bind:value=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'戳我'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果如图：<br><img src=\"/images/vue4.png\" alt=\"vue4\"></p>\n<h4 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h4><p>Vue提供了事件绑定机制的指令：v-on:；用其我们可以用来绑定一些常见的触发事件：click、mouseover …</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span> v-on:click=<span class=\"string\">\"show\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span> v-on:mouseover=<span class=\"string\">\"show\"</span>&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'戳我'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            show: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">                alert(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中methods是Vue内置的对象，用于存放一些自定义的方法函数</p>\n<p><strong>拓展</strong></p>\n<p>使用js内置的函数setInterval(定时器)，实现跑马灯效果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"开始\"</span> @click=<span class=\"string\">\"action\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"停止\"</span> @click=<span class=\"string\">\"stop\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'嘻嘻，哈哈'</span>,</span><br><span class=\"line\">            intervalId: null</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">action</span></span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(this.intervalId != null) <span class=\"built_in\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                // 定时器</span><br><span class=\"line\">                this.intervalId = setInterval(() =&gt; &#123;</span><br><span class=\"line\">                    // 截取首字符</span><br><span class=\"line\">                    var start = this.msg.substring(0, 1);</span><br><span class=\"line\">                    // 截取第一个字符后的所有字符</span><br><span class=\"line\">                    var end = this.msg.substring(1);</span><br><span class=\"line\">                    // 将后面的字符拼接到前面，实现循环的效果</span><br><span class=\"line\">                    this.msg = end + start;</span><br><span class=\"line\">                &#125;,400)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">stop</span></span>()&#123;</span><br><span class=\"line\">                // 停止定时器</span><br><span class=\"line\">                clearInterval(this.intervalId)</span><br><span class=\"line\">                // 每次清除定时器后需要将intervalId重新设置为null</span><br><span class=\"line\">                this.intervalId = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<p>1、v-on:也有简写形式：@，用法如上。<br>2、在视图层取VM中的数据我们可以使用或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：this.数据属性名（其中的this表示当前VM实例对象）。<br>3、methodName:function(){}在ES6中有一个简便的写法：methodName(){}。 4、setInterval()和clearInterval()是js中内置的函数，用法如上。<br>5、正常我们调用函数会写：name(function(){})，而ES6也提供了一个方式：methodName(() =&gt; {})，这种用法的好处就解决了this指向问题，因为如果元素定义在了函数内部，那么其中的this就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的=&gt;。</p>\n<p>效果如图：<br><img src=\"/images/vue5.png\" alt=\"vue5\"></p>\n<h4 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h4><blockquote>\n<p>.stop 阻止冒泡<br>.prevent 阻止默认事件<br>.capture 添加时间侦听器时使用时间捕获模式<br>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调<br>.once 事件只触发一次</p>\n</blockquote>\n<p>用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;div @click=<span class=\"string\">\"divClick\"</span>&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"戳我\"</span> @click.stop=<span class=\"string\">\"btnClick\"</span>&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"戳我\"</span> @click.prevent=<span class=\"string\">\"btnClick\"</span>&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'嘻嘻，哈哈'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">divClick</span></span>() &#123;</span><br><span class=\"line\">                console.log(<span class=\"string\">\"这是div的点击事件\"</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">btnClick</span></span>() &#123;</span><br><span class=\"line\">                console.log(<span class=\"string\">\"这是btn的点击事件\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h4><ul>\n<li>唯一的双向绑定指令：v-model</li>\n<li>单向绑定指令：v-bing</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'hello!'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"Vue中的样式\"><a href=\"#Vue中的样式\" class=\"headerlink\" title=\"Vue中的样式\"></a>Vue中的样式</h3><h4 id=\"外联样式\"><a href=\"#外联样式\" class=\"headerlink\" title=\"外联样式\"></a>外联样式</h4><ul>\n<li><p>数组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"['italic','color']\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n<p>其中的italic、color是自定义的类名，需在外部定义CSS样式</p>\n</li>\n<li><p>数组中嵌套对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"['italic',&#123;'color': flag&#125;]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n<p>其中的flag是Vue绑定的变量，在data进行声明</p>\n</li>\n<li><p>直接使用对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"&#123;italic:true, color:flag&#125;\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .italic &#123;</span><br><span class=\"line\">        font-style: italic;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .color &#123;</span><br><span class=\"line\">        color: skyblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"['italic','color']\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"['italic', &#123;'color':flag&#125;]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"&#123;italic:false, color:flag&#125;\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            flag: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内联样式\"><a href=\"#内联样式\" class=\"headerlink\" title=\"内联样式\"></a>内联样式</h4><ul>\n<li><p>将样式对象定义到data中，并在:style中引用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :style=<span class=\"string\">\"styleObj\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在:style中通过数组，引用多个data上的样式对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :style=<span class=\"string\">\"[styleObj, styleObj2]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span>&#125;,</span><br><span class=\"line\">    styleObj2: &#123; <span class=\"string\">'font-style'</span>: <span class=\"string\">'italic'</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;h2 :style=<span class=\"string\">\"styleObj\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :style=<span class=\"string\">\"[styleObj, styleObj2]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span> &#125;,</span><br><span class=\"line\">            styleObj2: &#123; <span class=\"string\">'font-style'</span>: <span class=\"string\">'italic'</span> &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h4><p>Vue提供了遍历集合、数组的指令：v-for；用法: v-for=”别名 in 集合名”</p>\n<h4 id=\"迭代数组\"><a href=\"#迭代数组\" class=\"headerlink\" title=\"迭代数组\"></a>迭代数组</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item, i in list\"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    list: [1,2,3,4]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>其中的i是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义</strong></p>\n<h4 id=\"迭代对象数组\"><a href=\"#迭代对象数组\" class=\"headerlink\" title=\"迭代对象数组\"></a>迭代对象数组</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item in list2\"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    list2: [</span><br><span class=\"line\">            &#123; id:1, name: <span class=\"string\">'嘻嘻'</span> &#125;,</span><br><span class=\"line\">            &#123; id:2, name: <span class=\"string\">'哈哈'</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>迭代对象数组，通过 的方式，这个属性名就是对象数组中定义的元素属性名</strong></p>\n<h4 id=\"迭代对象\"><a href=\"#迭代对象\" class=\"headerlink\" title=\"迭代对象\"></a>迭代对象</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"(val, key) in user\"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">            id: 1,</span><br><span class=\"line\">            name: <span class=\"string\">'LoonyCoder'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>迭代对象，迭代得到的是对象的value值和key值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。</strong></p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"item, i in list\"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"item in list2\"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"(val, key) in user\"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            list: [1,2,3,4], </span><br><span class=\"line\">            list2: [</span><br><span class=\"line\">                &#123; id:1, name: <span class=\"string\">'嘻嘻'</span> &#125;,</span><br><span class=\"line\">                &#123; id:2, name: <span class=\"string\">'哈哈'</span> &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            user: &#123;</span><br><span class=\"line\">                id: 1,</span><br><span class=\"line\">                name: <span class=\"string\">'LoonyCoder'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>在vue2.0+版本里，当使用v-for渲染数据，必须制定对应的key值（这里的key是一个属性，不是前面迭代的key值）。</p>\n<p><strong>用法：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item in user\"</span> :key=<span class=\"string\">\"item.id\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>其中:key就说明了key属性必须是通过v-bind绑定的元素，而:key=””中指定的值必须是string/number类型的值，比如此处使用的是item.id中ID是number值，并且是唯一的。<br><strong>目的：</strong><br>避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。</p>\n<h4 id=\"v-show和v-if\"><a href=\"#v-show和v-if\" class=\"headerlink\" title=\"v-show和v-if\"></a>v-show和v-if</h4><p>Vue提供了两个指令来实现元素显示状态的切换：v-if v-show<br><strong>区别</strong></p>\n<ul>\n<li>v-if的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。</li>\n<li>v-show的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的display:none样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"flag=!flag\"</span> value=<span class=\"string\">\"toggle\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;h3 v-if=<span class=\"string\">\"flag\"</span>&gt;这是v-if控制的元素&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3 v-show=<span class=\"string\">\"flag\"</span>&gt;这是v-show控制的元素&lt;/h3&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            flag: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果如下：<br><img src=\"/images/vue6.png\" alt=\"vue6\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是Vue-js\"><a href=\"#什么是Vue-js\" class=\"headerlink\" title=\"什么是Vue.js\"></a>什么是Vue.js</h3><ul>\n<li>Vue.js是目前很火的前端框架；与Angualr.js和React.js并称为前端三大主流框架。</li>\n<li>Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，</li>\n<li>在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。</li>\n</ul>\n<hr>\n<h3 id=\"后端的MVC和前端的MVVM之间的区别\"><a href=\"#后端的MVC和前端的MVVM之间的区别\" class=\"headerlink\" title=\"后端的MVC和前端的MVVM之间的区别\"></a>后端的MVC和前端的MVVM之间的区别</h3><ul>\n<li><p>MVC是后端的分层开发概念</p>\n</li>\n<li><p>MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）</p>\n</li>\n<li><p>Model： 页面需要展示的数据</p>\n</li>\n<li><p>View: 视图、HTML</p>\n</li>\n<li><p>VM: 数据（Model）和视图（View）之间的调度者</p>\n</li>\n</ul>\n<p><strong>图解</strong><br><img src=\"/images/vue1.png\" alt=\"vue图解\"></p>\n<hr>\n<h3 id=\"入门案例\"><a href=\"#入门案例\" class=\"headerlink\" title=\"入门案例\"></a>入门案例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- 插值表达式 --&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123;     // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'Hello Vue!'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<p>1、首先需要引入Vue.js<br>2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到<br>3、创建Vue实例，这个实例其实就是MVVM中的vm调度者<br>4、el: 表示当时Vue实例的控制区域；data: 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。<br>5、在指定Vue实例区域下，展示我们已经声明的元素msg，使用：即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）</p>\n<hr>\n<h3 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h3><h4 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h4><p>在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在vue.js还没有加载完毕时，视图层不会将识别为Vue中的插值表达式，而是作为字符串显示到页面上。<br>为了解决这个问题，Vue.js提供了v-cloak指令，可以解决插值表达式闪烁的问题。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>扩展</strong></p>\n<p>解决插值表达式闪烁问题，除了v-cloak指令，Vue还提供了v-text指令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-text=<span class=\"string\">\"msg\"</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>v-cloak与v-text的区别</strong><br>v-text默认会覆盖掉元素中原有的内容<br>v-cloak不会覆盖掉原有的内容<br><img src=\"/images/vue2.png\" alt=\"vue2\"></p>\n<h4 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h4><p><strong>在上面，我们了解了v-text输出Vue元素，但是如果我们需要显示的数据是一段HTML代码，v-text和都将无能为力，<br>为此，Vue提供了专门渲染HTML数据的指令：v-html</strong></p>\n<p><img src=\"/images/vue3.png\" alt=\"vue3\"></p>\n<p>上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用）这样可以吗？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"msg\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。<br>为了解决上述问题，Vue提供了v-bind:指令来绑定一些HTML属性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> v-bind:value=<span class=\"string\">\"msg\"</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，被v-bind:绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外v-bind:还有一个简易写法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"msg\"</span> /&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> v-bind:value=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'戳我'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果如图：<br><img src=\"/images/vue4.png\" alt=\"vue4\"></p>\n<h4 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h4><p>Vue提供了事件绑定机制的指令：v-on:；用其我们可以用来绑定一些常见的触发事件：click、mouseover …</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span> v-on:click=<span class=\"string\">\"show\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span> v-on:mouseover=<span class=\"string\">\"show\"</span>&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'戳我'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            show: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">                alert(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中methods是Vue内置的对象，用于存放一些自定义的方法函数</p>\n<p><strong>拓展</strong></p>\n<p>使用js内置的函数setInterval(定时器)，实现跑马灯效果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"开始\"</span> @click=<span class=\"string\">\"action\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"停止\"</span> @click=<span class=\"string\">\"stop\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'嘻嘻，哈哈'</span>,</span><br><span class=\"line\">            intervalId: null</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">action</span></span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(this.intervalId != null) <span class=\"built_in\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                // 定时器</span><br><span class=\"line\">                this.intervalId = setInterval(() =&gt; &#123;</span><br><span class=\"line\">                    // 截取首字符</span><br><span class=\"line\">                    var start = this.msg.substring(0, 1);</span><br><span class=\"line\">                    // 截取第一个字符后的所有字符</span><br><span class=\"line\">                    var end = this.msg.substring(1);</span><br><span class=\"line\">                    // 将后面的字符拼接到前面，实现循环的效果</span><br><span class=\"line\">                    this.msg = end + start;</span><br><span class=\"line\">                &#125;,400)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">stop</span></span>()&#123;</span><br><span class=\"line\">                // 停止定时器</span><br><span class=\"line\">                clearInterval(this.intervalId)</span><br><span class=\"line\">                // 每次清除定时器后需要将intervalId重新设置为null</span><br><span class=\"line\">                this.intervalId = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<p>1、v-on:也有简写形式：@，用法如上。<br>2、在视图层取VM中的数据我们可以使用或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：this.数据属性名（其中的this表示当前VM实例对象）。<br>3、methodName:function(){}在ES6中有一个简便的写法：methodName(){}。 4、setInterval()和clearInterval()是js中内置的函数，用法如上。<br>5、正常我们调用函数会写：name(function(){})，而ES6也提供了一个方式：methodName(() =&gt; {})，这种用法的好处就解决了this指向问题，因为如果元素定义在了函数内部，那么其中的this就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的=&gt;。</p>\n<p>效果如图：<br><img src=\"/images/vue5.png\" alt=\"vue5\"></p>\n<h4 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h4><blockquote>\n<p>.stop 阻止冒泡<br>.prevent 阻止默认事件<br>.capture 添加时间侦听器时使用时间捕获模式<br>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调<br>.once 事件只触发一次</p>\n</blockquote>\n<p>用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;div @click=<span class=\"string\">\"divClick\"</span>&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"戳我\"</span> @click.stop=<span class=\"string\">\"btnClick\"</span>&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"戳我\"</span> @click.prevent=<span class=\"string\">\"btnClick\"</span>&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'嘻嘻，哈哈'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">divClick</span></span>() &#123;</span><br><span class=\"line\">                console.log(<span class=\"string\">\"这是div的点击事件\"</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">btnClick</span></span>() &#123;</span><br><span class=\"line\">                console.log(<span class=\"string\">\"这是btn的点击事件\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h4><ul>\n<li>唯一的双向绑定指令：v-model</li>\n<li>单向绑定指令：v-bing</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'hello!'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"Vue中的样式\"><a href=\"#Vue中的样式\" class=\"headerlink\" title=\"Vue中的样式\"></a>Vue中的样式</h3><h4 id=\"外联样式\"><a href=\"#外联样式\" class=\"headerlink\" title=\"外联样式\"></a>外联样式</h4><ul>\n<li><p>数组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"['italic','color']\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n<p>其中的italic、color是自定义的类名，需在外部定义CSS样式</p>\n</li>\n<li><p>数组中嵌套对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"['italic',&#123;'color': flag&#125;]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n<p>其中的flag是Vue绑定的变量，在data进行声明</p>\n</li>\n<li><p>直接使用对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"&#123;italic:true, color:flag&#125;\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .italic &#123;</span><br><span class=\"line\">        font-style: italic;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .color &#123;</span><br><span class=\"line\">        color: skyblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"['italic','color']\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"['italic', &#123;'color':flag&#125;]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"&#123;italic:false, color:flag&#125;\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            flag: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内联样式\"><a href=\"#内联样式\" class=\"headerlink\" title=\"内联样式\"></a>内联样式</h4><ul>\n<li><p>将样式对象定义到data中，并在:style中引用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :style=<span class=\"string\">\"styleObj\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在:style中通过数组，引用多个data上的样式对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :style=<span class=\"string\">\"[styleObj, styleObj2]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span>&#125;,</span><br><span class=\"line\">    styleObj2: &#123; <span class=\"string\">'font-style'</span>: <span class=\"string\">'italic'</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;h2 :style=<span class=\"string\">\"styleObj\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :style=<span class=\"string\">\"[styleObj, styleObj2]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span> &#125;,</span><br><span class=\"line\">            styleObj2: &#123; <span class=\"string\">'font-style'</span>: <span class=\"string\">'italic'</span> &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h4><p>Vue提供了遍历集合、数组的指令：v-for；用法: v-for=”别名 in 集合名”</p>\n<h4 id=\"迭代数组\"><a href=\"#迭代数组\" class=\"headerlink\" title=\"迭代数组\"></a>迭代数组</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item, i in list\"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    list: [1,2,3,4]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>其中的i是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义</strong></p>\n<h4 id=\"迭代对象数组\"><a href=\"#迭代对象数组\" class=\"headerlink\" title=\"迭代对象数组\"></a>迭代对象数组</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item in list2\"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    list2: [</span><br><span class=\"line\">            &#123; id:1, name: <span class=\"string\">'嘻嘻'</span> &#125;,</span><br><span class=\"line\">            &#123; id:2, name: <span class=\"string\">'哈哈'</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>迭代对象数组，通过 的方式，这个属性名就是对象数组中定义的元素属性名</strong></p>\n<h4 id=\"迭代对象\"><a href=\"#迭代对象\" class=\"headerlink\" title=\"迭代对象\"></a>迭代对象</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"(val, key) in user\"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">            id: 1,</span><br><span class=\"line\">            name: <span class=\"string\">'LoonyCoder'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>迭代对象，迭代得到的是对象的value值和key值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。</strong></p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"item, i in list\"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"item in list2\"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"(val, key) in user\"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            list: [1,2,3,4], </span><br><span class=\"line\">            list2: [</span><br><span class=\"line\">                &#123; id:1, name: <span class=\"string\">'嘻嘻'</span> &#125;,</span><br><span class=\"line\">                &#123; id:2, name: <span class=\"string\">'哈哈'</span> &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            user: &#123;</span><br><span class=\"line\">                id: 1,</span><br><span class=\"line\">                name: <span class=\"string\">'LoonyCoder'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>在vue2.0+版本里，当使用v-for渲染数据，必须制定对应的key值（这里的key是一个属性，不是前面迭代的key值）。</p>\n<p><strong>用法：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item in user\"</span> :key=<span class=\"string\">\"item.id\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>其中:key就说明了key属性必须是通过v-bind绑定的元素，而:key=””中指定的值必须是string/number类型的值，比如此处使用的是item.id中ID是number值，并且是唯一的。<br><strong>目的：</strong><br>避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。</p>\n<h4 id=\"v-show和v-if\"><a href=\"#v-show和v-if\" class=\"headerlink\" title=\"v-show和v-if\"></a>v-show和v-if</h4><p>Vue提供了两个指令来实现元素显示状态的切换：v-if v-show<br><strong>区别</strong></p>\n<ul>\n<li>v-if的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。</li>\n<li>v-show的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的display:none样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"flag=!flag\"</span> value=<span class=\"string\">\"toggle\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;h3 v-if=<span class=\"string\">\"flag\"</span>&gt;这是v-if控制的元素&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3 v-show=<span class=\"string\">\"flag\"</span>&gt;这是v-show控制的元素&lt;/h3&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            flag: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果如下：<br><img src=\"/images/vue6.png\" alt=\"vue6\"></p>\n"},{"title":"Java基础（二）","date":"2019-12-29T16:00:00.000Z","_content":"\n###对象与类\n\n#### 对象的创建\n\n比如Student s = new Student()实例化一个对象，其实经历了如下几个过程：\n将Student.class加载到内存中\n在栈内存中给s开辟内存空间。\n在堆内存给Student类申请一个内存空间。\n给成员变量进行默认初始化，0 null false…\n自定义给成员变量初始化赋值\n初始化完毕，把堆内存地址赋值给栈内存的s变量\n\n#### Main方法剖析\n\n```bash\npublic static void main(String[] args) { ... }\n```\n\n- public: 公共的，访问权限最大，因为main方法是被JVM调用的。\n- static：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。\n- void: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。\n- main: 常见的方法入口，很多语言的入口方法都是main方法。\n- String[] args: 字符串数组，是作为命令行参数调用的。\n\n##### static关键字\n\n**static关键字特点：（可以修饰成员变量，也可修饰成员方法）**\n\n- 随着类的加载而加载\n- 优先于对象存在\n- 被类中的所有对象共享\n- 可直接通过类名调用\n\n**拓展**\n\n静态方法中没有this关键字，因为this代表当前方法对象，但static优于对象存在，所以在对象还未创建完毕static修饰的方法就被调用，此时this代表的对象还未创建。\n\n#### String\n\nString底层定义为public final class String，说明String是常量，一旦被创建就不能修改。可以查看如Integer LongString这些类的源码：\n```bash\npublic final class Integer {}\npublic final class Long {}\npublic final class String {}\n\n```\n\n这些**基本类型**，在初始化值、赋值时都是先从**常量池**中取数据，如果常量池中没有该数据，就new对象初始化为新数据。\n比如常见的一个面试题：\n```bash\nString s = \"ab\";\ns = \"abc\";\nString ss = \"ab\";\nss = new String(\"ab\");\n```\n\n这个s和ss各自创建了几个对象？答案：s创建两个对象；ss创建一个对象。因为s的常量池中有值ab，而重新赋值s = \"abc\"这个abc在s的常量池中不存在，所以new String()创建了一个新对象。ss同理分析。可以通过如下方式验证：\n```bash\nString ss = \"ab\";\nSystem.out.println(ss.hashCode());\nss = \"abc\";\nSystem.out.println(ss.hashCode());\n```\n[stack](/images/String1.png)\n\n##### StringBuffer\nString是不可变的字符串，StringBuffer是线程安全的可变字符串，用StringBuffer做字符串的拼接可以避免资源的浪费，因为String每次拼接新的字符串都是创建一个新的String对象。\n\n**String转换为StringBuffer**\n```bash\n//方式一\nString s = \"hello\";\nStringBuffer sb = new StringBuffer(s);\n//方式二\nStringBuffer sb = new StringBuffer();\nsb.append(s);\n```\n\n**StringBuffer转换成String**\n```bash\n//方式一\nStringBuffer sb = new StringBuffer(\"hello\");\nString s = new String(sb);\n//方式二\nString s = sb.toString();\n```\n\n##### 面试题\n\n> String, StringBuffer, StringBuilder 的区别？\n- String的内容不可变，StringBuffer和StringBuilder的内容都可变。\n- StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。\n\n> StringBuffer和数组的区别？\n- 二者都是一个容器，装其他数据\n- 但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。\n\n> String和StringBuffer作为参数传递\n- String可理解为特殊的引用类型，和基本类型一样，参数传递不会改变原数据内容。\n- StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。\n\n```bash\npublic class StringBufferDemo {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        String s2 = \"world\";\n        System.out.println(s1 + \"---\" + s2);// hello---world\n        change(s1, s2);\n        System.out.println(s1 + \"---\" + s2);// hello---world\n\n        StringBuffer sb1 = new StringBuffer(\"hello\");\n        StringBuffer sb2 = new StringBuffer(\"world\");\n        System.out.println(sb1 + \"---\" + sb2);// hello---world\n        change(sb1, sb2);\n        System.out.println(sb1 + \"---\" + sb2);// hello---worldworld\n\n    }\n\n    public static void change(StringBuffer sb1, StringBuffer sb2) {\n        sb1 = sb2;\n        sb2.append(sb1);\n    }\n\n    public static void change(String s1, String s2) {\n        s1 = s2;\n        s2 = s1 + s2;\n    }\n}\n```\n\n#### 参数传递\n\nJava中的参数传递：\n- 基本类型：形式参数的改变对实际参数没有影响。\n- 引用类型：形式参数的改变直接影响实际参数。\n\n例如：\n```bash\npublic class Demo01_Object {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 20;\n        change(a, b);\n        System.out.println(\"main: a:\" + a + \", b:\" + b); //10, 20\n        int[] arr = {1, 2, 3};\n        change(arr);\n        System.out.println(\"main: \" + arr[0]); //2\n    }\n\n    private static void change(int a, int b) {\n        a = b;\n        b = a + b;\n        System.out.println(\"change: a:\" + a + \", b:\" + b); //20, 40\n    }\n\n    private static void change(int[] arr) {\n        arr[0] = arr[1];\n        System.out.println(\"change\" + arr[0]); //2\n    }\n}\n```\n\n**引入概念**：\n在Java中**一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。所有的Java对象都储存在堆内存中**。例如：Date t = new Date()其中的t就是一个对象变量，new Date()是在堆内存中开辟了一个空间，而t指向new Date()的堆内存地址。\n因此，在上述代码中a b都是基本类型，而int[]是一个引用类型，那**基本类型形式参数改变对实际参数没有影响；对象类型形式参数改变直接影响实际参数。**\n\n[stack](/images/stack.png)\n\n##### 总结\n**Java程序语言总是采用按值调用**，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。\n- 一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。\n- 一个方法可以改变一个对象的引用状态\n- 一个方法不能让对象参数引用一个新对象\n\n比如：下列是无意义的：\n```bash\npublic static void swap(Employee x, Employee y) {\n    Employee temp = x;\n    x = y;\n    y = temp;\n}\n```\n\n当调用swap(e1, e2)时并不会改变e1和e2的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。\n\n- **基本类型**（包括Integer String Long）传递的参数是参数**值**的拷贝\n\n特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如IntgerCache LongCache，如果常量池中没有就重新new对象，例如：\n```bash\npublic static void main(String[] args) {\n    String s = \"123\";\n    System.out.println(\"main: \" + s.hashCode()); //48690\n    change(s);\n    change2(s);\n}\nprivate static void change(String s) {\n    s = \"123\";\n    System.out.println(\"change: \" + s.hashCode()); //48690\n}\nprivate static change2(String s) {\n    s = \"456\";\n    System.out.println(\"change2: \" + s.hashCode()); //51669\n}\n```\n\n- **引用类型**传递的参数是原对象在**堆内存的地址**的拷贝\n\n对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。\n\n#### 成员变量和局部变量\n成员变量和局部变量的区别：\n* 在类中的位置不同：\n   - 成员变量：在类中方法外\n   - 局部变量：在方法定义中或方法声明上\n* 在内存中的位置不同：\n   - 成员变量：在堆内存\n   - 局部变量：在栈内存\n* 声明周期不同：\n   - 成员变量：随着对象的创建而存在，随着对象的消失而消失。\n   - 局部变量：随着方法的调用而存在，随着方法调用完毕而消失\n* 初始化值不同：\n   - 成员变量：有默认初始化值\n   - 局部变量：没有默认初始化值，必须定义、赋值后才能使用\n\n#### 构造方法\n在Java中，当需要调用构造方法时，**若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义**。举例：\n```bash\npublic class Demo2_Construct {\n    public static void main(String[] args) {\n        Demo2Student student = new Demo2Student();\n        student.show();\n        // Demo2School school = new Demo2School(); //error\n    }\n}\n\nclass Demo2Student {\n    public void show() {\n        System.out.println(\"this student show\");\n    }\n}\n\nclass Demo2School {\n    private int size = 1000;\n    public Demo2School(int size) {\n        this.size = size;\n    }\n}\n```\n\n##### final\nfinal可以修改类、方法、变量。\n\n**特点**：\n- final可以修饰类，该类不能被继承。\n- final可以修饰方法，该方法不能被重写。\n- final可以修饰变量，该变量不能被重新赋值。\n\n**面试题**：final修饰局部变量的问题\n- 基本类型：被final修饰的基本类型的值不能被改变\n- 引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。\n\n**初始化时机**\n被final修饰的变量必须在构造方法完毕前被初始化，比如\n```bash\npublic class Demo {\n    final int WIDTH = 12;\n    //final int HEIGHT; //error\n    final int AREA;\n    {\n        AREA = 120;\n    }\n}\n```\n\n#### 继承\n1、Java支持单继承不支持多继承，但Java支持多层继承\n2、子类只能继承父类非私有成员（成员变量、成员方法）\n3、子类不能继承父类的构造方法，但可以通过super关键字访问父类的构造方法。\n\n##### 子类和父类的关系\n**子类中的所有构造方法都默认访问父类的无参构造方法**。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是super()。\n```bash\npublic class Demo04_Extends {\n    public static void main(String[] args) {\n        Demo04Son son = new Demo04Son();\n        son.show();\n    }\n}\n\nclass Demo04Son extends Demo04Parent{\n    private int num = 10;\n    public Demo04Son() {\n        super();\n    }\n\n    public void show() {\n        int num = 100;\n        System.out.println(num);\n        System.out.println(this.num);\n        System.out.println(super.num);\n    }\n}\n\nclass Demo04Parent {\n    public int num = 1;\n\n    public Demo04Parent() {\n        System.out.println(\"这是父类的无参构造函数\");\n    }\n}\n```\n\n##### this-super\nthis和super关键字的区别和使用场景？\n区别：\n- this: 代表当前类的对象引用\n- super: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）\n场景：\n- this.成员变量/方法\n- super.成员变量/方法\n- this(…) super(…)\n\n##### 加载顺序\n```bash\npublic class Demo04_Extends2 {\n    public static void main(String[] args) {\n        Demo04Zi zi = new Demo04Zi();\n    }\n}\nclass Demo04Fu {\n    static {\n        System.out.println(\"Fu 静态代码块\");\n    }\n    {\n        System.out.println(\"Fu 构造代码块\");\n    }\n    public Demo04Fu() {\n        System.out.println(\"Fu 构造方法\");\n    }\n}\nclass Demo04Zi extends Demo04Fu{\n    static {\n        System.out.println(\"Zi 静态代码块\");\n    }\n    {\n        System.out.println(\"Zi 构造代码块\");\n    }\n    public Demo04Zi() {\n        System.out.println(\"Zi 构造方法\");\n    }\n}\n```\n\n结果：\n```bash\nFu 静态代码块\nZi 静态代码块\nFu 构造代码块\nFu 构造方法\nZi 构造代码块\nZi 构造方法\n```\n\n##### 动态绑定\n**调用对象方法的执行过程：**\n[DomaticBind](/images/DomaticBind.png)\n1.编译器首先查看对象的声明类型和方法名。如调用change(a)方法，由于存在多个change()方法，JVM会先列举该类以及其超类中访问属性为public且名为change的方法。\n2.接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个方法表**（method table）**，JVM会直接从这个方法表中寻找名为change的方法中存在一个与提供的参数类型匹配的方法，这个过程称为**重载解析**。\n3.如果是private、static、final方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为**静态绑定**。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现**动态绑定**。\n4.当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。\n\n##### 强制类型转换\n将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接(int) double这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。\n- **向上转型**：将一个子类的引用赋值给一个超类变量。\n- **向下转型**：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。\n\n**注意**\n\n- 只能在继承层次内进行类型转换。\n- 在将超类转换成子类之前，应该使用instanceof进行检查。\n\n##### 内部类\n\n一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。\n- 内部类可以直接访问外部类的成员，包括私有\n- 外部类可以访问内部类的成员，必须创建对象\n- 直接访问内部类的成员：Outer.Inner in = new Outer().new Inner()\n\n**局部内部类**\n局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。\n\n> 局部内部类访问局部变量注意事项?\n​局部内部类访问局部变量必须用final修饰。因为**局部内部类的声明周期比局部变量长**，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。\n\n```bash\npublic class InnerClass {\n    public static void main(String[] args) {\n        Outer outer = new Outer();\n        outer.show();\n    }\n}\n\nclass Outer {\n    public void show() {\n        int num2 = 10;\n        class Inner {\n            private void show() {\n                System.out.println(num2);\n            }\n        }\n        Inner inner = new Inner();\n        inner.show();\n    }\n}\n```\n此时调用不会报错，但并没有加final修饰。这个类编译后会生成InnerClass.class和Outer.class两个文件，我们来看下Outer.class:\n```bash\nclass Outer {\n    Outer() {}\n    public void show() {\n        final int num2 = 10;\n        class Inner {\n            Inner() {}\n            private void show() {\n                System.out.println(num2);\n            }\n        }\n        Inner inner = new Inner();\n        inner.show();\n    }\n}\n```\n其中的num2被自动加上了final修饰（这是因为JDK1.8的原因），所以如果你再添上num2 = 1000就会报错。\n\n> 解决办法\n上面说过了应该将num2用final修饰。其原因就是Inner类的生命周期要比num2的声明周期长，当show()方法调用完毕后num2就已经消失了，但此时Inner类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用final修饰，这个变量成为常量，在初始化内部类的时候，final num2就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。","source":"_posts/JavaBasic2.md","raw":"---\ntitle: Java基础（二）\ncategories:\n    - Java\ndate: 2019-12-30\ntags:\n\t- Java\n\t- Java基础\n\n---\n\n###对象与类\n\n#### 对象的创建\n\n比如Student s = new Student()实例化一个对象，其实经历了如下几个过程：\n将Student.class加载到内存中\n在栈内存中给s开辟内存空间。\n在堆内存给Student类申请一个内存空间。\n给成员变量进行默认初始化，0 null false…\n自定义给成员变量初始化赋值\n初始化完毕，把堆内存地址赋值给栈内存的s变量\n\n#### Main方法剖析\n\n```bash\npublic static void main(String[] args) { ... }\n```\n\n- public: 公共的，访问权限最大，因为main方法是被JVM调用的。\n- static：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。\n- void: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。\n- main: 常见的方法入口，很多语言的入口方法都是main方法。\n- String[] args: 字符串数组，是作为命令行参数调用的。\n\n##### static关键字\n\n**static关键字特点：（可以修饰成员变量，也可修饰成员方法）**\n\n- 随着类的加载而加载\n- 优先于对象存在\n- 被类中的所有对象共享\n- 可直接通过类名调用\n\n**拓展**\n\n静态方法中没有this关键字，因为this代表当前方法对象，但static优于对象存在，所以在对象还未创建完毕static修饰的方法就被调用，此时this代表的对象还未创建。\n\n#### String\n\nString底层定义为public final class String，说明String是常量，一旦被创建就不能修改。可以查看如Integer LongString这些类的源码：\n```bash\npublic final class Integer {}\npublic final class Long {}\npublic final class String {}\n\n```\n\n这些**基本类型**，在初始化值、赋值时都是先从**常量池**中取数据，如果常量池中没有该数据，就new对象初始化为新数据。\n比如常见的一个面试题：\n```bash\nString s = \"ab\";\ns = \"abc\";\nString ss = \"ab\";\nss = new String(\"ab\");\n```\n\n这个s和ss各自创建了几个对象？答案：s创建两个对象；ss创建一个对象。因为s的常量池中有值ab，而重新赋值s = \"abc\"这个abc在s的常量池中不存在，所以new String()创建了一个新对象。ss同理分析。可以通过如下方式验证：\n```bash\nString ss = \"ab\";\nSystem.out.println(ss.hashCode());\nss = \"abc\";\nSystem.out.println(ss.hashCode());\n```\n[stack](/images/String1.png)\n\n##### StringBuffer\nString是不可变的字符串，StringBuffer是线程安全的可变字符串，用StringBuffer做字符串的拼接可以避免资源的浪费，因为String每次拼接新的字符串都是创建一个新的String对象。\n\n**String转换为StringBuffer**\n```bash\n//方式一\nString s = \"hello\";\nStringBuffer sb = new StringBuffer(s);\n//方式二\nStringBuffer sb = new StringBuffer();\nsb.append(s);\n```\n\n**StringBuffer转换成String**\n```bash\n//方式一\nStringBuffer sb = new StringBuffer(\"hello\");\nString s = new String(sb);\n//方式二\nString s = sb.toString();\n```\n\n##### 面试题\n\n> String, StringBuffer, StringBuilder 的区别？\n- String的内容不可变，StringBuffer和StringBuilder的内容都可变。\n- StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。\n\n> StringBuffer和数组的区别？\n- 二者都是一个容器，装其他数据\n- 但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。\n\n> String和StringBuffer作为参数传递\n- String可理解为特殊的引用类型，和基本类型一样，参数传递不会改变原数据内容。\n- StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。\n\n```bash\npublic class StringBufferDemo {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        String s2 = \"world\";\n        System.out.println(s1 + \"---\" + s2);// hello---world\n        change(s1, s2);\n        System.out.println(s1 + \"---\" + s2);// hello---world\n\n        StringBuffer sb1 = new StringBuffer(\"hello\");\n        StringBuffer sb2 = new StringBuffer(\"world\");\n        System.out.println(sb1 + \"---\" + sb2);// hello---world\n        change(sb1, sb2);\n        System.out.println(sb1 + \"---\" + sb2);// hello---worldworld\n\n    }\n\n    public static void change(StringBuffer sb1, StringBuffer sb2) {\n        sb1 = sb2;\n        sb2.append(sb1);\n    }\n\n    public static void change(String s1, String s2) {\n        s1 = s2;\n        s2 = s1 + s2;\n    }\n}\n```\n\n#### 参数传递\n\nJava中的参数传递：\n- 基本类型：形式参数的改变对实际参数没有影响。\n- 引用类型：形式参数的改变直接影响实际参数。\n\n例如：\n```bash\npublic class Demo01_Object {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 20;\n        change(a, b);\n        System.out.println(\"main: a:\" + a + \", b:\" + b); //10, 20\n        int[] arr = {1, 2, 3};\n        change(arr);\n        System.out.println(\"main: \" + arr[0]); //2\n    }\n\n    private static void change(int a, int b) {\n        a = b;\n        b = a + b;\n        System.out.println(\"change: a:\" + a + \", b:\" + b); //20, 40\n    }\n\n    private static void change(int[] arr) {\n        arr[0] = arr[1];\n        System.out.println(\"change\" + arr[0]); //2\n    }\n}\n```\n\n**引入概念**：\n在Java中**一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。所有的Java对象都储存在堆内存中**。例如：Date t = new Date()其中的t就是一个对象变量，new Date()是在堆内存中开辟了一个空间，而t指向new Date()的堆内存地址。\n因此，在上述代码中a b都是基本类型，而int[]是一个引用类型，那**基本类型形式参数改变对实际参数没有影响；对象类型形式参数改变直接影响实际参数。**\n\n[stack](/images/stack.png)\n\n##### 总结\n**Java程序语言总是采用按值调用**，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。\n- 一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。\n- 一个方法可以改变一个对象的引用状态\n- 一个方法不能让对象参数引用一个新对象\n\n比如：下列是无意义的：\n```bash\npublic static void swap(Employee x, Employee y) {\n    Employee temp = x;\n    x = y;\n    y = temp;\n}\n```\n\n当调用swap(e1, e2)时并不会改变e1和e2的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。\n\n- **基本类型**（包括Integer String Long）传递的参数是参数**值**的拷贝\n\n特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如IntgerCache LongCache，如果常量池中没有就重新new对象，例如：\n```bash\npublic static void main(String[] args) {\n    String s = \"123\";\n    System.out.println(\"main: \" + s.hashCode()); //48690\n    change(s);\n    change2(s);\n}\nprivate static void change(String s) {\n    s = \"123\";\n    System.out.println(\"change: \" + s.hashCode()); //48690\n}\nprivate static change2(String s) {\n    s = \"456\";\n    System.out.println(\"change2: \" + s.hashCode()); //51669\n}\n```\n\n- **引用类型**传递的参数是原对象在**堆内存的地址**的拷贝\n\n对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。\n\n#### 成员变量和局部变量\n成员变量和局部变量的区别：\n* 在类中的位置不同：\n   - 成员变量：在类中方法外\n   - 局部变量：在方法定义中或方法声明上\n* 在内存中的位置不同：\n   - 成员变量：在堆内存\n   - 局部变量：在栈内存\n* 声明周期不同：\n   - 成员变量：随着对象的创建而存在，随着对象的消失而消失。\n   - 局部变量：随着方法的调用而存在，随着方法调用完毕而消失\n* 初始化值不同：\n   - 成员变量：有默认初始化值\n   - 局部变量：没有默认初始化值，必须定义、赋值后才能使用\n\n#### 构造方法\n在Java中，当需要调用构造方法时，**若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义**。举例：\n```bash\npublic class Demo2_Construct {\n    public static void main(String[] args) {\n        Demo2Student student = new Demo2Student();\n        student.show();\n        // Demo2School school = new Demo2School(); //error\n    }\n}\n\nclass Demo2Student {\n    public void show() {\n        System.out.println(\"this student show\");\n    }\n}\n\nclass Demo2School {\n    private int size = 1000;\n    public Demo2School(int size) {\n        this.size = size;\n    }\n}\n```\n\n##### final\nfinal可以修改类、方法、变量。\n\n**特点**：\n- final可以修饰类，该类不能被继承。\n- final可以修饰方法，该方法不能被重写。\n- final可以修饰变量，该变量不能被重新赋值。\n\n**面试题**：final修饰局部变量的问题\n- 基本类型：被final修饰的基本类型的值不能被改变\n- 引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。\n\n**初始化时机**\n被final修饰的变量必须在构造方法完毕前被初始化，比如\n```bash\npublic class Demo {\n    final int WIDTH = 12;\n    //final int HEIGHT; //error\n    final int AREA;\n    {\n        AREA = 120;\n    }\n}\n```\n\n#### 继承\n1、Java支持单继承不支持多继承，但Java支持多层继承\n2、子类只能继承父类非私有成员（成员变量、成员方法）\n3、子类不能继承父类的构造方法，但可以通过super关键字访问父类的构造方法。\n\n##### 子类和父类的关系\n**子类中的所有构造方法都默认访问父类的无参构造方法**。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是super()。\n```bash\npublic class Demo04_Extends {\n    public static void main(String[] args) {\n        Demo04Son son = new Demo04Son();\n        son.show();\n    }\n}\n\nclass Demo04Son extends Demo04Parent{\n    private int num = 10;\n    public Demo04Son() {\n        super();\n    }\n\n    public void show() {\n        int num = 100;\n        System.out.println(num);\n        System.out.println(this.num);\n        System.out.println(super.num);\n    }\n}\n\nclass Demo04Parent {\n    public int num = 1;\n\n    public Demo04Parent() {\n        System.out.println(\"这是父类的无参构造函数\");\n    }\n}\n```\n\n##### this-super\nthis和super关键字的区别和使用场景？\n区别：\n- this: 代表当前类的对象引用\n- super: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）\n场景：\n- this.成员变量/方法\n- super.成员变量/方法\n- this(…) super(…)\n\n##### 加载顺序\n```bash\npublic class Demo04_Extends2 {\n    public static void main(String[] args) {\n        Demo04Zi zi = new Demo04Zi();\n    }\n}\nclass Demo04Fu {\n    static {\n        System.out.println(\"Fu 静态代码块\");\n    }\n    {\n        System.out.println(\"Fu 构造代码块\");\n    }\n    public Demo04Fu() {\n        System.out.println(\"Fu 构造方法\");\n    }\n}\nclass Demo04Zi extends Demo04Fu{\n    static {\n        System.out.println(\"Zi 静态代码块\");\n    }\n    {\n        System.out.println(\"Zi 构造代码块\");\n    }\n    public Demo04Zi() {\n        System.out.println(\"Zi 构造方法\");\n    }\n}\n```\n\n结果：\n```bash\nFu 静态代码块\nZi 静态代码块\nFu 构造代码块\nFu 构造方法\nZi 构造代码块\nZi 构造方法\n```\n\n##### 动态绑定\n**调用对象方法的执行过程：**\n[DomaticBind](/images/DomaticBind.png)\n1.编译器首先查看对象的声明类型和方法名。如调用change(a)方法，由于存在多个change()方法，JVM会先列举该类以及其超类中访问属性为public且名为change的方法。\n2.接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个方法表**（method table）**，JVM会直接从这个方法表中寻找名为change的方法中存在一个与提供的参数类型匹配的方法，这个过程称为**重载解析**。\n3.如果是private、static、final方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为**静态绑定**。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现**动态绑定**。\n4.当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。\n\n##### 强制类型转换\n将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接(int) double这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。\n- **向上转型**：将一个子类的引用赋值给一个超类变量。\n- **向下转型**：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。\n\n**注意**\n\n- 只能在继承层次内进行类型转换。\n- 在将超类转换成子类之前，应该使用instanceof进行检查。\n\n##### 内部类\n\n一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。\n- 内部类可以直接访问外部类的成员，包括私有\n- 外部类可以访问内部类的成员，必须创建对象\n- 直接访问内部类的成员：Outer.Inner in = new Outer().new Inner()\n\n**局部内部类**\n局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。\n\n> 局部内部类访问局部变量注意事项?\n​局部内部类访问局部变量必须用final修饰。因为**局部内部类的声明周期比局部变量长**，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。\n\n```bash\npublic class InnerClass {\n    public static void main(String[] args) {\n        Outer outer = new Outer();\n        outer.show();\n    }\n}\n\nclass Outer {\n    public void show() {\n        int num2 = 10;\n        class Inner {\n            private void show() {\n                System.out.println(num2);\n            }\n        }\n        Inner inner = new Inner();\n        inner.show();\n    }\n}\n```\n此时调用不会报错，但并没有加final修饰。这个类编译后会生成InnerClass.class和Outer.class两个文件，我们来看下Outer.class:\n```bash\nclass Outer {\n    Outer() {}\n    public void show() {\n        final int num2 = 10;\n        class Inner {\n            Inner() {}\n            private void show() {\n                System.out.println(num2);\n            }\n        }\n        Inner inner = new Inner();\n        inner.show();\n    }\n}\n```\n其中的num2被自动加上了final修饰（这是因为JDK1.8的原因），所以如果你再添上num2 = 1000就会报错。\n\n> 解决办法\n上面说过了应该将num2用final修饰。其原因就是Inner类的生命周期要比num2的声明周期长，当show()方法调用完毕后num2就已经消失了，但此时Inner类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用final修饰，这个变量成为常量，在初始化内部类的时候，final num2就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。","slug":"JavaBasic2","published":1,"updated":"2020-01-10T09:11:52.485Z","_id":"ck529vsji0000be6kcklmdvfk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>###对象与类</p>\n<h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><p>比如Student s = new Student()实例化一个对象，其实经历了如下几个过程：<br>将Student.class加载到内存中<br>在栈内存中给s开辟内存空间。<br>在堆内存给Student类申请一个内存空间。<br>给成员变量进行默认初始化，0 null false…<br>自定义给成员变量初始化赋值<br>初始化完毕，把堆内存地址赋值给栈内存的s变量</p>\n<h4 id=\"Main方法剖析\"><a href=\"#Main方法剖析\" class=\"headerlink\" title=\"Main方法剖析\"></a>Main方法剖析</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>public: 公共的，访问权限最大，因为main方法是被JVM调用的。</li>\n<li>static：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。</li>\n<li>void: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。</li>\n<li>main: 常见的方法入口，很多语言的入口方法都是main方法。</li>\n<li>String[] args: 字符串数组，是作为命令行参数调用的。</li>\n</ul>\n<h5 id=\"static关键字\"><a href=\"#static关键字\" class=\"headerlink\" title=\"static关键字\"></a>static关键字</h5><p><strong>static关键字特点：（可以修饰成员变量，也可修饰成员方法）</strong></p>\n<ul>\n<li>随着类的加载而加载</li>\n<li>优先于对象存在</li>\n<li>被类中的所有对象共享</li>\n<li>可直接通过类名调用</li>\n</ul>\n<p><strong>拓展</strong></p>\n<p>静态方法中没有this关键字，因为this代表当前方法对象，但static优于对象存在，所以在对象还未创建完毕static修饰的方法就被调用，此时this代表的对象还未创建。</p>\n<h4 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h4><p>String底层定义为public final class String，说明String是常量，一旦被创建就不能修改。可以查看如Integer LongString这些类的源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class Integer &#123;&#125;</span><br><span class=\"line\">public final class Long &#123;&#125;</span><br><span class=\"line\">public final class String &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这些<strong>基本类型</strong>，在初始化值、赋值时都是先从<strong>常量池</strong>中取数据，如果常量池中没有该数据，就new对象初始化为新数据。<br>比如常见的一个面试题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">s = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">String ss = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">ss = new String(<span class=\"string\">\"ab\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个s和ss各自创建了几个对象？答案：s创建两个对象；ss创建一个对象。因为s的常量池中有值ab，而重新赋值s = “abc”这个abc在s的常量池中不存在，所以new String()创建了一个新对象。ss同理分析。可以通过如下方式验证：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String ss = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">System.out.println(ss.hashCode());</span><br><span class=\"line\">ss = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">System.out.println(ss.hashCode());</span><br></pre></td></tr></table></figure>\n<p><a href=\"/images/String1.png\">stack</a></p>\n<h5 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h5><p>String是不可变的字符串，StringBuffer是线程安全的可变字符串，用StringBuffer做字符串的拼接可以避免资源的浪费，因为String每次拼接新的字符串都是创建一个新的String对象。</p>\n<p><strong>String转换为StringBuffer</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式一</span><br><span class=\"line\">String s = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">StringBuffer sb = new StringBuffer(s);</span><br><span class=\"line\">//方式二</span><br><span class=\"line\">StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">sb.append(s);</span><br></pre></td></tr></table></figure>\n\n<p><strong>StringBuffer转换成String</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式一</span><br><span class=\"line\">StringBuffer sb = new StringBuffer(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">String s = new String(sb);</span><br><span class=\"line\">//方式二</span><br><span class=\"line\">String s = sb.toString();</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h5><blockquote>\n<p>String, StringBuffer, StringBuilder 的区别？</p>\n</blockquote>\n<ul>\n<li>String的内容不可变，StringBuffer和StringBuilder的内容都可变。</li>\n<li>StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。</li>\n</ul>\n<blockquote>\n<p>StringBuffer和数组的区别？</p>\n</blockquote>\n<ul>\n<li>二者都是一个容器，装其他数据</li>\n<li>但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。</li>\n</ul>\n<blockquote>\n<p>String和StringBuffer作为参数传递</p>\n</blockquote>\n<ul>\n<li>String可理解为特殊的引用类型，和基本类型一样，参数传递不会改变原数据内容。</li>\n<li>StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StringBufferDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String s1 = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">        String s2 = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\">        System.out.println(s1 + <span class=\"string\">\"---\"</span> + s2);// hello---world</span><br><span class=\"line\">        change(s1, s2);</span><br><span class=\"line\">        System.out.println(s1 + <span class=\"string\">\"---\"</span> + s2);// hello---world</span><br><span class=\"line\"></span><br><span class=\"line\">        StringBuffer sb1 = new StringBuffer(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">        StringBuffer sb2 = new StringBuffer(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">        System.out.println(sb1 + <span class=\"string\">\"---\"</span> + sb2);// hello---world</span><br><span class=\"line\">        change(sb1, sb2);</span><br><span class=\"line\">        System.out.println(sb1 + <span class=\"string\">\"---\"</span> + sb2);// hello---worldworld</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void change(StringBuffer sb1, StringBuffer sb2) &#123;</span><br><span class=\"line\">        sb1 = sb2;</span><br><span class=\"line\">        sb2.append(sb1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void change(String s1, String s2) &#123;</span><br><span class=\"line\">        s1 = s2;</span><br><span class=\"line\">        s2 = s1 + s2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><p>Java中的参数传递：</p>\n<ul>\n<li>基本类型：形式参数的改变对实际参数没有影响。</li>\n<li>引用类型：形式参数的改变直接影响实际参数。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo01_Object &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a = 10;</span><br><span class=\"line\">        int b = 20;</span><br><span class=\"line\">        change(a, b);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"main: a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b); //10, 20</span><br><span class=\"line\">        int[] arr = &#123;1, 2, 3&#125;;</span><br><span class=\"line\">        change(arr);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"main: \"</span> + arr[0]); //2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void change(int a, int b) &#123;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">        b = a + b;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"change: a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b); //20, 40</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void change(int[] arr) &#123;</span><br><span class=\"line\">        arr[0] = arr[1];</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"change\"</span> + arr[0]); //2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>引入概念</strong>：<br>在Java中<strong>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。所有的Java对象都储存在堆内存中</strong>。例如：Date t = new Date()其中的t就是一个对象变量，new Date()是在堆内存中开辟了一个空间，而t指向new Date()的堆内存地址。<br>因此，在上述代码中a b都是基本类型，而int[]是一个引用类型，那<strong>基本类型形式参数改变对实际参数没有影响；对象类型形式参数改变直接影响实际参数。</strong></p>\n<p><a href=\"/images/stack.png\">stack</a></p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p><strong>Java程序语言总是采用按值调用</strong>，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。</li>\n<li>一个方法可以改变一个对象的引用状态</li>\n<li>一个方法不能让对象参数引用一个新对象</li>\n</ul>\n<p>比如：下列是无意义的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void swap(Employee x, Employee y) &#123;</span><br><span class=\"line\">    Employee temp = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用swap(e1, e2)时并不会改变e1和e2的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</p>\n<ul>\n<li><strong>基本类型</strong>（包括Integer String Long）传递的参数是参数<strong>值</strong>的拷贝</li>\n</ul>\n<p>特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如IntgerCache LongCache，如果常量池中没有就重新new对象，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    String s = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"main: \"</span> + s.hashCode()); //48690</span><br><span class=\"line\">    change(s);</span><br><span class=\"line\">    change2(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static void change(String s) &#123;</span><br><span class=\"line\">    s = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"change: \"</span> + s.hashCode()); //48690</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static change2(String s) &#123;</span><br><span class=\"line\">    s = <span class=\"string\">\"456\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"change2: \"</span> + s.hashCode()); //51669</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>引用类型</strong>传递的参数是原对象在<strong>堆内存的地址</strong>的拷贝</li>\n</ul>\n<p>对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。</p>\n<h4 id=\"成员变量和局部变量\"><a href=\"#成员变量和局部变量\" class=\"headerlink\" title=\"成员变量和局部变量\"></a>成员变量和局部变量</h4><p>成员变量和局部变量的区别：</p>\n<ul>\n<li>在类中的位置不同：<ul>\n<li>成员变量：在类中方法外</li>\n<li>局部变量：在方法定义中或方法声明上</li>\n</ul>\n</li>\n<li>在内存中的位置不同：<ul>\n<li>成员变量：在堆内存</li>\n<li>局部变量：在栈内存</li>\n</ul>\n</li>\n<li>声明周期不同：<ul>\n<li>成员变量：随着对象的创建而存在，随着对象的消失而消失。</li>\n<li>局部变量：随着方法的调用而存在，随着方法调用完毕而消失</li>\n</ul>\n</li>\n<li>初始化值不同：<ul>\n<li>成员变量：有默认初始化值</li>\n<li>局部变量：没有默认初始化值，必须定义、赋值后才能使用</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p>在Java中，当需要调用构造方法时，<strong>若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义</strong>。举例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo2_Construct &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo2Student student = new Demo2Student();</span><br><span class=\"line\">        student.show();</span><br><span class=\"line\">        // Demo2School school = new Demo2School(); //error</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo2Student &#123;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"this student show\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo2School &#123;</span><br><span class=\"line\">    private int size = 1000;</span><br><span class=\"line\">    public Demo2School(int size) &#123;</span><br><span class=\"line\">        this.size = size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h5><p>final可以修改类、方法、变量。</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>final可以修饰类，该类不能被继承。</li>\n<li>final可以修饰方法，该方法不能被重写。</li>\n<li>final可以修饰变量，该变量不能被重新赋值。</li>\n</ul>\n<p><strong>面试题</strong>：final修饰局部变量的问题</p>\n<ul>\n<li>基本类型：被final修饰的基本类型的值不能被改变</li>\n<li>引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。</li>\n</ul>\n<p><strong>初始化时机</strong><br>被final修饰的变量必须在构造方法完毕前被初始化，比如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\">    final int WIDTH = 12;</span><br><span class=\"line\">    //final int HEIGHT; //error</span><br><span class=\"line\">    final int AREA;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AREA = 120;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>1、Java支持单继承不支持多继承，但Java支持多层继承<br>2、子类只能继承父类非私有成员（成员变量、成员方法）<br>3、子类不能继承父类的构造方法，但可以通过super关键字访问父类的构造方法。</p>\n<h5 id=\"子类和父类的关系\"><a href=\"#子类和父类的关系\" class=\"headerlink\" title=\"子类和父类的关系\"></a>子类和父类的关系</h5><p><strong>子类中的所有构造方法都默认访问父类的无参构造方法</strong>。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是super()。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo04_Extends &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo04Son son = new Demo04Son();</span><br><span class=\"line\">        son.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo04Son extends Demo04Parent&#123;</span><br><span class=\"line\">    private int num = 10;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Son</span></span>() &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        int num = 100;</span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">        System.out.println(this.num);</span><br><span class=\"line\">        System.out.println(super.num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo04Parent &#123;</span><br><span class=\"line\">    public int num = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Parent</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"这是父类的无参构造函数\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"this-super\"><a href=\"#this-super\" class=\"headerlink\" title=\"this-super\"></a>this-super</h5><p>this和super关键字的区别和使用场景？<br>区别：</p>\n<ul>\n<li>this: 代表当前类的对象引用</li>\n<li>super: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）<br>场景：</li>\n<li>this.成员变量/方法</li>\n<li>super.成员变量/方法</li>\n<li>this(…) super(…)</li>\n</ul>\n<h5 id=\"加载顺序\"><a href=\"#加载顺序\" class=\"headerlink\" title=\"加载顺序\"></a>加载顺序</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo04_Extends2 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo04Zi zi = new Demo04Zi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Demo04Fu &#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 构造代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Fu</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Demo04Zi extends Demo04Fu&#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 构造代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Zi</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fu 静态代码块</span><br><span class=\"line\">Zi 静态代码块</span><br><span class=\"line\">Fu 构造代码块</span><br><span class=\"line\">Fu 构造方法</span><br><span class=\"line\">Zi 构造代码块</span><br><span class=\"line\">Zi 构造方法</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h5><p><strong>调用对象方法的执行过程：</strong><br><a href=\"/images/DomaticBind.png\">DomaticBind</a><br>1.编译器首先查看对象的声明类型和方法名。如调用change(a)方法，由于存在多个change()方法，JVM会先列举该类以及其超类中访问属性为public且名为change的方法。<br>2.接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个方法表<strong>（method table）</strong>，JVM会直接从这个方法表中寻找名为change的方法中存在一个与提供的参数类型匹配的方法，这个过程称为<strong>重载解析</strong>。<br>3.如果是private、static、final方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为<strong>静态绑定</strong>。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现<strong>动态绑定</strong>。<br>4.当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。</p>\n<h5 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h5><p>将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接(int) double这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。</p>\n<ul>\n<li><strong>向上转型</strong>：将一个子类的引用赋值给一个超类变量。</li>\n<li><strong>向下转型</strong>：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>只能在继承层次内进行类型转换。</li>\n<li>在将超类转换成子类之前，应该使用instanceof进行检查。</li>\n</ul>\n<h5 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h5><p>一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。</p>\n<ul>\n<li>内部类可以直接访问外部类的成员，包括私有</li>\n<li>外部类可以访问内部类的成员，必须创建对象</li>\n<li>直接访问内部类的成员：Outer.Inner in = new Outer().new Inner()</li>\n</ul>\n<p><strong>局部内部类</strong><br>局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。</p>\n<blockquote>\n<p>局部内部类访问局部变量注意事项?<br>​局部内部类访问局部变量必须用final修饰。因为<strong>局部内部类的声明周期比局部变量长</strong>，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class InnerClass &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Outer outer = new Outer();</span><br><span class=\"line\">        outer.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Outer &#123;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        int num2 = 10;</span><br><span class=\"line\">        class Inner &#123;</span><br><span class=\"line\">            private void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">                System.out.println(num2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Inner inner = new Inner();</span><br><span class=\"line\">        inner.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时调用不会报错，但并没有加final修饰。这个类编译后会生成InnerClass.class和Outer.class两个文件，我们来看下Outer.class:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Outer &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">Outer</span></span>() &#123;&#125;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        final int num2 = 10;</span><br><span class=\"line\">        class Inner &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">Inner</span></span>() &#123;&#125;</span><br><span class=\"line\">            private void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">                System.out.println(num2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Inner inner = new Inner();</span><br><span class=\"line\">        inner.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中的num2被自动加上了final修饰（这是因为JDK1.8的原因），所以如果你再添上num2 = 1000就会报错。</p>\n<blockquote>\n<p>解决办法<br>上面说过了应该将num2用final修饰。其原因就是Inner类的生命周期要比num2的声明周期长，当show()方法调用完毕后num2就已经消失了，但此时Inner类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用final修饰，这个变量成为常量，在初始化内部类的时候，final num2就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>###对象与类</p>\n<h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><p>比如Student s = new Student()实例化一个对象，其实经历了如下几个过程：<br>将Student.class加载到内存中<br>在栈内存中给s开辟内存空间。<br>在堆内存给Student类申请一个内存空间。<br>给成员变量进行默认初始化，0 null false…<br>自定义给成员变量初始化赋值<br>初始化完毕，把堆内存地址赋值给栈内存的s变量</p>\n<h4 id=\"Main方法剖析\"><a href=\"#Main方法剖析\" class=\"headerlink\" title=\"Main方法剖析\"></a>Main方法剖析</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>public: 公共的，访问权限最大，因为main方法是被JVM调用的。</li>\n<li>static：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。</li>\n<li>void: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。</li>\n<li>main: 常见的方法入口，很多语言的入口方法都是main方法。</li>\n<li>String[] args: 字符串数组，是作为命令行参数调用的。</li>\n</ul>\n<h5 id=\"static关键字\"><a href=\"#static关键字\" class=\"headerlink\" title=\"static关键字\"></a>static关键字</h5><p><strong>static关键字特点：（可以修饰成员变量，也可修饰成员方法）</strong></p>\n<ul>\n<li>随着类的加载而加载</li>\n<li>优先于对象存在</li>\n<li>被类中的所有对象共享</li>\n<li>可直接通过类名调用</li>\n</ul>\n<p><strong>拓展</strong></p>\n<p>静态方法中没有this关键字，因为this代表当前方法对象，但static优于对象存在，所以在对象还未创建完毕static修饰的方法就被调用，此时this代表的对象还未创建。</p>\n<h4 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h4><p>String底层定义为public final class String，说明String是常量，一旦被创建就不能修改。可以查看如Integer LongString这些类的源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class Integer &#123;&#125;</span><br><span class=\"line\">public final class Long &#123;&#125;</span><br><span class=\"line\">public final class String &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这些<strong>基本类型</strong>，在初始化值、赋值时都是先从<strong>常量池</strong>中取数据，如果常量池中没有该数据，就new对象初始化为新数据。<br>比如常见的一个面试题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">s = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">String ss = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">ss = new String(<span class=\"string\">\"ab\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个s和ss各自创建了几个对象？答案：s创建两个对象；ss创建一个对象。因为s的常量池中有值ab，而重新赋值s = “abc”这个abc在s的常量池中不存在，所以new String()创建了一个新对象。ss同理分析。可以通过如下方式验证：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String ss = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">System.out.println(ss.hashCode());</span><br><span class=\"line\">ss = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">System.out.println(ss.hashCode());</span><br></pre></td></tr></table></figure>\n<p><a href=\"/images/String1.png\">stack</a></p>\n<h5 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h5><p>String是不可变的字符串，StringBuffer是线程安全的可变字符串，用StringBuffer做字符串的拼接可以避免资源的浪费，因为String每次拼接新的字符串都是创建一个新的String对象。</p>\n<p><strong>String转换为StringBuffer</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式一</span><br><span class=\"line\">String s = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">StringBuffer sb = new StringBuffer(s);</span><br><span class=\"line\">//方式二</span><br><span class=\"line\">StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">sb.append(s);</span><br></pre></td></tr></table></figure>\n\n<p><strong>StringBuffer转换成String</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式一</span><br><span class=\"line\">StringBuffer sb = new StringBuffer(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">String s = new String(sb);</span><br><span class=\"line\">//方式二</span><br><span class=\"line\">String s = sb.toString();</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h5><blockquote>\n<p>String, StringBuffer, StringBuilder 的区别？</p>\n</blockquote>\n<ul>\n<li>String的内容不可变，StringBuffer和StringBuilder的内容都可变。</li>\n<li>StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。</li>\n</ul>\n<blockquote>\n<p>StringBuffer和数组的区别？</p>\n</blockquote>\n<ul>\n<li>二者都是一个容器，装其他数据</li>\n<li>但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。</li>\n</ul>\n<blockquote>\n<p>String和StringBuffer作为参数传递</p>\n</blockquote>\n<ul>\n<li>String可理解为特殊的引用类型，和基本类型一样，参数传递不会改变原数据内容。</li>\n<li>StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StringBufferDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String s1 = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">        String s2 = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\">        System.out.println(s1 + <span class=\"string\">\"---\"</span> + s2);// hello---world</span><br><span class=\"line\">        change(s1, s2);</span><br><span class=\"line\">        System.out.println(s1 + <span class=\"string\">\"---\"</span> + s2);// hello---world</span><br><span class=\"line\"></span><br><span class=\"line\">        StringBuffer sb1 = new StringBuffer(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">        StringBuffer sb2 = new StringBuffer(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">        System.out.println(sb1 + <span class=\"string\">\"---\"</span> + sb2);// hello---world</span><br><span class=\"line\">        change(sb1, sb2);</span><br><span class=\"line\">        System.out.println(sb1 + <span class=\"string\">\"---\"</span> + sb2);// hello---worldworld</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void change(StringBuffer sb1, StringBuffer sb2) &#123;</span><br><span class=\"line\">        sb1 = sb2;</span><br><span class=\"line\">        sb2.append(sb1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void change(String s1, String s2) &#123;</span><br><span class=\"line\">        s1 = s2;</span><br><span class=\"line\">        s2 = s1 + s2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><p>Java中的参数传递：</p>\n<ul>\n<li>基本类型：形式参数的改变对实际参数没有影响。</li>\n<li>引用类型：形式参数的改变直接影响实际参数。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo01_Object &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a = 10;</span><br><span class=\"line\">        int b = 20;</span><br><span class=\"line\">        change(a, b);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"main: a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b); //10, 20</span><br><span class=\"line\">        int[] arr = &#123;1, 2, 3&#125;;</span><br><span class=\"line\">        change(arr);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"main: \"</span> + arr[0]); //2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void change(int a, int b) &#123;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">        b = a + b;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"change: a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b); //20, 40</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void change(int[] arr) &#123;</span><br><span class=\"line\">        arr[0] = arr[1];</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"change\"</span> + arr[0]); //2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>引入概念</strong>：<br>在Java中<strong>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。所有的Java对象都储存在堆内存中</strong>。例如：Date t = new Date()其中的t就是一个对象变量，new Date()是在堆内存中开辟了一个空间，而t指向new Date()的堆内存地址。<br>因此，在上述代码中a b都是基本类型，而int[]是一个引用类型，那<strong>基本类型形式参数改变对实际参数没有影响；对象类型形式参数改变直接影响实际参数。</strong></p>\n<p><a href=\"/images/stack.png\">stack</a></p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p><strong>Java程序语言总是采用按值调用</strong>，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。</li>\n<li>一个方法可以改变一个对象的引用状态</li>\n<li>一个方法不能让对象参数引用一个新对象</li>\n</ul>\n<p>比如：下列是无意义的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void swap(Employee x, Employee y) &#123;</span><br><span class=\"line\">    Employee temp = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用swap(e1, e2)时并不会改变e1和e2的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</p>\n<ul>\n<li><strong>基本类型</strong>（包括Integer String Long）传递的参数是参数<strong>值</strong>的拷贝</li>\n</ul>\n<p>特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如IntgerCache LongCache，如果常量池中没有就重新new对象，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    String s = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"main: \"</span> + s.hashCode()); //48690</span><br><span class=\"line\">    change(s);</span><br><span class=\"line\">    change2(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static void change(String s) &#123;</span><br><span class=\"line\">    s = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"change: \"</span> + s.hashCode()); //48690</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static change2(String s) &#123;</span><br><span class=\"line\">    s = <span class=\"string\">\"456\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"change2: \"</span> + s.hashCode()); //51669</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>引用类型</strong>传递的参数是原对象在<strong>堆内存的地址</strong>的拷贝</li>\n</ul>\n<p>对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。</p>\n<h4 id=\"成员变量和局部变量\"><a href=\"#成员变量和局部变量\" class=\"headerlink\" title=\"成员变量和局部变量\"></a>成员变量和局部变量</h4><p>成员变量和局部变量的区别：</p>\n<ul>\n<li>在类中的位置不同：<ul>\n<li>成员变量：在类中方法外</li>\n<li>局部变量：在方法定义中或方法声明上</li>\n</ul>\n</li>\n<li>在内存中的位置不同：<ul>\n<li>成员变量：在堆内存</li>\n<li>局部变量：在栈内存</li>\n</ul>\n</li>\n<li>声明周期不同：<ul>\n<li>成员变量：随着对象的创建而存在，随着对象的消失而消失。</li>\n<li>局部变量：随着方法的调用而存在，随着方法调用完毕而消失</li>\n</ul>\n</li>\n<li>初始化值不同：<ul>\n<li>成员变量：有默认初始化值</li>\n<li>局部变量：没有默认初始化值，必须定义、赋值后才能使用</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p>在Java中，当需要调用构造方法时，<strong>若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义</strong>。举例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo2_Construct &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo2Student student = new Demo2Student();</span><br><span class=\"line\">        student.show();</span><br><span class=\"line\">        // Demo2School school = new Demo2School(); //error</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo2Student &#123;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"this student show\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo2School &#123;</span><br><span class=\"line\">    private int size = 1000;</span><br><span class=\"line\">    public Demo2School(int size) &#123;</span><br><span class=\"line\">        this.size = size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h5><p>final可以修改类、方法、变量。</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>final可以修饰类，该类不能被继承。</li>\n<li>final可以修饰方法，该方法不能被重写。</li>\n<li>final可以修饰变量，该变量不能被重新赋值。</li>\n</ul>\n<p><strong>面试题</strong>：final修饰局部变量的问题</p>\n<ul>\n<li>基本类型：被final修饰的基本类型的值不能被改变</li>\n<li>引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。</li>\n</ul>\n<p><strong>初始化时机</strong><br>被final修饰的变量必须在构造方法完毕前被初始化，比如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\">    final int WIDTH = 12;</span><br><span class=\"line\">    //final int HEIGHT; //error</span><br><span class=\"line\">    final int AREA;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AREA = 120;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>1、Java支持单继承不支持多继承，但Java支持多层继承<br>2、子类只能继承父类非私有成员（成员变量、成员方法）<br>3、子类不能继承父类的构造方法，但可以通过super关键字访问父类的构造方法。</p>\n<h5 id=\"子类和父类的关系\"><a href=\"#子类和父类的关系\" class=\"headerlink\" title=\"子类和父类的关系\"></a>子类和父类的关系</h5><p><strong>子类中的所有构造方法都默认访问父类的无参构造方法</strong>。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是super()。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo04_Extends &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo04Son son = new Demo04Son();</span><br><span class=\"line\">        son.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo04Son extends Demo04Parent&#123;</span><br><span class=\"line\">    private int num = 10;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Son</span></span>() &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        int num = 100;</span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">        System.out.println(this.num);</span><br><span class=\"line\">        System.out.println(super.num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo04Parent &#123;</span><br><span class=\"line\">    public int num = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Parent</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"这是父类的无参构造函数\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"this-super\"><a href=\"#this-super\" class=\"headerlink\" title=\"this-super\"></a>this-super</h5><p>this和super关键字的区别和使用场景？<br>区别：</p>\n<ul>\n<li>this: 代表当前类的对象引用</li>\n<li>super: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）<br>场景：</li>\n<li>this.成员变量/方法</li>\n<li>super.成员变量/方法</li>\n<li>this(…) super(…)</li>\n</ul>\n<h5 id=\"加载顺序\"><a href=\"#加载顺序\" class=\"headerlink\" title=\"加载顺序\"></a>加载顺序</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo04_Extends2 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo04Zi zi = new Demo04Zi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Demo04Fu &#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 构造代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Fu</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Demo04Zi extends Demo04Fu&#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 构造代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Zi</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fu 静态代码块</span><br><span class=\"line\">Zi 静态代码块</span><br><span class=\"line\">Fu 构造代码块</span><br><span class=\"line\">Fu 构造方法</span><br><span class=\"line\">Zi 构造代码块</span><br><span class=\"line\">Zi 构造方法</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h5><p><strong>调用对象方法的执行过程：</strong><br><a href=\"/images/DomaticBind.png\">DomaticBind</a><br>1.编译器首先查看对象的声明类型和方法名。如调用change(a)方法，由于存在多个change()方法，JVM会先列举该类以及其超类中访问属性为public且名为change的方法。<br>2.接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个方法表<strong>（method table）</strong>，JVM会直接从这个方法表中寻找名为change的方法中存在一个与提供的参数类型匹配的方法，这个过程称为<strong>重载解析</strong>。<br>3.如果是private、static、final方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为<strong>静态绑定</strong>。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现<strong>动态绑定</strong>。<br>4.当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。</p>\n<h5 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h5><p>将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接(int) double这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。</p>\n<ul>\n<li><strong>向上转型</strong>：将一个子类的引用赋值给一个超类变量。</li>\n<li><strong>向下转型</strong>：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>只能在继承层次内进行类型转换。</li>\n<li>在将超类转换成子类之前，应该使用instanceof进行检查。</li>\n</ul>\n<h5 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h5><p>一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。</p>\n<ul>\n<li>内部类可以直接访问外部类的成员，包括私有</li>\n<li>外部类可以访问内部类的成员，必须创建对象</li>\n<li>直接访问内部类的成员：Outer.Inner in = new Outer().new Inner()</li>\n</ul>\n<p><strong>局部内部类</strong><br>局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。</p>\n<blockquote>\n<p>局部内部类访问局部变量注意事项?<br>​局部内部类访问局部变量必须用final修饰。因为<strong>局部内部类的声明周期比局部变量长</strong>，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class InnerClass &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Outer outer = new Outer();</span><br><span class=\"line\">        outer.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Outer &#123;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        int num2 = 10;</span><br><span class=\"line\">        class Inner &#123;</span><br><span class=\"line\">            private void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">                System.out.println(num2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Inner inner = new Inner();</span><br><span class=\"line\">        inner.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时调用不会报错，但并没有加final修饰。这个类编译后会生成InnerClass.class和Outer.class两个文件，我们来看下Outer.class:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Outer &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">Outer</span></span>() &#123;&#125;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        final int num2 = 10;</span><br><span class=\"line\">        class Inner &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">Inner</span></span>() &#123;&#125;</span><br><span class=\"line\">            private void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">                System.out.println(num2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Inner inner = new Inner();</span><br><span class=\"line\">        inner.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中的num2被自动加上了final修饰（这是因为JDK1.8的原因），所以如果你再添上num2 = 1000就会报错。</p>\n<blockquote>\n<p>解决办法<br>上面说过了应该将num2用final修饰。其原因就是Inner类的生命周期要比num2的声明周期长，当show()方法调用完毕后num2就已经消失了，但此时Inner类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用final修饰，这个变量成为常量，在初始化内部类的时候，final num2就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。</p>\n</blockquote>\n"},{"title":"Java基础（一）","date":"2019-12-29T16:00:00.000Z","_content":"\n记录一些Java基础的知识点，为了自己查阅资料的时候方便一些。\n\n---\n### Java基础\n\n#### JDK和JRE的区别？\n\n1、jre即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库\n2、jdk是Java开发工具包，例如：tools.jar\n\n---\n\n#### == 和 equals的区别\n\n1、==是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址\n2、equals是超类Object就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。equals方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。\nObject类equals方法源码：\n```bash\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\nnew对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，举个栗子：\n```bash\npublic class EqualsTest {\n\n    public static void main(String[] args) {\n        User a = new User();\n        User b = new User();\n        System.out.println(a == b); //false\n        System.out.println(a.equals(b)); //true\n    }\n}\n\nclass User {\n    private int age;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof User)) return false;\n        User user = (User) o;\n        return age == user.age;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(age);\n    }\n}\n```\n---\n\n#### 两个对象的hashCode()相同，则equals()一定为true？\n**如果两个对象相等(equals()为true)，那么他们的hashCode()一定相同**\n**如果两个对象的hashCode()相同，他们的equals()方法不一定相同**\n\nJVM虚拟机通过hashCode()方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过hashCode()获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用equals()与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用equals()方法比较的次数。\n\n```bash\npublic class EqualsTest {\n\n    public static void main(String[] args) {\n        User a = new User();\n        User b = new User();\n        System.out.println(a == b); //false\n        System.out.println(a.equals(b)); //false\n        System.out.println(a.hashCode() == b.hashCode()); //false\n    }\n}\n\nclass User {\n    private int age;\n}\n```\n---\n\n#### final的作用\n可修饰类、类属性、类方法。\n1、被final修饰的类不能被继承\n2、final修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。\n```bash\npublic class FinalTest {\n\n    private static final User USER = new User();\n\n    public static void main(String[] args) {\n        User u2 = new User();\n//        user = u2; // ERROR\n        USER.age = 23;\n    }\n}\n\nclass User {\n    int age = 12;\n}\n```\n3、类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。\n\n---\n\n#### String属于基本数据类型吗？\n\n**不，String属于特殊的引用类型**\n\nJava中基本数据类型有：int、short、long、char、boolean、float、double、byte\n\n1、String是特殊的引用类型并且是final的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。\n2、String s = \"a\"; s += \"b\";，这段代码执行前后，字符串常量池中将出现a和ab两个字符串常量，而原本s变量的引用指向了常量池中ab。\n3、String s = new String(\"ab\")，这段代码一共创建了几个对象？一个或两个。如果字符串常量池中有了ab这个字符串(比如在此之前已经使用了String str = \"ab\")，那么新的s对象引用其实仅仅是指向了字符串常量中的ab，并没有创建新的字符串对象。但是，每次调用new都会在堆内存开辟空间，创建一个String对象，这是肯定的。\n\n栗子：\n```bash\npublic class StringTest {\n\n    public static void main(String[] args) {\n        String a = \"abc\";\n        String b = \"abc\";\n        String c = new String(\"abc\");\n        System.out.println(a == b); //true\n        System.out.println(a.equals(b)); //true\n        System.out.println(a.equals(c)); //true\n    }\n}\n```\n\n**String和StringBuffer和StringBuilder的区别**\n1、String是不可变字符串，StringBuffer和StringBuilder是可变字符串。如果经常改变字符串的原始数据，最好使用StringBuffer代替。\n2、String默认重写了equals方法和hashCode()方法；而StringBuffer没有重写equals方法，使用new StringBuffer(\"\")会直接在堆内存中开辟空间储存对象。因此将StringBuffer对象储存仅Java集合中可能会出现问题。\n3、StringBuffer是线程安全的，效率低；StringBuilder是线程不安全的，效率高。\n\n---\n\n#### static关键字？是否可覆盖？\n\nstatic关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。\n\nstatic标记的方法只能访问static变量或方法\n非static标记的方法可以访问static或非static标记的变量或方法\n\n---\n\n#### 自动拆、装箱\n\n因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。\n具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)\n\n基本数据类型|引用数据类型\n:--:|:--:\nint|Integer\nbyte|Byte\nshort|Short\nlong|Long\nfloat|Float\ndouble|Double\nchar|Char\nboolean|Boolean\n\n栗子：\n```bash\npublic static void main(String[] args) {\n    Integer i1 = 100;\n    Integer i2 = 100;\n    Integer i3 = 200;\n    Integer i4 = 200;\n    System.out.println(i1 == i2);\n    System.out.println(i3 == i4);\n}\n```\n\n结果：\n```bash\ntrue\nfalse\n```\n\nJava中实现基本数据类型和引用类型之间的拆装箱一般都是用过valueOf()方法实现的。例如我们看下Integer类的valueOf()方法源码：\n```bash\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n\n可以看到：当声明一个新的整数型变量，编译时通过Integer类的valueOf()进行拆装箱计算，这个方法会首先比较这个整数值是否在IntegerCache的范围内，如果在就返回IntegerCache类中的数值；如果不在就直接new Integer。那么我们看下IntegerCache类源码：\n\n```bash\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n```\n所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在[-128, 127]之间，就直接返回IntegerCache中储存的常量值，否则就直接new一个新的Integer来保存这个常量值。所以上面才会出现false的结果。\n同理：其他的数据类型例如：long、short等都具有对应的LongCache、ShortCache等类。\n\n---\n\n#### Overriding和Overloaded\n方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。\nOverriding: 子类中定义了和父类中名称、参数列表相同的方法\nOverloaded: 方法名相同，参数列表不同\n\n---\n\n#### Java支持多继承吗？\n不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过多层继承实现。\n类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。\n从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。\n\n---\n\n#### 接口和抽象类的区别？\n\n+ 接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。\n+ 接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )\n+ 类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )\n+ 抽象类可以是不提供接口方法实现的情况下实现接口\n+ 接口中声明的变量默认都是final的；但抽象类可以包含非final的变量\n+ 接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public\n+ 接口是绝对抽象的，不可以被实例化；\n\n---\n\n#### 引用传递和值传递\n\n**Java中采用值传递的方式**\n栗子：\n```bash\npublic class TransferTest {\n\n\n    public static void main(String[] args) {\n        int a = 1;\n        Integer b = 2;\n        swap(a, b);\n        System.out.println(a);\n        System.out.println(b);\n\n        int[] arr = {1, 2};\n        swap(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    private static void swap(int[] arr) {\n        arr[0] = 10;\n    }\n\n    private static void swap(int a, Integer b) {\n        a = 10;\n        b = 20;\n    }\n}\n```\n\n方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。\n所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。\n\n---\n\n#### IO流\n\n![IO流](http://cdn.tycoding.cn/20180127210359151.png)\n\n**1、Java中有几种类型的流？**\n字符流和字节流。字节流继承InputStream和OutputStream；字符流继承自InputStreamReader和OutputStreamWriter。\n\n**2、谈谈Java IO中的方法阻塞**\nJava中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。\n\n**3、字符流和字节流的区别？**\n数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。\n而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。\n字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。\n\n**4、NIO**\n传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read()等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept()时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。\n而对于NIO，它是非阻塞式，核心类：\n+ Buffer： 为所有的原始类型提供Buffer缓冲支持\n+ Charset： 字符集编码解码解决方案\n+ Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接。\n\n---\n\n#### 说说List、Set、Map三者的区别\n\n+ List: List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素\n+ Set: 不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素\n+ Map: 使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。\n\n---\n\n#### Array和ArrayList有什么区别？\n\n+ Array可以包含基本类型和对象类型；ArrayList只能包含对象类型\n+ Array大小是固定的；ArrayList大小是动态变化的\n+ ArrayList提供了诸如addAll()、removeAll()、iterator()方法等\n+ 对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。\n\n---\n\n#### ArrayList和LinkedList的区别？\n\n1、**是否保证线程安全**： ArrayList和LinkedList都是不同步的，也就是不保证线程安全\n2、**底层数据结构**： ArrayList底层使用的是Object数组；LinkedList底层使用的是 双向链表 结构\n3、**插入和删除是否受元素位置影响？** ArrayList采用数组储存，所以插入和删除元素都受元素位置的影响；LinkedList 采用链表储存，所以插入、删除元素都不受元素位置影响。\n4、**是否支持快速随机访问？** LinkedList因为使用链表储存，无法通过元素索引快速访问；而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。\n5、**内存空间占用**： ArrayList的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而LinkedList的空间花费体现在他的每一个元素都需要消耗比ArrayList更多的空间（因为要储存直接后继和直接前驱以及数据）。\n\n---\n\n**什么是迭代器**\n*Iterator*接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法*iterator()*。迭代器在迭代的过程中可以删除底层集合的元素。\n\n**Iterator和ListIterator的区别？**\n+ Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List\n+ Iterator对集合只能向前遍历（next()）；而*ListIterator可以向前遍历（next()），也可以向后遍历（previous()）\n+ ListIterator实现了Iterator接口\n\n**RandomAccess接口**\n```bash\n//ArrayList\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{}\n\n//RandomAccess\npublic interface RandomAccess {\n}\n\n//LinkedList\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n{}\n```\n\n源码中ArrayList类实现了RandomAccess接口，LinkedList类中却没有实现这个接口，但是RandomAccess接口中却什么也没有定义。可以看RandomAccess接口上的注释：\n```bash\n/**\n * Marker interface used by <tt>List</tt> implementations to indicate that\n * they support fast (generally constant time) random access.  The primary\n * purpose of this interface is to allow generic algorithms to alter their\n * behavior to provide good performance when applied to either random or\n * sequential access lists.\n */\n```\n大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看Collections类中的binarySearch方法：\n```bash\npublic static <T>\nint binarySearch(List<? extends Comparable<? super T>> list, T key) {\n    if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key);\n    else\n        return Collections.iteratorBinarySearch(list, key);\n}\n\nprivate static <T>\nint indexedBinarySearch(List<? extends Comparable<? super T>> list, T key) {\n    int low = 0;\n    int high = list.size()-1;\n\n    while (low <= high) {\n        int mid = (low + high) >>> 1;\n        Comparable<? super T> midVal = list.get(mid);\n        int cmp = midVal.compareTo(key);\n\n        if (cmp < 0)\n            low = mid + 1;\n        else if (cmp > 0)\n            high = mid - 1;\n        else\n            return mid; // key found\n    }\n    return -(low + 1);  // key not found\n}\n\nprivate static <T>\nint iteratorBinarySearch(List<? extends Comparable<? super T>> list, T key)\n{\n    int low = 0;\n    int high = list.size()-1;\n    ListIterator<? extends Comparable<? super T>> i = list.listIterator();\n\n    while (low <= high) {\n        int mid = (low + high) >>> 1;\n        Comparable<? super T> midVal = get(i, mid);\n        int cmp = midVal.compareTo(key);\n\n        if (cmp < 0)\n            low = mid + 1;\n        else if (cmp > 0)\n            high = mid - 1;\n        else\n            return mid; // key found\n    }\n    return -(low + 1);  // key not found\n}\n```\n\nbinarySearch()方法是从List中查找指定元素，其中首先判断传入的List时候实现了RandomAccess接口，如果实现了就调用indexedBinarySearch()方法，否则就调用iteratorBinarySearch()方法。再看这两个方法的源码：\n如果传入的List实现了RandomAccess接口，采用普通for循环遍历\n若传入的List未实现RandomAccess接口，采用iterator遍历\n\n**链表**\n\n**链表（Linked List）**由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针\n>单向链表\n单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。\n+ 单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找\n![单向链表](http://cdn.tycoding.cn/1120165-20171207161602113-1451349858.png)\n\n+ 单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可\n![单向链表](http://cdn.tycoding.cn/1120165-20171207162758425-142549066.png)\n\n+ 删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可\n![单向链表](http://cdn.tycoding.cn/1120165-20171207162815925-341262498.png)\n\n>双向链表\n**双向链表** 包含两个指针，prev指向前一个节点，next指向后一个节点。\n![双向链表](http://cdn.tycoding.cn/双向链表.png)\n\n>双向循环链表\n**双向循环链表** 最后一个节点的*next*指向*head*，而*head*的*prev*指向最后一个节点，形成一个环。\n![双向循环链表](http://cdn.tycoding.cn/双向循环链表.png)\n\n---\n\n#### ArrayList和Vector和LinkedList的区别？\n+ **ArrayList**: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高\n+ **Vector**: 底层数据结构是数组，查询快，增删慢。线程安全，效率低\n+ **LinkedList**: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高\n\n---\n\n#### 谈谈ArrayList的扩容机制\nJava中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，ArrayList的出现就解决了这一问题。\nArrayList的扩容机制表现在add()方法上，先看add()方法的源码：\n```bash\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\n//获取最小容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\n//判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n```\n\n当向ArrayList对象中添加新元素时，首先会调用ensureCapacityInternal(size)方法，size为最小扩容量；ensureCapacityInternal()方法会首先调用calculateCapacity来确定需要的最小容量；最后调用ensureExplicitCapacity()方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用grow()方法扩容：\n```bash\nprivate void grow(int minCapacity) {\n    // 获取ArrayList中elementDaata数组的长度\n    int oldCapacity = elementData.length;\n    // 扩容至原来的1.5倍\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    // 判断新的数组容量够不够\n    // 够了就直接使用这个长度创建新数组\n    if (newCapacity - minCapacity < 0)\n        // 不够就将数组的长度设置为需要的长度\n        newCapacity = minCapacity;\n    // 检查此时的最大值是否溢出\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // 调用Arrays.copyOf()将elementData数组数据拷贝到新数组\n    // 并将elementData指向新数组newCapacity的内存地址\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n**总结**： ArrayList扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。\n\n---\n\n#### HashMap和HashTable的区别？\n1、HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度\n2、线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰。\n3、效率: HashMap线程不安全效率高，HashTable线程安全效率低。\n3、对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null\n5、底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制。\n\n---\n\n#### HashMap和HashSet区别?\n**HashSet底层采用HashMap实现**\nHashMap|HashSet\n:--|:--\n实现了Map接口|实现了Set接口\n储存键值堆|仅储存对象\n调用put()向Map中添加元素|调用add()向Set中添加元素\nHashMap使用Key计算HashCode|HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以用equals判断对象的相等性\n\n---\n\n#### HashSet如何检查重复？\n在前面讲hashCode和equals时就提到了，HashSet集合同样适用。向HashSet中存入一个元素，HashSet首先会根据对象的hashCode值判断当期集合中此hashCode对应的位置有没有值，如果没有就直接添加，如果有就再调用equals方法比较两个对象是否相同，相同就不再储存（保证了Set集合不重复的特性），否则就散列到其他位置储存。\n\n---\n\n#### HashMap底层实现？\nMap在Java中的实现由很多，HashMap便是其中之一，随着JDK版本的更新，HashMap的实现也在不断更新：\n+ <=JDK1.7: Table数组 + Entry链表\n+ >=JDK1.8: Table数组 + Entry链表/红黑树\n\n#### Hash\n\n**Hash（哈希、散列）**，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。\nHash函数的一种实现：\n直接取余法： f(x) = x mod max\n位运算法： f(x) = x & max\nHashMap采用 位运算法，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：\n```bash\n7 & 33 = 1\n    \n    000111\n  & 100001\n  --------\n    000001 = 1\n\n```\n\n---\n\n#### Hash冲突\n假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到HashMap集合中，若将多个K-V数据存入put，HashMap根据元素key计算到对应的hashCode值，如果计算得到多个不同的key对应的hashCode值相同（即要储存到同一位置），此时这种现象就称为 Hash冲突。\nHashMap默认采用了 链地址法 解决Hash冲突问题，即通过类似单链表的方式将 冲突的元素 串起来，搜索时遍历这个链表即可。注意： 如果冲突的Hash越来越多，这个链就会越来越长。\n\n---\n\n#### 实现原理\n![hash冲突与实现原理](http://cdn.tycoding.cn/8db4a3bdfb238da1a1c4431d2b6e075c_hd.png)\n这里我们需要了解两个名词：\nTable: 哈希桶数组（哈希表），存放Node元素，底层是一个Node[] table\nNode: 节点元素，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（K-V）\nHashMap内部的一些关键属性需要了解：\nDEFAULT_INITIAL_CAPACITY: Tabale数组的初始化长度，默认是1 << 4，2^4 = 16\nMAXIMUM_CAPACITY: Table数组最高长度，默认为1 << 30，2^30 = 1073741824\nDEFAULT_LOAD_FACTOR: 负载因子，当总元素数 > 数组长度 * 负载因子时，Table数组将扩容，默认是0.75\nTREEIFY_THRESHOLD: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8\nUNTREEIFY_THRESHOLD: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6\nMIN_TREEIFY_CAPACITY: 最小树化阀值，当Table中所有元素超过该值，才会进行树化\nsize: 当前HashMap实际存在的键值对数量\nthreshold: HashMap所能容纳的最大数据量的Node（键值对）个数。Node[] table初始化长度length是16，loadFactor负载因子默认是0.75，threshold = length * loadFactor\nloadFactor: 负载因子，默认是0.17\nmodCount: 记录HashMap内部结构发生变化的次数\nHashMap内部存在一个NodeTable数组，这个数组的初始化长度是DEFAULT_INITIAL_CAPACITY，他是一个单向链表：\n```bash\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; //key的Hash值\n    final K key; //key\n    V value; //value\n    Node<K,V> next; //下一个节点\n}\n```\n\n参考单链表的结构，Table中每个Node节点包含两个部分，Node元素作为节点的header，next指向下一个节点。**这种链式结构的存在正是为了解决Hash冲突**\n\n栗子：\n```bash\nmap.put(\"loonycoder\", \"18\");\n```\nHashMap将根据\"loonycoder\"这个Key得到其hashCode值，然后经过Hash算法定位到其在HashMap储存的位置，如果两个不同的key定位到了同一个位置，此时就发生了Hash冲突。\n在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过TREEIFY_THRESHOLD阀值后，会将链表转换为红黑树的实现TreeNode:\n```bash\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n    TreeNode<K,V> parent;  // red-black tree links\n    TreeNode<K,V> left;\n    TreeNode<K,V> right;\n    TreeNode<K,V> prev;    // needed to unlink next upon deletion\n    boolean red;\n}\n```\n当发生**Hash冲突**时，根据HashMap默认采用的 **链地址法**，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。但是 随着Hash冲突越来越多，这个**链将越来越长**，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。\n![地址链法](http://cdn.tycoding.cn/JDK1.8之后的HashMap底层数据结构.jpg)\n\n**总结**\n到此，我们总结一下HashMap的实现原理：\n+ HashMap根据key的hashCode值存储元素。put新元素会遍历链表，根据新元素的key计算hashCode得到散列位置，如果该位置有值再调用equals判断value是否相同，相同就散列到其他位置储存。\n+ HashMap在put新元素时如果遇到key对应的hashCode相同，可能会产生Hash冲突问题。HashMap的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。\n+ 如果发生Hash冲突的元素很多，这个 **链** 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（TreeNode）存储元素。\n\n---\n\n#### Collection和Collections的区别？\n+ Collection是集合类的上级接口，继承他的接口主要有Set和List\n+ Collections仅是针对集合类封装的一个工具类，在java.util包下\n\n---\n\n#### Comparable和Comparator的区别？\n\n+ Comparable接口来自java.lang包，提供compareTo(Object obj) 方法排序\n+ Comparator接口来自java.util包，提供compare(Object obj1, Object obj2)方法排序\n当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。\n\n#### Java集合框架总结\n\n##### Collection\n![Collection](http://cdn.tycoding.cn/QQ20190623-181246.png)\n\n**List**\n\nArrayList: Object数组，线程不安全，查询快，增删慢，效率高\nVector: Object数组，线程安全，查询快，增删慢，效率低\nLinkedList: 双向链表，线程不安全，查询慢，增删快，效率高\n\n**Set**\n\nHashSet: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素\nLinkedHashSet: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现\nTreeSet 有序、唯一，红黑树\n\n##### Map\n![Map](http://cdn.tycoding.cn/QQ20190623-181259.png)\n\n+ HashMap: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。\n+ LinkedHashMap: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。\n+ HashTable: 数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题\nTreeMap: 红黑树\n\n---\n\n### Java并发\n\n#### 线程和进程的区别？\n+ 进程是程序的一次执行过程，是系统运行程序的基本单位\n+ 线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，\n在Java中，启用一个main方法就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。\n\n---\n\n#### 从JVM角度分析进程和线程的关系？\n根据JVM的内存划分，对于线程而言：多个线程共享进程的堆、方法区资源，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。\n\n也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。\n\n##### 为什么方法区和堆是线程共享区？\n+ **方法区（Method Area）** 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 运行时常量池 ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。\n+ **堆（Heap）** 堆内存储存了对象实例（比如new关键字创建的实例对象），它是JVM中内存区最大的一块区域。\n所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。\n\n##### 为什么虚拟机栈和本地方法栈是线程独占区？\n+ **虚拟机栈**： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。\n+ **本地方法栈**： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。\n\n##### 程序计数器是什么？\n\n**程序计数器（Program Counter Register）**：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。\n\n---\n\n#### 说说并行和并发的区别？\n+ **并行**： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）\n+ **并发**： 单位时间内，多个任务同时执行。\n\n---\n\n#### 使用多线程可能带来什么问题？\n并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题\n\n---\n\n#### 说说线程的生命周期和状态？\n状态名称|状态说明\n:--|:--\nnew|初始状态，线程被创建，但还没有调用start()方法\nrunnable|运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”\nblocked|阻塞状态，表示线程阻塞于锁\nwaiting|等待状态，线程需要等待当前线程或其他线程执行完成\ntime_waiting|超时等待状态，他可以实现在指定时间后自动返回\nterminated|终止状态，表示当前线程已经执行完毕\n\n对应，程序会因为不同代码的执行产生不同的状态，如下图：\n![线程图](http://cdn.tycoding.cn/Java+线程状态变迁.png)\n如上，线程创建后将进入NEW（初始）状态，调用start()开始运行，当线程执行wait()方法后，线程将进入WAITING（等待）状态，可以通过wait(long)或join(long)等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED（阻塞）状态。\n\n---\n\n#### 什么是上下文切换？\n简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用**随机分配时间片并轮转**的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 **任务从保存到再加载的过程就是一次上下文切换**。\n\n---\n\n#### 什么是死锁？如何避免?\n举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。\n![死锁](http://cdn.tycoding.cn/2019-4死锁1.png)\n栗子：\n```bash\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();//资源 1\n    private static Object resource2 = new Object();//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\nOutput：\n\n```bash\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n```\n线程1以resource1作为同步监视器，即可以轻松获取resource1同时也锁定了resource1，此时调用sleep让线程1等待1秒钟；此时线程2开始执行，他以resource2作为同步监视器同时也锁定了resource2，此时调用sleep让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取resource2时发现resource2已经被线程2锁定了，同理线程2结束等待后想要获取resource1时发现resource1已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。\n因此产生死锁需要具备以下四个条件：\n\n1、互斥条件：该资源任意一个时刻只能由一个线程占用\n2、请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放\n3、不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源\n4、循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。\n\n避免死锁就要破坏这四个条件中任意一个：\n1、破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥\n2、破坏请求与保持条件：一次性申请所有资源\n3、破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用\n\n解决方案: 修改线程2\n```bash\nnew Thread(() -> {\n    synchronized (resource1) {\n        System.out.println(Thread.currentThread() + \"get resource1\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread() + \"waiting get resource2\");\n        synchronized (resource2) {\n            System.out.println(Thread.currentThread() + \"get resource2\");\n        }\n    }\n}, \"线程 2\").start();\n```\n\nOutput：\n```bash\nThread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n\nProcess finished with exit code 0\n```\n\n---\n\n#### 说说sleep()方法和wait()方法的区别？\n两者最主要的区别在于：**sleep 方法没有释放锁，而 wait 方法释放了锁**\n+ 两者都可以暂停线程的执行\n+ wait()通常用于线程间交互/通信，sleep()通常用户暂停执行\n+ wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n---\n\n#### 调用start()方法会执行run()方法，为什么不能直接调用run()方法？\nnew一个Thread，线程进入了新建状态；调用start()方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这才是真正的多线程工作。而直接执行run()方法，会吧run()方法当做一个main线程下的一个普通方法去执行，并不会在某个线程中执行他。\n**总结：调用start方法可以启动线程并使线程进入就绪状态，而run()方法只是Thread的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行**\n\n---\n\n#### synchronized关键字\nsynchronized关键字解决多个线程之间访问资源的同步性，synchronized关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。\nsynchronized关键字最主要的三种使用方式：\n+ **修饰实例方法**： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁\n```bash\n// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象\npublic synchronized void add() {}\n```\n+ **修饰静态方法**： 给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。\n```bash\n// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)\npublic synchronized static void add() {}\n```\n\n+ **修饰代码块**：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁\n\n---\n","source":"_posts/JavaBasic1.md","raw":"---\ntitle: Java基础（一）\ncategories:\n    - Java\ndate: 2019-12-30\ntags:\n\t- Java\n\t- Java基础\n\n---\n\n记录一些Java基础的知识点，为了自己查阅资料的时候方便一些。\n\n---\n### Java基础\n\n#### JDK和JRE的区别？\n\n1、jre即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库\n2、jdk是Java开发工具包，例如：tools.jar\n\n---\n\n#### == 和 equals的区别\n\n1、==是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址\n2、equals是超类Object就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。equals方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。\nObject类equals方法源码：\n```bash\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\nnew对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，举个栗子：\n```bash\npublic class EqualsTest {\n\n    public static void main(String[] args) {\n        User a = new User();\n        User b = new User();\n        System.out.println(a == b); //false\n        System.out.println(a.equals(b)); //true\n    }\n}\n\nclass User {\n    private int age;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof User)) return false;\n        User user = (User) o;\n        return age == user.age;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(age);\n    }\n}\n```\n---\n\n#### 两个对象的hashCode()相同，则equals()一定为true？\n**如果两个对象相等(equals()为true)，那么他们的hashCode()一定相同**\n**如果两个对象的hashCode()相同，他们的equals()方法不一定相同**\n\nJVM虚拟机通过hashCode()方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过hashCode()获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用equals()与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用equals()方法比较的次数。\n\n```bash\npublic class EqualsTest {\n\n    public static void main(String[] args) {\n        User a = new User();\n        User b = new User();\n        System.out.println(a == b); //false\n        System.out.println(a.equals(b)); //false\n        System.out.println(a.hashCode() == b.hashCode()); //false\n    }\n}\n\nclass User {\n    private int age;\n}\n```\n---\n\n#### final的作用\n可修饰类、类属性、类方法。\n1、被final修饰的类不能被继承\n2、final修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。\n```bash\npublic class FinalTest {\n\n    private static final User USER = new User();\n\n    public static void main(String[] args) {\n        User u2 = new User();\n//        user = u2; // ERROR\n        USER.age = 23;\n    }\n}\n\nclass User {\n    int age = 12;\n}\n```\n3、类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。\n\n---\n\n#### String属于基本数据类型吗？\n\n**不，String属于特殊的引用类型**\n\nJava中基本数据类型有：int、short、long、char、boolean、float、double、byte\n\n1、String是特殊的引用类型并且是final的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。\n2、String s = \"a\"; s += \"b\";，这段代码执行前后，字符串常量池中将出现a和ab两个字符串常量，而原本s变量的引用指向了常量池中ab。\n3、String s = new String(\"ab\")，这段代码一共创建了几个对象？一个或两个。如果字符串常量池中有了ab这个字符串(比如在此之前已经使用了String str = \"ab\")，那么新的s对象引用其实仅仅是指向了字符串常量中的ab，并没有创建新的字符串对象。但是，每次调用new都会在堆内存开辟空间，创建一个String对象，这是肯定的。\n\n栗子：\n```bash\npublic class StringTest {\n\n    public static void main(String[] args) {\n        String a = \"abc\";\n        String b = \"abc\";\n        String c = new String(\"abc\");\n        System.out.println(a == b); //true\n        System.out.println(a.equals(b)); //true\n        System.out.println(a.equals(c)); //true\n    }\n}\n```\n\n**String和StringBuffer和StringBuilder的区别**\n1、String是不可变字符串，StringBuffer和StringBuilder是可变字符串。如果经常改变字符串的原始数据，最好使用StringBuffer代替。\n2、String默认重写了equals方法和hashCode()方法；而StringBuffer没有重写equals方法，使用new StringBuffer(\"\")会直接在堆内存中开辟空间储存对象。因此将StringBuffer对象储存仅Java集合中可能会出现问题。\n3、StringBuffer是线程安全的，效率低；StringBuilder是线程不安全的，效率高。\n\n---\n\n#### static关键字？是否可覆盖？\n\nstatic关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。\n\nstatic标记的方法只能访问static变量或方法\n非static标记的方法可以访问static或非static标记的变量或方法\n\n---\n\n#### 自动拆、装箱\n\n因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。\n具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)\n\n基本数据类型|引用数据类型\n:--:|:--:\nint|Integer\nbyte|Byte\nshort|Short\nlong|Long\nfloat|Float\ndouble|Double\nchar|Char\nboolean|Boolean\n\n栗子：\n```bash\npublic static void main(String[] args) {\n    Integer i1 = 100;\n    Integer i2 = 100;\n    Integer i3 = 200;\n    Integer i4 = 200;\n    System.out.println(i1 == i2);\n    System.out.println(i3 == i4);\n}\n```\n\n结果：\n```bash\ntrue\nfalse\n```\n\nJava中实现基本数据类型和引用类型之间的拆装箱一般都是用过valueOf()方法实现的。例如我们看下Integer类的valueOf()方法源码：\n```bash\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n\n可以看到：当声明一个新的整数型变量，编译时通过Integer类的valueOf()进行拆装箱计算，这个方法会首先比较这个整数值是否在IntegerCache的范围内，如果在就返回IntegerCache类中的数值；如果不在就直接new Integer。那么我们看下IntegerCache类源码：\n\n```bash\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n```\n所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在[-128, 127]之间，就直接返回IntegerCache中储存的常量值，否则就直接new一个新的Integer来保存这个常量值。所以上面才会出现false的结果。\n同理：其他的数据类型例如：long、short等都具有对应的LongCache、ShortCache等类。\n\n---\n\n#### Overriding和Overloaded\n方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。\nOverriding: 子类中定义了和父类中名称、参数列表相同的方法\nOverloaded: 方法名相同，参数列表不同\n\n---\n\n#### Java支持多继承吗？\n不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过多层继承实现。\n类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。\n从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。\n\n---\n\n#### 接口和抽象类的区别？\n\n+ 接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。\n+ 接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )\n+ 类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )\n+ 抽象类可以是不提供接口方法实现的情况下实现接口\n+ 接口中声明的变量默认都是final的；但抽象类可以包含非final的变量\n+ 接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public\n+ 接口是绝对抽象的，不可以被实例化；\n\n---\n\n#### 引用传递和值传递\n\n**Java中采用值传递的方式**\n栗子：\n```bash\npublic class TransferTest {\n\n\n    public static void main(String[] args) {\n        int a = 1;\n        Integer b = 2;\n        swap(a, b);\n        System.out.println(a);\n        System.out.println(b);\n\n        int[] arr = {1, 2};\n        swap(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    private static void swap(int[] arr) {\n        arr[0] = 10;\n    }\n\n    private static void swap(int a, Integer b) {\n        a = 10;\n        b = 20;\n    }\n}\n```\n\n方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。\n所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。\n\n---\n\n#### IO流\n\n![IO流](http://cdn.tycoding.cn/20180127210359151.png)\n\n**1、Java中有几种类型的流？**\n字符流和字节流。字节流继承InputStream和OutputStream；字符流继承自InputStreamReader和OutputStreamWriter。\n\n**2、谈谈Java IO中的方法阻塞**\nJava中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。\n\n**3、字符流和字节流的区别？**\n数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。\n而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。\n字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。\n\n**4、NIO**\n传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read()等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept()时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。\n而对于NIO，它是非阻塞式，核心类：\n+ Buffer： 为所有的原始类型提供Buffer缓冲支持\n+ Charset： 字符集编码解码解决方案\n+ Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接。\n\n---\n\n#### 说说List、Set、Map三者的区别\n\n+ List: List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素\n+ Set: 不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素\n+ Map: 使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。\n\n---\n\n#### Array和ArrayList有什么区别？\n\n+ Array可以包含基本类型和对象类型；ArrayList只能包含对象类型\n+ Array大小是固定的；ArrayList大小是动态变化的\n+ ArrayList提供了诸如addAll()、removeAll()、iterator()方法等\n+ 对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。\n\n---\n\n#### ArrayList和LinkedList的区别？\n\n1、**是否保证线程安全**： ArrayList和LinkedList都是不同步的，也就是不保证线程安全\n2、**底层数据结构**： ArrayList底层使用的是Object数组；LinkedList底层使用的是 双向链表 结构\n3、**插入和删除是否受元素位置影响？** ArrayList采用数组储存，所以插入和删除元素都受元素位置的影响；LinkedList 采用链表储存，所以插入、删除元素都不受元素位置影响。\n4、**是否支持快速随机访问？** LinkedList因为使用链表储存，无法通过元素索引快速访问；而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。\n5、**内存空间占用**： ArrayList的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而LinkedList的空间花费体现在他的每一个元素都需要消耗比ArrayList更多的空间（因为要储存直接后继和直接前驱以及数据）。\n\n---\n\n**什么是迭代器**\n*Iterator*接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法*iterator()*。迭代器在迭代的过程中可以删除底层集合的元素。\n\n**Iterator和ListIterator的区别？**\n+ Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List\n+ Iterator对集合只能向前遍历（next()）；而*ListIterator可以向前遍历（next()），也可以向后遍历（previous()）\n+ ListIterator实现了Iterator接口\n\n**RandomAccess接口**\n```bash\n//ArrayList\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{}\n\n//RandomAccess\npublic interface RandomAccess {\n}\n\n//LinkedList\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n{}\n```\n\n源码中ArrayList类实现了RandomAccess接口，LinkedList类中却没有实现这个接口，但是RandomAccess接口中却什么也没有定义。可以看RandomAccess接口上的注释：\n```bash\n/**\n * Marker interface used by <tt>List</tt> implementations to indicate that\n * they support fast (generally constant time) random access.  The primary\n * purpose of this interface is to allow generic algorithms to alter their\n * behavior to provide good performance when applied to either random or\n * sequential access lists.\n */\n```\n大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看Collections类中的binarySearch方法：\n```bash\npublic static <T>\nint binarySearch(List<? extends Comparable<? super T>> list, T key) {\n    if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key);\n    else\n        return Collections.iteratorBinarySearch(list, key);\n}\n\nprivate static <T>\nint indexedBinarySearch(List<? extends Comparable<? super T>> list, T key) {\n    int low = 0;\n    int high = list.size()-1;\n\n    while (low <= high) {\n        int mid = (low + high) >>> 1;\n        Comparable<? super T> midVal = list.get(mid);\n        int cmp = midVal.compareTo(key);\n\n        if (cmp < 0)\n            low = mid + 1;\n        else if (cmp > 0)\n            high = mid - 1;\n        else\n            return mid; // key found\n    }\n    return -(low + 1);  // key not found\n}\n\nprivate static <T>\nint iteratorBinarySearch(List<? extends Comparable<? super T>> list, T key)\n{\n    int low = 0;\n    int high = list.size()-1;\n    ListIterator<? extends Comparable<? super T>> i = list.listIterator();\n\n    while (low <= high) {\n        int mid = (low + high) >>> 1;\n        Comparable<? super T> midVal = get(i, mid);\n        int cmp = midVal.compareTo(key);\n\n        if (cmp < 0)\n            low = mid + 1;\n        else if (cmp > 0)\n            high = mid - 1;\n        else\n            return mid; // key found\n    }\n    return -(low + 1);  // key not found\n}\n```\n\nbinarySearch()方法是从List中查找指定元素，其中首先判断传入的List时候实现了RandomAccess接口，如果实现了就调用indexedBinarySearch()方法，否则就调用iteratorBinarySearch()方法。再看这两个方法的源码：\n如果传入的List实现了RandomAccess接口，采用普通for循环遍历\n若传入的List未实现RandomAccess接口，采用iterator遍历\n\n**链表**\n\n**链表（Linked List）**由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针\n>单向链表\n单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。\n+ 单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找\n![单向链表](http://cdn.tycoding.cn/1120165-20171207161602113-1451349858.png)\n\n+ 单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可\n![单向链表](http://cdn.tycoding.cn/1120165-20171207162758425-142549066.png)\n\n+ 删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可\n![单向链表](http://cdn.tycoding.cn/1120165-20171207162815925-341262498.png)\n\n>双向链表\n**双向链表** 包含两个指针，prev指向前一个节点，next指向后一个节点。\n![双向链表](http://cdn.tycoding.cn/双向链表.png)\n\n>双向循环链表\n**双向循环链表** 最后一个节点的*next*指向*head*，而*head*的*prev*指向最后一个节点，形成一个环。\n![双向循环链表](http://cdn.tycoding.cn/双向循环链表.png)\n\n---\n\n#### ArrayList和Vector和LinkedList的区别？\n+ **ArrayList**: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高\n+ **Vector**: 底层数据结构是数组，查询快，增删慢。线程安全，效率低\n+ **LinkedList**: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高\n\n---\n\n#### 谈谈ArrayList的扩容机制\nJava中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，ArrayList的出现就解决了这一问题。\nArrayList的扩容机制表现在add()方法上，先看add()方法的源码：\n```bash\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\n//获取最小容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\n//判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n```\n\n当向ArrayList对象中添加新元素时，首先会调用ensureCapacityInternal(size)方法，size为最小扩容量；ensureCapacityInternal()方法会首先调用calculateCapacity来确定需要的最小容量；最后调用ensureExplicitCapacity()方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用grow()方法扩容：\n```bash\nprivate void grow(int minCapacity) {\n    // 获取ArrayList中elementDaata数组的长度\n    int oldCapacity = elementData.length;\n    // 扩容至原来的1.5倍\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    // 判断新的数组容量够不够\n    // 够了就直接使用这个长度创建新数组\n    if (newCapacity - minCapacity < 0)\n        // 不够就将数组的长度设置为需要的长度\n        newCapacity = minCapacity;\n    // 检查此时的最大值是否溢出\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // 调用Arrays.copyOf()将elementData数组数据拷贝到新数组\n    // 并将elementData指向新数组newCapacity的内存地址\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n**总结**： ArrayList扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。\n\n---\n\n#### HashMap和HashTable的区别？\n1、HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度\n2、线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰。\n3、效率: HashMap线程不安全效率高，HashTable线程安全效率低。\n3、对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null\n5、底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制。\n\n---\n\n#### HashMap和HashSet区别?\n**HashSet底层采用HashMap实现**\nHashMap|HashSet\n:--|:--\n实现了Map接口|实现了Set接口\n储存键值堆|仅储存对象\n调用put()向Map中添加元素|调用add()向Set中添加元素\nHashMap使用Key计算HashCode|HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以用equals判断对象的相等性\n\n---\n\n#### HashSet如何检查重复？\n在前面讲hashCode和equals时就提到了，HashSet集合同样适用。向HashSet中存入一个元素，HashSet首先会根据对象的hashCode值判断当期集合中此hashCode对应的位置有没有值，如果没有就直接添加，如果有就再调用equals方法比较两个对象是否相同，相同就不再储存（保证了Set集合不重复的特性），否则就散列到其他位置储存。\n\n---\n\n#### HashMap底层实现？\nMap在Java中的实现由很多，HashMap便是其中之一，随着JDK版本的更新，HashMap的实现也在不断更新：\n+ <=JDK1.7: Table数组 + Entry链表\n+ >=JDK1.8: Table数组 + Entry链表/红黑树\n\n#### Hash\n\n**Hash（哈希、散列）**，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。\nHash函数的一种实现：\n直接取余法： f(x) = x mod max\n位运算法： f(x) = x & max\nHashMap采用 位运算法，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：\n```bash\n7 & 33 = 1\n    \n    000111\n  & 100001\n  --------\n    000001 = 1\n\n```\n\n---\n\n#### Hash冲突\n假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到HashMap集合中，若将多个K-V数据存入put，HashMap根据元素key计算到对应的hashCode值，如果计算得到多个不同的key对应的hashCode值相同（即要储存到同一位置），此时这种现象就称为 Hash冲突。\nHashMap默认采用了 链地址法 解决Hash冲突问题，即通过类似单链表的方式将 冲突的元素 串起来，搜索时遍历这个链表即可。注意： 如果冲突的Hash越来越多，这个链就会越来越长。\n\n---\n\n#### 实现原理\n![hash冲突与实现原理](http://cdn.tycoding.cn/8db4a3bdfb238da1a1c4431d2b6e075c_hd.png)\n这里我们需要了解两个名词：\nTable: 哈希桶数组（哈希表），存放Node元素，底层是一个Node[] table\nNode: 节点元素，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（K-V）\nHashMap内部的一些关键属性需要了解：\nDEFAULT_INITIAL_CAPACITY: Tabale数组的初始化长度，默认是1 << 4，2^4 = 16\nMAXIMUM_CAPACITY: Table数组最高长度，默认为1 << 30，2^30 = 1073741824\nDEFAULT_LOAD_FACTOR: 负载因子，当总元素数 > 数组长度 * 负载因子时，Table数组将扩容，默认是0.75\nTREEIFY_THRESHOLD: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8\nUNTREEIFY_THRESHOLD: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6\nMIN_TREEIFY_CAPACITY: 最小树化阀值，当Table中所有元素超过该值，才会进行树化\nsize: 当前HashMap实际存在的键值对数量\nthreshold: HashMap所能容纳的最大数据量的Node（键值对）个数。Node[] table初始化长度length是16，loadFactor负载因子默认是0.75，threshold = length * loadFactor\nloadFactor: 负载因子，默认是0.17\nmodCount: 记录HashMap内部结构发生变化的次数\nHashMap内部存在一个NodeTable数组，这个数组的初始化长度是DEFAULT_INITIAL_CAPACITY，他是一个单向链表：\n```bash\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; //key的Hash值\n    final K key; //key\n    V value; //value\n    Node<K,V> next; //下一个节点\n}\n```\n\n参考单链表的结构，Table中每个Node节点包含两个部分，Node元素作为节点的header，next指向下一个节点。**这种链式结构的存在正是为了解决Hash冲突**\n\n栗子：\n```bash\nmap.put(\"loonycoder\", \"18\");\n```\nHashMap将根据\"loonycoder\"这个Key得到其hashCode值，然后经过Hash算法定位到其在HashMap储存的位置，如果两个不同的key定位到了同一个位置，此时就发生了Hash冲突。\n在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过TREEIFY_THRESHOLD阀值后，会将链表转换为红黑树的实现TreeNode:\n```bash\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n    TreeNode<K,V> parent;  // red-black tree links\n    TreeNode<K,V> left;\n    TreeNode<K,V> right;\n    TreeNode<K,V> prev;    // needed to unlink next upon deletion\n    boolean red;\n}\n```\n当发生**Hash冲突**时，根据HashMap默认采用的 **链地址法**，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。但是 随着Hash冲突越来越多，这个**链将越来越长**，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。\n![地址链法](http://cdn.tycoding.cn/JDK1.8之后的HashMap底层数据结构.jpg)\n\n**总结**\n到此，我们总结一下HashMap的实现原理：\n+ HashMap根据key的hashCode值存储元素。put新元素会遍历链表，根据新元素的key计算hashCode得到散列位置，如果该位置有值再调用equals判断value是否相同，相同就散列到其他位置储存。\n+ HashMap在put新元素时如果遇到key对应的hashCode相同，可能会产生Hash冲突问题。HashMap的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。\n+ 如果发生Hash冲突的元素很多，这个 **链** 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（TreeNode）存储元素。\n\n---\n\n#### Collection和Collections的区别？\n+ Collection是集合类的上级接口，继承他的接口主要有Set和List\n+ Collections仅是针对集合类封装的一个工具类，在java.util包下\n\n---\n\n#### Comparable和Comparator的区别？\n\n+ Comparable接口来自java.lang包，提供compareTo(Object obj) 方法排序\n+ Comparator接口来自java.util包，提供compare(Object obj1, Object obj2)方法排序\n当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。\n\n#### Java集合框架总结\n\n##### Collection\n![Collection](http://cdn.tycoding.cn/QQ20190623-181246.png)\n\n**List**\n\nArrayList: Object数组，线程不安全，查询快，增删慢，效率高\nVector: Object数组，线程安全，查询快，增删慢，效率低\nLinkedList: 双向链表，线程不安全，查询慢，增删快，效率高\n\n**Set**\n\nHashSet: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素\nLinkedHashSet: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现\nTreeSet 有序、唯一，红黑树\n\n##### Map\n![Map](http://cdn.tycoding.cn/QQ20190623-181259.png)\n\n+ HashMap: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。\n+ LinkedHashMap: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。\n+ HashTable: 数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题\nTreeMap: 红黑树\n\n---\n\n### Java并发\n\n#### 线程和进程的区别？\n+ 进程是程序的一次执行过程，是系统运行程序的基本单位\n+ 线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，\n在Java中，启用一个main方法就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。\n\n---\n\n#### 从JVM角度分析进程和线程的关系？\n根据JVM的内存划分，对于线程而言：多个线程共享进程的堆、方法区资源，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。\n\n也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。\n\n##### 为什么方法区和堆是线程共享区？\n+ **方法区（Method Area）** 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 运行时常量池 ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。\n+ **堆（Heap）** 堆内存储存了对象实例（比如new关键字创建的实例对象），它是JVM中内存区最大的一块区域。\n所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。\n\n##### 为什么虚拟机栈和本地方法栈是线程独占区？\n+ **虚拟机栈**： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。\n+ **本地方法栈**： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。\n\n##### 程序计数器是什么？\n\n**程序计数器（Program Counter Register）**：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。\n\n---\n\n#### 说说并行和并发的区别？\n+ **并行**： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）\n+ **并发**： 单位时间内，多个任务同时执行。\n\n---\n\n#### 使用多线程可能带来什么问题？\n并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题\n\n---\n\n#### 说说线程的生命周期和状态？\n状态名称|状态说明\n:--|:--\nnew|初始状态，线程被创建，但还没有调用start()方法\nrunnable|运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”\nblocked|阻塞状态，表示线程阻塞于锁\nwaiting|等待状态，线程需要等待当前线程或其他线程执行完成\ntime_waiting|超时等待状态，他可以实现在指定时间后自动返回\nterminated|终止状态，表示当前线程已经执行完毕\n\n对应，程序会因为不同代码的执行产生不同的状态，如下图：\n![线程图](http://cdn.tycoding.cn/Java+线程状态变迁.png)\n如上，线程创建后将进入NEW（初始）状态，调用start()开始运行，当线程执行wait()方法后，线程将进入WAITING（等待）状态，可以通过wait(long)或join(long)等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED（阻塞）状态。\n\n---\n\n#### 什么是上下文切换？\n简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用**随机分配时间片并轮转**的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 **任务从保存到再加载的过程就是一次上下文切换**。\n\n---\n\n#### 什么是死锁？如何避免?\n举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。\n![死锁](http://cdn.tycoding.cn/2019-4死锁1.png)\n栗子：\n```bash\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();//资源 1\n    private static Object resource2 = new Object();//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\nOutput：\n\n```bash\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n```\n线程1以resource1作为同步监视器，即可以轻松获取resource1同时也锁定了resource1，此时调用sleep让线程1等待1秒钟；此时线程2开始执行，他以resource2作为同步监视器同时也锁定了resource2，此时调用sleep让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取resource2时发现resource2已经被线程2锁定了，同理线程2结束等待后想要获取resource1时发现resource1已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。\n因此产生死锁需要具备以下四个条件：\n\n1、互斥条件：该资源任意一个时刻只能由一个线程占用\n2、请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放\n3、不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源\n4、循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。\n\n避免死锁就要破坏这四个条件中任意一个：\n1、破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥\n2、破坏请求与保持条件：一次性申请所有资源\n3、破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用\n\n解决方案: 修改线程2\n```bash\nnew Thread(() -> {\n    synchronized (resource1) {\n        System.out.println(Thread.currentThread() + \"get resource1\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread() + \"waiting get resource2\");\n        synchronized (resource2) {\n            System.out.println(Thread.currentThread() + \"get resource2\");\n        }\n    }\n}, \"线程 2\").start();\n```\n\nOutput：\n```bash\nThread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n\nProcess finished with exit code 0\n```\n\n---\n\n#### 说说sleep()方法和wait()方法的区别？\n两者最主要的区别在于：**sleep 方法没有释放锁，而 wait 方法释放了锁**\n+ 两者都可以暂停线程的执行\n+ wait()通常用于线程间交互/通信，sleep()通常用户暂停执行\n+ wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n---\n\n#### 调用start()方法会执行run()方法，为什么不能直接调用run()方法？\nnew一个Thread，线程进入了新建状态；调用start()方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这才是真正的多线程工作。而直接执行run()方法，会吧run()方法当做一个main线程下的一个普通方法去执行，并不会在某个线程中执行他。\n**总结：调用start方法可以启动线程并使线程进入就绪状态，而run()方法只是Thread的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行**\n\n---\n\n#### synchronized关键字\nsynchronized关键字解决多个线程之间访问资源的同步性，synchronized关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。\nsynchronized关键字最主要的三种使用方式：\n+ **修饰实例方法**： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁\n```bash\n// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象\npublic synchronized void add() {}\n```\n+ **修饰静态方法**： 给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。\n```bash\n// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)\npublic synchronized static void add() {}\n```\n\n+ **修饰代码块**：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁\n\n---\n","slug":"JavaBasic1","published":1,"updated":"2020-01-10T09:09:57.953Z","_id":"ck529vslf0004be6k1b8954cs","comments":1,"layout":"post","photos":[],"link":"","content":"<p>记录一些Java基础的知识点，为了自己查阅资料的时候方便一些。</p>\n<hr>\n<h3 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h3><h4 id=\"JDK和JRE的区别？\"><a href=\"#JDK和JRE的区别？\" class=\"headerlink\" title=\"JDK和JRE的区别？\"></a>JDK和JRE的区别？</h4><p>1、jre即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库<br>2、jdk是Java开发工具包，例如：tools.jar</p>\n<hr>\n<h4 id=\"和-equals的区别\"><a href=\"#和-equals的区别\" class=\"headerlink\" title=\"== 和 equals的区别\"></a>== 和 equals的区别</h4><p>1、==是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址<br>2、equals是超类Object就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。equals方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。<br>Object类equals方法源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object obj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> (this == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>new对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，举个栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class EqualsTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User a = new User();</span><br><span class=\"line\">        User b = new User();</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean equals(Object o) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (this == o) <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o instanceof User)) <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        User user = (User) o;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> age == user.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int <span class=\"function\"><span class=\"title\">hashCode</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Objects.hash(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"两个对象的hashCode-相同，则equals-一定为true？\"><a href=\"#两个对象的hashCode-相同，则equals-一定为true？\" class=\"headerlink\" title=\"两个对象的hashCode()相同，则equals()一定为true？\"></a>两个对象的hashCode()相同，则equals()一定为true？</h4><p><strong>如果两个对象相等(equals()为true)，那么他们的hashCode()一定相同</strong><br><strong>如果两个对象的hashCode()相同，他们的equals()方法不一定相同</strong></p>\n<p>JVM虚拟机通过hashCode()方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过hashCode()获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用equals()与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用equals()方法比较的次数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class EqualsTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User a = new User();</span><br><span class=\"line\">        User b = new User();</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.hashCode() == b.hashCode()); //<span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"final的作用\"><a href=\"#final的作用\" class=\"headerlink\" title=\"final的作用\"></a>final的作用</h4><p>可修饰类、类属性、类方法。<br>1、被final修饰的类不能被继承<br>2、final修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FinalTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final User USER = new User();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User u2 = new User();</span><br><span class=\"line\">//        user = u2; // ERROR</span><br><span class=\"line\">        USER.age = 23;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    int age = 12;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。</p>\n<hr>\n<h4 id=\"String属于基本数据类型吗？\"><a href=\"#String属于基本数据类型吗？\" class=\"headerlink\" title=\"String属于基本数据类型吗？\"></a>String属于基本数据类型吗？</h4><p><strong>不，String属于特殊的引用类型</strong></p>\n<p>Java中基本数据类型有：int、short、long、char、boolean、float、double、byte</p>\n<p>1、String是特殊的引用类型并且是final的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。<br>2、String s = “a”; s += “b”;，这段代码执行前后，字符串常量池中将出现a和ab两个字符串常量，而原本s变量的引用指向了常量池中ab。<br>3、String s = new String(“ab”)，这段代码一共创建了几个对象？一个或两个。如果字符串常量池中有了ab这个字符串(比如在此之前已经使用了String str = “ab”)，那么新的s对象引用其实仅仅是指向了字符串常量中的ab，并没有创建新的字符串对象。但是，每次调用new都会在堆内存开辟空间，创建一个String对象，这是肯定的。</p>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StringTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String a = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        String b = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        String c = new String(<span class=\"string\">\"abc\"</span>);</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">true</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">true</span></span><br><span class=\"line\">        System.out.println(a.equals(c)); //<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>String和StringBuffer和StringBuilder的区别</strong><br>1、String是不可变字符串，StringBuffer和StringBuilder是可变字符串。如果经常改变字符串的原始数据，最好使用StringBuffer代替。<br>2、String默认重写了equals方法和hashCode()方法；而StringBuffer没有重写equals方法，使用new StringBuffer(“”)会直接在堆内存中开辟空间储存对象。因此将StringBuffer对象储存仅Java集合中可能会出现问题。<br>3、StringBuffer是线程安全的，效率低；StringBuilder是线程不安全的，效率高。</p>\n<hr>\n<h4 id=\"static关键字？是否可覆盖？\"><a href=\"#static关键字？是否可覆盖？\" class=\"headerlink\" title=\"static关键字？是否可覆盖？\"></a>static关键字？是否可覆盖？</h4><p>static关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。</p>\n<p>static标记的方法只能访问static变量或方法<br>非static标记的方法可以访问static或非static标记的变量或方法</p>\n<hr>\n<h4 id=\"自动拆、装箱\"><a href=\"#自动拆、装箱\" class=\"headerlink\" title=\"自动拆、装箱\"></a>自动拆、装箱</h4><p>因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。<br>具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">引用数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">int</td>\n<td align=\"center\">Integer</td>\n</tr>\n<tr>\n<td align=\"center\">byte</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">Short</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">Long</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">Float</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">Double</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Char</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n</tbody></table>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Integer i1 = 100;</span><br><span class=\"line\">    Integer i2 = 100;</span><br><span class=\"line\">    Integer i3 = 200;</span><br><span class=\"line\">    Integer i4 = 200;</span><br><span class=\"line\">    System.out.println(i1 == i2);</span><br><span class=\"line\">    System.out.println(i3 == i4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>Java中实现基本数据类型和引用类型之间的拆装箱一般都是用过valueOf()方法实现的。例如我们看下Integer类的valueOf()方法源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"built_in\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到：当声明一个新的整数型变量，编译时通过Integer类的valueOf()进行拆装箱计算，这个方法会首先比较这个整数值是否在IntegerCache的范围内，如果在就返回IntegerCache类中的数值；如果不在就直接new Integer。那么我们看下IntegerCache类源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class IntegerCache &#123;</span><br><span class=\"line\">    static final int low = -128;</span><br><span class=\"line\">    static final int high;</span><br><span class=\"line\">    static final Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        // high value may be configured by property</span><br><span class=\"line\">        int h = 127;</span><br><span class=\"line\">        String integerCacheHighPropValue =</span><br><span class=\"line\">            sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (integerCacheHighPropValue != null) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                int i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                i = Math.max(i, 127);</span><br><span class=\"line\">                // Maximum array size is Integer.MAX_VALUE</span><br><span class=\"line\">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class=\"line\">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                // If the property cannot be parsed into an int, ignore it.</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">        cache = new Integer[(high - low) + 1];</span><br><span class=\"line\">        int j = low;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int k = 0; k &lt; cache.length; k++)</span><br><span class=\"line\">            cache[k] = new Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class=\"line\">        assert IntegerCache.high &gt;= 127;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private <span class=\"function\"><span class=\"title\">IntegerCache</span></span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在[-128, 127]之间，就直接返回IntegerCache中储存的常量值，否则就直接new一个新的Integer来保存这个常量值。所以上面才会出现false的结果。<br>同理：其他的数据类型例如：long、short等都具有对应的LongCache、ShortCache等类。</p>\n<hr>\n<h4 id=\"Overriding和Overloaded\"><a href=\"#Overriding和Overloaded\" class=\"headerlink\" title=\"Overriding和Overloaded\"></a>Overriding和Overloaded</h4><p>方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。<br>Overriding: 子类中定义了和父类中名称、参数列表相同的方法<br>Overloaded: 方法名相同，参数列表不同</p>\n<hr>\n<h4 id=\"Java支持多继承吗？\"><a href=\"#Java支持多继承吗？\" class=\"headerlink\" title=\"Java支持多继承吗？\"></a>Java支持多继承吗？</h4><p>不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过多层继承实现。<br>类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。<br>从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。</p>\n<hr>\n<h4 id=\"接口和抽象类的区别？\"><a href=\"#接口和抽象类的区别？\" class=\"headerlink\" title=\"接口和抽象类的区别？\"></a>接口和抽象类的区别？</h4><ul>\n<li>接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li>\n<li>接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )</li>\n<li>类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )</li>\n<li>抽象类可以是不提供接口方法实现的情况下实现接口</li>\n<li>接口中声明的变量默认都是final的；但抽象类可以包含非final的变量</li>\n<li>接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public</li>\n<li>接口是绝对抽象的，不可以被实例化；</li>\n</ul>\n<hr>\n<h4 id=\"引用传递和值传递\"><a href=\"#引用传递和值传递\" class=\"headerlink\" title=\"引用传递和值传递\"></a>引用传递和值传递</h4><p><strong>Java中采用值传递的方式</strong><br>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TransferTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a = 1;</span><br><span class=\"line\">        Integer b = 2;</span><br><span class=\"line\">        swap(a, b);</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">        System.out.println(b);</span><br><span class=\"line\"></span><br><span class=\"line\">        int[] arr = &#123;1, 2&#125;;</span><br><span class=\"line\">        swap(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void swap(int[] arr) &#123;</span><br><span class=\"line\">        arr[0] = 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void swap(int a, Integer b) &#123;</span><br><span class=\"line\">        a = 10;</span><br><span class=\"line\">        b = 20;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。<br>所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。</p>\n<hr>\n<h4 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h4><p><img src=\"http://cdn.tycoding.cn/20180127210359151.png\" alt=\"IO流\"></p>\n<p><strong>1、Java中有几种类型的流？</strong><br>字符流和字节流。字节流继承InputStream和OutputStream；字符流继承自InputStreamReader和OutputStreamWriter。</p>\n<p><strong>2、谈谈Java IO中的方法阻塞</strong><br>Java中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。</p>\n<p><strong>3、字符流和字节流的区别？</strong><br>数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。<br>而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。<br>字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。</p>\n<p><strong>4、NIO</strong><br>传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read()等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept()时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。<br>而对于NIO，它是非阻塞式，核心类：</p>\n<ul>\n<li>Buffer： 为所有的原始类型提供Buffer缓冲支持</li>\n<li>Charset： 字符集编码解码解决方案</li>\n<li>Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接。</li>\n</ul>\n<hr>\n<h4 id=\"说说List、Set、Map三者的区别\"><a href=\"#说说List、Set、Map三者的区别\" class=\"headerlink\" title=\"说说List、Set、Map三者的区别\"></a>说说List、Set、Map三者的区别</h4><ul>\n<li>List: List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素</li>\n<li>Set: 不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素</li>\n<li>Map: 使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。</li>\n</ul>\n<hr>\n<h4 id=\"Array和ArrayList有什么区别？\"><a href=\"#Array和ArrayList有什么区别？\" class=\"headerlink\" title=\"Array和ArrayList有什么区别？\"></a>Array和ArrayList有什么区别？</h4><ul>\n<li>Array可以包含基本类型和对象类型；ArrayList只能包含对象类型</li>\n<li>Array大小是固定的；ArrayList大小是动态变化的</li>\n<li>ArrayList提供了诸如addAll()、removeAll()、iterator()方法等</li>\n<li>对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。</li>\n</ul>\n<hr>\n<h4 id=\"ArrayList和LinkedList的区别？\"><a href=\"#ArrayList和LinkedList的区别？\" class=\"headerlink\" title=\"ArrayList和LinkedList的区别？\"></a>ArrayList和LinkedList的区别？</h4><p>1、<strong>是否保证线程安全</strong>： ArrayList和LinkedList都是不同步的，也就是不保证线程安全<br>2、<strong>底层数据结构</strong>： ArrayList底层使用的是Object数组；LinkedList底层使用的是 双向链表 结构<br>3、<strong>插入和删除是否受元素位置影响？</strong> ArrayList采用数组储存，所以插入和删除元素都受元素位置的影响；LinkedList 采用链表储存，所以插入、删除元素都不受元素位置影响。<br>4、<strong>是否支持快速随机访问？</strong> LinkedList因为使用链表储存，无法通过元素索引快速访问；而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。<br>5、<strong>内存空间占用</strong>： ArrayList的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而LinkedList的空间花费体现在他的每一个元素都需要消耗比ArrayList更多的空间（因为要储存直接后继和直接前驱以及数据）。</p>\n<hr>\n<p><strong>什么是迭代器</strong><br><em>Iterator</em>接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法<em>iterator()</em>。迭代器在迭代的过程中可以删除底层集合的元素。</p>\n<p><strong>Iterator和ListIterator的区别？</strong></p>\n<ul>\n<li>Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List</li>\n<li>Iterator对集合只能向前遍历（next()）；而*ListIterator可以向前遍历（next()），也可以向后遍历（previous()）</li>\n<li>ListIterator实现了Iterator接口</li>\n</ul>\n<p><strong>RandomAccess接口</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ArrayList</span><br><span class=\"line\">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class=\"line\">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//RandomAccess</span><br><span class=\"line\">public interface RandomAccess &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//LinkedList</span><br><span class=\"line\">public class LinkedList&lt;E&gt;</span><br><span class=\"line\">    extends AbstractSequentialList&lt;E&gt;</span><br><span class=\"line\">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码中ArrayList类实现了RandomAccess接口，LinkedList类中却没有实现这个接口，但是RandomAccess接口中却什么也没有定义。可以看RandomAccess接口上的注释：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that</span><br><span class=\"line\"> * they support fast (generally constant time) random access.  The primary</span><br><span class=\"line\"> * purpose of this interface is to allow generic algorithms to alter their</span><br><span class=\"line\"> * behavior to provide good performance when applied to either random or</span><br><span class=\"line\"> * sequential access lists.</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<p>大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看Collections类中的binarySearch方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt;</span><br><span class=\"line\">int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static &lt;T&gt;</span><br><span class=\"line\">int indexedBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class=\"line\">    int low = 0;</span><br><span class=\"line\">    int high = list.size()-1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class=\"line\">        Comparable&lt;? super T&gt; midVal = list.get(mid);</span><br><span class=\"line\">        int cmp = midVal.compareTo(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &lt; 0)</span><br><span class=\"line\">            low = mid + 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; 0)</span><br><span class=\"line\">            high = mid - 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> mid; // key found</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> -(low + 1);  // key not found</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static &lt;T&gt;</span><br><span class=\"line\">int iteratorBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int low = 0;</span><br><span class=\"line\">    int high = list.size()-1;</span><br><span class=\"line\">    ListIterator&lt;? extends Comparable&lt;? super T&gt;&gt; i = list.listIterator();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class=\"line\">        Comparable&lt;? super T&gt; midVal = get(i, mid);</span><br><span class=\"line\">        int cmp = midVal.compareTo(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &lt; 0)</span><br><span class=\"line\">            low = mid + 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; 0)</span><br><span class=\"line\">            high = mid - 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> mid; // key found</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> -(low + 1);  // key not found</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>binarySearch()方法是从List中查找指定元素，其中首先判断传入的List时候实现了RandomAccess接口，如果实现了就调用indexedBinarySearch()方法，否则就调用iteratorBinarySearch()方法。再看这两个方法的源码：<br>如果传入的List实现了RandomAccess接口，采用普通for循环遍历<br>若传入的List未实现RandomAccess接口，采用iterator遍历</p>\n<p><strong>链表</strong></p>\n<p><strong>链表（Linked List）</strong>由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针</p>\n<blockquote>\n<p>单向链表<br>单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。</p>\n</blockquote>\n<ul>\n<li><p>单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找<br><img src=\"http://cdn.tycoding.cn/1120165-20171207161602113-1451349858.png\" alt=\"单向链表\"></p>\n</li>\n<li><p>单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可<br><img src=\"http://cdn.tycoding.cn/1120165-20171207162758425-142549066.png\" alt=\"单向链表\"></p>\n</li>\n<li><p>删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可<br><img src=\"http://cdn.tycoding.cn/1120165-20171207162815925-341262498.png\" alt=\"单向链表\"></p>\n</li>\n</ul>\n<blockquote>\n<p>双向链表<br><strong>双向链表</strong> 包含两个指针，prev指向前一个节点，next指向后一个节点。<br><img src=\"http://cdn.tycoding.cn/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png\" alt=\"双向链表\"></p>\n</blockquote>\n<blockquote>\n<p>双向循环链表<br><strong>双向循环链表</strong> 最后一个节点的<em>next</em>指向<em>head</em>，而<em>head</em>的<em>prev</em>指向最后一个节点，形成一个环。<br><img src=\"http://cdn.tycoding.cn/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png\" alt=\"双向循环链表\"></p>\n</blockquote>\n<hr>\n<h4 id=\"ArrayList和Vector和LinkedList的区别？\"><a href=\"#ArrayList和Vector和LinkedList的区别？\" class=\"headerlink\" title=\"ArrayList和Vector和LinkedList的区别？\"></a>ArrayList和Vector和LinkedList的区别？</h4><ul>\n<li><strong>ArrayList</strong>: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高</li>\n<li><strong>Vector</strong>: 底层数据结构是数组，查询快，增删慢。线程安全，效率低</li>\n<li><strong>LinkedList</strong>: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高</li>\n</ul>\n<hr>\n<h4 id=\"谈谈ArrayList的扩容机制\"><a href=\"#谈谈ArrayList的扩容机制\" class=\"headerlink\" title=\"谈谈ArrayList的扩容机制\"></a>谈谈ArrayList的扩容机制</h4><p>Java中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，ArrayList的出现就解决了这一问题。<br>ArrayList的扩容机制表现在add()方法上，先看add()方法的源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//获取最小容量</span><br><span class=\"line\">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//判断是否需要扩容</span><br><span class=\"line\">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">    // overflow-conscious code</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; 0)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当向ArrayList对象中添加新元素时，首先会调用ensureCapacityInternal(size)方法，size为最小扩容量；ensureCapacityInternal()方法会首先调用calculateCapacity来确定需要的最小容量；最后调用ensureExplicitCapacity()方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用grow()方法扩容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void grow(int minCapacity) &#123;</span><br><span class=\"line\">    // 获取ArrayList中elementDaata数组的长度</span><br><span class=\"line\">    int oldCapacity = elementData.length;</span><br><span class=\"line\">    // 扩容至原来的1.5倍</span><br><span class=\"line\">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class=\"line\">    // 判断新的数组容量够不够</span><br><span class=\"line\">    // 够了就直接使用这个长度创建新数组</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class=\"line\">        // 不够就将数组的长度设置为需要的长度</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    // 检查此时的最大值是否溢出</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    // 调用Arrays.copyOf()将elementData数组数据拷贝到新数组</span><br><span class=\"line\">    // 并将elementData指向新数组newCapacity的内存地址</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结</strong>： ArrayList扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。</p>\n<hr>\n<h4 id=\"HashMap和HashTable的区别？\"><a href=\"#HashMap和HashTable的区别？\" class=\"headerlink\" title=\"HashMap和HashTable的区别？\"></a>HashMap和HashTable的区别？</h4><p>1、HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度<br>2、线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰。<br>3、效率: HashMap线程不安全效率高，HashTable线程安全效率低。<br>3、对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null<br>5、底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制。</p>\n<hr>\n<h4 id=\"HashMap和HashSet区别\"><a href=\"#HashMap和HashSet区别\" class=\"headerlink\" title=\"HashMap和HashSet区别?\"></a>HashMap和HashSet区别?</h4><p><strong>HashSet底层采用HashMap实现</strong><br>HashMap|HashSet<br>:–|:–<br>实现了Map接口|实现了Set接口<br>储存键值堆|仅储存对象<br>调用put()向Map中添加元素|调用add()向Set中添加元素<br>HashMap使用Key计算HashCode|HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以用equals判断对象的相等性</p>\n<hr>\n<h4 id=\"HashSet如何检查重复？\"><a href=\"#HashSet如何检查重复？\" class=\"headerlink\" title=\"HashSet如何检查重复？\"></a>HashSet如何检查重复？</h4><p>在前面讲hashCode和equals时就提到了，HashSet集合同样适用。向HashSet中存入一个元素，HashSet首先会根据对象的hashCode值判断当期集合中此hashCode对应的位置有没有值，如果没有就直接添加，如果有就再调用equals方法比较两个对象是否相同，相同就不再储存（保证了Set集合不重复的特性），否则就散列到其他位置储存。</p>\n<hr>\n<h4 id=\"HashMap底层实现？\"><a href=\"#HashMap底层实现？\" class=\"headerlink\" title=\"HashMap底层实现？\"></a>HashMap底层实现？</h4><p>Map在Java中的实现由很多，HashMap便是其中之一，随着JDK版本的更新，HashMap的实现也在不断更新：</p>\n<ul>\n<li>&lt;=JDK1.7: Table数组 + Entry链表</li>\n<li><blockquote>\n<p>=JDK1.8: Table数组 + Entry链表/红黑树</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h4><p><strong>Hash（哈希、散列）</strong>，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。<br>Hash函数的一种实现：<br>直接取余法： f(x) = x mod max<br>位运算法： f(x) = x &amp; max<br>HashMap采用 位运算法，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 &amp; 33 = 1</span><br><span class=\"line\">    </span><br><span class=\"line\">    000111</span><br><span class=\"line\">  &amp; 100001</span><br><span class=\"line\">  --------</span><br><span class=\"line\">    000001 = 1</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"Hash冲突\"><a href=\"#Hash冲突\" class=\"headerlink\" title=\"Hash冲突\"></a>Hash冲突</h4><p>假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到HashMap集合中，若将多个K-V数据存入put，HashMap根据元素key计算到对应的hashCode值，如果计算得到多个不同的key对应的hashCode值相同（即要储存到同一位置），此时这种现象就称为 Hash冲突。<br>HashMap默认采用了 链地址法 解决Hash冲突问题，即通过类似单链表的方式将 冲突的元素 串起来，搜索时遍历这个链表即可。注意： 如果冲突的Hash越来越多，这个链就会越来越长。</p>\n<hr>\n<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p><img src=\"http://cdn.tycoding.cn/8db4a3bdfb238da1a1c4431d2b6e075c_hd.png\" alt=\"hash冲突与实现原理\"><br>这里我们需要了解两个名词：<br>Table: 哈希桶数组（哈希表），存放Node元素，底层是一个Node[] table<br>Node: 节点元素，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（K-V）<br>HashMap内部的一些关键属性需要了解：<br>DEFAULT_INITIAL_CAPACITY: Tabale数组的初始化长度，默认是1 &lt;&lt; 4，2^4 = 16<br>MAXIMUM_CAPACITY: Table数组最高长度，默认为1 &lt;&lt; 30，2^30 = 1073741824<br>DEFAULT_LOAD_FACTOR: 负载因子，当总元素数 &gt; 数组长度 * 负载因子时，Table数组将扩容，默认是0.75<br>TREEIFY_THRESHOLD: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8<br>UNTREEIFY_THRESHOLD: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6<br>MIN_TREEIFY_CAPACITY: 最小树化阀值，当Table中所有元素超过该值，才会进行树化<br>size: 当前HashMap实际存在的键值对数量<br>threshold: HashMap所能容纳的最大数据量的Node（键值对）个数。Node[] table初始化长度length是16，loadFactor负载因子默认是0.75，threshold = length * loadFactor<br>loadFactor: 负载因子，默认是0.17<br>modCount: 记录HashMap内部结构发生变化的次数<br>HashMap内部存在一个NodeTable数组，这个数组的初始化长度是DEFAULT_INITIAL_CAPACITY，他是一个单向链表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    final int <span class=\"built_in\">hash</span>; //key的Hash值</span><br><span class=\"line\">    final K key; //key</span><br><span class=\"line\">    V value; //value</span><br><span class=\"line\">    Node&lt;K,V&gt; next; //下一个节点</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考单链表的结构，Table中每个Node节点包含两个部分，Node元素作为节点的header，next指向下一个节点。<strong>这种链式结构的存在正是为了解决Hash冲突</strong></p>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.put(<span class=\"string\">\"loonycoder\"</span>, <span class=\"string\">\"18\"</span>);</span><br></pre></td></tr></table></figure>\n<p>HashMap将根据”loonycoder”这个Key得到其hashCode值，然后经过Hash算法定位到其在HashMap储存的位置，如果两个不同的key定位到了同一个位置，此时就发生了Hash冲突。<br>在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过TREEIFY_THRESHOLD阀值后，会将链表转换为红黑树的实现TreeNode:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class=\"line\">    boolean red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当发生<strong>Hash冲突</strong>时，根据HashMap默认采用的 <strong>链地址法</strong>，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。但是 随着Hash冲突越来越多，这个<strong>链将越来越长</strong>，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。<br><img src=\"http://cdn.tycoding.cn/JDK1.8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg\" alt=\"地址链法\"></p>\n<p><strong>总结</strong><br>到此，我们总结一下HashMap的实现原理：</p>\n<ul>\n<li>HashMap根据key的hashCode值存储元素。put新元素会遍历链表，根据新元素的key计算hashCode得到散列位置，如果该位置有值再调用equals判断value是否相同，相同就散列到其他位置储存。</li>\n<li>HashMap在put新元素时如果遇到key对应的hashCode相同，可能会产生Hash冲突问题。HashMap的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。</li>\n<li>如果发生Hash冲突的元素很多，这个 <strong>链</strong> 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（TreeNode）存储元素。</li>\n</ul>\n<hr>\n<h4 id=\"Collection和Collections的区别？\"><a href=\"#Collection和Collections的区别？\" class=\"headerlink\" title=\"Collection和Collections的区别？\"></a>Collection和Collections的区别？</h4><ul>\n<li>Collection是集合类的上级接口，继承他的接口主要有Set和List</li>\n<li>Collections仅是针对集合类封装的一个工具类，在java.util包下</li>\n</ul>\n<hr>\n<h4 id=\"Comparable和Comparator的区别？\"><a href=\"#Comparable和Comparator的区别？\" class=\"headerlink\" title=\"Comparable和Comparator的区别？\"></a>Comparable和Comparator的区别？</h4><ul>\n<li>Comparable接口来自java.lang包，提供compareTo(Object obj) 方法排序</li>\n<li>Comparator接口来自java.util包，提供compare(Object obj1, Object obj2)方法排序<br>当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。</li>\n</ul>\n<h4 id=\"Java集合框架总结\"><a href=\"#Java集合框架总结\" class=\"headerlink\" title=\"Java集合框架总结\"></a>Java集合框架总结</h4><h5 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h5><p><img src=\"http://cdn.tycoding.cn/QQ20190623-181246.png\" alt=\"Collection\"></p>\n<p><strong>List</strong></p>\n<p>ArrayList: Object数组，线程不安全，查询快，增删慢，效率高<br>Vector: Object数组，线程安全，查询快，增删慢，效率低<br>LinkedList: 双向链表，线程不安全，查询慢，增删快，效率高</p>\n<p><strong>Set</strong></p>\n<p>HashSet: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素<br>LinkedHashSet: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现<br>TreeSet 有序、唯一，红黑树</p>\n<h5 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h5><p><img src=\"http://cdn.tycoding.cn/QQ20190623-181259.png\" alt=\"Map\"></p>\n<ul>\n<li>HashMap: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。</li>\n<li>LinkedHashMap: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li>\n<li>HashTable: 数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题<br>TreeMap: 红黑树</li>\n</ul>\n<hr>\n<h3 id=\"Java并发\"><a href=\"#Java并发\" class=\"headerlink\" title=\"Java并发\"></a>Java并发</h3><h4 id=\"线程和进程的区别？\"><a href=\"#线程和进程的区别？\" class=\"headerlink\" title=\"线程和进程的区别？\"></a>线程和进程的区别？</h4><ul>\n<li>进程是程序的一次执行过程，是系统运行程序的基本单位</li>\n<li>线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，<br>在Java中，启用一个main方法就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。</li>\n</ul>\n<hr>\n<h4 id=\"从JVM角度分析进程和线程的关系？\"><a href=\"#从JVM角度分析进程和线程的关系？\" class=\"headerlink\" title=\"从JVM角度分析进程和线程的关系？\"></a>从JVM角度分析进程和线程的关系？</h4><p>根据JVM的内存划分，对于线程而言：多个线程共享进程的堆、方法区资源，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。</p>\n<p>也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。</p>\n<h5 id=\"为什么方法区和堆是线程共享区？\"><a href=\"#为什么方法区和堆是线程共享区？\" class=\"headerlink\" title=\"为什么方法区和堆是线程共享区？\"></a>为什么方法区和堆是线程共享区？</h5><ul>\n<li><strong>方法区（Method Area）</strong> 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 运行时常量池 ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。</li>\n<li><strong>堆（Heap）</strong> 堆内存储存了对象实例（比如new关键字创建的实例对象），它是JVM中内存区最大的一块区域。<br>所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。</li>\n</ul>\n<h5 id=\"为什么虚拟机栈和本地方法栈是线程独占区？\"><a href=\"#为什么虚拟机栈和本地方法栈是线程独占区？\" class=\"headerlink\" title=\"为什么虚拟机栈和本地方法栈是线程独占区？\"></a>为什么虚拟机栈和本地方法栈是线程独占区？</h5><ul>\n<li><strong>虚拟机栈</strong>： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。</li>\n<li><strong>本地方法栈</strong>： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。</li>\n</ul>\n<h5 id=\"程序计数器是什么？\"><a href=\"#程序计数器是什么？\" class=\"headerlink\" title=\"程序计数器是什么？\"></a>程序计数器是什么？</h5><p><strong>程序计数器（Program Counter Register）</strong>：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。</p>\n<hr>\n<h4 id=\"说说并行和并发的区别？\"><a href=\"#说说并行和并发的区别？\" class=\"headerlink\" title=\"说说并行和并发的区别？\"></a>说说并行和并发的区别？</h4><ul>\n<li><strong>并行</strong>： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>\n<li><strong>并发</strong>： 单位时间内，多个任务同时执行。</li>\n</ul>\n<hr>\n<h4 id=\"使用多线程可能带来什么问题？\"><a href=\"#使用多线程可能带来什么问题？\" class=\"headerlink\" title=\"使用多线程可能带来什么问题？\"></a>使用多线程可能带来什么问题？</h4><p>并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题</p>\n<hr>\n<h4 id=\"说说线程的生命周期和状态？\"><a href=\"#说说线程的生命周期和状态？\" class=\"headerlink\" title=\"说说线程的生命周期和状态？\"></a>说说线程的生命周期和状态？</h4><table>\n<thead>\n<tr>\n<th align=\"left\">状态名称</th>\n<th align=\"left\">状态说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">new</td>\n<td align=\"left\">初始状态，线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td align=\"left\">runnable</td>\n<td align=\"left\">运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”</td>\n</tr>\n<tr>\n<td align=\"left\">blocked</td>\n<td align=\"left\">阻塞状态，表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td align=\"left\">waiting</td>\n<td align=\"left\">等待状态，线程需要等待当前线程或其他线程执行完成</td>\n</tr>\n<tr>\n<td align=\"left\">time_waiting</td>\n<td align=\"left\">超时等待状态，他可以实现在指定时间后自动返回</td>\n</tr>\n<tr>\n<td align=\"left\">terminated</td>\n<td align=\"left\">终止状态，表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p>对应，程序会因为不同代码的执行产生不同的状态，如下图：<br><img src=\"http://cdn.tycoding.cn/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png\" alt=\"线程图\"><br>如上，线程创建后将进入NEW（初始）状态，调用start()开始运行，当线程执行wait()方法后，线程将进入WAITING（等待）状态，可以通过wait(long)或join(long)等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED（阻塞）状态。</p>\n<hr>\n<h4 id=\"什么是上下文切换？\"><a href=\"#什么是上下文切换？\" class=\"headerlink\" title=\"什么是上下文切换？\"></a>什么是上下文切换？</h4><p>简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用<strong>随机分配时间片并轮转</strong>的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 <strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<hr>\n<h4 id=\"什么是死锁？如何避免\"><a href=\"#什么是死锁？如何避免\" class=\"headerlink\" title=\"什么是死锁？如何避免?\"></a>什么是死锁？如何避免?</h4><p>举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。<br><img src=\"http://cdn.tycoding.cn/2019-4%E6%AD%BB%E9%94%811.png\" alt=\"死锁\"><br>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DeadLockDemo &#123;</span><br><span class=\"line\">    private static Object resource1 = new Object();//资源 1</span><br><span class=\"line\">    private static Object resource2 = new Object();//资源 2</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            synchronized (resource1) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource2\"</span>);</span><br><span class=\"line\">                synchronized (resource2) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 1\"</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            synchronized (resource2) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource1\"</span>);</span><br><span class=\"line\">                synchronized (resource1) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 2\"</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Output：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 1,5,main]get resource1</span><br><span class=\"line\">Thread[线程 2,5,main]get resource2</span><br><span class=\"line\">Thread[线程 1,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure>\n<p>线程1以resource1作为同步监视器，即可以轻松获取resource1同时也锁定了resource1，此时调用sleep让线程1等待1秒钟；此时线程2开始执行，他以resource2作为同步监视器同时也锁定了resource2，此时调用sleep让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取resource2时发现resource2已经被线程2锁定了，同理线程2结束等待后想要获取resource1时发现resource1已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。<br>因此产生死锁需要具备以下四个条件：</p>\n<p>1、互斥条件：该资源任意一个时刻只能由一个线程占用<br>2、请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放<br>3、不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源<br>4、循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。</p>\n<p>避免死锁就要破坏这四个条件中任意一个：<br>1、破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥<br>2、破坏请求与保持条件：一次性申请所有资源<br>3、破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用</p>\n<p>解决方案: 修改线程2</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(() -&gt; &#123;</span><br><span class=\"line\">    synchronized (resource1) &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource2\"</span>);</span><br><span class=\"line\">        synchronized (resource2) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">\"线程 2\"</span>).start();</span><br></pre></td></tr></table></figure>\n\n<p>Output：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 1,5,main]get resource1</span><br><span class=\"line\">Thread[线程 1,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 1,5,main]get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]get resource1</span><br><span class=\"line\">Thread[线程 2,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]get resource2</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with <span class=\"built_in\">exit</span> code 0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"说说sleep-方法和wait-方法的区别？\"><a href=\"#说说sleep-方法和wait-方法的区别？\" class=\"headerlink\" title=\"说说sleep()方法和wait()方法的区别？\"></a>说说sleep()方法和wait()方法的区别？</h4><p>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong></p>\n<ul>\n<li>两者都可以暂停线程的执行</li>\n<li>wait()通常用于线程间交互/通信，sleep()通常用户暂停执行</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<hr>\n<h4 id=\"调用start-方法会执行run-方法，为什么不能直接调用run-方法？\"><a href=\"#调用start-方法会执行run-方法，为什么不能直接调用run-方法？\" class=\"headerlink\" title=\"调用start()方法会执行run()方法，为什么不能直接调用run()方法？\"></a>调用start()方法会执行run()方法，为什么不能直接调用run()方法？</h4><p>new一个Thread，线程进入了新建状态；调用start()方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这才是真正的多线程工作。而直接执行run()方法，会吧run()方法当做一个main线程下的一个普通方法去执行，并不会在某个线程中执行他。<br><strong>总结：调用start方法可以启动线程并使线程进入就绪状态，而run()方法只是Thread的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行</strong></p>\n<hr>\n<h4 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h4><p>synchronized关键字解决多个线程之间访问资源的同步性，synchronized关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。<br>synchronized关键字最主要的三种使用方式：</p>\n<ul>\n<li><p><strong>修饰实例方法</strong>： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象</span><br><span class=\"line\">public synchronized void <span class=\"function\"><span class=\"title\">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>修饰静态方法</strong>： 给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)</span><br><span class=\"line\">public synchronized static void <span class=\"function\"><span class=\"title\">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁</p>\n</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p>记录一些Java基础的知识点，为了自己查阅资料的时候方便一些。</p>\n<hr>\n<h3 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h3><h4 id=\"JDK和JRE的区别？\"><a href=\"#JDK和JRE的区别？\" class=\"headerlink\" title=\"JDK和JRE的区别？\"></a>JDK和JRE的区别？</h4><p>1、jre即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库<br>2、jdk是Java开发工具包，例如：tools.jar</p>\n<hr>\n<h4 id=\"和-equals的区别\"><a href=\"#和-equals的区别\" class=\"headerlink\" title=\"== 和 equals的区别\"></a>== 和 equals的区别</h4><p>1、==是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址<br>2、equals是超类Object就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。equals方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。<br>Object类equals方法源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object obj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> (this == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>new对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，举个栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class EqualsTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User a = new User();</span><br><span class=\"line\">        User b = new User();</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean equals(Object o) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (this == o) <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o instanceof User)) <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        User user = (User) o;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> age == user.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int <span class=\"function\"><span class=\"title\">hashCode</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Objects.hash(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"两个对象的hashCode-相同，则equals-一定为true？\"><a href=\"#两个对象的hashCode-相同，则equals-一定为true？\" class=\"headerlink\" title=\"两个对象的hashCode()相同，则equals()一定为true？\"></a>两个对象的hashCode()相同，则equals()一定为true？</h4><p><strong>如果两个对象相等(equals()为true)，那么他们的hashCode()一定相同</strong><br><strong>如果两个对象的hashCode()相同，他们的equals()方法不一定相同</strong></p>\n<p>JVM虚拟机通过hashCode()方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过hashCode()获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用equals()与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用equals()方法比较的次数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class EqualsTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User a = new User();</span><br><span class=\"line\">        User b = new User();</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.hashCode() == b.hashCode()); //<span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"final的作用\"><a href=\"#final的作用\" class=\"headerlink\" title=\"final的作用\"></a>final的作用</h4><p>可修饰类、类属性、类方法。<br>1、被final修饰的类不能被继承<br>2、final修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FinalTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final User USER = new User();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User u2 = new User();</span><br><span class=\"line\">//        user = u2; // ERROR</span><br><span class=\"line\">        USER.age = 23;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    int age = 12;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。</p>\n<hr>\n<h4 id=\"String属于基本数据类型吗？\"><a href=\"#String属于基本数据类型吗？\" class=\"headerlink\" title=\"String属于基本数据类型吗？\"></a>String属于基本数据类型吗？</h4><p><strong>不，String属于特殊的引用类型</strong></p>\n<p>Java中基本数据类型有：int、short、long、char、boolean、float、double、byte</p>\n<p>1、String是特殊的引用类型并且是final的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。<br>2、String s = “a”; s += “b”;，这段代码执行前后，字符串常量池中将出现a和ab两个字符串常量，而原本s变量的引用指向了常量池中ab。<br>3、String s = new String(“ab”)，这段代码一共创建了几个对象？一个或两个。如果字符串常量池中有了ab这个字符串(比如在此之前已经使用了String str = “ab”)，那么新的s对象引用其实仅仅是指向了字符串常量中的ab，并没有创建新的字符串对象。但是，每次调用new都会在堆内存开辟空间，创建一个String对象，这是肯定的。</p>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StringTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String a = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        String b = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        String c = new String(<span class=\"string\">\"abc\"</span>);</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">true</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">true</span></span><br><span class=\"line\">        System.out.println(a.equals(c)); //<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>String和StringBuffer和StringBuilder的区别</strong><br>1、String是不可变字符串，StringBuffer和StringBuilder是可变字符串。如果经常改变字符串的原始数据，最好使用StringBuffer代替。<br>2、String默认重写了equals方法和hashCode()方法；而StringBuffer没有重写equals方法，使用new StringBuffer(“”)会直接在堆内存中开辟空间储存对象。因此将StringBuffer对象储存仅Java集合中可能会出现问题。<br>3、StringBuffer是线程安全的，效率低；StringBuilder是线程不安全的，效率高。</p>\n<hr>\n<h4 id=\"static关键字？是否可覆盖？\"><a href=\"#static关键字？是否可覆盖？\" class=\"headerlink\" title=\"static关键字？是否可覆盖？\"></a>static关键字？是否可覆盖？</h4><p>static关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。</p>\n<p>static标记的方法只能访问static变量或方法<br>非static标记的方法可以访问static或非static标记的变量或方法</p>\n<hr>\n<h4 id=\"自动拆、装箱\"><a href=\"#自动拆、装箱\" class=\"headerlink\" title=\"自动拆、装箱\"></a>自动拆、装箱</h4><p>因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。<br>具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">引用数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">int</td>\n<td align=\"center\">Integer</td>\n</tr>\n<tr>\n<td align=\"center\">byte</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">Short</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">Long</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">Float</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">Double</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Char</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n</tbody></table>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Integer i1 = 100;</span><br><span class=\"line\">    Integer i2 = 100;</span><br><span class=\"line\">    Integer i3 = 200;</span><br><span class=\"line\">    Integer i4 = 200;</span><br><span class=\"line\">    System.out.println(i1 == i2);</span><br><span class=\"line\">    System.out.println(i3 == i4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>Java中实现基本数据类型和引用类型之间的拆装箱一般都是用过valueOf()方法实现的。例如我们看下Integer类的valueOf()方法源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"built_in\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到：当声明一个新的整数型变量，编译时通过Integer类的valueOf()进行拆装箱计算，这个方法会首先比较这个整数值是否在IntegerCache的范围内，如果在就返回IntegerCache类中的数值；如果不在就直接new Integer。那么我们看下IntegerCache类源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class IntegerCache &#123;</span><br><span class=\"line\">    static final int low = -128;</span><br><span class=\"line\">    static final int high;</span><br><span class=\"line\">    static final Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        // high value may be configured by property</span><br><span class=\"line\">        int h = 127;</span><br><span class=\"line\">        String integerCacheHighPropValue =</span><br><span class=\"line\">            sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (integerCacheHighPropValue != null) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                int i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                i = Math.max(i, 127);</span><br><span class=\"line\">                // Maximum array size is Integer.MAX_VALUE</span><br><span class=\"line\">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class=\"line\">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                // If the property cannot be parsed into an int, ignore it.</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">        cache = new Integer[(high - low) + 1];</span><br><span class=\"line\">        int j = low;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int k = 0; k &lt; cache.length; k++)</span><br><span class=\"line\">            cache[k] = new Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class=\"line\">        assert IntegerCache.high &gt;= 127;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private <span class=\"function\"><span class=\"title\">IntegerCache</span></span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在[-128, 127]之间，就直接返回IntegerCache中储存的常量值，否则就直接new一个新的Integer来保存这个常量值。所以上面才会出现false的结果。<br>同理：其他的数据类型例如：long、short等都具有对应的LongCache、ShortCache等类。</p>\n<hr>\n<h4 id=\"Overriding和Overloaded\"><a href=\"#Overriding和Overloaded\" class=\"headerlink\" title=\"Overriding和Overloaded\"></a>Overriding和Overloaded</h4><p>方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。<br>Overriding: 子类中定义了和父类中名称、参数列表相同的方法<br>Overloaded: 方法名相同，参数列表不同</p>\n<hr>\n<h4 id=\"Java支持多继承吗？\"><a href=\"#Java支持多继承吗？\" class=\"headerlink\" title=\"Java支持多继承吗？\"></a>Java支持多继承吗？</h4><p>不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过多层继承实现。<br>类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。<br>从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。</p>\n<hr>\n<h4 id=\"接口和抽象类的区别？\"><a href=\"#接口和抽象类的区别？\" class=\"headerlink\" title=\"接口和抽象类的区别？\"></a>接口和抽象类的区别？</h4><ul>\n<li>接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li>\n<li>接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )</li>\n<li>类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )</li>\n<li>抽象类可以是不提供接口方法实现的情况下实现接口</li>\n<li>接口中声明的变量默认都是final的；但抽象类可以包含非final的变量</li>\n<li>接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public</li>\n<li>接口是绝对抽象的，不可以被实例化；</li>\n</ul>\n<hr>\n<h4 id=\"引用传递和值传递\"><a href=\"#引用传递和值传递\" class=\"headerlink\" title=\"引用传递和值传递\"></a>引用传递和值传递</h4><p><strong>Java中采用值传递的方式</strong><br>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TransferTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a = 1;</span><br><span class=\"line\">        Integer b = 2;</span><br><span class=\"line\">        swap(a, b);</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">        System.out.println(b);</span><br><span class=\"line\"></span><br><span class=\"line\">        int[] arr = &#123;1, 2&#125;;</span><br><span class=\"line\">        swap(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void swap(int[] arr) &#123;</span><br><span class=\"line\">        arr[0] = 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void swap(int a, Integer b) &#123;</span><br><span class=\"line\">        a = 10;</span><br><span class=\"line\">        b = 20;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。<br>所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。</p>\n<hr>\n<h4 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h4><p><img src=\"http://cdn.tycoding.cn/20180127210359151.png\" alt=\"IO流\"></p>\n<p><strong>1、Java中有几种类型的流？</strong><br>字符流和字节流。字节流继承InputStream和OutputStream；字符流继承自InputStreamReader和OutputStreamWriter。</p>\n<p><strong>2、谈谈Java IO中的方法阻塞</strong><br>Java中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。</p>\n<p><strong>3、字符流和字节流的区别？</strong><br>数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。<br>而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。<br>字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。</p>\n<p><strong>4、NIO</strong><br>传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read()等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept()时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。<br>而对于NIO，它是非阻塞式，核心类：</p>\n<ul>\n<li>Buffer： 为所有的原始类型提供Buffer缓冲支持</li>\n<li>Charset： 字符集编码解码解决方案</li>\n<li>Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接。</li>\n</ul>\n<hr>\n<h4 id=\"说说List、Set、Map三者的区别\"><a href=\"#说说List、Set、Map三者的区别\" class=\"headerlink\" title=\"说说List、Set、Map三者的区别\"></a>说说List、Set、Map三者的区别</h4><ul>\n<li>List: List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素</li>\n<li>Set: 不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素</li>\n<li>Map: 使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。</li>\n</ul>\n<hr>\n<h4 id=\"Array和ArrayList有什么区别？\"><a href=\"#Array和ArrayList有什么区别？\" class=\"headerlink\" title=\"Array和ArrayList有什么区别？\"></a>Array和ArrayList有什么区别？</h4><ul>\n<li>Array可以包含基本类型和对象类型；ArrayList只能包含对象类型</li>\n<li>Array大小是固定的；ArrayList大小是动态变化的</li>\n<li>ArrayList提供了诸如addAll()、removeAll()、iterator()方法等</li>\n<li>对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。</li>\n</ul>\n<hr>\n<h4 id=\"ArrayList和LinkedList的区别？\"><a href=\"#ArrayList和LinkedList的区别？\" class=\"headerlink\" title=\"ArrayList和LinkedList的区别？\"></a>ArrayList和LinkedList的区别？</h4><p>1、<strong>是否保证线程安全</strong>： ArrayList和LinkedList都是不同步的，也就是不保证线程安全<br>2、<strong>底层数据结构</strong>： ArrayList底层使用的是Object数组；LinkedList底层使用的是 双向链表 结构<br>3、<strong>插入和删除是否受元素位置影响？</strong> ArrayList采用数组储存，所以插入和删除元素都受元素位置的影响；LinkedList 采用链表储存，所以插入、删除元素都不受元素位置影响。<br>4、<strong>是否支持快速随机访问？</strong> LinkedList因为使用链表储存，无法通过元素索引快速访问；而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。<br>5、<strong>内存空间占用</strong>： ArrayList的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而LinkedList的空间花费体现在他的每一个元素都需要消耗比ArrayList更多的空间（因为要储存直接后继和直接前驱以及数据）。</p>\n<hr>\n<p><strong>什么是迭代器</strong><br><em>Iterator</em>接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法<em>iterator()</em>。迭代器在迭代的过程中可以删除底层集合的元素。</p>\n<p><strong>Iterator和ListIterator的区别？</strong></p>\n<ul>\n<li>Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List</li>\n<li>Iterator对集合只能向前遍历（next()）；而*ListIterator可以向前遍历（next()），也可以向后遍历（previous()）</li>\n<li>ListIterator实现了Iterator接口</li>\n</ul>\n<p><strong>RandomAccess接口</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ArrayList</span><br><span class=\"line\">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class=\"line\">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//RandomAccess</span><br><span class=\"line\">public interface RandomAccess &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//LinkedList</span><br><span class=\"line\">public class LinkedList&lt;E&gt;</span><br><span class=\"line\">    extends AbstractSequentialList&lt;E&gt;</span><br><span class=\"line\">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码中ArrayList类实现了RandomAccess接口，LinkedList类中却没有实现这个接口，但是RandomAccess接口中却什么也没有定义。可以看RandomAccess接口上的注释：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that</span><br><span class=\"line\"> * they support fast (generally constant time) random access.  The primary</span><br><span class=\"line\"> * purpose of this interface is to allow generic algorithms to alter their</span><br><span class=\"line\"> * behavior to provide good performance when applied to either random or</span><br><span class=\"line\"> * sequential access lists.</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<p>大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看Collections类中的binarySearch方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt;</span><br><span class=\"line\">int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static &lt;T&gt;</span><br><span class=\"line\">int indexedBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class=\"line\">    int low = 0;</span><br><span class=\"line\">    int high = list.size()-1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class=\"line\">        Comparable&lt;? super T&gt; midVal = list.get(mid);</span><br><span class=\"line\">        int cmp = midVal.compareTo(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &lt; 0)</span><br><span class=\"line\">            low = mid + 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; 0)</span><br><span class=\"line\">            high = mid - 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> mid; // key found</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> -(low + 1);  // key not found</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static &lt;T&gt;</span><br><span class=\"line\">int iteratorBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int low = 0;</span><br><span class=\"line\">    int high = list.size()-1;</span><br><span class=\"line\">    ListIterator&lt;? extends Comparable&lt;? super T&gt;&gt; i = list.listIterator();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class=\"line\">        Comparable&lt;? super T&gt; midVal = get(i, mid);</span><br><span class=\"line\">        int cmp = midVal.compareTo(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &lt; 0)</span><br><span class=\"line\">            low = mid + 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; 0)</span><br><span class=\"line\">            high = mid - 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> mid; // key found</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> -(low + 1);  // key not found</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>binarySearch()方法是从List中查找指定元素，其中首先判断传入的List时候实现了RandomAccess接口，如果实现了就调用indexedBinarySearch()方法，否则就调用iteratorBinarySearch()方法。再看这两个方法的源码：<br>如果传入的List实现了RandomAccess接口，采用普通for循环遍历<br>若传入的List未实现RandomAccess接口，采用iterator遍历</p>\n<p><strong>链表</strong></p>\n<p><strong>链表（Linked List）</strong>由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针</p>\n<blockquote>\n<p>单向链表<br>单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。</p>\n</blockquote>\n<ul>\n<li><p>单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找<br><img src=\"http://cdn.tycoding.cn/1120165-20171207161602113-1451349858.png\" alt=\"单向链表\"></p>\n</li>\n<li><p>单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可<br><img src=\"http://cdn.tycoding.cn/1120165-20171207162758425-142549066.png\" alt=\"单向链表\"></p>\n</li>\n<li><p>删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可<br><img src=\"http://cdn.tycoding.cn/1120165-20171207162815925-341262498.png\" alt=\"单向链表\"></p>\n</li>\n</ul>\n<blockquote>\n<p>双向链表<br><strong>双向链表</strong> 包含两个指针，prev指向前一个节点，next指向后一个节点。<br><img src=\"http://cdn.tycoding.cn/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png\" alt=\"双向链表\"></p>\n</blockquote>\n<blockquote>\n<p>双向循环链表<br><strong>双向循环链表</strong> 最后一个节点的<em>next</em>指向<em>head</em>，而<em>head</em>的<em>prev</em>指向最后一个节点，形成一个环。<br><img src=\"http://cdn.tycoding.cn/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png\" alt=\"双向循环链表\"></p>\n</blockquote>\n<hr>\n<h4 id=\"ArrayList和Vector和LinkedList的区别？\"><a href=\"#ArrayList和Vector和LinkedList的区别？\" class=\"headerlink\" title=\"ArrayList和Vector和LinkedList的区别？\"></a>ArrayList和Vector和LinkedList的区别？</h4><ul>\n<li><strong>ArrayList</strong>: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高</li>\n<li><strong>Vector</strong>: 底层数据结构是数组，查询快，增删慢。线程安全，效率低</li>\n<li><strong>LinkedList</strong>: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高</li>\n</ul>\n<hr>\n<h4 id=\"谈谈ArrayList的扩容机制\"><a href=\"#谈谈ArrayList的扩容机制\" class=\"headerlink\" title=\"谈谈ArrayList的扩容机制\"></a>谈谈ArrayList的扩容机制</h4><p>Java中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，ArrayList的出现就解决了这一问题。<br>ArrayList的扩容机制表现在add()方法上，先看add()方法的源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//获取最小容量</span><br><span class=\"line\">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//判断是否需要扩容</span><br><span class=\"line\">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">    // overflow-conscious code</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; 0)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当向ArrayList对象中添加新元素时，首先会调用ensureCapacityInternal(size)方法，size为最小扩容量；ensureCapacityInternal()方法会首先调用calculateCapacity来确定需要的最小容量；最后调用ensureExplicitCapacity()方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用grow()方法扩容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void grow(int minCapacity) &#123;</span><br><span class=\"line\">    // 获取ArrayList中elementDaata数组的长度</span><br><span class=\"line\">    int oldCapacity = elementData.length;</span><br><span class=\"line\">    // 扩容至原来的1.5倍</span><br><span class=\"line\">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class=\"line\">    // 判断新的数组容量够不够</span><br><span class=\"line\">    // 够了就直接使用这个长度创建新数组</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class=\"line\">        // 不够就将数组的长度设置为需要的长度</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    // 检查此时的最大值是否溢出</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    // 调用Arrays.copyOf()将elementData数组数据拷贝到新数组</span><br><span class=\"line\">    // 并将elementData指向新数组newCapacity的内存地址</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结</strong>： ArrayList扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。</p>\n<hr>\n<h4 id=\"HashMap和HashTable的区别？\"><a href=\"#HashMap和HashTable的区别？\" class=\"headerlink\" title=\"HashMap和HashTable的区别？\"></a>HashMap和HashTable的区别？</h4><p>1、HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度<br>2、线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰。<br>3、效率: HashMap线程不安全效率高，HashTable线程安全效率低。<br>3、对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null<br>5、底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制。</p>\n<hr>\n<h4 id=\"HashMap和HashSet区别\"><a href=\"#HashMap和HashSet区别\" class=\"headerlink\" title=\"HashMap和HashSet区别?\"></a>HashMap和HashSet区别?</h4><p><strong>HashSet底层采用HashMap实现</strong><br>HashMap|HashSet<br>:–|:–<br>实现了Map接口|实现了Set接口<br>储存键值堆|仅储存对象<br>调用put()向Map中添加元素|调用add()向Set中添加元素<br>HashMap使用Key计算HashCode|HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以用equals判断对象的相等性</p>\n<hr>\n<h4 id=\"HashSet如何检查重复？\"><a href=\"#HashSet如何检查重复？\" class=\"headerlink\" title=\"HashSet如何检查重复？\"></a>HashSet如何检查重复？</h4><p>在前面讲hashCode和equals时就提到了，HashSet集合同样适用。向HashSet中存入一个元素，HashSet首先会根据对象的hashCode值判断当期集合中此hashCode对应的位置有没有值，如果没有就直接添加，如果有就再调用equals方法比较两个对象是否相同，相同就不再储存（保证了Set集合不重复的特性），否则就散列到其他位置储存。</p>\n<hr>\n<h4 id=\"HashMap底层实现？\"><a href=\"#HashMap底层实现？\" class=\"headerlink\" title=\"HashMap底层实现？\"></a>HashMap底层实现？</h4><p>Map在Java中的实现由很多，HashMap便是其中之一，随着JDK版本的更新，HashMap的实现也在不断更新：</p>\n<ul>\n<li>&lt;=JDK1.7: Table数组 + Entry链表</li>\n<li><blockquote>\n<p>=JDK1.8: Table数组 + Entry链表/红黑树</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h4><p><strong>Hash（哈希、散列）</strong>，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。<br>Hash函数的一种实现：<br>直接取余法： f(x) = x mod max<br>位运算法： f(x) = x &amp; max<br>HashMap采用 位运算法，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 &amp; 33 = 1</span><br><span class=\"line\">    </span><br><span class=\"line\">    000111</span><br><span class=\"line\">  &amp; 100001</span><br><span class=\"line\">  --------</span><br><span class=\"line\">    000001 = 1</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"Hash冲突\"><a href=\"#Hash冲突\" class=\"headerlink\" title=\"Hash冲突\"></a>Hash冲突</h4><p>假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到HashMap集合中，若将多个K-V数据存入put，HashMap根据元素key计算到对应的hashCode值，如果计算得到多个不同的key对应的hashCode值相同（即要储存到同一位置），此时这种现象就称为 Hash冲突。<br>HashMap默认采用了 链地址法 解决Hash冲突问题，即通过类似单链表的方式将 冲突的元素 串起来，搜索时遍历这个链表即可。注意： 如果冲突的Hash越来越多，这个链就会越来越长。</p>\n<hr>\n<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p><img src=\"http://cdn.tycoding.cn/8db4a3bdfb238da1a1c4431d2b6e075c_hd.png\" alt=\"hash冲突与实现原理\"><br>这里我们需要了解两个名词：<br>Table: 哈希桶数组（哈希表），存放Node元素，底层是一个Node[] table<br>Node: 节点元素，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（K-V）<br>HashMap内部的一些关键属性需要了解：<br>DEFAULT_INITIAL_CAPACITY: Tabale数组的初始化长度，默认是1 &lt;&lt; 4，2^4 = 16<br>MAXIMUM_CAPACITY: Table数组最高长度，默认为1 &lt;&lt; 30，2^30 = 1073741824<br>DEFAULT_LOAD_FACTOR: 负载因子，当总元素数 &gt; 数组长度 * 负载因子时，Table数组将扩容，默认是0.75<br>TREEIFY_THRESHOLD: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8<br>UNTREEIFY_THRESHOLD: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6<br>MIN_TREEIFY_CAPACITY: 最小树化阀值，当Table中所有元素超过该值，才会进行树化<br>size: 当前HashMap实际存在的键值对数量<br>threshold: HashMap所能容纳的最大数据量的Node（键值对）个数。Node[] table初始化长度length是16，loadFactor负载因子默认是0.75，threshold = length * loadFactor<br>loadFactor: 负载因子，默认是0.17<br>modCount: 记录HashMap内部结构发生变化的次数<br>HashMap内部存在一个NodeTable数组，这个数组的初始化长度是DEFAULT_INITIAL_CAPACITY，他是一个单向链表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    final int <span class=\"built_in\">hash</span>; //key的Hash值</span><br><span class=\"line\">    final K key; //key</span><br><span class=\"line\">    V value; //value</span><br><span class=\"line\">    Node&lt;K,V&gt; next; //下一个节点</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考单链表的结构，Table中每个Node节点包含两个部分，Node元素作为节点的header，next指向下一个节点。<strong>这种链式结构的存在正是为了解决Hash冲突</strong></p>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.put(<span class=\"string\">\"loonycoder\"</span>, <span class=\"string\">\"18\"</span>);</span><br></pre></td></tr></table></figure>\n<p>HashMap将根据”loonycoder”这个Key得到其hashCode值，然后经过Hash算法定位到其在HashMap储存的位置，如果两个不同的key定位到了同一个位置，此时就发生了Hash冲突。<br>在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过TREEIFY_THRESHOLD阀值后，会将链表转换为红黑树的实现TreeNode:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class=\"line\">    boolean red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当发生<strong>Hash冲突</strong>时，根据HashMap默认采用的 <strong>链地址法</strong>，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。但是 随着Hash冲突越来越多，这个<strong>链将越来越长</strong>，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。<br><img src=\"http://cdn.tycoding.cn/JDK1.8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg\" alt=\"地址链法\"></p>\n<p><strong>总结</strong><br>到此，我们总结一下HashMap的实现原理：</p>\n<ul>\n<li>HashMap根据key的hashCode值存储元素。put新元素会遍历链表，根据新元素的key计算hashCode得到散列位置，如果该位置有值再调用equals判断value是否相同，相同就散列到其他位置储存。</li>\n<li>HashMap在put新元素时如果遇到key对应的hashCode相同，可能会产生Hash冲突问题。HashMap的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。</li>\n<li>如果发生Hash冲突的元素很多，这个 <strong>链</strong> 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（TreeNode）存储元素。</li>\n</ul>\n<hr>\n<h4 id=\"Collection和Collections的区别？\"><a href=\"#Collection和Collections的区别？\" class=\"headerlink\" title=\"Collection和Collections的区别？\"></a>Collection和Collections的区别？</h4><ul>\n<li>Collection是集合类的上级接口，继承他的接口主要有Set和List</li>\n<li>Collections仅是针对集合类封装的一个工具类，在java.util包下</li>\n</ul>\n<hr>\n<h4 id=\"Comparable和Comparator的区别？\"><a href=\"#Comparable和Comparator的区别？\" class=\"headerlink\" title=\"Comparable和Comparator的区别？\"></a>Comparable和Comparator的区别？</h4><ul>\n<li>Comparable接口来自java.lang包，提供compareTo(Object obj) 方法排序</li>\n<li>Comparator接口来自java.util包，提供compare(Object obj1, Object obj2)方法排序<br>当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。</li>\n</ul>\n<h4 id=\"Java集合框架总结\"><a href=\"#Java集合框架总结\" class=\"headerlink\" title=\"Java集合框架总结\"></a>Java集合框架总结</h4><h5 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h5><p><img src=\"http://cdn.tycoding.cn/QQ20190623-181246.png\" alt=\"Collection\"></p>\n<p><strong>List</strong></p>\n<p>ArrayList: Object数组，线程不安全，查询快，增删慢，效率高<br>Vector: Object数组，线程安全，查询快，增删慢，效率低<br>LinkedList: 双向链表，线程不安全，查询慢，增删快，效率高</p>\n<p><strong>Set</strong></p>\n<p>HashSet: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素<br>LinkedHashSet: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现<br>TreeSet 有序、唯一，红黑树</p>\n<h5 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h5><p><img src=\"http://cdn.tycoding.cn/QQ20190623-181259.png\" alt=\"Map\"></p>\n<ul>\n<li>HashMap: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。</li>\n<li>LinkedHashMap: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li>\n<li>HashTable: 数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题<br>TreeMap: 红黑树</li>\n</ul>\n<hr>\n<h3 id=\"Java并发\"><a href=\"#Java并发\" class=\"headerlink\" title=\"Java并发\"></a>Java并发</h3><h4 id=\"线程和进程的区别？\"><a href=\"#线程和进程的区别？\" class=\"headerlink\" title=\"线程和进程的区别？\"></a>线程和进程的区别？</h4><ul>\n<li>进程是程序的一次执行过程，是系统运行程序的基本单位</li>\n<li>线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，<br>在Java中，启用一个main方法就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。</li>\n</ul>\n<hr>\n<h4 id=\"从JVM角度分析进程和线程的关系？\"><a href=\"#从JVM角度分析进程和线程的关系？\" class=\"headerlink\" title=\"从JVM角度分析进程和线程的关系？\"></a>从JVM角度分析进程和线程的关系？</h4><p>根据JVM的内存划分，对于线程而言：多个线程共享进程的堆、方法区资源，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。</p>\n<p>也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。</p>\n<h5 id=\"为什么方法区和堆是线程共享区？\"><a href=\"#为什么方法区和堆是线程共享区？\" class=\"headerlink\" title=\"为什么方法区和堆是线程共享区？\"></a>为什么方法区和堆是线程共享区？</h5><ul>\n<li><strong>方法区（Method Area）</strong> 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 运行时常量池 ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。</li>\n<li><strong>堆（Heap）</strong> 堆内存储存了对象实例（比如new关键字创建的实例对象），它是JVM中内存区最大的一块区域。<br>所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。</li>\n</ul>\n<h5 id=\"为什么虚拟机栈和本地方法栈是线程独占区？\"><a href=\"#为什么虚拟机栈和本地方法栈是线程独占区？\" class=\"headerlink\" title=\"为什么虚拟机栈和本地方法栈是线程独占区？\"></a>为什么虚拟机栈和本地方法栈是线程独占区？</h5><ul>\n<li><strong>虚拟机栈</strong>： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。</li>\n<li><strong>本地方法栈</strong>： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。</li>\n</ul>\n<h5 id=\"程序计数器是什么？\"><a href=\"#程序计数器是什么？\" class=\"headerlink\" title=\"程序计数器是什么？\"></a>程序计数器是什么？</h5><p><strong>程序计数器（Program Counter Register）</strong>：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。</p>\n<hr>\n<h4 id=\"说说并行和并发的区别？\"><a href=\"#说说并行和并发的区别？\" class=\"headerlink\" title=\"说说并行和并发的区别？\"></a>说说并行和并发的区别？</h4><ul>\n<li><strong>并行</strong>： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>\n<li><strong>并发</strong>： 单位时间内，多个任务同时执行。</li>\n</ul>\n<hr>\n<h4 id=\"使用多线程可能带来什么问题？\"><a href=\"#使用多线程可能带来什么问题？\" class=\"headerlink\" title=\"使用多线程可能带来什么问题？\"></a>使用多线程可能带来什么问题？</h4><p>并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题</p>\n<hr>\n<h4 id=\"说说线程的生命周期和状态？\"><a href=\"#说说线程的生命周期和状态？\" class=\"headerlink\" title=\"说说线程的生命周期和状态？\"></a>说说线程的生命周期和状态？</h4><table>\n<thead>\n<tr>\n<th align=\"left\">状态名称</th>\n<th align=\"left\">状态说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">new</td>\n<td align=\"left\">初始状态，线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td align=\"left\">runnable</td>\n<td align=\"left\">运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”</td>\n</tr>\n<tr>\n<td align=\"left\">blocked</td>\n<td align=\"left\">阻塞状态，表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td align=\"left\">waiting</td>\n<td align=\"left\">等待状态，线程需要等待当前线程或其他线程执行完成</td>\n</tr>\n<tr>\n<td align=\"left\">time_waiting</td>\n<td align=\"left\">超时等待状态，他可以实现在指定时间后自动返回</td>\n</tr>\n<tr>\n<td align=\"left\">terminated</td>\n<td align=\"left\">终止状态，表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p>对应，程序会因为不同代码的执行产生不同的状态，如下图：<br><img src=\"http://cdn.tycoding.cn/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png\" alt=\"线程图\"><br>如上，线程创建后将进入NEW（初始）状态，调用start()开始运行，当线程执行wait()方法后，线程将进入WAITING（等待）状态，可以通过wait(long)或join(long)等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED（阻塞）状态。</p>\n<hr>\n<h4 id=\"什么是上下文切换？\"><a href=\"#什么是上下文切换？\" class=\"headerlink\" title=\"什么是上下文切换？\"></a>什么是上下文切换？</h4><p>简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用<strong>随机分配时间片并轮转</strong>的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 <strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<hr>\n<h4 id=\"什么是死锁？如何避免\"><a href=\"#什么是死锁？如何避免\" class=\"headerlink\" title=\"什么是死锁？如何避免?\"></a>什么是死锁？如何避免?</h4><p>举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。<br><img src=\"http://cdn.tycoding.cn/2019-4%E6%AD%BB%E9%94%811.png\" alt=\"死锁\"><br>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DeadLockDemo &#123;</span><br><span class=\"line\">    private static Object resource1 = new Object();//资源 1</span><br><span class=\"line\">    private static Object resource2 = new Object();//资源 2</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            synchronized (resource1) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource2\"</span>);</span><br><span class=\"line\">                synchronized (resource2) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 1\"</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            synchronized (resource2) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource1\"</span>);</span><br><span class=\"line\">                synchronized (resource1) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 2\"</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Output：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 1,5,main]get resource1</span><br><span class=\"line\">Thread[线程 2,5,main]get resource2</span><br><span class=\"line\">Thread[线程 1,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure>\n<p>线程1以resource1作为同步监视器，即可以轻松获取resource1同时也锁定了resource1，此时调用sleep让线程1等待1秒钟；此时线程2开始执行，他以resource2作为同步监视器同时也锁定了resource2，此时调用sleep让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取resource2时发现resource2已经被线程2锁定了，同理线程2结束等待后想要获取resource1时发现resource1已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。<br>因此产生死锁需要具备以下四个条件：</p>\n<p>1、互斥条件：该资源任意一个时刻只能由一个线程占用<br>2、请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放<br>3、不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源<br>4、循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。</p>\n<p>避免死锁就要破坏这四个条件中任意一个：<br>1、破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥<br>2、破坏请求与保持条件：一次性申请所有资源<br>3、破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用</p>\n<p>解决方案: 修改线程2</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(() -&gt; &#123;</span><br><span class=\"line\">    synchronized (resource1) &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource2\"</span>);</span><br><span class=\"line\">        synchronized (resource2) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">\"线程 2\"</span>).start();</span><br></pre></td></tr></table></figure>\n\n<p>Output：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 1,5,main]get resource1</span><br><span class=\"line\">Thread[线程 1,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 1,5,main]get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]get resource1</span><br><span class=\"line\">Thread[线程 2,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]get resource2</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with <span class=\"built_in\">exit</span> code 0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"说说sleep-方法和wait-方法的区别？\"><a href=\"#说说sleep-方法和wait-方法的区别？\" class=\"headerlink\" title=\"说说sleep()方法和wait()方法的区别？\"></a>说说sleep()方法和wait()方法的区别？</h4><p>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong></p>\n<ul>\n<li>两者都可以暂停线程的执行</li>\n<li>wait()通常用于线程间交互/通信，sleep()通常用户暂停执行</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<hr>\n<h4 id=\"调用start-方法会执行run-方法，为什么不能直接调用run-方法？\"><a href=\"#调用start-方法会执行run-方法，为什么不能直接调用run-方法？\" class=\"headerlink\" title=\"调用start()方法会执行run()方法，为什么不能直接调用run()方法？\"></a>调用start()方法会执行run()方法，为什么不能直接调用run()方法？</h4><p>new一个Thread，线程进入了新建状态；调用start()方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这才是真正的多线程工作。而直接执行run()方法，会吧run()方法当做一个main线程下的一个普通方法去执行，并不会在某个线程中执行他。<br><strong>总结：调用start方法可以启动线程并使线程进入就绪状态，而run()方法只是Thread的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行</strong></p>\n<hr>\n<h4 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h4><p>synchronized关键字解决多个线程之间访问资源的同步性，synchronized关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。<br>synchronized关键字最主要的三种使用方式：</p>\n<ul>\n<li><p><strong>修饰实例方法</strong>： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象</span><br><span class=\"line\">public synchronized void <span class=\"function\"><span class=\"title\">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>修饰静态方法</strong>： 给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)</span><br><span class=\"line\">public synchronized static void <span class=\"function\"><span class=\"title\">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁</p>\n</li>\n</ul>\n<hr>\n"},{"title":"Shiro会话管理","date":"2020-01-09T16:00:00.000Z","_content":"\n### Shiro在线会话管理\n\n参考文章：\n- [跟我学Shrio-在线会话](https://www.iteye.com/blog/jinnianshilongnian-2047643)\n- [Spring Boot Shiro在线会话管理](https://mrbird.cc/Spring-Boot-Shiro%20session.html)\n\n实现效果预览：\n![实现效果预览](/images/shiro1.png)\n\nShiro提供一个对象org.apache.shiro.session.mgt.eis.SessionDAO，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。\n\n![目录](/images/shiro2.png)\n\n下面我们实现两个功能：\n- 获取在线会话列表\n- 实现强制下线功能\n\n#### 准备\n\n##### ShiroConfig\n这里我使用的是Redis来储存Shiro的Session信息，修改SessionDAO配置：\n```bash\n@Bean\npublic RedisSessionDAO redisSessionDAO() {\n    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();\n    redisSessionDAO.setRedisManager(redisManager());\n    return redisSessionDAO;\n}\n\n@ConfigurationProperties(prefix = \"redis.shiro\")\npublic RedisManager redisManager() {\n    return new RedisManager();\n}\n```\n\n还需要将SessionDAO注入到SessionManager中：\n```bash\n@Bean\npublic SessionManager sessionManager() {\n    DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();\n    defaultWebSessionManager.setCacheManager(cacheManager());\n    defaultWebSessionManager.setSessionDAO(sessionDAO());\n    return sessionManager;\n}\n```\n\n最后将SessionManager注入到SecurityManager中：\n```bash\n@Bean\npublic SecurityManager securityManager() {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    securityManager.setRealm(realm());\n\n    //自定义sessionManager\n    securityManager.setSessionManager(sessionManager());\n    //自定义缓存实现\n    securityManager.setCacheManager(cacheManager());\n\n    return securityManager;\n}\n```\n\n#### 获取在线会话列表\n\n##### OnlineUser.java\n```bash\n@Data\npublic class OnlineUser implements Serializable {\n\n    private String id; //sessionId\n\n    private String uid; //用户ID\n\n    private String username; //用户名\n\n    private String host; //主机地址\n\n    private String address; //地理位置\n\n    @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private Date startTime; //用户开始访问时间\n\n    @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private Date endTime; //用户最后访问时间\n\n    private Long timeout; //超时时间\n\n    private String status; //状态\n\n    public void setHost(String host) {\n        this.host = host.equals(\"0:0:0:0:0:0:0:1\") ? \"127.0.0.1\" : host;\n    }\n}\n```\n\n##### Service\n编写获取在线会话列表的service层实现：\n```bash\n@Override\npublic List<OnlineUser> list() {\n    List<OnlineUser> list = new ArrayList<>();\n    Collection<Session> sessions = sessionDAO.getActiveSessions(); //获取在线会话的集合\n    for (Session session : sessions) {\n        if (session != null) {\n            OnlineUser onlineUser = new OnlineUser();\n            SimplePrincipalCollection principalCollection;\n            User user;\n            //判断此session是否还在登录状态\n            if (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) {\n                continue;\n            } else {\n                //如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据\n                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);\n                user = (User) principalCollection.getPrimaryPrincipal();\n                onlineUser.setUid(user.getId().toString());\n                onlineUser.setUsername(user.getUsername());\n            }\n            onlineUser.setId(session.getId().toString());\n            onlineUser.setHost(session.getHost());\n            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));\n            onlineUser.setStartTime(session.getStartTimestamp());\n            onlineUser.setEndTime(session.getLastAccessTime());\n            long timeout = session.getTimeout();\n            onlineUser.setTimeout(timeout);\n            onlineUser.setStatus(timeout == 0L ? \"0\" : \"1\"); //0在线 1下线\n            list.add(onlineUser);\n        }\n    }\n    return list;\n}\n```\n\ngetActiveSessions()将获取到所有有效的Session集合，通过DefaultSubjectContext.PRINCIPALS_SESSION_KEY可以判断当前系统Subject中的session key和sessions列表中的session是否匹配，不匹配则session无效。\nsession.getHost()顾名思义就是获取Host主机地址即IP地址。\nAddressUtil.getAddress(session.getHost())是通过IP地址查询其详细的地理位置，使用了ip2region开源库。\n\n##### 根据IP查询地址位置\n\n开源地址：https://github.com/lionsoul2014/ip2region\n引入ip2region的依赖：\n```bash\n<dependency>\n    <groupId>org.lionsoul</groupId>\n    <artifactId>ip2region</artifactId>\n    <version>1.7.2</version>\n</dependency>\n```\n拷贝ip2region.db文件（开源仓库中找）到项目的resources/config/下\n参考官方实例代码写工具类AddressUtil.java\n官方实例：https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java\n\n```bash\npublic class AddressUtil {\n\n    public static String getAddress(String ip) {\n        //db\n        String dbPath = AddressUtil.class.getResource(\"/config/ip2region.db\").getPath();\n\n        File file = new File(dbPath);\n\n        if (!file.exists()) {\n            throw new GlobalException(\"缺少 ip2region.db库\");\n        }\n\n        int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree\n\n        try {\n            DbConfig config = new DbConfig();\n            DbSearcher searcher = new DbSearcher(config, file.getPath());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n            //define the method\n            Method method = null;\n            switch (algorithm) {\n                case DbSearcher.BTREE_ALGORITHM:\n                    method = searcher.getClass().getMethod(\"btreeSearch\", String.class);\n                    break;\n                case DbSearcher.BINARY_ALGORITHM:\n                    method = searcher.getClass().getMethod(\"binarySearch\", String.class);\n                    break;\n                case DbSearcher.MEMORY_ALGORITYM:\n                    method = searcher.getClass().getMethod(\"memorySearch\", String.class);\n                    break;\n            }\n\n            DataBlock dataBlock = null;\n            if (!Util.isIpAddress(ip)) {\n                System.out.println(\"Error: Invalid ip address\");\n            }\n            dataBlock = (DataBlock) method.invoke(searcher, ip);\n            reader.close();\n            searcher.close();\n            return dataBlock.getRegion();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\n```\n\n##### 结\n当前端请求/online/list接口时，将List<OnlineUser>结合数据返回给前端渲染即可。\n\n#### 实现强制下线功能\n\n##### controller\n```bash\n@GetMapping(\"/forceLogout\")\npublic ResponseCode forceLogout(String id) {\n    try {\n        sessionService.forceLogout(id);\n        return ResponseCode.SUCCESS();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return ResponseCode.ERROR();\n    }\n}\n```\n\n注意这个id是sessionID\n\n##### service实现\n```bash\n@Override\npublic void forceLogout(String id) {\n    Session session = sessionDAO.readSession(id);\n    session.setTimeout(0L);\n    session.stop();\n    sessionDAO.delete(session);\n}\n```\n\n\n","source":"_posts/Shiro.md","raw":"---\ntitle: Shiro会话管理\ncategories:\n    - Java框架\ndate: 2020-01-10\ntags:\n\t- 框架\n\t- 权限框架\t\n---\n\n### Shiro在线会话管理\n\n参考文章：\n- [跟我学Shrio-在线会话](https://www.iteye.com/blog/jinnianshilongnian-2047643)\n- [Spring Boot Shiro在线会话管理](https://mrbird.cc/Spring-Boot-Shiro%20session.html)\n\n实现效果预览：\n![实现效果预览](/images/shiro1.png)\n\nShiro提供一个对象org.apache.shiro.session.mgt.eis.SessionDAO，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。\n\n![目录](/images/shiro2.png)\n\n下面我们实现两个功能：\n- 获取在线会话列表\n- 实现强制下线功能\n\n#### 准备\n\n##### ShiroConfig\n这里我使用的是Redis来储存Shiro的Session信息，修改SessionDAO配置：\n```bash\n@Bean\npublic RedisSessionDAO redisSessionDAO() {\n    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();\n    redisSessionDAO.setRedisManager(redisManager());\n    return redisSessionDAO;\n}\n\n@ConfigurationProperties(prefix = \"redis.shiro\")\npublic RedisManager redisManager() {\n    return new RedisManager();\n}\n```\n\n还需要将SessionDAO注入到SessionManager中：\n```bash\n@Bean\npublic SessionManager sessionManager() {\n    DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();\n    defaultWebSessionManager.setCacheManager(cacheManager());\n    defaultWebSessionManager.setSessionDAO(sessionDAO());\n    return sessionManager;\n}\n```\n\n最后将SessionManager注入到SecurityManager中：\n```bash\n@Bean\npublic SecurityManager securityManager() {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    securityManager.setRealm(realm());\n\n    //自定义sessionManager\n    securityManager.setSessionManager(sessionManager());\n    //自定义缓存实现\n    securityManager.setCacheManager(cacheManager());\n\n    return securityManager;\n}\n```\n\n#### 获取在线会话列表\n\n##### OnlineUser.java\n```bash\n@Data\npublic class OnlineUser implements Serializable {\n\n    private String id; //sessionId\n\n    private String uid; //用户ID\n\n    private String username; //用户名\n\n    private String host; //主机地址\n\n    private String address; //地理位置\n\n    @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private Date startTime; //用户开始访问时间\n\n    @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private Date endTime; //用户最后访问时间\n\n    private Long timeout; //超时时间\n\n    private String status; //状态\n\n    public void setHost(String host) {\n        this.host = host.equals(\"0:0:0:0:0:0:0:1\") ? \"127.0.0.1\" : host;\n    }\n}\n```\n\n##### Service\n编写获取在线会话列表的service层实现：\n```bash\n@Override\npublic List<OnlineUser> list() {\n    List<OnlineUser> list = new ArrayList<>();\n    Collection<Session> sessions = sessionDAO.getActiveSessions(); //获取在线会话的集合\n    for (Session session : sessions) {\n        if (session != null) {\n            OnlineUser onlineUser = new OnlineUser();\n            SimplePrincipalCollection principalCollection;\n            User user;\n            //判断此session是否还在登录状态\n            if (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) {\n                continue;\n            } else {\n                //如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据\n                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);\n                user = (User) principalCollection.getPrimaryPrincipal();\n                onlineUser.setUid(user.getId().toString());\n                onlineUser.setUsername(user.getUsername());\n            }\n            onlineUser.setId(session.getId().toString());\n            onlineUser.setHost(session.getHost());\n            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));\n            onlineUser.setStartTime(session.getStartTimestamp());\n            onlineUser.setEndTime(session.getLastAccessTime());\n            long timeout = session.getTimeout();\n            onlineUser.setTimeout(timeout);\n            onlineUser.setStatus(timeout == 0L ? \"0\" : \"1\"); //0在线 1下线\n            list.add(onlineUser);\n        }\n    }\n    return list;\n}\n```\n\ngetActiveSessions()将获取到所有有效的Session集合，通过DefaultSubjectContext.PRINCIPALS_SESSION_KEY可以判断当前系统Subject中的session key和sessions列表中的session是否匹配，不匹配则session无效。\nsession.getHost()顾名思义就是获取Host主机地址即IP地址。\nAddressUtil.getAddress(session.getHost())是通过IP地址查询其详细的地理位置，使用了ip2region开源库。\n\n##### 根据IP查询地址位置\n\n开源地址：https://github.com/lionsoul2014/ip2region\n引入ip2region的依赖：\n```bash\n<dependency>\n    <groupId>org.lionsoul</groupId>\n    <artifactId>ip2region</artifactId>\n    <version>1.7.2</version>\n</dependency>\n```\n拷贝ip2region.db文件（开源仓库中找）到项目的resources/config/下\n参考官方实例代码写工具类AddressUtil.java\n官方实例：https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java\n\n```bash\npublic class AddressUtil {\n\n    public static String getAddress(String ip) {\n        //db\n        String dbPath = AddressUtil.class.getResource(\"/config/ip2region.db\").getPath();\n\n        File file = new File(dbPath);\n\n        if (!file.exists()) {\n            throw new GlobalException(\"缺少 ip2region.db库\");\n        }\n\n        int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree\n\n        try {\n            DbConfig config = new DbConfig();\n            DbSearcher searcher = new DbSearcher(config, file.getPath());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n            //define the method\n            Method method = null;\n            switch (algorithm) {\n                case DbSearcher.BTREE_ALGORITHM:\n                    method = searcher.getClass().getMethod(\"btreeSearch\", String.class);\n                    break;\n                case DbSearcher.BINARY_ALGORITHM:\n                    method = searcher.getClass().getMethod(\"binarySearch\", String.class);\n                    break;\n                case DbSearcher.MEMORY_ALGORITYM:\n                    method = searcher.getClass().getMethod(\"memorySearch\", String.class);\n                    break;\n            }\n\n            DataBlock dataBlock = null;\n            if (!Util.isIpAddress(ip)) {\n                System.out.println(\"Error: Invalid ip address\");\n            }\n            dataBlock = (DataBlock) method.invoke(searcher, ip);\n            reader.close();\n            searcher.close();\n            return dataBlock.getRegion();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\n```\n\n##### 结\n当前端请求/online/list接口时，将List<OnlineUser>结合数据返回给前端渲染即可。\n\n#### 实现强制下线功能\n\n##### controller\n```bash\n@GetMapping(\"/forceLogout\")\npublic ResponseCode forceLogout(String id) {\n    try {\n        sessionService.forceLogout(id);\n        return ResponseCode.SUCCESS();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return ResponseCode.ERROR();\n    }\n}\n```\n\n注意这个id是sessionID\n\n##### service实现\n```bash\n@Override\npublic void forceLogout(String id) {\n    Session session = sessionDAO.readSession(id);\n    session.setTimeout(0L);\n    session.stop();\n    sessionDAO.delete(session);\n}\n```\n\n\n","slug":"Shiro","published":1,"updated":"2020-01-10T09:03:45.726Z","_id":"ck57xfme50000d36kef11hpp8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Shiro在线会话管理\"><a href=\"#Shiro在线会话管理\" class=\"headerlink\" title=\"Shiro在线会话管理\"></a>Shiro在线会话管理</h3><p>参考文章：</p>\n<ul>\n<li><a href=\"https://www.iteye.com/blog/jinnianshilongnian-2047643\" target=\"_blank\" rel=\"noopener\">跟我学Shrio-在线会话</a></li>\n<li><a href=\"https://mrbird.cc/Spring-Boot-Shiro%20session.html\" target=\"_blank\" rel=\"noopener\">Spring Boot Shiro在线会话管理</a></li>\n</ul>\n<p>实现效果预览：<br><img src=\"/images/shiro1.png\" alt=\"实现效果预览\"></p>\n<p>Shiro提供一个对象org.apache.shiro.session.mgt.eis.SessionDAO，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。</p>\n<p><img src=\"/images/shiro2.png\" alt=\"目录\"></p>\n<p>下面我们实现两个功能：</p>\n<ul>\n<li>获取在线会话列表</li>\n<li>实现强制下线功能</li>\n</ul>\n<h4 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h4><h5 id=\"ShiroConfig\"><a href=\"#ShiroConfig\" class=\"headerlink\" title=\"ShiroConfig\"></a>ShiroConfig</h5><p>这里我使用的是Redis来储存Shiro的Session信息，修改SessionDAO配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public RedisSessionDAO <span class=\"function\"><span class=\"title\">redisSessionDAO</span></span>() &#123;</span><br><span class=\"line\">    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();</span><br><span class=\"line\">    redisSessionDAO.setRedisManager(redisManager());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> redisSessionDAO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@ConfigurationProperties(prefix = <span class=\"string\">\"redis.shiro\"</span>)</span><br><span class=\"line\">public RedisManager <span class=\"function\"><span class=\"title\">redisManager</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new RedisManager();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还需要将SessionDAO注入到SessionManager中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public SessionManager <span class=\"function\"><span class=\"title\">sessionManager</span></span>() &#123;</span><br><span class=\"line\">    DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();</span><br><span class=\"line\">    defaultWebSessionManager.setCacheManager(cacheManager());</span><br><span class=\"line\">    defaultWebSessionManager.setSessionDAO(sessionDAO());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> sessionManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后将SessionManager注入到SecurityManager中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public SecurityManager <span class=\"function\"><span class=\"title\">securityManager</span></span>() &#123;</span><br><span class=\"line\">    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class=\"line\">    securityManager.setRealm(realm());</span><br><span class=\"line\"></span><br><span class=\"line\">    //自定义sessionManager</span><br><span class=\"line\">    securityManager.setSessionManager(sessionManager());</span><br><span class=\"line\">    //自定义缓存实现</span><br><span class=\"line\">    securityManager.setCacheManager(cacheManager());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> securityManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"获取在线会话列表\"><a href=\"#获取在线会话列表\" class=\"headerlink\" title=\"获取在线会话列表\"></a>获取在线会话列表</h4><h5 id=\"OnlineUser-java\"><a href=\"#OnlineUser-java\" class=\"headerlink\" title=\"OnlineUser.java\"></a>OnlineUser.java</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Data</span><br><span class=\"line\">public class OnlineUser implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id; //sessionId</span><br><span class=\"line\"></span><br><span class=\"line\">    private String uid; //用户ID</span><br><span class=\"line\"></span><br><span class=\"line\">    private String username; //用户名</span><br><span class=\"line\"></span><br><span class=\"line\">    private String host; //主机地址</span><br><span class=\"line\"></span><br><span class=\"line\">    private String address; //地理位置</span><br><span class=\"line\"></span><br><span class=\"line\">    @DateTimeFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">    @JsonFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>, timezone = <span class=\"string\">\"GMT+8\"</span>)</span><br><span class=\"line\">    private Date startTime; //用户开始访问时间</span><br><span class=\"line\"></span><br><span class=\"line\">    @DateTimeFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">    @JsonFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>, timezone = <span class=\"string\">\"GMT+8\"</span>)</span><br><span class=\"line\">    private Date endTime; //用户最后访问时间</span><br><span class=\"line\"></span><br><span class=\"line\">    private Long timeout; //超时时间</span><br><span class=\"line\"></span><br><span class=\"line\">    private String status; //状态</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setHost(String host) &#123;</span><br><span class=\"line\">        this.host = host.equals(<span class=\"string\">\"0:0:0:0:0:0:0:1\"</span>) ? <span class=\"string\">\"127.0.0.1\"</span> : host;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h5><p>编写获取在线会话列表的service层实现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public List&lt;OnlineUser&gt; <span class=\"function\"><span class=\"title\">list</span></span>() &#123;</span><br><span class=\"line\">    List&lt;OnlineUser&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    Collection&lt;Session&gt; sessions = sessionDAO.getActiveSessions(); //获取在线会话的集合</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Session session : sessions) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (session != null) &#123;</span><br><span class=\"line\">            OnlineUser onlineUser = new OnlineUser();</span><br><span class=\"line\">            SimplePrincipalCollection principalCollection;</span><br><span class=\"line\">            User user;</span><br><span class=\"line\">            //判断此session是否还在登录状态</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                //如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据</span><br><span class=\"line\">                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);</span><br><span class=\"line\">                user = (User) principalCollection.getPrimaryPrincipal();</span><br><span class=\"line\">                onlineUser.setUid(user.getId().toString());</span><br><span class=\"line\">                onlineUser.setUsername(user.getUsername());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            onlineUser.setId(session.getId().toString());</span><br><span class=\"line\">            onlineUser.setHost(session.getHost());</span><br><span class=\"line\">            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));</span><br><span class=\"line\">            onlineUser.setStartTime(session.getStartTimestamp());</span><br><span class=\"line\">            onlineUser.setEndTime(session.getLastAccessTime());</span><br><span class=\"line\">            long timeout = session.getTimeout();</span><br><span class=\"line\">            onlineUser.setTimeout(timeout);</span><br><span class=\"line\">            onlineUser.setStatus(timeout == 0L ? <span class=\"string\">\"0\"</span> : <span class=\"string\">\"1\"</span>); //0在线 1下线</span><br><span class=\"line\">            list.add(onlineUser);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getActiveSessions()将获取到所有有效的Session集合，通过DefaultSubjectContext.PRINCIPALS_SESSION_KEY可以判断当前系统Subject中的session key和sessions列表中的session是否匹配，不匹配则session无效。<br>session.getHost()顾名思义就是获取Host主机地址即IP地址。<br>AddressUtil.getAddress(session.getHost())是通过IP地址查询其详细的地理位置，使用了ip2region开源库。</p>\n<h5 id=\"根据IP查询地址位置\"><a href=\"#根据IP查询地址位置\" class=\"headerlink\" title=\"根据IP查询地址位置\"></a>根据IP查询地址位置</h5><p>开源地址：<a href=\"https://github.com/lionsoul2014/ip2region\" target=\"_blank\" rel=\"noopener\">https://github.com/lionsoul2014/ip2region</a><br>引入ip2region的依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.lionsoul&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;ip2region&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.2&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>拷贝ip2region.db文件（开源仓库中找）到项目的resources/config/下<br>参考官方实例代码写工具类AddressUtil.java<br>官方实例：<a href=\"https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java\" target=\"_blank\" rel=\"noopener\">https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AddressUtil &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static String getAddress(String ip) &#123;</span><br><span class=\"line\">        //db</span><br><span class=\"line\">        String dbPath = AddressUtil.class.getResource(<span class=\"string\">\"/config/ip2region.db\"</span>).getPath();</span><br><span class=\"line\"></span><br><span class=\"line\">        File file = new File(dbPath);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file.exists()) &#123;</span><br><span class=\"line\">            throw new GlobalException(<span class=\"string\">\"缺少 ip2region.db库\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            DbConfig config = new DbConfig();</span><br><span class=\"line\">            DbSearcher searcher = new DbSearcher(config, file.getPath());</span><br><span class=\"line\">            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span><br><span class=\"line\"></span><br><span class=\"line\">            //define the method</span><br><span class=\"line\">            Method method = null;</span><br><span class=\"line\">            switch (algorithm) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.BTREE_ALGORITHM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"btreeSearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.BINARY_ALGORITHM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"binarySearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.MEMORY_ALGORITYM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"memorySearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            DataBlock dataBlock = null;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Util.isIpAddress(ip)) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Error: Invalid ip address\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dataBlock = (DataBlock) method.invoke(searcher, ip);</span><br><span class=\"line\">            reader.close();</span><br><span class=\"line\">            searcher.close();</span><br><span class=\"line\">            <span class=\"built_in\">return</span> dataBlock.getRegion();</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"结\"><a href=\"#结\" class=\"headerlink\" title=\"结\"></a>结</h5><p>当前端请求/online/list接口时，将List<OnlineUser>结合数据返回给前端渲染即可。</p>\n<h4 id=\"实现强制下线功能\"><a href=\"#实现强制下线功能\" class=\"headerlink\" title=\"实现强制下线功能\"></a>实现强制下线功能</h4><h5 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(<span class=\"string\">\"/forceLogout\"</span>)</span><br><span class=\"line\">public ResponseCode forceLogout(String id) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        sessionService.forceLogout(id);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ResponseCode.SUCCESS();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ResponseCode.ERROR();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意这个id是sessionID</p>\n<h5 id=\"service实现\"><a href=\"#service实现\" class=\"headerlink\" title=\"service实现\"></a>service实现</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void forceLogout(String id) &#123;</span><br><span class=\"line\">    Session session = sessionDAO.readSession(id);</span><br><span class=\"line\">    session.setTimeout(0L);</span><br><span class=\"line\">    session.stop();</span><br><span class=\"line\">    sessionDAO.delete(session);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Shiro在线会话管理\"><a href=\"#Shiro在线会话管理\" class=\"headerlink\" title=\"Shiro在线会话管理\"></a>Shiro在线会话管理</h3><p>参考文章：</p>\n<ul>\n<li><a href=\"https://www.iteye.com/blog/jinnianshilongnian-2047643\" target=\"_blank\" rel=\"noopener\">跟我学Shrio-在线会话</a></li>\n<li><a href=\"https://mrbird.cc/Spring-Boot-Shiro%20session.html\" target=\"_blank\" rel=\"noopener\">Spring Boot Shiro在线会话管理</a></li>\n</ul>\n<p>实现效果预览：<br><img src=\"/images/shiro1.png\" alt=\"实现效果预览\"></p>\n<p>Shiro提供一个对象org.apache.shiro.session.mgt.eis.SessionDAO，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。</p>\n<p><img src=\"/images/shiro2.png\" alt=\"目录\"></p>\n<p>下面我们实现两个功能：</p>\n<ul>\n<li>获取在线会话列表</li>\n<li>实现强制下线功能</li>\n</ul>\n<h4 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h4><h5 id=\"ShiroConfig\"><a href=\"#ShiroConfig\" class=\"headerlink\" title=\"ShiroConfig\"></a>ShiroConfig</h5><p>这里我使用的是Redis来储存Shiro的Session信息，修改SessionDAO配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public RedisSessionDAO <span class=\"function\"><span class=\"title\">redisSessionDAO</span></span>() &#123;</span><br><span class=\"line\">    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();</span><br><span class=\"line\">    redisSessionDAO.setRedisManager(redisManager());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> redisSessionDAO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@ConfigurationProperties(prefix = <span class=\"string\">\"redis.shiro\"</span>)</span><br><span class=\"line\">public RedisManager <span class=\"function\"><span class=\"title\">redisManager</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new RedisManager();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还需要将SessionDAO注入到SessionManager中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public SessionManager <span class=\"function\"><span class=\"title\">sessionManager</span></span>() &#123;</span><br><span class=\"line\">    DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();</span><br><span class=\"line\">    defaultWebSessionManager.setCacheManager(cacheManager());</span><br><span class=\"line\">    defaultWebSessionManager.setSessionDAO(sessionDAO());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> sessionManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后将SessionManager注入到SecurityManager中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public SecurityManager <span class=\"function\"><span class=\"title\">securityManager</span></span>() &#123;</span><br><span class=\"line\">    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class=\"line\">    securityManager.setRealm(realm());</span><br><span class=\"line\"></span><br><span class=\"line\">    //自定义sessionManager</span><br><span class=\"line\">    securityManager.setSessionManager(sessionManager());</span><br><span class=\"line\">    //自定义缓存实现</span><br><span class=\"line\">    securityManager.setCacheManager(cacheManager());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> securityManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"获取在线会话列表\"><a href=\"#获取在线会话列表\" class=\"headerlink\" title=\"获取在线会话列表\"></a>获取在线会话列表</h4><h5 id=\"OnlineUser-java\"><a href=\"#OnlineUser-java\" class=\"headerlink\" title=\"OnlineUser.java\"></a>OnlineUser.java</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Data</span><br><span class=\"line\">public class OnlineUser implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id; //sessionId</span><br><span class=\"line\"></span><br><span class=\"line\">    private String uid; //用户ID</span><br><span class=\"line\"></span><br><span class=\"line\">    private String username; //用户名</span><br><span class=\"line\"></span><br><span class=\"line\">    private String host; //主机地址</span><br><span class=\"line\"></span><br><span class=\"line\">    private String address; //地理位置</span><br><span class=\"line\"></span><br><span class=\"line\">    @DateTimeFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">    @JsonFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>, timezone = <span class=\"string\">\"GMT+8\"</span>)</span><br><span class=\"line\">    private Date startTime; //用户开始访问时间</span><br><span class=\"line\"></span><br><span class=\"line\">    @DateTimeFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">    @JsonFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>, timezone = <span class=\"string\">\"GMT+8\"</span>)</span><br><span class=\"line\">    private Date endTime; //用户最后访问时间</span><br><span class=\"line\"></span><br><span class=\"line\">    private Long timeout; //超时时间</span><br><span class=\"line\"></span><br><span class=\"line\">    private String status; //状态</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setHost(String host) &#123;</span><br><span class=\"line\">        this.host = host.equals(<span class=\"string\">\"0:0:0:0:0:0:0:1\"</span>) ? <span class=\"string\">\"127.0.0.1\"</span> : host;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h5><p>编写获取在线会话列表的service层实现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public List&lt;OnlineUser&gt; <span class=\"function\"><span class=\"title\">list</span></span>() &#123;</span><br><span class=\"line\">    List&lt;OnlineUser&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    Collection&lt;Session&gt; sessions = sessionDAO.getActiveSessions(); //获取在线会话的集合</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Session session : sessions) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (session != null) &#123;</span><br><span class=\"line\">            OnlineUser onlineUser = new OnlineUser();</span><br><span class=\"line\">            SimplePrincipalCollection principalCollection;</span><br><span class=\"line\">            User user;</span><br><span class=\"line\">            //判断此session是否还在登录状态</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                //如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据</span><br><span class=\"line\">                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);</span><br><span class=\"line\">                user = (User) principalCollection.getPrimaryPrincipal();</span><br><span class=\"line\">                onlineUser.setUid(user.getId().toString());</span><br><span class=\"line\">                onlineUser.setUsername(user.getUsername());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            onlineUser.setId(session.getId().toString());</span><br><span class=\"line\">            onlineUser.setHost(session.getHost());</span><br><span class=\"line\">            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));</span><br><span class=\"line\">            onlineUser.setStartTime(session.getStartTimestamp());</span><br><span class=\"line\">            onlineUser.setEndTime(session.getLastAccessTime());</span><br><span class=\"line\">            long timeout = session.getTimeout();</span><br><span class=\"line\">            onlineUser.setTimeout(timeout);</span><br><span class=\"line\">            onlineUser.setStatus(timeout == 0L ? <span class=\"string\">\"0\"</span> : <span class=\"string\">\"1\"</span>); //0在线 1下线</span><br><span class=\"line\">            list.add(onlineUser);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getActiveSessions()将获取到所有有效的Session集合，通过DefaultSubjectContext.PRINCIPALS_SESSION_KEY可以判断当前系统Subject中的session key和sessions列表中的session是否匹配，不匹配则session无效。<br>session.getHost()顾名思义就是获取Host主机地址即IP地址。<br>AddressUtil.getAddress(session.getHost())是通过IP地址查询其详细的地理位置，使用了ip2region开源库。</p>\n<h5 id=\"根据IP查询地址位置\"><a href=\"#根据IP查询地址位置\" class=\"headerlink\" title=\"根据IP查询地址位置\"></a>根据IP查询地址位置</h5><p>开源地址：<a href=\"https://github.com/lionsoul2014/ip2region\" target=\"_blank\" rel=\"noopener\">https://github.com/lionsoul2014/ip2region</a><br>引入ip2region的依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.lionsoul&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;ip2region&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.2&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>拷贝ip2region.db文件（开源仓库中找）到项目的resources/config/下<br>参考官方实例代码写工具类AddressUtil.java<br>官方实例：<a href=\"https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java\" target=\"_blank\" rel=\"noopener\">https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AddressUtil &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static String getAddress(String ip) &#123;</span><br><span class=\"line\">        //db</span><br><span class=\"line\">        String dbPath = AddressUtil.class.getResource(<span class=\"string\">\"/config/ip2region.db\"</span>).getPath();</span><br><span class=\"line\"></span><br><span class=\"line\">        File file = new File(dbPath);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file.exists()) &#123;</span><br><span class=\"line\">            throw new GlobalException(<span class=\"string\">\"缺少 ip2region.db库\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            DbConfig config = new DbConfig();</span><br><span class=\"line\">            DbSearcher searcher = new DbSearcher(config, file.getPath());</span><br><span class=\"line\">            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span><br><span class=\"line\"></span><br><span class=\"line\">            //define the method</span><br><span class=\"line\">            Method method = null;</span><br><span class=\"line\">            switch (algorithm) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.BTREE_ALGORITHM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"btreeSearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.BINARY_ALGORITHM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"binarySearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.MEMORY_ALGORITYM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"memorySearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            DataBlock dataBlock = null;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Util.isIpAddress(ip)) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Error: Invalid ip address\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dataBlock = (DataBlock) method.invoke(searcher, ip);</span><br><span class=\"line\">            reader.close();</span><br><span class=\"line\">            searcher.close();</span><br><span class=\"line\">            <span class=\"built_in\">return</span> dataBlock.getRegion();</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"结\"><a href=\"#结\" class=\"headerlink\" title=\"结\"></a>结</h5><p>当前端请求/online/list接口时，将List<OnlineUser>结合数据返回给前端渲染即可。</p>\n<h4 id=\"实现强制下线功能\"><a href=\"#实现强制下线功能\" class=\"headerlink\" title=\"实现强制下线功能\"></a>实现强制下线功能</h4><h5 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(<span class=\"string\">\"/forceLogout\"</span>)</span><br><span class=\"line\">public ResponseCode forceLogout(String id) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        sessionService.forceLogout(id);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ResponseCode.SUCCESS();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ResponseCode.ERROR();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意这个id是sessionID</p>\n<h5 id=\"service实现\"><a href=\"#service实现\" class=\"headerlink\" title=\"service实现\"></a>service实现</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void forceLogout(String id) &#123;</span><br><span class=\"line\">    Session session = sessionDAO.readSession(id);</span><br><span class=\"line\">    session.setTimeout(0L);</span><br><span class=\"line\">    session.stop();</span><br><span class=\"line\">    sessionDAO.delete(session);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck4xxfhf10000fs6kdsf267ed","category_id":"ck4seojjv0001h7s67lt40541","_id":"ck4xxfhfb0005fs6kcozk06ev"},{"post_id":"ck51w70e80000ml6ke95j9hpg","category_id":"ck51vzg8z0001f96k47kf92dq","_id":"ck51w70ej0002ml6kcnu09p60"},{"post_id":"ck529vsji0000be6kcklmdvfk","category_id":"ck4seojjv0001h7s67lt40541","_id":"ck529vsjz0003be6k8im7aw69"},{"post_id":"ck529vslf0004be6k1b8954cs","category_id":"ck4seojjv0001h7s67lt40541","_id":"ck529vslj0007be6k1tf2dsnz"},{"post_id":"ck57xfme50000d36kef11hpp8","category_id":"ck57xfmeb0001d36kf2xdg6sh","_id":"ck57xfmee0004d36keddvfi4r"}],"PostTag":[{"post_id":"ck4xxfhf10000fs6kdsf267ed","tag_id":"ck4seojjz0002h7s6bxv01y3n","_id":"ck4xxfhfa0003fs6k27a46sdm"},{"post_id":"ck51w70e80000ml6ke95j9hpg","tag_id":"ck51vzg930002f96kfcljd45q","_id":"ck51w70ei0001ml6k5s63ci36"},{"post_id":"ck529vsji0000be6kcklmdvfk","tag_id":"ck4seojjz0002h7s6bxv01y3n","_id":"ck529vsjy0001be6kdzhm5rpk"},{"post_id":"ck529vsji0000be6kcklmdvfk","tag_id":"ck4seojk00003h7s637qb86df","_id":"ck529vsjz0002be6kex3a9tsz"},{"post_id":"ck529vslf0004be6k1b8954cs","tag_id":"ck4seojjz0002h7s6bxv01y3n","_id":"ck529vslj0005be6kbbx466m5"},{"post_id":"ck529vslf0004be6k1b8954cs","tag_id":"ck4seojk00003h7s637qb86df","_id":"ck529vslj0006be6k43oceteu"},{"post_id":"ck57xfme50000d36kef11hpp8","tag_id":"ck57xfmed0002d36kggnc3bah","_id":"ck57xfmee0005d36k12xrbyke"},{"post_id":"ck57xfme50000d36kef11hpp8","tag_id":"ck57xfmed0003d36k6cp5g1f1","_id":"ck57xfmee0006d36k3ljh2ce4"},{"post_id":"ck4xxfhf10000fs6kdsf267ed","tag_id":"ck57yd84k0000vh6kfacxhvgv","_id":"ck57yd84o0001vh6k50bxal1q"}],"Tag":[{"name":"web","_id":"ck4kwhov60000za6k3rpv13rx"},{"name":"hexo","_id":"ck4kwhov80001za6kgavbczb7"},{"name":"github","_id":"ck4kwhov80002za6kcdm2fyj7"},{"name":"Java","_id":"ck4seojjz0002h7s6bxv01y3n"},{"name":"Java基础","_id":"ck4seojk00003h7s637qb86df"},{"name":"Java框架","_id":"ck4xxfhf70001fs6k2pxr3lbr"},{"name":"前端框架","_id":"ck51vzg930002f96kfcljd45q"},{"name":"框架","_id":"ck57xfmed0002d36kggnc3bah"},{"name":"权限框架","_id":"ck57xfmed0003d36k6cp5g1f1"},{"name":"Java框架 - 数据库","_id":"ck57yd84k0000vh6kfacxhvgv"}]}}