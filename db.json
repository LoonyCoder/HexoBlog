{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"source/images/DomaticBind.png","path":"images/DomaticBind.png","modified":0,"renderable":0},{"_id":"source/images/String1.png","path":"images/String1.png","modified":0,"renderable":0},{"_id":"source/images/docker1.jpg","path":"images/docker1.jpg","modified":0,"renderable":0},{"_id":"source/images/deadlock.png","path":"images/deadlock.png","modified":0,"renderable":0},{"_id":"source/images/collection1.png","path":"images/collection1.png","modified":0,"renderable":0},{"_id":"source/images/docker11.png","path":"images/docker11.png","modified":0,"renderable":0},{"_id":"source/images/docker10.png","path":"images/docker10.png","modified":0,"renderable":0},{"_id":"source/images/docker4.png","path":"images/docker4.png","modified":0,"renderable":0},{"_id":"source/images/docker3.png","path":"images/docker3.png","modified":0,"renderable":0},{"_id":"source/images/docker12.png","path":"images/docker12.png","modified":0,"renderable":0},{"_id":"source/images/docker8.png","path":"images/docker8.png","modified":0,"renderable":0},{"_id":"source/images/docker6.png","path":"images/docker6.png","modified":0,"renderable":0},{"_id":"source/images/docker9.png","path":"images/docker9.png","modified":0,"renderable":0},{"_id":"source/images/linktable1.png","path":"images/linktable1.png","modified":0,"renderable":0},{"_id":"source/images/linktable2.png","path":"images/linktable2.png","modified":0,"renderable":0},{"_id":"source/images/linktable3.png","path":"images/linktable3.png","modified":0,"renderable":0},{"_id":"source/images/linux-logo.jpg","path":"images/linux-logo.jpg","modified":0,"renderable":0},{"_id":"source/images/linktable5.png","path":"images/linktable5.png","modified":0,"renderable":0},{"_id":"source/images/linktable4.png","path":"images/linktable4.png","modified":0,"renderable":0},{"_id":"source/images/map1.png","path":"images/map1.png","modified":0,"renderable":0},{"_id":"source/images/mapperxml.png","path":"images/mapperxml.png","modified":0,"renderable":0},{"_id":"source/images/math1.png","path":"images/math1.png","modified":0,"renderable":0},{"_id":"source/images/math3.png","path":"images/math3.png","modified":0,"renderable":0},{"_id":"source/images/math2.png","path":"images/math2.png","modified":0,"renderable":0},{"_id":"source/images/math4.png","path":"images/math4.png","modified":0,"renderable":0},{"_id":"source/images/math5.png","path":"images/math5.png","modified":0,"renderable":0},{"_id":"source/images/math6.png","path":"images/math6.png","modified":0,"renderable":0},{"_id":"source/images/mybatis_logo.jpg","path":"images/mybatis_logo.jpg","modified":0,"renderable":0},{"_id":"source/images/nginx.jpg","path":"images/nginx.jpg","modified":0,"renderable":0},{"_id":"source/images/nginx4.png","path":"images/nginx4.png","modified":0,"renderable":0},{"_id":"source/images/nginx5.png","path":"images/nginx5.png","modified":0,"renderable":0},{"_id":"source/images/nginx6.png","path":"images/nginx6.png","modified":0,"renderable":0},{"_id":"source/images/nginx7.png","path":"images/nginx7.png","modified":0,"renderable":0},{"_id":"source/images/redis1.jpg","path":"images/redis1.jpg","modified":0,"renderable":0},{"_id":"source/images/redis-logo.png","path":"images/redis-logo.png","modified":0,"renderable":0},{"_id":"source/images/redis10.png","path":"images/redis10.png","modified":0,"renderable":0},{"_id":"source/images/redis17.png","path":"images/redis17.png","modified":0,"renderable":0},{"_id":"source/images/redis18.png","path":"images/redis18.png","modified":0,"renderable":0},{"_id":"source/images/redis19.png","path":"images/redis19.png","modified":0,"renderable":0},{"_id":"source/images/redis2.jpg","path":"images/redis2.jpg","modified":0,"renderable":0},{"_id":"source/images/redis22.png","path":"images/redis22.png","modified":0,"renderable":0},{"_id":"source/images/redis23.png","path":"images/redis23.png","modified":0,"renderable":0},{"_id":"source/images/redis3.jpg","path":"images/redis3.jpg","modified":0,"renderable":0},{"_id":"source/images/redis4.jpg","path":"images/redis4.jpg","modified":0,"renderable":0},{"_id":"source/images/redis5.jpg","path":"images/redis5.jpg","modified":0,"renderable":0},{"_id":"source/images/redis6.jpg","path":"images/redis6.jpg","modified":0,"renderable":0},{"_id":"source/images/redis9.png","path":"images/redis9.png","modified":0,"renderable":0},{"_id":"source/images/redis7.jpg","path":"images/redis7.jpg","modified":0,"renderable":0},{"_id":"source/images/redis8.png","path":"images/redis8.png","modified":0,"renderable":0},{"_id":"source/images/spring-framework.gif","path":"images/spring-framework.gif","modified":0,"renderable":0},{"_id":"source/images/shiro2.png","path":"images/shiro2.png","modified":0,"renderable":0},{"_id":"source/images/shiro1.png","path":"images/shiro1.png","modified":0,"renderable":0},{"_id":"source/images/spring_logo.jpg","path":"images/spring_logo.jpg","modified":0,"renderable":0},{"_id":"source/images/test.png","path":"images/test.png","modified":0,"renderable":0},{"_id":"source/images/stack.png","path":"images/stack.png","modified":0,"renderable":0},{"_id":"source/images/thread.png","path":"images/thread.png","modified":0,"renderable":0},{"_id":"source/images/vue10.png","path":"images/vue10.png","modified":0,"renderable":0},{"_id":"source/images/vue12.png","path":"images/vue12.png","modified":0,"renderable":0},{"_id":"source/images/vue13.png","path":"images/vue13.png","modified":0,"renderable":0},{"_id":"source/images/vue14.png","path":"images/vue14.png","modified":0,"renderable":0},{"_id":"source/images/vue18.png","path":"images/vue18.png","modified":0,"renderable":0},{"_id":"source/images/vue2.png","path":"images/vue2.png","modified":0,"renderable":0},{"_id":"source/images/vue3.png","path":"images/vue3.png","modified":0,"renderable":0},{"_id":"source/images/vue20.png","path":"images/vue20.png","modified":0,"renderable":0},{"_id":"source/images/vue4.png","path":"images/vue4.png","modified":0,"renderable":0},{"_id":"source/images/vue5.png","path":"images/vue5.png","modified":0,"renderable":0},{"_id":"source/images/vue6.png","path":"images/vue6.png","modified":0,"renderable":0},{"_id":"source/images/vue8.png","path":"images/vue8.png","modified":0,"renderable":0},{"_id":"source/images/20180127210359151.png","path":"images/20180127210359151.png","modified":0,"renderable":0},{"_id":"source/images/2.png","path":"images/2.png","modified":0,"renderable":0},{"_id":"source/images/3.png","path":"images/3.png","modified":0,"renderable":0},{"_id":"source/images/author.png","path":"images/author.png","modified":0,"renderable":0},{"_id":"source/images/author.jpg","path":"images/author.jpg","modified":0,"renderable":0},{"_id":"source/images/classloader.png","path":"images/classloader.png","modified":0,"renderable":0},{"_id":"source/images/docker2.png","path":"images/docker2.png","modified":0,"renderable":0},{"_id":"source/images/docker5.png","path":"images/docker5.png","modified":0,"renderable":0},{"_id":"source/images/hash1.png","path":"images/hash1.png","modified":0,"renderable":0},{"_id":"source/images/io.png","path":"images/io.png","modified":0,"renderable":0},{"_id":"source/images/mybatis3.png","path":"images/mybatis3.png","modified":0,"renderable":0},{"_id":"source/images/mybatis1.png","path":"images/mybatis1.png","modified":0,"renderable":0},{"_id":"source/images/mybatisflow.png","path":"images/mybatisflow.png","modified":0,"renderable":0},{"_id":"source/images/nginx1.png","path":"images/nginx1.png","modified":0,"renderable":0},{"_id":"source/images/nginx3.png","path":"images/nginx3.png","modified":0,"renderable":0},{"_id":"source/images/redis11.png","path":"images/redis11.png","modified":0,"renderable":0},{"_id":"source/images/redis14.png","path":"images/redis14.png","modified":0,"renderable":0},{"_id":"source/images/redis15.png","path":"images/redis15.png","modified":0,"renderable":0},{"_id":"source/images/redis16.png","path":"images/redis16.png","modified":0,"renderable":0},{"_id":"source/images/spring-aop1.png","path":"images/spring-aop1.png","modified":0,"renderable":0},{"_id":"source/images/tcp1.png","path":"images/tcp1.png","modified":0,"renderable":0},{"_id":"source/images/vue11.png","path":"images/vue11.png","modified":0,"renderable":0},{"_id":"source/images/vue16.png","path":"images/vue16.png","modified":0,"renderable":0},{"_id":"source/images/vue15.png","path":"images/vue15.png","modified":0,"renderable":0},{"_id":"source/images/vue17.png","path":"images/vue17.png","modified":0,"renderable":0},{"_id":"source/images/vue7.png","path":"images/vue7.png","modified":0,"renderable":0},{"_id":"source/images/vue9.png","path":"images/vue9.png","modified":0,"renderable":0},{"_id":"source/images/execAfter.png","path":"images/execAfter.png","modified":0,"renderable":0},{"_id":"source/images/execAfter1.png","path":"images/execAfter1.png","modified":0,"renderable":0},{"_id":"source/images/execBefore.png","path":"images/execBefore.png","modified":0,"renderable":0},{"_id":"source/images/execResult2.png","path":"images/execResult2.png","modified":0,"renderable":0},{"_id":"source/images/kafka1.png","path":"images/kafka1.png","modified":0,"renderable":0},{"_id":"source/images/kafka2.png","path":"images/kafka2.png","modified":0,"renderable":0},{"_id":"source/images/redis12.png","path":"images/redis12.png","modified":0,"renderable":0},{"_id":"source/images/redis13.png","path":"images/redis13.png","modified":0,"renderable":0},{"_id":"source/images/spring-ioc1.png","path":"images/spring-ioc1.png","modified":0,"renderable":0},{"_id":"source/images/spring-ioc2.png","path":"images/spring-ioc2.png","modified":0,"renderable":0},{"_id":"source/images/execResult1.png","path":"images/execResult1.png","modified":0,"renderable":0},{"_id":"source/images/nginx2.png","path":"images/nginx2.png","modified":0,"renderable":0},{"_id":"source/images/redis21.png","path":"images/redis21.png","modified":0,"renderable":0},{"_id":"source/images/vue19.png","path":"images/vue19.png","modified":0,"renderable":0},{"_id":"source/images/thread2.png","path":"images/thread2.png","modified":0,"renderable":0},{"_id":"source/images/docker7.png","path":"images/docker7.png","modified":0,"renderable":0},{"_id":"source/images/mybatis4.png","path":"images/mybatis4.png","modified":0,"renderable":0},{"_id":"source/images/1.png","path":"images/1.png","modified":0,"renderable":0},{"_id":"source/images/mybatis2.png","path":"images/mybatis2.png","modified":0,"renderable":0},{"_id":"source/images/redis20.png","path":"images/redis20.png","modified":0,"renderable":0},{"_id":"source/images/testResult.png","path":"images/testResult.png","modified":0,"renderable":0},{"_id":"source/images/vue1.png","path":"images/vue1.png","modified":0,"renderable":0},{"_id":"source/images/table.png","path":"images/table.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/apple-touch-icon.png","path":"img/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/post.js","path":"js/post.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/anchor/anchor.min.js","path":"lib/anchor/anchor.min.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/fancybox/jquery.fancybox.min.css","path":"lib/fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/popper/popper.min.js","path":"lib/popper/popper.min.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/prettify/prettify.min.js","path":"lib/prettify/prettify.min.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/github-markdown/github-markdown.min.css","path":"lib/github-markdown/github-markdown.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/katex/katex.min.css","path":"lib/katex/katex.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/prettify/github-v2.min.css","path":"lib/prettify/github-v2.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/smoothscroll/SmoothScroll.min.js","path":"lib/smoothscroll/SmoothScroll.min.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/prettify/tomorrow-night-eighties.min.css","path":"lib/prettify/tomorrow-night-eighties.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/tocbot/tocbot.min.js","path":"lib/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/typed/typed.min.js","path":"lib/typed/typed.min.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/prettify/tomorrow-night.min.css","path":"lib/prettify/tomorrow-night.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/prettify/tomorrow.min.css","path":"lib/prettify/tomorrow.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/fancybox/jquery.fancybox.min.js","path":"lib/fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/bootstrap/js/bootstrap.min.js","path":"lib/bootstrap/js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.eot","path":"lib/font-awesome/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.woff","path":"lib/font-awesome/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.woff","path":"lib/font-awesome/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.woff","path":"lib/font-awesome/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.eot","path":"lib/font-awesome/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.svg","path":"lib/font-awesome/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.woff2","path":"lib/mdbootstrap/font/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.eot","path":"lib/mdbootstrap/font/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.woff","path":"lib/mdbootstrap/font/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.woff2","path":"lib/mdbootstrap/font/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.eot","path":"lib/mdbootstrap/font/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.woff","path":"lib/mdbootstrap/font/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.eot","path":"lib/mdbootstrap/font/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.woff2","path":"lib/mdbootstrap/font/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.woff","path":"lib/mdbootstrap/font/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.eot","path":"lib/mdbootstrap/font/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.woff2","path":"lib/mdbootstrap/font/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.woff","path":"lib/mdbootstrap/font/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.woff2","path":"lib/mdbootstrap/font/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.eot","path":"lib/font-awesome/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.eot","path":"lib/mdbootstrap/font/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.ttf","path":"lib/mdbootstrap/font/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.woff","path":"lib/mdbootstrap/font/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.ttf","path":"lib/mdbootstrap/font/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.ttf","path":"lib/mdbootstrap/font/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.ttf","path":"lib/mdbootstrap/font/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/js/mdb.min.js","path":"lib/mdbootstrap/js/mdb.min.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/bootstrap/css/bootstrap.min.css","path":"lib/bootstrap/css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/css/mdb.min.css","path":"lib/mdbootstrap/css/mdb.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.ttf","path":"lib/mdbootstrap/font/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.svg","path":"lib/font-awesome/webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.svg","path":"lib/font-awesome/webfonts/fa-solid-900.svg","modified":0,"renderable":1},{"_id":"source/images/banner.jpg","path":"images/banner.jpg","modified":0,"renderable":0},{"_id":"source/images/post_banner.jpg","path":"images/post_banner.jpg","modified":0,"renderable":0},{"_id":"source/images/moon.jpg","path":"images/moon.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"themes/next7/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1582375466669},{"_id":"themes/next7/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1582375466669},{"_id":"themes/next7/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1582375466669},{"_id":"themes/next7/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1582375466671},{"_id":"themes/next7/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1582375466671},{"_id":"themes/next7/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1582375466671},{"_id":"themes/next7/README.md","hash":"d3035c6961280c1b4afb3a07661f5a635ce1eaff","modified":1582375466672},{"_id":"themes/next7/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1582375466671},{"_id":"themes/next7/_config.yml","hash":"b76ca42be831a3f8de1d892e6b9301fd9c153cf4","modified":1582376835922},{"_id":"themes/next7/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1582375466672},{"_id":"themes/next7/gulpfile.js","hash":"72e6d5a6e32d5f95d82e4c4d0c963d39555bb760","modified":1582375466676},{"_id":"themes/next7/package.json","hash":"42cadbbe64ebbc2ddf55854f9b61d28289ae9380","modified":1582375466687},{"_id":"source/.DS_Store","hash":"3d1d98d969df3a58a08c88e8eac9f3a36609be0f","modified":1582380163108},{"_id":"themes/next7/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1582375466669},{"_id":"themes/next7/.github/CONTRIBUTING.md","hash":"1b87a7d22d466d78856900bd94875944181c991a","modified":1582375466670},{"_id":"themes/next7/.github/PULL_REQUEST_TEMPLATE.md","hash":"715dcf9b0429a4a4c7107d6d1d00a34e4cf9aa99","modified":1582375466670},{"_id":"themes/next7/.github/config.yml","hash":"e4f4b9afe59bc508c4f7634895b33d7d460a7cb1","modified":1582375466670},{"_id":"themes/next7/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1582375466670},{"_id":"themes/next7/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1582375466671},{"_id":"themes/next7/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1582375466671},{"_id":"themes/next7/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1582375466671},{"_id":"themes/next7/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1582375466671},{"_id":"themes/next7/.github/stale.yml","hash":"941209526c2f7d916c76163c9e1ac1af9d956679","modified":1582375466671},{"_id":"themes/next7/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1582375466671},{"_id":"themes/next7/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1582375466672},{"_id":"themes/next7/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1582375466673},{"_id":"themes/next7/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1582375466673},{"_id":"themes/next7/docs/DATA-FILES.md","hash":"40a8089076005e0d26ef7c0db58a2b5b464cda6c","modified":1582375466673},{"_id":"themes/next7/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1582375466673},{"_id":"themes/next7/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"08cda41b4bcf687facfda19ab39718ec7a05ae54","modified":1582375466673},{"_id":"themes/next7/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1582375466673},{"_id":"themes/next7/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1582375466674},{"_id":"themes/next7/docs/UPDATE-FROM-5.1.X.md","hash":"682937d48bf5d243842a76190921322e26c75247","modified":1582375466674},{"_id":"themes/next7/languages/de.yml","hash":"109943f7adcd5cdbe4c6c95c9d279603f07edacb","modified":1582375466676},{"_id":"themes/next7/languages/default.yml","hash":"20f951dc4df8602ffdd05a1d5899c5a9bc1759cc","modified":1582375466676},{"_id":"themes/next7/languages/en.yml","hash":"20f951dc4df8602ffdd05a1d5899c5a9bc1759cc","modified":1582375466676},{"_id":"themes/next7/languages/es.yml","hash":"53ef4a621fd628748b8ed711fe86080e9c9c91c8","modified":1582375466676},{"_id":"themes/next7/languages/fa.yml","hash":"a24e0cf28e9f137d0d2219498778693c3c3960b2","modified":1582375466676},{"_id":"themes/next7/languages/fr.yml","hash":"578a30a51b9ecbbcb4c200362ad9a37ffd3272db","modified":1582375466676},{"_id":"themes/next7/languages/hu.yml","hash":"074d069af9aed5ad34fa809bd058a3b9e2d01051","modified":1582375466677},{"_id":"themes/next7/languages/id.yml","hash":"6037450ecd02796e08ca2e98037845b7c30c2807","modified":1582375466677},{"_id":"themes/next7/languages/it.yml","hash":"ba2c8f51f2f719dabe71b6053c6fe6866161ec66","modified":1582375466677},{"_id":"themes/next7/languages/ja.yml","hash":"5e13b521201944815665bd077b65d7ce69622b81","modified":1582375466677},{"_id":"themes/next7/languages/ko.yml","hash":"4aa8f3bf06e02879863b19901476cb23ecd2d709","modified":1582375466677},{"_id":"themes/next7/languages/nl.yml","hash":"e27b29c60d88ef4c30de291b595cf8cad639c5d1","modified":1582375466677},{"_id":"themes/next7/languages/pt-BR.yml","hash":"0660471e067d01ec80962d5721ae282aafff274d","modified":1582375466677},{"_id":"themes/next7/languages/pt.yml","hash":"f7516b9d86b52c80bf63d3efc7ee6fd985205001","modified":1582375466677},{"_id":"themes/next7/languages/ru.yml","hash":"7dcb2aab65a4b202476856f3e004862334229bcb","modified":1582375466677},{"_id":"themes/next7/languages/tr.yml","hash":"145d28f6f051129dc6393affe8f68cd7ba925078","modified":1582375466678},{"_id":"themes/next7/languages/uk.yml","hash":"21a573cdf8e26d87d5e32c5555bc645983268abe","modified":1582375466678},{"_id":"themes/next7/languages/vi.yml","hash":"ffc144f606e171fdd8cdb41808ac36e406015a54","modified":1582375466678},{"_id":"themes/next7/languages/zh-CN.yml","hash":"038c3a650d2e3a288be9ba6580564172c50b4289","modified":1582375466678},{"_id":"themes/next7/languages/zh-HK.yml","hash":"2620632caa3c94022d9513ab1971d15512e737e7","modified":1582375466678},{"_id":"themes/next7/languages/zh-TW.yml","hash":"0964e90406bbd495e901d6b9d5f10124c8cad950","modified":1582375466678},{"_id":"themes/next7/layout/_layout.swig","hash":"29ee038b0d5ffdb45327598733ea968588367769","modified":1582375466678},{"_id":"themes/next7/layout/archive.swig","hash":"26526c09a4334099e2141456697696fcd1f9783f","modified":1582375466686},{"_id":"themes/next7/layout/category.swig","hash":"c55debb2588e4746b02d31ec249bf0a84fdea260","modified":1582375466686},{"_id":"themes/next7/layout/index.swig","hash":"3bc6fb1e9707d74b96e1346d3f03fe6584f764f4","modified":1582375466686},{"_id":"themes/next7/layout/page.swig","hash":"e61d64c055b6497a04affc143f47fdd0a6dc495b","modified":1582375466687},{"_id":"themes/next7/layout/post.swig","hash":"382d9f9a9b35e1f369585f7f9f9b5dd6fa58d2f0","modified":1582375466687},{"_id":"themes/next7/layout/tag.swig","hash":"7ff6e34d557a3da1c6a29ecd97842bf73ff213dc","modified":1582375466687},{"_id":"themes/next7/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1582375466689},{"_id":"source/_posts/.DS_Store","hash":"7a30ea39d58eae8685f381f73081d818bc39514c","modified":1582304129979},{"_id":"source/_posts/Algorithm.md","hash":"691ba15cac8ccd67e5393b289011a358238a9921","modified":1582298989781},{"_id":"source/_posts/JavaBasic1.md","hash":"801efee8d39b7c3f544406d8651b872b32e9c56b","modified":1582298864892},{"_id":"source/_posts/JavaBasic2.md","hash":"61c6e45ed40a8baecb03a3206efe677fc444f2de","modified":1582298880037},{"_id":"source/_posts/Mybatis-1.md","hash":"18682fea679bc40eed9144655a589adf2ec74572","modified":1582299046063},{"_id":"source/_posts/Mybatis-2.md","hash":"38c6167821bb280cc86ad9dd2a22b32e65f3d098","modified":1582299059665},{"_id":"source/_posts/Shiro.md","hash":"72b14a970d8fdd7b543a9acf6c314c97e17961a0","modified":1582299034320},{"_id":"source/_posts/Mybatis-3.md","hash":"5f469299e43e37ebdcdd2f94359b620b54a2400e","modified":1582299074115},{"_id":"source/_posts/Spring-1.md","hash":"dfd6dfedb8f99f925159e08bece6301d332af63e","modified":1582299091345},{"_id":"source/_posts/Spring-3.md","hash":"370175f762776a6d72a3ef421e078faf90bf93a2","modified":1582302965264},{"_id":"source/_posts/Vue2.md","hash":"b12790ad0a7d48ea224f6430a3ae06ef309e4245","modified":1582298925145},{"_id":"source/_posts/Vue1.md","hash":"c4963a5e65769895591df5d0563e11d1a4ec0f70","modified":1582298895936},{"_id":"source/_posts/Vue3.md","hash":"2ef95ef816748aa2f7f4444880f8600d54415dbc","modified":1582298936290},{"_id":"source/_posts/docker.md","hash":"3084b041432ef3732539e01a861fff93190ccc40","modified":1582299132616},{"_id":"source/_posts/Vue4.md","hash":"d20d7725a56290894bea991a094d98769b885f6d","modified":1582298953307},{"_id":"source/_posts/interview.md","hash":"f4797f674b96b94381c382e90868f048f810271b","modified":1582120692461},{"_id":"source/_posts/redis-2.md","hash":"f831344a5ba0009b5cd4a85fad9a27d2e18c2c15","modified":1582305307351},{"_id":"source/_posts/nginx.md","hash":"0ef3051df4ccaffa0be599b0585dc28e383a01d5","modified":1582299141607},{"_id":"source/_posts/linux-1.md","hash":"277072f52ef33fb5687bf612d818505d863f2976","modified":1582367421270},{"_id":"source/about/index.md","hash":"901b85ca4e68679ec7dec29395e24cdd803c59f5","modified":1582375233847},{"_id":"source/_posts/redis-1.md","hash":"d61ef832951902d184327001091427ebc214d817","modified":1582310158898},{"_id":"source/about/.DS_Store","hash":"a906525de297e8b40766c156e6b9aa874c5ffa79","modified":1577240720589},{"_id":"source/tags/index.md","hash":"10386ed21a0554d390c73e5425d86f146fe2bd24","modified":1577254440531},{"_id":"source/categories/index.md","hash":"e9e615282832f88d8f4750494baa0cb0e8b3e023","modified":1577254032125},{"_id":"source/images/.DS_Store","hash":"1202a02cb4fbcf5ae147f90c85a59cddcf7face3","modified":1582379680686},{"_id":"source/images/DomaticBind.png","hash":"cd7fbcd97376eafbb224edcadb690799f45c645c","modified":1578304386792},{"_id":"source/images/String1.png","hash":"afc6a1eaabbf745686d9da1572fd7bbb842dcb70","modified":1578303346593},{"_id":"source/images/docker1.jpg","hash":"628a21017237112a5f7feee574f72dea656b3841","modified":1581598100933},{"_id":"source/images/deadlock.png","hash":"f63036ff0143e102534f0d1ce048060550b1dd59","modified":1582120541195},{"_id":"source/images/collection1.png","hash":"251da553598406e87c35a4545df30bd28040ccc8","modified":1582120447895},{"_id":"source/images/docker11.png","hash":"4cea5b5e07be39bcee4789978319fb85788bffc4","modified":1581599634777},{"_id":"source/images/docker10.png","hash":"befdb1c56f60e3b2ffa67b71b630d27ee04f41e4","modified":1581599577083},{"_id":"source/images/docker4.png","hash":"449d813a8b5178812522d40b4a5650a54380ca18","modified":1581598431432},{"_id":"source/images/docker3.png","hash":"158912be97e1f2d0f9595c1f6aa145813b587514","modified":1581598360072},{"_id":"source/images/docker12.png","hash":"417444a09b3a2e3cafbcc98f64ccb060958553c3","modified":1581599685124},{"_id":"source/images/docker8.png","hash":"56f2b058f83002486d4b578da9b7d818805e34c0","modified":1581599134641},{"_id":"source/images/docker6.png","hash":"99ce88799bbf1cd4e015c0247fdc55a032a349e6","modified":1581598705015},{"_id":"source/images/docker9.png","hash":"4bd8bc4b09fc496e469d47ed6aefd4f79ea4c4cd","modified":1581599477205},{"_id":"source/images/linktable1.png","hash":"799f768ef51935977174ab61543974a2cf4957c6","modified":1582120315324},{"_id":"source/images/linktable2.png","hash":"cc2302e52f3549196f2caafdc823ec4ddf3162a4","modified":1582120323634},{"_id":"source/images/linktable3.png","hash":"b3168918169491d4e19c1aa576eac5f11879f266","modified":1582120332118},{"_id":"source/images/linux-logo.jpg","hash":"b9a177128e177f8c1420c1a85d4d268f87c6d419","modified":1582364433601},{"_id":"source/images/linktable5.png","hash":"38daf65690e672c070846a9a640499bed3a05abc","modified":1582120346452},{"_id":"source/images/linktable4.png","hash":"7b846bc3e54e7c273c9c6000336fea66be4dd279","modified":1582120338725},{"_id":"source/images/map1.png","hash":"aa910ebab66ef6b17d29d83b09d5bedc1147b2f5","modified":1582120468215},{"_id":"source/images/mapperxml.png","hash":"9db12bf3362ac599f886a4979465ab915f8b6c9f","modified":1578042997488},{"_id":"source/images/math1.png","hash":"9023ce7c386de5e4abe501f3dabf6013af3ef498","modified":1581600900957},{"_id":"source/images/math3.png","hash":"2a6b8d224b29ed2c849776407eac0582ab9dba81","modified":1581600995243},{"_id":"source/images/math2.png","hash":"954e9b2a96f29c57d796079bb36c4472bef50bb2","modified":1581600941494},{"_id":"source/images/math4.png","hash":"f21a91d19bc95288730e51bf954219005284d9cb","modified":1581601064769},{"_id":"source/images/math5.png","hash":"b2e9e14a79694d16eed2306fc4f93e7bf713c23f","modified":1581601156029},{"_id":"source/images/math6.png","hash":"a766c724efbfd152b5c477b433d162b5b7b0f6e1","modified":1581601320511},{"_id":"source/images/mybatis_logo.jpg","hash":"a14d5a370c21eda0d193b0ac46637e1db1b8c1de","modified":1582292551922},{"_id":"source/images/nginx.jpg","hash":"12ca2e6ca8e2be48c2060f61206229779ffbfcd1","modified":1581582372109},{"_id":"source/images/nginx4.png","hash":"3af3072995184f63d0a75324c02527c3e6544538","modified":1581583067456},{"_id":"source/images/nginx5.png","hash":"43a76b61becc6afdd23acb3d88177e3a03366be7","modified":1581583589558},{"_id":"source/images/nginx6.png","hash":"491b705deb7b8dcb8adb048e5a42f1c4da4b31dc","modified":1581583638130},{"_id":"source/images/nginx7.png","hash":"c17dc449825991fa932065f3b5673b7bf45d947f","modified":1581583796488},{"_id":"source/images/redis1.jpg","hash":"ac6a6a25cea2e0cdc1092139527b41ba1513f3ca","modified":1582304648540},{"_id":"source/images/redis-logo.png","hash":"f6185b68d1d1c2a4ae92226da2bc21b158b79e98","modified":1582305136049},{"_id":"source/images/redis10.png","hash":"19fa7769b36f6fab9565ba9ff4e10ec5058e24c1","modified":1582305850888},{"_id":"source/images/redis17.png","hash":"435da22ed6455c0e66a9ade31126c23baec7b66d","modified":1582307912629},{"_id":"source/images/redis18.png","hash":"80596d2905d7426d022bd20e46e0448bded47736","modified":1582308112440},{"_id":"source/images/redis19.png","hash":"69333348bad01f5c5d1fc911da6e7c311d8d9919","modified":1582308850196},{"_id":"source/images/redis2.jpg","hash":"5a06f30a426b38d18618963344b79f255ea5ba3b","modified":1582304704204},{"_id":"source/images/redis22.png","hash":"51c015fc546b616450f456e62e2316f8071e5680","modified":1582309451220},{"_id":"source/images/redis23.png","hash":"fdebc86324b5470cf27d11433d49d12fc6302ed4","modified":1582309724455},{"_id":"source/images/redis3.jpg","hash":"d6a73c9470f5c7e6c5ce25eb5377f9d9dac0e726","modified":1582304784117},{"_id":"source/images/redis4.jpg","hash":"1654796182534cafd587319995b13532eed1f262","modified":1582304795307},{"_id":"source/images/redis5.jpg","hash":"2581e6e9ba57b3dbf439ef11e78da9ce4763723d","modified":1582304867179},{"_id":"source/images/redis6.jpg","hash":"33a53f014b745da6240577adf7c533d47beec752","modified":1582304916789},{"_id":"source/images/redis9.png","hash":"698fe81f8ed82b59cd7262c53cce4c79f25f027f","modified":1582305774568},{"_id":"source/images/redis7.jpg","hash":"b290e8a960d2f687ffb4704f513237bf2db8b129","modified":1582304923566},{"_id":"source/images/redis8.png","hash":"dd584640e4e144b36f259c2d8ff97689667b0ee9","modified":1582305721178},{"_id":"source/images/spring-framework.gif","hash":"5f1a7c0074b3b32ae14a325face291bfc3905fd7","modified":1582293868088},{"_id":"source/images/shiro2.png","hash":"4f6181f77ddcb81619083bf96f57e85d80b39977","modified":1578646168070},{"_id":"source/images/shiro1.png","hash":"5dcb3a6002f3005145da796cd6926a14f0358187","modified":1578646110972},{"_id":"source/images/spring_logo.jpg","hash":"a8bd6127c10707f58e8e7f556cc14d1e1ff019d3","modified":1582292630977},{"_id":"source/images/test.png","hash":"2b4606ba3e36b0bb37dd46cdaf830fb48d43c217","modified":1578043236266},{"_id":"source/images/stack.png","hash":"44730d0212fada434d90c74a9d91a9e8f882962b","modified":1578303662507},{"_id":"source/images/thread.png","hash":"5090d556fba9f989a8b5ad133337c6ddc208deda","modified":1582119335355},{"_id":"source/images/vue10.png","hash":"959a24b034047afbb9e3bedfaa61bb834cb3e293","modified":1581445616834},{"_id":"source/images/vue12.png","hash":"c8e384250b702b349e88c87607d2f37863b93d88","modified":1581445663420},{"_id":"source/images/vue13.png","hash":"ae29ca656a3450f70ae96f806df23efa9a7b7ad7","modified":1581445712424},{"_id":"source/images/vue14.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1581445747924},{"_id":"source/images/vue18.png","hash":"a3230a1e0c1d945d96f132356b66b042342dce47","modified":1581487273706},{"_id":"source/images/vue2.png","hash":"243d7ccf2b2a0162218d269f2ae5c9a0ba7a0229","modified":1578278602307},{"_id":"source/images/vue3.png","hash":"0891de9363a546dd806f5e5fe837d3082a27565b","modified":1578278655753},{"_id":"source/images/vue20.png","hash":"794fc3e74e23a5b18bd3c19a9347d2f699798a05","modified":1581487433952},{"_id":"source/images/vue4.png","hash":"1f7e4ea318bc779b25bf441aef2d7f257f4363cb","modified":1578278769965},{"_id":"source/images/vue5.png","hash":"c83cb6f0dac95e114a5b2707452ace8ea4ff034e","modified":1578278922750},{"_id":"source/images/vue6.png","hash":"7f16bda0e86a7497ad8cf8b151061f4a0e83bbac","modified":1578279674830},{"_id":"source/images/vue8.png","hash":"a5dd7b68dd393143acedbfab8198a731b16490c5","modified":1581445514204},{"_id":"source/_posts/Spring-2.md","hash":"f8984d1f62521a995c45fc1f30146e23f47ea2f0","modified":1582299099005},{"_id":"source/images/20180127210359151.png","hash":"b328ce766e5d959221b06df896ae2d2559e961ac","modified":1577705348278},{"_id":"source/images/2.png","hash":"813b2e528a9395cdd427da48a5ce2a0d3b830a6c","modified":1578041694100},{"_id":"source/images/3.png","hash":"2aa599677842864f1c5d006393a7cd8bb44ea174","modified":1578041708744},{"_id":"source/images/author.png","hash":"f21db080ce6a437b2e60d179015889f6e0831b05","modified":1581443959012},{"_id":"source/images/author.jpg","hash":"bf13ddca01c2e6aec062848c81aa256f3a45c8b9","modified":1577255793277},{"_id":"source/images/classloader.png","hash":"4ca131fc56c4bc60ad5ed33d3f2448d343b17ad0","modified":1582119619966},{"_id":"source/images/docker2.png","hash":"dd3fc1cf3a2b234253cc58fe9ac5cf122552ea34","modified":1581598284331},{"_id":"source/images/docker5.png","hash":"29d91a9acd947ef4fbec7bdcce1c7519843f9841","modified":1581598670318},{"_id":"source/images/hash1.png","hash":"d00e6d851a6a0ff456541d5dcfdecf1a23ae37c5","modified":1582120381557},{"_id":"source/images/io.png","hash":"b328ce766e5d959221b06df896ae2d2559e961ac","modified":1582120199110},{"_id":"source/images/mybatis3.png","hash":"e7f90ca5a3f2ffe5592d98e481ccb4fdb2234562","modified":1581534069883},{"_id":"source/images/mybatis1.png","hash":"9a838351c61a62fe8132028bdfd29f6b275ab109","modified":1581530502928},{"_id":"source/images/mybatisflow.png","hash":"09ce0b986c5ed5aae38f7f927ed48323de41d05d","modified":1582119054786},{"_id":"source/images/nginx1.png","hash":"080a8c25ed0010ce129754e6dd87459ffdeedfba","modified":1581582827546},{"_id":"source/images/nginx3.png","hash":"e43356b41a6bc6349ecb16fa9ad72e7b9b366adc","modified":1581582955669},{"_id":"source/images/redis11.png","hash":"118b8703966ef0e7e5a6f43255d4360565776e05","modified":1582306308251},{"_id":"source/images/redis14.png","hash":"c8d8be3b6de877eebb5a71da5d3bb55eba9943b4","modified":1582307465428},{"_id":"source/images/redis15.png","hash":"d239aa4fe120cc9d393ac913a0a6e133cf1aa39f","modified":1582307543006},{"_id":"source/images/redis16.png","hash":"4cbe86bb02c82cb62c03b25d2fcb288273aae589","modified":1582307594097},{"_id":"source/images/spring-aop1.png","hash":"f1c3fa28aee06f181d42e0571a3d04f6f0add386","modified":1582299818544},{"_id":"source/images/tcp1.png","hash":"895c8be763dbd2d0dd9d9646e3b189cad241a583","modified":1582118147167},{"_id":"source/images/vue11.png","hash":"a02aac351c4547ec35ce456b4aa5268039ec0847","modified":1581445657708},{"_id":"source/images/vue16.png","hash":"440b1133fee7a0d9d426531a5c1ce04688bf79bd","modified":1581487107038},{"_id":"source/images/vue15.png","hash":"79ff3d090e6b1bb59a49dcf486655fb8ac69e704","modified":1581486670116},{"_id":"source/images/vue17.png","hash":"9d0b9d78d7a427499e03f847034942c5e2e53ead","modified":1581487119308},{"_id":"themes/next7/.github/ISSUE_TEMPLATE/bug-report.md","hash":"8ae029084b9ac482adf0fae2a0979dd388476513","modified":1582375466670},{"_id":"themes/next7/.github/ISSUE_TEMPLATE/feature-request.md","hash":"7a9526f749205c882d672a4f51e6a3033c80ca6e","modified":1582375466670},{"_id":"source/images/vue7.png","hash":"7c8e016f4d64ab9982bd0fbe6876c9930ff69fe4","modified":1581445506029},{"_id":"themes/next7/.github/ISSUE_TEMPLATE/other.md","hash":"89667adbb85c25716dba607cd7a38191acf60736","modified":1582375466670},{"_id":"themes/next7/.github/ISSUE_TEMPLATE/question.md","hash":"789a3cceb8f37a4b63b1fb2452a03332a3c365ed","modified":1582375466670},{"_id":"source/images/vue9.png","hash":"10e13fa4ec6044c65691a4368fb88eaa018cf8f0","modified":1581445610061},{"_id":"themes/next7/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1582375466674},{"_id":"themes/next7/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1582375466674},{"_id":"themes/next7/docs/ru/README.md","hash":"2b3988e79d96b66640d6a98f0c0e6de9099805e6","modified":1582375466674},{"_id":"themes/next7/docs/ru/UPDATE-FROM-5.1.X.md","hash":"fe3f5cda1975114884d84bef384a562920d70335","modified":1582375466674},{"_id":"themes/next7/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1582375466675},{"_id":"themes/next7/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1582375466675},{"_id":"themes/next7/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1582375466675},{"_id":"themes/next7/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1582375466675},{"_id":"themes/next7/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1582375466675},{"_id":"themes/next7/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"0b0b9ec6ec4a89e701a3b91f8d7d95752d3e241b","modified":1582375466675},{"_id":"themes/next7/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1582375466676},{"_id":"themes/next7/docs/zh-CN/README.md","hash":"e5f6668c3a79e4a364931b9b4e5fa92f8c771ec8","modified":1582375466676},{"_id":"themes/next7/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"7f37327bbcae7ed7d04d187fd5e9bc6bbf14926a","modified":1582375466676},{"_id":"themes/next7/layout/_macro/post-collapse.swig","hash":"815676d904f92748ddf4f529bed2baf066997bc6","modified":1582375466678},{"_id":"themes/next7/layout/_macro/post.swig","hash":"a14b72e1507a770d6224943d7d86688aea0578cf","modified":1582375466679},{"_id":"themes/next7/layout/_macro/sidebar.swig","hash":"e2c9db54cc9e154e882008fde6588b065fadc9a7","modified":1582375466679},{"_id":"themes/next7/layout/_partials/comments.swig","hash":"0c4914a5fd08f15beec71940218c814ad9a89f3f","modified":1582375466679},{"_id":"themes/next7/layout/_partials/footer.swig","hash":"1ee6335c12773dc43f8b92136770cb10d460c25c","modified":1582375466679},{"_id":"themes/next7/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1582375466680},{"_id":"themes/next7/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1582375466682},{"_id":"themes/next7/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1582375466682},{"_id":"themes/next7/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1582375466682},{"_id":"themes/next7/layout/_scripts/pjax.swig","hash":"a3462c37ab6d7642b1e95860ea5c4cfbac78efab","modified":1582375466682},{"_id":"themes/next7/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1582375466683},{"_id":"themes/next7/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1582375466683},{"_id":"themes/next7/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1582375466684},{"_id":"themes/next7/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1582375466684},{"_id":"themes/next7/layout/_third-party/quicklink.swig","hash":"dd6bd817cb69b5ad5e9746498146314b54054ff8","modified":1582375466685},{"_id":"themes/next7/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1582375466685},{"_id":"themes/next7/scripts/events/index.js","hash":"9047d8ae2670e43429b16a7919a08a0a0a81afe0","modified":1582375466687},{"_id":"themes/next7/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1582375466688},{"_id":"themes/next7/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1582375466688},{"_id":"themes/next7/scripts/filters/locals.js","hash":"5bbfdc1c373542159660b7a68ed0b57ca18ad10b","modified":1582375466689},{"_id":"themes/next7/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1582375466689},{"_id":"themes/next7/scripts/filters/post.js","hash":"f2f566f2577c554377fd704442399acdd14a8118","modified":1582375466689},{"_id":"themes/next7/scripts/helpers/engine.js","hash":"cb211b6b50913454b1737782e9e2af96cfa40448","modified":1582375466689},{"_id":"themes/next7/scripts/helpers/font.js","hash":"32268fb4c59c5b37c1eb1c9582ab630e09e5cc7d","modified":1582375466689},{"_id":"themes/next7/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1582375466689},{"_id":"themes/next7/scripts/helpers/next-url.js","hash":"58347687b02f7ab5e64bef07525c8efa97c9e8fb","modified":1582375466689},{"_id":"themes/next7/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1582375466690},{"_id":"themes/next7/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1582375466690},{"_id":"themes/next7/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1582375466690},{"_id":"themes/next7/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1582375466690},{"_id":"themes/next7/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1582375466690},{"_id":"themes/next7/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1582375466690},{"_id":"themes/next7/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1582375466690},{"_id":"themes/next7/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1582375466690},{"_id":"themes/next7/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1582375466690},{"_id":"themes/next7/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1582375466691},{"_id":"themes/next7/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1582375466703},{"_id":"themes/next7/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1582375466703},{"_id":"themes/next7/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1582375466703},{"_id":"themes/next7/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1582375466703},{"_id":"themes/next7/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1582375466703},{"_id":"themes/next7/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1582375466704},{"_id":"themes/next7/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1582375466704},{"_id":"themes/next7/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1582375466704},{"_id":"themes/next7/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1582375466704},{"_id":"themes/next7/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1582375466704},{"_id":"themes/next7/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1582375466704},{"_id":"themes/next7/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1582375466704},{"_id":"themes/next7/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1582375466704},{"_id":"themes/next7/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1582375466704},{"_id":"themes/next7/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1582375466705},{"_id":"themes/next7/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1582375466705},{"_id":"themes/next7/source/js/algolia-search.js","hash":"f31a633c15391ce0095579735a479f3f92622eab","modified":1582375466705},{"_id":"themes/next7/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1582375466705},{"_id":"themes/next7/source/js/local-search.js","hash":"0d30f1c0e4d4a1cc26d494808f3f36132d06ae14","modified":1582375466705},{"_id":"themes/next7/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1582375466705},{"_id":"themes/next7/source/js/next-boot.js","hash":"f7045763e277e685c271bd4b4c37e531d699ac63","modified":1582375466705},{"_id":"themes/next7/source/js/utils.js","hash":"4faf7598289774fe091f33fa693b2e6b2ca1e994","modified":1582375466706},{"_id":"themes/next7/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1582375466706},{"_id":"source/images/execAfter.png","hash":"3278e77d428c21a8d1756a484e27ff2b9f3a69ac","modified":1581509836269},{"_id":"source/images/execAfter1.png","hash":"143420e95e363e944b40b011738903624f37d15c","modified":1581510250389},{"_id":"source/images/execBefore.png","hash":"8bcd5183e9d05152ef6cb9ae8b145f0213297d76","modified":1581509784635},{"_id":"source/images/execResult2.png","hash":"cd74a1f0dba76be0c09caf36f957411c73f72e05","modified":1581509355875},{"_id":"source/images/kafka1.png","hash":"8dfd3cae31730fad1ea02f3f2d07bfffaa96bb94","modified":1582117359335},{"_id":"source/images/kafka2.png","hash":"1b3ba1df82c5cd07680d211e8740403e6fa5263f","modified":1582117359173},{"_id":"source/images/redis12.png","hash":"61af62de36d91bb659b181b454c65d8a70643e3b","modified":1582306381808},{"_id":"source/images/redis13.png","hash":"5e580faad3222c6b681de2294398fa52c886e96d","modified":1582307208504},{"_id":"source/images/spring-ioc1.png","hash":"4ef7f43786dada656563c8d2f438a91eeea949c9","modified":1582295041452},{"_id":"source/images/spring-ioc2.png","hash":"9ff8769766331773b52bdbd98587c8907a18d46c","modified":1582295357252},{"_id":"themes/next7/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582375466700},{"_id":"themes/next7/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582375466700},{"_id":"source/images/execResult1.png","hash":"152abfa8b8106a1f96b5ac5e1ed504f09172ed19","modified":1581508509836},{"_id":"source/images/nginx2.png","hash":"41ac22d5b004275b0c494fc82c73d472b689f935","modified":1581582851298},{"_id":"source/images/redis21.png","hash":"43e27c147e57e29041764ff63a3625464e5af245","modified":1582309250691},{"_id":"source/images/vue19.png","hash":"29fb226b32c2c6556725a708caadec480ad5e796","modified":1581487426786},{"_id":"themes/next7/layout/_partials/head/head-unique.swig","hash":"1638483d2d2dad1da4c841a6fb9f6ee96b850187","modified":1582375466679},{"_id":"themes/next7/layout/_partials/head/head.swig","hash":"1ea12d4b9490d9065ebf1b8739b90ce5defd6398","modified":1582375466679},{"_id":"themes/next7/layout/_partials/header/brand.swig","hash":"6cd12613863c3fd7a10c6a81c84f57a770f96566","modified":1582375466679},{"_id":"themes/next7/layout/_partials/header/index.swig","hash":"30528a8da30994b1ef9355a72b09b2cd85a7c0e9","modified":1582375466680},{"_id":"themes/next7/layout/_partials/header/menu-item.swig","hash":"e6076865dba066c5f0008e22217efb850d5af69c","modified":1582375466680},{"_id":"themes/next7/layout/_partials/header/menu.swig","hash":"bbf0c8e42491fac70f4f8165224f1d7d92a040d7","modified":1582375466680},{"_id":"themes/next7/layout/_partials/header/sub-menu.swig","hash":"54ba9508a901c295a02c8e34e9cece7c7dcad518","modified":1582375466680},{"_id":"themes/next7/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1582375466680},{"_id":"themes/next7/layout/_partials/page/page-header.swig","hash":"a56e4f6ad95c106f361d354f828d1ef4810b1d76","modified":1582375466680},{"_id":"themes/next7/layout/_partials/post/post-copyright.swig","hash":"94d54b0c65d504f772af1e62424952e092b6c21d","modified":1582375466680},{"_id":"themes/next7/layout/_partials/post/post-followme.swig","hash":"14c33bd544903e74388739599fffe3ecb66ed4b0","modified":1582375466680},{"_id":"themes/next7/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1582375466681},{"_id":"themes/next7/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1582375466681},{"_id":"themes/next7/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1582375466681},{"_id":"themes/next7/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1582375466681},{"_id":"themes/next7/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1582375466681},{"_id":"themes/next7/layout/_partials/search/localsearch.swig","hash":"2791a8dc20a276704fc8b03f9822f76578a9152d","modified":1582375466681},{"_id":"themes/next7/layout/_partials/sidebar/site-overview.swig","hash":"716b78cd90addc4216413719554721cb362b0c18","modified":1582375466682},{"_id":"themes/next7/layout/_scripts/pages/schedule.swig","hash":"a2bb0bec243685e670b60a3d54142950adc03af0","modified":1582375466682},{"_id":"themes/next7/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1582375466682},{"_id":"themes/next7/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1582375466683},{"_id":"themes/next7/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1582375466683},{"_id":"themes/next7/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1582375466683},{"_id":"themes/next7/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1582375466683},{"_id":"themes/next7/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1582375466683},{"_id":"themes/next7/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1582375466683},{"_id":"themes/next7/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1582375466683},{"_id":"themes/next7/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1582375466684},{"_id":"themes/next7/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1582375466684},{"_id":"themes/next7/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1582375466684},{"_id":"themes/next7/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1582375466684},{"_id":"themes/next7/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1582375466684},{"_id":"themes/next7/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1582375466684},{"_id":"themes/next7/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1582375466684},{"_id":"themes/next7/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1582375466684},{"_id":"themes/next7/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1582375466685},{"_id":"themes/next7/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1582375466685},{"_id":"themes/next7/layout/_third-party/math/mathjax.swig","hash":"a18a9b52f58c7988c411a819518d8e7715e5fb92","modified":1582375466685},{"_id":"themes/next7/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1582375466685},{"_id":"themes/next7/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1582375466685},{"_id":"themes/next7/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1582375466685},{"_id":"themes/next7/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1582375466685},{"_id":"themes/next7/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1582375466686},{"_id":"themes/next7/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1582375466686},{"_id":"themes/next7/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1582375466686},{"_id":"themes/next7/layout/_third-party/statistics/lean-analytics.swig","hash":"a239f1558d1209012ce4571cbc665fe461291e41","modified":1582375466686},{"_id":"themes/next7/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1582375466686},{"_id":"themes/next7/layout/_third-party/tags/pdf.swig","hash":"529d752f269afcf8f64e07a1eacd6fda70fb211f","modified":1582375466686},{"_id":"themes/next7/scripts/events/lib/config.js","hash":"b205d72a56b1827681f0a260c266e0c02065fd08","modified":1582375466687},{"_id":"themes/next7/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1582375466687},{"_id":"themes/next7/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1582375466687},{"_id":"themes/next7/scripts/filters/comment/changyan.js","hash":"1f20213af8da3127701e6bb9da995e5c91be2051","modified":1582375466688},{"_id":"themes/next7/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1582375466688},{"_id":"themes/next7/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1582375466688},{"_id":"themes/next7/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1582375466688},{"_id":"themes/next7/scripts/filters/comment/disqus.js","hash":"19cbd24880d0fbbd4d5698cd54da598f03b942da","modified":1582375466688},{"_id":"themes/next7/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1582375466688},{"_id":"themes/next7/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1582375466688},{"_id":"themes/next7/scripts/filters/comment/valine.js","hash":"6a72b5928cdab9526a288177991e4b2aedd028cf","modified":1582375466688},{"_id":"themes/next7/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1582375466700},{"_id":"themes/next7/source/css/_mixins/Pisces.styl","hash":"644c1f0b02be9bf59955ebdf496136b3fa4b660b","modified":1582375466700},{"_id":"themes/next7/source/css/_mixins/base.styl","hash":"0a25f3df1b5c39794365efde387647da81da884a","modified":1582375466700},{"_id":"themes/next7/source/css/_variables/Gemini.styl","hash":"52550138127ae9ebbe049bcdacd94d767c003855","modified":1582375466702},{"_id":"themes/next7/source/css/_variables/Mist.styl","hash":"b9d7058db61df7bbd2b58779efe45621a06ffc18","modified":1582375466702},{"_id":"themes/next7/source/css/_variables/Muse.styl","hash":"c261d685c5ed0df34718d94bb2ba977c0ed443e6","modified":1582375466702},{"_id":"themes/next7/source/css/_variables/Pisces.styl","hash":"50bc57e66331c0f15a4527010b4ca3316ac92403","modified":1582375466703},{"_id":"themes/next7/source/css/_variables/base.styl","hash":"d4e817e2b238ace5d7ac568ce0c5380196a6d039","modified":1582375466703},{"_id":"themes/next7/source/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1582375466706},{"_id":"themes/next7/source/js/schemes/pisces.js","hash":"f068b46f8c305c7436c2767492a6bed42dcd764c","modified":1582375466706},{"_id":"themes/next7/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1582375466707},{"_id":"themes/next7/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1582375466707},{"_id":"themes/next7/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1582375466707},{"_id":"themes/next7/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1582375466707},{"_id":"themes/next7/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1582375466707},{"_id":"themes/next7/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1582375466710},{"_id":"themes/next7/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1582375466710},{"_id":"source/images/thread2.png","hash":"acd561fcd85184adfb9cd634f2698776f99f88cf","modified":1582120515756},{"_id":"source/images/docker7.png","hash":"a5925cf319047cf8e365b20e87adfb720fc83541","modified":1581598779300},{"_id":"source/images/mybatis4.png","hash":"24f9f9b58a7944de49211c1791486a4cdde52078","modified":1581534802028},{"_id":"themes/next7/source/css/_common/components/back-to-top-sidebar.styl","hash":"80d359661d08b80ad561b97f8508766b3e1f6d01","modified":1582375466691},{"_id":"themes/next7/source/css/_common/components/back-to-top.styl","hash":"47ee915d7b0a97e74140a25fbfc01c04d6781534","modified":1582375466691},{"_id":"themes/next7/source/css/_common/components/components.styl","hash":"112f5e8f1fe5cec4419e87acfbdef0e615ed23f3","modified":1582375466691},{"_id":"themes/next7/source/css/_common/components/rainbow.styl","hash":"bc87cea0b534f2d75db60f300b069456f6516d1b","modified":1582375466694},{"_id":"themes/next7/source/css/_common/components/reading-progress.styl","hash":"170c4598cbbe49cd1527f94158d97d2320a6b906","modified":1582375466694},{"_id":"themes/next7/source/css/_common/outline/mobile.styl","hash":"990bd301ce2de0a6b936781c58318f3945d81bc2","modified":1582375466695},{"_id":"themes/next7/source/css/_common/outline/outline.styl","hash":"44fe82eadbdbb2f66adda37ac83ebd0f85876bfc","modified":1582375466696},{"_id":"themes/next7/source/css/_common/scaffolding/base.styl","hash":"4f7879a50d4608c46cc2061c725a2564597a45bd","modified":1582375466697},{"_id":"themes/next7/source/css/_common/scaffolding/comments.styl","hash":"3faa8a7cdb05ef3f3b02920d381773dfd54270a5","modified":1582375466697},{"_id":"themes/next7/source/css/_common/scaffolding/buttons.styl","hash":"d8ba44b8e1a0332c5c1079ff65fc83d2918a5865","modified":1582375466697},{"_id":"themes/next7/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1582375466698},{"_id":"themes/next7/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1582375466698},{"_id":"themes/next7/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1582375466698},{"_id":"themes/next7/source/css/_common/scaffolding/tables.styl","hash":"8e1cc5e3b20d804a7265f945b877388bffee39eb","modified":1582375466699},{"_id":"themes/next7/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1582375466699},{"_id":"themes/next7/source/css/_schemes/Gemini/index.styl","hash":"1693ec6b53758ac15d2c7798c789d6ae8af913ea","modified":1582375466700},{"_id":"themes/next7/source/css/_schemes/Mist/_header.styl","hash":"adea92b504d436780c2792af0269f8b7835525f3","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Mist/_layout.styl","hash":"24a086a6904bbf5355a354403c9b0e6069f7eb01","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Mist/_menu.styl","hash":"3d52f762577afac1ab50390e555b069408370fe8","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Mist/_posts-expand.styl","hash":"e321bd62f5e04d1fdc101a470ec13604e99816a5","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Muse/_header.styl","hash":"3646e915b0a55f3b66e41d802b082aba88a76e06","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Muse/_menu.styl","hash":"a54662bd4cbbe316048a811d3b5c83fb6df63739","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Muse/_sidebar.styl","hash":"5ae608ce00ec2d7b9aa4ab2d8dfdf4a73422acc4","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1582375466701},{"_id":"themes/next7/source/css/_schemes/Pisces/_layout.styl","hash":"b797c693378d94160121a2b8d9df0622a76cdbda","modified":1582375466702},{"_id":"themes/next7/source/css/_schemes/Pisces/_header.styl","hash":"a406ecd03d2d3b0e160b44a42deeae1ed9aa6aa1","modified":1582375466702},{"_id":"themes/next7/source/css/_schemes/Pisces/_menu.styl","hash":"698f25ad68508450dd8a41f2732d2bab14f8d1fe","modified":1582375466702},{"_id":"themes/next7/source/css/_schemes/Pisces/_sidebar.styl","hash":"06098b8f8ea343c434c858207297a47c1275155a","modified":1582375466702},{"_id":"themes/next7/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0424a1fcffa1ae82fe70935972a894aca885bf9a","modified":1582375466702},{"_id":"themes/next7/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1582375466702},{"_id":"themes/next7/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1582375466707},{"_id":"themes/next7/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1582375466707},{"_id":"themes/next7/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1582375466708},{"_id":"source/images/1.png","hash":"dbaa036550e513533d58e64467adb126c6875146","modified":1578041671922},{"_id":"source/images/mybatis2.png","hash":"04e416309a5093ee57bac52260b01796d2762f12","modified":1581531864281},{"_id":"source/images/redis20.png","hash":"2578d9e883d2200bac7ec18e0c08decaa0c0dbc0","modified":1582308937410},{"_id":"source/images/testResult.png","hash":"051a44fb9aa93e5eb79b32057dc404dd47d6b1c0","modified":1581434083929},{"_id":"themes/next7/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1582375466709},{"_id":"themes/next7/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1582375466709},{"_id":"themes/next7/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1582375466691},{"_id":"themes/next7/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1582375466691},{"_id":"themes/next7/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1582375466691},{"_id":"themes/next7/source/css/_common/components/pages/schedule.styl","hash":"6336c2b129db802221b1fd75e5fbe8aab85c0a1f","modified":1582375466692},{"_id":"themes/next7/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1582375466692},{"_id":"themes/next7/source/css/_common/components/post/post-collapse.styl","hash":"af182c0d1e52f94280f6108936914f04ed541eee","modified":1582375466692},{"_id":"themes/next7/source/css/_common/components/post/post-copyright.styl","hash":"4b84f35e7040f9adb5cc540c366d7f9eb4c48bcc","modified":1582375466692},{"_id":"themes/next7/source/css/_common/components/post/post-eof.styl","hash":"e3ade812b5541eca5b863ad3ff234ea95925bf31","modified":1582375466692},{"_id":"themes/next7/source/css/_common/components/post/post-expand.styl","hash":"5d5c022aa3b2f89c2f2a178212338bb64804dd75","modified":1582375466692},{"_id":"themes/next7/source/css/_common/components/post/post-followme.styl","hash":"60ed14e9ddcb138837ca22efb8886f9bff2a3dd2","modified":1582375466693},{"_id":"themes/next7/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1582375466693},{"_id":"themes/next7/source/css/_common/components/post/post-header.styl","hash":"bcba503e956e4b737b062faa66341bd880f16c10","modified":1582375466693},{"_id":"themes/next7/source/css/_common/components/post/post-nav.styl","hash":"9df5ba77e6cf36129bddc270407215c23c60ff38","modified":1582375466693},{"_id":"themes/next7/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1582375466693},{"_id":"themes/next7/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1582375466693},{"_id":"themes/next7/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1582375466693},{"_id":"themes/next7/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1582375466693},{"_id":"themes/next7/source/css/_common/components/post/post.styl","hash":"c7939407797acbd1ae0d8bae8e13b2bf045f870e","modified":1582375466694},{"_id":"themes/next7/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1582375466694},{"_id":"themes/next7/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1582375466694},{"_id":"themes/next7/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1582375466694},{"_id":"themes/next7/source/css/_common/components/third-party/search.styl","hash":"418890a2041e4d623e235890951143d183df6f03","modified":1582375466694},{"_id":"themes/next7/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1582375466694},{"_id":"themes/next7/source/css/_common/outline/footer/footer.styl","hash":"f5821481440a0624c8aec5fc85f093de1527095f","modified":1582375466695},{"_id":"themes/next7/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1582375466695},{"_id":"themes/next7/source/css/_common/outline/header/github-banner.styl","hash":"0672ea2acf28dcc2cfc5244da36d3387d71a17cb","modified":1582375466695},{"_id":"themes/next7/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1582375466695},{"_id":"themes/next7/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1582375466695},{"_id":"themes/next7/source/css/_common/outline/header/menu.styl","hash":"d5d85d3646d184e0340924addcfd2523fb289d00","modified":1582375466695},{"_id":"themes/next7/source/css/_common/outline/header/site-meta.styl","hash":"9a418cadb160a11e7203a3964aef4149a54808a5","modified":1582375466695},{"_id":"themes/next7/source/css/_common/outline/header/site-nav.styl","hash":"c26c60317ae9c49ca55779ea89892db90cfbad2e","modified":1582375466695},{"_id":"themes/next7/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1582375466696},{"_id":"themes/next7/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"95339b71ac90553fb1634c536c9749055e0c788a","modified":1582375466696},{"_id":"themes/next7/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1582375466696},{"_id":"themes/next7/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"a237c290e8934d1a8cbbf22b3f30503d9663021d","modified":1582375466696},{"_id":"themes/next7/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1582375466696},{"_id":"themes/next7/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1582375466696},{"_id":"themes/next7/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"521534f483440434e808f92377bc3fc73667c89a","modified":1582375466696},{"_id":"themes/next7/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1582375466696},{"_id":"themes/next7/source/css/_common/outline/sidebar/sidebar.styl","hash":"f9796139bb7cb1d7e59c9c6726e2e063f7e33024","modified":1582375466697},{"_id":"themes/next7/source/css/_common/outline/sidebar/site-state.styl","hash":"9a18b186b08ec220d1b17cf83812bcdd06077814","modified":1582375466697},{"_id":"themes/next7/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"5e655bc1d9e213e466af2f8358725fdc668fe52d","modified":1582375466698},{"_id":"themes/next7/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1582375466698},{"_id":"themes/next7/source/css/_common/scaffolding/highlight/highlight.styl","hash":"b4923515ca8e44aa62e839ce948f759cfd1f896f","modified":1582375466698},{"_id":"themes/next7/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1582375466698},{"_id":"themes/next7/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1582375466699},{"_id":"themes/next7/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1582375466699},{"_id":"themes/next7/source/css/_common/scaffolding/tags/label.styl","hash":"5bf28a03ef021c27cfd713971caca5a0b9466fd1","modified":1582375466699},{"_id":"themes/next7/source/css/_common/scaffolding/tags/note.styl","hash":"1a14c1b92d8a4dd8aabb5949333ac0ac79094c6c","modified":1582375466699},{"_id":"themes/next7/source/css/_common/scaffolding/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1582375466699},{"_id":"themes/next7/source/css/_common/scaffolding/tags/tabs.styl","hash":"d2f0f2171722533bba308f944a2ec727b083582c","modified":1582375466699},{"_id":"themes/next7/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1582375466699},{"_id":"themes/next7/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1582375466709},{"_id":"source/images/vue1.png","hash":"3f8b94381119e0e93753bae326c2eb500f2333a0","modified":1578278367933},{"_id":"source/images/table.png","hash":"0a08748bb13db763c5977ea378124155c0d1cbd2","modified":1581433608572},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1577167056866},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1577167056866},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1577167056866},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1577167056867},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1577167056866},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1577167056867},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1577167056867},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1577167056867},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1577167056867},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1577167056867},{"_id":"themes/next/.DS_Store","hash":"db4c398833e0aa6ef7db70b3456d8e0215c476a6","modified":1582374091824},{"_id":"themes/next/README.cn.md","hash":"263b74f1ac7c0f6f9424b8cced4b0b320ae61efc","modified":1577167056867},{"_id":"themes/next/README.md","hash":"287c7e6b7a6ddf75d815dda0df8bd228e3f285c5","modified":1577167056867},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1577167056868},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1577167056868},{"_id":"themes/next/_config.yml","hash":"a1801591feef97ed59f1b563f843c9a0a8c0ef9f","modified":1582377576912},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1577167056884},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1577167056866},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1577167056866},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1577167056866},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1577167056866},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1577167056868},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1577167056868},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1577167056868},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1577167056868},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1577167056869},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1577167056869},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1577167056869},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1577167056869},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1577167056869},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1577167056869},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1577167056869},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1577167056869},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1577167056869},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1577167056869},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1577167056870},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f9f0ba24ffaa0028245de3da9525958d6715281c","modified":1577253520909},{"_id":"themes/next/layout/_layout.swig","hash":"c7a5f2e3749fb0b94b8b57d61526da646a5d8fbe","modified":1582303894938},{"_id":"themes/next/layout/.DS_Store","hash":"e96ed27615fc807b073712730e2db5e6b1d9bc62","modified":1582303887630},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1577167056878},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1577167056878},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1577167056878},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1577167056878},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1577167056878},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1577167056878},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1577167056885},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1577167056879},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1577167056886},{"_id":"themes/next/scripts/.DS_Store","hash":"c23e8992957e272a90ddbb470965ec82706443ce","modified":1578128439635},{"_id":"themes/next/source/.DS_Store","hash":"d4e7b64d8c8f03569ce05938c0ba4c73082bd698","modified":1582304056720},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1577167056940},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1577167056940},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1577167056940},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056905},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1577167056870},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1577167056870},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1577167056871},{"_id":"themes/next/layout/_custom/.DS_Store","hash":"11fd6ef763efb1f6094472b5bb7596ad645e7dec","modified":1582303892633},{"_id":"themes/next/layout/_partials/footer.swig","hash":"2b1aedc521b7cc12bf7a76a6cacfef781f453e3d","modified":1578046000214},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1577167056871},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1577167056872},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1577167056872},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1577167056872},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1577167056870},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1577167056871},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1577167056870},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1577167056871},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1577167056871},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1577167056873},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"98df9cd472f255a283e2c72002a4a4f4dc84eafc","modified":1581576098862},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1577167056873},{"_id":"themes/next/layout/_macro/post.swig","hash":"b152ca6819b5ab126e39ba0d087638206cec8ec4","modified":1578128920555},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1577167056874},{"_id":"themes/next/layout/_scripts/.DS_Store","hash":"137b2b33df29f70c89991676eaa273572ab43828","modified":1578043972986},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1577167056876},{"_id":"themes/next/layout/_third-party/.DS_Store","hash":"d421666a745411c4c143cd6c528bdef8177ba7f8","modified":1581576649165},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1577167056876},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1577167056876},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1577167056877},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1577167056877},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1577167056877},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1577167056877},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1577167056886},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1577167056886},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1577167056887},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1577167056887},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1577167056887},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1577167056887},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1577167056888},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1577167056888},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1577167056888},{"_id":"themes/next/source/css/.DS_Store","hash":"2d505d672bd12d0ada826527523934b113ee427c","modified":1582304062635},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1577167056905},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1577167056905},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1577167056905},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1577167056905},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1577167056905},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1577167056905},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1577167056906},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1577167056906},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1577167056906},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1577167056906},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1577167056906},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1577167056907},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1577167056907},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1577167056907},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1577167056908},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1577167056908},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1577167056908},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1577167056909},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1577167056908},{"_id":"themes/next/source/lib/.DS_Store","hash":"fddb360245a3e356c0ea285724c180736a56365c","modified":1582303983384},{"_id":"themes/next/source/js/.DS_Store","hash":"21cb8f8573249f79f9dfbf7fb79d05583e6bb4ea","modified":1582304048263},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056904},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056905},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056899},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056900},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577167056900},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1577167056872},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1577167056872},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1577167056872},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1577167056872},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1577167056872},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1577167056872},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1577167056872},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1577167056873},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1577167056873},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1577167056873},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1576588786000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1576588786000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1576588786000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1577167056874},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1576588786000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1577167056874},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1577167056874},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1577167056874},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1577167056874},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"b04e4670b8744ba540b7b64fec0bcc3a88a67f24","modified":1581576185282},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1577167056875},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1577167056875},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1577167056875},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1577167056875},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1577167056876},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1577167056876},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1577167056878},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1577167056878},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1577167056877},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1577167056878},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1577167056904},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1577167056904},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1577167056904},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"0f45c255ae5408d29f1dcb61a52db8185133390f","modified":1581576682151},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"76bf7810aa1df145c64d60816abd7f893f6adf62","modified":1582303908582},{"_id":"themes/next/source/css/_schemes/.DS_Store","hash":"69cb863623e9e0a400e75e37175cd1b0877e4fea","modified":1577174282939},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1577167056899},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1577167056900},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1577167056900},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1577167056915},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1577167056918},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1577167056917},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1577167056921},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1577167056921},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1577167056921},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1577167056921},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1577167056922},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1577167056922},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1577167056922},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1577167056922},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1577167056922},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1577167056931},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1577167056931},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1577167056931},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1577167056932},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1577167056932},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1577167056932},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1577167056932},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1577167056933},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1577167056932},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1577167056933},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1577167056934},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1577167056934},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1577167056935},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1577167056935},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1577167056938},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1577167056935},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1577167056939},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1577167056938},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1577167056939},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1577167056939},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1577167056909},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1577167056909},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1577167056909},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1577167056909},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1577167056910},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1577167056910},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1577167056910},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1577167056910},{"_id":"themes/next/source/js/src/.DS_Store","hash":"a68d473bb21f4ebc47bb460b1d63405d370e67c7","modified":1582303923667},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1577167056911},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1577167056912},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1577167056912},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1577167056931},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1577167056877},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1577167056877},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1577167056896},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1577167056899},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1577167056898},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1577167056899},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1577167056899},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1577167056899},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1577167056899},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1577167056899},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1577167056900},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1577167056900},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1577167056900},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1577167056900},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Mist/.DS_Store","hash":"94694524b02635304624ed506d64ebd71164a579","modified":1577174270266},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1577167056900},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3cf08d36232790e0470c9411c93eb1a1b1bd47ac","modified":1577174013887},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Muse/.DS_Store","hash":"d16a403c0d7ebc16e6589ed78ab6d7498c11a43a","modified":1577173807827},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1577167056902},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1577167056902},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1577167056913},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1577167056914},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1577167056914},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1577167056918},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1577167056920},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1577167056920},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1577167056921},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1577167056921},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1577167056922},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1577167056923},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1577167056923},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1577167056937},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1577167056938},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1577167056911},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1577167056914},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1577167056920},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1577167056931},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1577167056930},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1577167056939},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1577167056890},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1577167056889},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1577167056890},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1577167056890},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1577167056890},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1577167056890},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1577167056891},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1577167056891},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1577167056891},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1577167056891},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1577167056891},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1577167056892},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1577167056893},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1577167056894},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1577167056898},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1577167056895},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1577167056896},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1577167056897},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1577167056897},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1577167056901},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1577167056902},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1577167056912},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1577167056912},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1577167056913},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1577167056913},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1577167056919},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1577167056919},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1577167056925},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1577167056929},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1577167056913},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1577167056926},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1577167056917},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1577167056937},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1577167056928},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1581876994000},{"_id":"themes/fluid/LICENSE","hash":"77259cff2096bcf2974d2091a28302511b9103f4","modified":1581876994000},{"_id":"themes/fluid/README.md","hash":"acbe540c327cdc3e23ac60ce0692b6a41c95d70b","modified":1581876994000},{"_id":"themes/fluid/README_en.md","hash":"ecd6bd8bd994adceab3433577e9d410a22afd2b6","modified":1581876994000},{"_id":"themes/fluid/Changelog.md","hash":"1e0a956af419758336cce4a6661a834f59628b55","modified":1581876994000},{"_id":"themes/fluid/_static_prefix.yml","hash":"9c66446ad2e4d9f68549108adc1c8afd53f1a60b","modified":1581876994000},{"_id":"themes/fluid/_config.yml","hash":"4af84947e5e82e9e32c8fb2c1d767d5a0cabf1c1","modified":1582382275071},{"_id":"themes/fluid/layout/page.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581876994000},{"_id":"themes/fluid/pages/about.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581876994000},{"_id":"themes/fluid/layout/404.ejs","hash":"8207b0b7e14384a8ae3a954bbad1db14664bb918","modified":1581876994000},{"_id":"themes/fluid/languages/en.yml","hash":"370b61742ea947934c72331ad29a2f1ec10db70f","modified":1581876994000},{"_id":"themes/fluid/languages/ja.yml","hash":"5fb9d2233a62a737b455d18931c3cc5ea3264195","modified":1581876994000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"ccc2ec0c56c5de49ca3b39da7f4d23edab59a942","modified":1581876994000},{"_id":"themes/fluid/layout/about.ejs","hash":"62167c99a1deeeef31e2c972039a238e8a69146e","modified":1581876994000},{"_id":"themes/fluid/layout/archive.ejs","hash":"ed39c0a0facd2e746276e061a27ae38867f7b71c","modified":1581876994000},{"_id":"themes/fluid/layout/categories.ejs","hash":"8a3347ec1ba39d5dd3984ba2b3c90eb8258e5977","modified":1581876994000},{"_id":"themes/fluid/layout/category.ejs","hash":"9cc94d4044e1170ffff2f98d4842b0fc27bf168d","modified":1581876994000},{"_id":"themes/fluid/layout/index.ejs","hash":"dc766a5cba9b2f91f8a4d717b512d5caba80545b","modified":1581876994000},{"_id":"themes/fluid/layout/layout.ejs","hash":"edf20a9e72f8a70de7f836cfd9324e506af6adff","modified":1581876994000},{"_id":"themes/fluid/layout/links.ejs","hash":"a77a6e192151f20d08f7f421b578ba2ea32332b4","modified":1581876994000},{"_id":"themes/fluid/layout/post.ejs","hash":"fbf6860fa6d89956d02bd28c9ae0d2fed59467a0","modified":1581876994000},{"_id":"themes/fluid/layout/tag.ejs","hash":"f47a126f3848bcdf482f2ed9c7f396e65a30ef7d","modified":1581876994000},{"_id":"themes/fluid/layout/tags.ejs","hash":"716769e91a69014cefffdddb137098bb2ed99297","modified":1581876994000},{"_id":"themes/fluid/pages/local-search.xml","hash":"6606c859dc91b1a216e1a2b9eb0d1ec98db5d98b","modified":1581876994000},{"_id":"themes/fluid/scripts/helpers.js","hash":"7bd7e12252981003448e3b867e25cc303b3465fe","modified":1581876994000},{"_id":"themes/fluid/scripts/lazyload.js","hash":"ab682108e69328fece371955b2eb271f51016596","modified":1581876994000},{"_id":"themes/fluid/scripts/merge-configs.js","hash":"63727d66f6a0340538d17b52dde9c7f0fe70cf83","modified":1581876994000},{"_id":"themes/fluid/scripts/local-search.js","hash":"6db2897057b51617edb19cf8f40ea30106d66f37","modified":1581876994000},{"_id":"themes/fluid/scripts/pages.js","hash":"b62aa2783da3dd81f54a826b1171447b45dba479","modified":1581876994000},{"_id":"themes/fluid/scripts/wordcount.js","hash":"154e838ba4f5b6e9510da7e618a63fe9b388bd3d","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"cd2d2358380638b3d11b89cf6cb99e5dd1da3875","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/busuanzi.ejs","hash":"c3dec7af6da974e783a45f83ee48a6d3281783cc","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"3c3b521c7e982922b344d9779ff6a798469aa8e5","modified":1582381442856},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"98f1bab1fc424cd52e1cc93f94e4d63569306996","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"1305a0817e540323dfcd3b4a558103b592a7d78d","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"c798fdce888c6f26790cd201e0962ce8d479a6fc","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"e59408274d8060d535be8ab923284df2f8aa8506","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"80e6ba34a1ff59d6e51e7d4c331494b562594144","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"13c29a2e9681d7ec2e0577d68d03fba55077eb78","modified":1581876994000},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"818aa1166f5aeb2fa3712e11481d3c65bc211524","modified":1581876994000},{"_id":"themes/fluid/source/css/main.styl","hash":"33a5dac12a89f0b6f343f4b7f639f8cb2c29e330","modified":1581876994000},{"_id":"themes/fluid/source/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1581876994000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1581876994000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1581876994000},{"_id":"themes/fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1581876994000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1581876994000},{"_id":"themes/fluid/source/js/lazyload.js","hash":"bb11c0a419de1fc4ce1ef633574ce0f9b91e1441","modified":1581876994000},{"_id":"themes/fluid/source/js/local-search.js","hash":"66046f2ad85aa22fd64bbd0e968a498a2c5bfbaa","modified":1581876994000},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1581876994000},{"_id":"themes/fluid/source/js/main.js","hash":"c1bee0e5ba4f4fe121549bd1122266446810d6b2","modified":1581876994000},{"_id":"themes/fluid/source/js/post.js","hash":"80bbd64dd5ab0873db0a5b96dc377103e1c42a78","modified":1581876994000},{"_id":"themes/fluid/source/css/_functions/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581876994000},{"_id":"themes/fluid/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581876994000},{"_id":"themes/fluid/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"5898fb0a5610c840ba20a6a84c2952e9331d89b9","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"b8d84205f2cd899ba490fc2335ea2e1353f1d03d","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"19fb3d0390a8e2334030b3f43b53f1019b682433","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"8ab72945ef82f80147e60604dbb8506f3dcdec4f","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"2cfd1e0cbf0b71d74de2760fd2303bb90afedc42","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"c4bbcf1507f19be6e077e73d0b38d00003f3161b","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"f1a4ced91653cd1c9ce1943d36488492bb5f152e","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"40032ca6af619716fa3479eeb9a5f47924d95126","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"784a8e656dbf535269bb901fc7b2469dc24e1899","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"421ad423f4a44a9468253e1f117145a500fdec78","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"2778826c66c442e33ac9f9c32bc6e9e1ec0ef8f5","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/plugins/prettify.ejs","hash":"d835646f43d27cfa63c1d84c851a16cd1c49f970","modified":1581876994000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"2ee91a9782ffca316b12ab45a96a9bbafe57e5af","modified":1581876994000},{"_id":"themes/fluid/source/css/_custom/custom.styl","hash":"3626d8439c27c9bfde008de8a7ba5124bbc7c397","modified":1581876994000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"271abbfef0414cb6d854a0278f8348e3f6fc70b1","modified":1581876994000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"68caf7cc73fa6211f9802b69293a2a38d7322de7","modified":1581876994000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"03703ece80dac645607d4731dff3fdd923777d2a","modified":1581876994000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"56ee4f721b54c623286dd172085aaf34c0128837","modified":1581876994000},{"_id":"themes/fluid/source/lib/anchor/anchor.min.js","hash":"0996588202bd062dad6f592615cb4791e1f8be91","modified":1581876994000},{"_id":"themes/fluid/source/lib/fancybox/jquery.fancybox.min.css","hash":"bfa13de0fab7defa3a25c3197e90b600c4897c34","modified":1581876994000},{"_id":"themes/fluid/source/lib/popper/popper.min.js","hash":"27d61a7e89d12ce0744f34fa804230eeb13ff128","modified":1581876994000},{"_id":"themes/fluid/source/lib/prettify/prettify.min.js","hash":"03044b62cdb1c300537c14dcf424333fcf4c9110","modified":1581876994000},{"_id":"themes/fluid/source/lib/github-markdown/github-markdown.min.css","hash":"23ec6f05c5b69aa8ffb12c59c9bf1325ee5a26d1","modified":1581876994000},{"_id":"themes/fluid/source/lib/katex/katex.min.css","hash":"f29c27f5b804ec30acdebb8ec0488fc4a9e1538a","modified":1581876994000},{"_id":"themes/fluid/source/lib/prettify/github-v2.min.css","hash":"da1b8e6d4df1f044d12f461880e677d65dbbf2d3","modified":1581876994000},{"_id":"themes/fluid/source/lib/smoothscroll/SmoothScroll.min.js","hash":"ee5dea9ea4c5edb110f30a277e5fca7993f948b5","modified":1581876994000},{"_id":"themes/fluid/source/lib/prettify/tomorrow-night-eighties.min.css","hash":"a5f2102fc148359a92435b170f3bfb25e1221837","modified":1581876994000},{"_id":"themes/fluid/source/lib/tocbot/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1581876994000},{"_id":"themes/fluid/source/lib/typed/typed.min.js","hash":"38b792348023d55caabd7f888ae477ee143e6abe","modified":1581876994000},{"_id":"themes/fluid/source/lib/prettify/tomorrow-night.min.css","hash":"535256d676d247d3282e9a8ae2777c6f7df4fdc6","modified":1581876994000},{"_id":"themes/fluid/source/lib/prettify/tomorrow.min.css","hash":"ea61879c64ca73a5ea233b1315faf7f2fdfebca9","modified":1581876994000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581876994000},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581876994000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581876994000},{"_id":"themes/fluid/source/lib/fancybox/jquery.fancybox.min.js","hash":"211f4852cbb5662e11b9688bef8415ca328a88ef","modified":1581876994000},{"_id":"themes/fluid/source/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1581876994000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"c42222b737664023ee95db6c379e6e4a40f1cbcd","modified":1581876994000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"79475bf3e25a67f38a921d23dece86cd7584c528","modified":1581876994000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"43f49545fe2581338d971ecdf848942cc519e378","modified":1581876994000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"2772bf9adbda307fdf94241e653c7eb70ec6e975","modified":1581876994000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"eee2e84a23f1bbccbe1c24395dce15814a291e8b","modified":1581876994000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"ed9268c7a4ba135437ec30adfe4724cf2719e1cc","modified":1581876994000},{"_id":"themes/fluid/source/lib/bootstrap/js/bootstrap.min.js","hash":"8260ff4bf54350c075bc10d18e349d158e1a4af1","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/css/all.min.css","hash":"6f4095f66e56d39ef0adefbe85a1dcfc13bd133b","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"2e97930b520222ec3c2e4188ce07cc1904beba48","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"5eb58f4263f87c543388bf66dec7d1f0b7c5b32c","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"38e6bd17442bb34e0e13a2c9bcbc5299f68be173","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"8b356dc021032d9380af47f7608a6b62a9b6f363","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"9465c5894ca2f93655fa5767b820b762aff6b518","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"2417fe03c7330a5160f070d6ab747a2bc4bbd41b","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"5d5d1448b199c38f1b39a49b1e9b3f1381a26cad","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"d378644ff0f7549fa6f217a08dfd2566a770638e","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"453e71a65f2958480b74fdb75a53d41068699dbf","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"3fbe9822118e91350912f51f3080ce4aa9b3ec38","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"f9583bce6740a4125e14d0628ffbd946b7ddfdda","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"2b0ebea58a0bc895400dffe8c5e434c8b12338e3","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/js/mdb.min.js","hash":"fef8d611bbc14ad31ca9ec9e2990bfde4d873bb1","modified":1581876994000},{"_id":"themes/fluid/source/lib/bootstrap/css/bootstrap.min.css","hash":"3665a5389b7a20dd3b2fe9cb0ed3d80bec1cf2a3","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"7b280debee5800806092e35a6bc2c6fd9c51cf63","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/css/mdb.min.css","hash":"62818e7755b098a1c3b503425356570a2c7474d9","modified":1581876994000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"fcac55c6f9e9993cea6e2ecc729fffc36c7009b2","modified":1581876994000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"3d24b0004b9dac32a46622cefa72cb3173b13115","modified":1581876994000},{"_id":"themes/fluid/.DS_Store","hash":"ce93b3b1cd302e1c93625f6ec979e4e6fa9ac3a5","modified":1582380619198},{"_id":"source/images/post_banner.jpg","hash":"a2ea4715379e5a293bf751894b16734b1bf1663a","modified":1582380414417},{"_id":"themes/fluid/layout/.DS_Store","hash":"cc4defddd90e793b6c54e7c4b66cf0e080244d74","modified":1582380624208},{"_id":"source/images/banner.jpg","hash":"725b3aaafe3338784a004d840e8751b27125d975","modified":1582379802548},{"_id":"public/search.xml","hash":"2dc5c848c0de0d45e2937bc19de60d7e1d6192d4","modified":1582382312598},{"_id":"public/local-search.xml","hash":"6ea9b12d956b3f1da12db178e71e1882ae3edb31","modified":1582380659501},{"_id":"public/about/index.html","hash":"6dcb6f39be9192f328a97aa39902301adeed6661","modified":1582382312598},{"_id":"public/tags/index.html","hash":"c282463e1116fbd70f0d7aa02b9d7c05eb827430","modified":1582382312598},{"_id":"public/categories/index.html","hash":"77affbf97d724f166c697d6d370b318af4838574","modified":1582382312598},{"_id":"public/archives/index.html","hash":"aa024f41a6109bb97c31fb18c723549c758d1944","modified":1582382312598},{"_id":"public/archives/page/2/index.html","hash":"963a5d099555840278c5dbe994efdf84764eee5d","modified":1582382312598},{"_id":"public/archives/2018/index.html","hash":"234490745c86311ce558118df0a497553cc17b49","modified":1582382312598},{"_id":"public/archives/2018/page/2/index.html","hash":"0d39995d7f5661dea229c456444374e3e361dd39","modified":1582382312598},{"_id":"public/archives/2018/08/index.html","hash":"dd314f0a95a1174bce82e2406d708a5c4117e9b3","modified":1582382312598},{"_id":"public/archives/2018/09/index.html","hash":"3d0be174d1e4fd9b22aaa4063542d6a7e0a0dbd5","modified":1582382312598},{"_id":"public/archives/2018/10/index.html","hash":"8fc350fc7b561c590628131a39e1ecf1091704d2","modified":1582382312598},{"_id":"public/archives/2018/11/index.html","hash":"b65f90d784415bfcbc91537ea787f71bd2e36a6a","modified":1582382312598},{"_id":"public/archives/2018/12/index.html","hash":"68b736e0361d88b27a6bc8f4753eeee4c47b1509","modified":1582382312598},{"_id":"public/archives/2020/index.html","hash":"09c8a4d70858c1505c17a06c7e636a1324dff36b","modified":1582382312598},{"_id":"public/archives/2020/02/index.html","hash":"09c8a4d70858c1505c17a06c7e636a1324dff36b","modified":1582382312598},{"_id":"public/categories/算法/index.html","hash":"a9419a015295a676c1af462b9137ae8920502adc","modified":1582382312598},{"_id":"public/categories/Java/index.html","hash":"0b8872c46de5894aab79bfca4ee8da63f0d959b8","modified":1582382312598},{"_id":"public/categories/Mybatis/index.html","hash":"8d427d15f1b7e2af78a5c38964ac2263b7fe254c","modified":1582382312598},{"_id":"public/categories/Java框架/index.html","hash":"2396367dd3a233345da1468311c825cfb21700c0","modified":1582382312598},{"_id":"public/categories/Web前端/index.html","hash":"632fbf78b3e6e2b2bda4a23adf40fb7b2ab4533f","modified":1582382312598},{"_id":"public/categories/Docker/index.html","hash":"84fd9c72ee93e288c0e25ac09c911dc1870e2030","modified":1582382312598},{"_id":"public/categories/Interview/index.html","hash":"8bc06e72392a65d7d1da8e41ef15b88f58ac1b30","modified":1582382312598},{"_id":"public/categories/Nginx/index.html","hash":"e8edc1181dcc4d6e16c38a3fa9fa4ca8f7dcf399","modified":1582382312598},{"_id":"public/categories/数据库/index.html","hash":"a87ac3d6c6e953e34b0492269f873724f57f14f3","modified":1582382312598},{"_id":"public/categories/Linux/index.html","hash":"1dc644df07b7489afc2edeae919f7252766ee3be","modified":1582382312598},{"_id":"public/tags/数据结构-算法/index.html","hash":"07865ce6bb82124dec815e7336b0f7a6e652b44d","modified":1582382312598},{"_id":"public/tags/Java/index.html","hash":"9dfe5602836334c60720582f7e90417fed3f430e","modified":1582382312598},{"_id":"public/tags/Java基础/index.html","hash":"4319ecd6650880945f0d350619b53df0520a594c","modified":1582382312598},{"_id":"public/tags/Java框架-数据库/index.html","hash":"05cb7cafdd0d511c1bf511f977b1ba3633b0856c","modified":1582382312598},{"_id":"public/tags/框架/index.html","hash":"53d3ee6caa05fa027c81c1906b905385888a5d5e","modified":1582382312598},{"_id":"public/tags/权限框架/index.html","hash":"ee22fb991bc334a214b45b14eb48dd83940b5b60","modified":1582382312598},{"_id":"public/tags/框架-Spring/index.html","hash":"4fe65ba9adde7baf736b39ba8701650a99494038","modified":1582382312598},{"_id":"public/tags/前端框架/index.html","hash":"1c8744df8b2d2d6920869631b2f41a1839bbceaf","modified":1582382312598},{"_id":"public/tags/DevOps-服务器/index.html","hash":"918486f0e9129cb1ceb9cc3da884696a253e7cd8","modified":1582382312598},{"_id":"public/tags/Java-面试题/index.html","hash":"10150df0acb80baa911770875b461b6be547aa0c","modified":1582382312598},{"_id":"public/tags/HTTP服务器/index.html","hash":"0ad4644d4e5e516d563aad44c1f7efbabec7908f","modified":1582382312598},{"_id":"public/tags/数据库-Redis/index.html","hash":"6836cd63f1b78f98da9c40c107b6f0130271e5ee","modified":1582382312598},{"_id":"public/tags/Linux-服务器/index.html","hash":"1b4a1a3333ccafca99b2830960887196fe0b2a0a","modified":1582382312598},{"_id":"public/404.html","hash":"bf25ec40e98ad5d5f96248a5db3e6d74e862b64c","modified":1582382312598},{"_id":"public/links/index.html","hash":"23118775fba7bbd39cdae9e84ab77ef8a2b95121","modified":1582382312598},{"_id":"public/2020/02/14/interview/index.html","hash":"daece64f264546f7dc36dde05487948cb0428324","modified":1582382312598},{"_id":"public/2018/12/14/linux-1/index.html","hash":"a93bc7b131dfdaf1e4dc764adf6556a27788d32a","modified":1582382312598},{"_id":"public/2018/12/06/redis-2/index.html","hash":"623fd1396227afa3f68ede97f2bb9ae6b9eb9a84","modified":1582382312598},{"_id":"public/2018/11/28/redis-1/index.html","hash":"d40e27920443c5eff728e7632998dfbfffdbcfb1","modified":1582382312598},{"_id":"public/2018/11/21/nginx/index.html","hash":"6e9709ef1b224a5b95d34bfd83571bbc89ebb673","modified":1582382312598},{"_id":"public/2018/11/14/docker/index.html","hash":"2b572f11dc884cfb88d1c3d6f09427762b87ee64","modified":1582382312598},{"_id":"public/2018/11/07/Spring-3/index.html","hash":"00e219fdaaf1a4e9aa4b90cb22a947c946b98d4e","modified":1582382312598},{"_id":"public/2018/10/30/Spring-2/index.html","hash":"92a4985233ace8f15fe188037a4f285bc4e1adcf","modified":1582382312598},{"_id":"public/2018/10/22/Spring-1/index.html","hash":"dc52af674b6e5467d9d7904296b2d8d849285b40","modified":1582382312598},{"_id":"public/2018/10/15/Mybatis-3/index.html","hash":"29b7e1207ab703f68e328f06197cf7498e446fab","modified":1582382312598},{"_id":"public/2018/10/06/Mybatis-2/index.html","hash":"7a714be0e0cca19fdc8e551585893ad128af0215","modified":1582382312598},{"_id":"public/2018/09/30/Mybatis-1/index.html","hash":"a432d2ef45a4ab34c64b42a9116ffcbc9bc14628","modified":1582382312598},{"_id":"public/2018/09/23/Shiro/index.html","hash":"e04d1e8998e92c963b42cfa183b899d58cdd027a","modified":1582382312598},{"_id":"public/2018/09/15/Vue4/index.html","hash":"586522ad077de8e2951cdf66a0db5754d75a9ac4","modified":1582382312598},{"_id":"public/2018/09/07/Vue3/index.html","hash":"4f86d2ba4567e888051e2f402bf23249dfe82fb4","modified":1582382312598},{"_id":"public/2018/08/30/Vue2/index.html","hash":"554bce5679d91aeba1804d24b8d1a14be1e67267","modified":1582382312598},{"_id":"public/2018/08/24/Vue1/index.html","hash":"7255a9fe6a1fc012d4bbf07302b795878b159655","modified":1582382312598},{"_id":"public/2018/08/16/Algorithm/index.html","hash":"187cdb271c851b5678065da8930f57ce5b183187","modified":1582382312598},{"_id":"public/2018/08/08/JavaBasic2/index.html","hash":"d7f446496611d672fa796b98ad22364c826b5409","modified":1582382312598},{"_id":"public/2018/08/01/JavaBasic1/index.html","hash":"da0657ce20a57e1a6f16b09c07ee0a74ce50dd48","modified":1582382312598},{"_id":"public/index.html","hash":"3238ce1bcbfe71a42e7c3994939539914b324ecd","modified":1582382312598},{"_id":"public/page/2/index.html","hash":"93f95f4e0163258127469560b541b9395b1c05e1","modified":1582382312598},{"_id":"public/images/deadlock.png","hash":"f63036ff0143e102534f0d1ce048060550b1dd59","modified":1582380659501},{"_id":"public/images/docker1.jpg","hash":"628a21017237112a5f7feee574f72dea656b3841","modified":1582380659501},{"_id":"public/images/DomaticBind.png","hash":"cd7fbcd97376eafbb224edcadb690799f45c645c","modified":1582380659501},{"_id":"public/images/docker10.png","hash":"befdb1c56f60e3b2ffa67b71b630d27ee04f41e4","modified":1582380659501},{"_id":"public/images/collection1.png","hash":"251da553598406e87c35a4545df30bd28040ccc8","modified":1582380659501},{"_id":"public/images/docker11.png","hash":"4cea5b5e07be39bcee4789978319fb85788bffc4","modified":1582380659501},{"_id":"public/images/String1.png","hash":"afc6a1eaabbf745686d9da1572fd7bbb842dcb70","modified":1582380659501},{"_id":"public/images/docker3.png","hash":"158912be97e1f2d0f9595c1f6aa145813b587514","modified":1582380659501},{"_id":"public/images/docker4.png","hash":"449d813a8b5178812522d40b4a5650a54380ca18","modified":1582380659501},{"_id":"public/images/docker8.png","hash":"56f2b058f83002486d4b578da9b7d818805e34c0","modified":1582380659501},{"_id":"public/images/docker12.png","hash":"417444a09b3a2e3cafbcc98f64ccb060958553c3","modified":1582380659501},{"_id":"public/images/docker9.png","hash":"4bd8bc4b09fc496e469d47ed6aefd4f79ea4c4cd","modified":1582380659501},{"_id":"public/images/docker6.png","hash":"99ce88799bbf1cd4e015c0247fdc55a032a349e6","modified":1582380659501},{"_id":"public/images/linktable2.png","hash":"cc2302e52f3549196f2caafdc823ec4ddf3162a4","modified":1582380659501},{"_id":"public/images/linktable1.png","hash":"799f768ef51935977174ab61543974a2cf4957c6","modified":1582380659501},{"_id":"public/images/linktable4.png","hash":"7b846bc3e54e7c273c9c6000336fea66be4dd279","modified":1582380659501},{"_id":"public/images/linux-logo.jpg","hash":"b9a177128e177f8c1420c1a85d4d268f87c6d419","modified":1582380659501},{"_id":"public/images/linktable3.png","hash":"b3168918169491d4e19c1aa576eac5f11879f266","modified":1582380659501},{"_id":"public/images/map1.png","hash":"aa910ebab66ef6b17d29d83b09d5bedc1147b2f5","modified":1582380659501},{"_id":"public/images/linktable5.png","hash":"38daf65690e672c070846a9a640499bed3a05abc","modified":1582380659501},{"_id":"public/images/math2.png","hash":"954e9b2a96f29c57d796079bb36c4472bef50bb2","modified":1582380659501},{"_id":"public/images/mapperxml.png","hash":"9db12bf3362ac599f886a4979465ab915f8b6c9f","modified":1582380659501},{"_id":"public/images/math1.png","hash":"9023ce7c386de5e4abe501f3dabf6013af3ef498","modified":1582380659501},{"_id":"public/images/math4.png","hash":"f21a91d19bc95288730e51bf954219005284d9cb","modified":1582380659501},{"_id":"public/images/math5.png","hash":"b2e9e14a79694d16eed2306fc4f93e7bf713c23f","modified":1582380659501},{"_id":"public/images/mybatis_logo.jpg","hash":"a14d5a370c21eda0d193b0ac46637e1db1b8c1de","modified":1582380659501},{"_id":"public/images/math3.png","hash":"2a6b8d224b29ed2c849776407eac0582ab9dba81","modified":1582380659501},{"_id":"public/images/math6.png","hash":"a766c724efbfd152b5c477b433d162b5b7b0f6e1","modified":1582380659501},{"_id":"public/images/nginx5.png","hash":"43a76b61becc6afdd23acb3d88177e3a03366be7","modified":1582380659501},{"_id":"public/images/nginx4.png","hash":"3af3072995184f63d0a75324c02527c3e6544538","modified":1582380659501},{"_id":"public/images/nginx.jpg","hash":"12ca2e6ca8e2be48c2060f61206229779ffbfcd1","modified":1582380659501},{"_id":"public/images/nginx6.png","hash":"491b705deb7b8dcb8adb048e5a42f1c4da4b31dc","modified":1582380659501},{"_id":"public/images/redis17.png","hash":"435da22ed6455c0e66a9ade31126c23baec7b66d","modified":1582380659501},{"_id":"public/images/redis-logo.png","hash":"f6185b68d1d1c2a4ae92226da2bc21b158b79e98","modified":1582380659501},{"_id":"public/images/redis10.png","hash":"19fa7769b36f6fab9565ba9ff4e10ec5058e24c1","modified":1582380659501},{"_id":"public/images/nginx7.png","hash":"c17dc449825991fa932065f3b5673b7bf45d947f","modified":1582380659501},{"_id":"public/images/redis2.jpg","hash":"5a06f30a426b38d18618963344b79f255ea5ba3b","modified":1582380659501},{"_id":"public/images/redis18.png","hash":"80596d2905d7426d022bd20e46e0448bded47736","modified":1582380659501},{"_id":"public/images/redis19.png","hash":"69333348bad01f5c5d1fc911da6e7c311d8d9919","modified":1582380659501},{"_id":"public/images/redis23.png","hash":"fdebc86324b5470cf27d11433d49d12fc6302ed4","modified":1582380659501},{"_id":"public/images/redis22.png","hash":"51c015fc546b616450f456e62e2316f8071e5680","modified":1582380659501},{"_id":"public/images/redis1.jpg","hash":"ac6a6a25cea2e0cdc1092139527b41ba1513f3ca","modified":1582380659501},{"_id":"public/images/redis3.jpg","hash":"d6a73c9470f5c7e6c5ce25eb5377f9d9dac0e726","modified":1582380659501},{"_id":"public/images/redis4.jpg","hash":"1654796182534cafd587319995b13532eed1f262","modified":1582380659501},{"_id":"public/images/redis5.jpg","hash":"2581e6e9ba57b3dbf439ef11e78da9ce4763723d","modified":1582380659501},{"_id":"public/images/redis9.png","hash":"698fe81f8ed82b59cd7262c53cce4c79f25f027f","modified":1582380659501},{"_id":"public/images/redis6.jpg","hash":"33a53f014b745da6240577adf7c533d47beec752","modified":1582380659501},{"_id":"public/images/redis7.jpg","hash":"b290e8a960d2f687ffb4704f513237bf2db8b129","modified":1582380659501},{"_id":"public/images/spring-framework.gif","hash":"5f1a7c0074b3b32ae14a325face291bfc3905fd7","modified":1582380659501},{"_id":"public/images/redis8.png","hash":"dd584640e4e144b36f259c2d8ff97689667b0ee9","modified":1582380659501},{"_id":"public/images/shiro2.png","hash":"4f6181f77ddcb81619083bf96f57e85d80b39977","modified":1582380659501},{"_id":"public/images/spring_logo.jpg","hash":"a8bd6127c10707f58e8e7f556cc14d1e1ff019d3","modified":1582380659501},{"_id":"public/images/shiro1.png","hash":"5dcb3a6002f3005145da796cd6926a14f0358187","modified":1582380659501},{"_id":"public/images/test.png","hash":"2b4606ba3e36b0bb37dd46cdaf830fb48d43c217","modified":1582380659501},{"_id":"public/images/stack.png","hash":"44730d0212fada434d90c74a9d91a9e8f882962b","modified":1582380659501},{"_id":"public/images/thread.png","hash":"5090d556fba9f989a8b5ad133337c6ddc208deda","modified":1582380659501},{"_id":"public/images/vue10.png","hash":"959a24b034047afbb9e3bedfaa61bb834cb3e293","modified":1582380659501},{"_id":"public/images/vue12.png","hash":"c8e384250b702b349e88c87607d2f37863b93d88","modified":1582380659501},{"_id":"public/images/vue13.png","hash":"ae29ca656a3450f70ae96f806df23efa9a7b7ad7","modified":1582380659501},{"_id":"public/images/vue18.png","hash":"a3230a1e0c1d945d96f132356b66b042342dce47","modified":1582380659501},{"_id":"public/images/vue2.png","hash":"243d7ccf2b2a0162218d269f2ae5c9a0ba7a0229","modified":1582380659501},{"_id":"public/images/vue14.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1582380659501},{"_id":"public/images/vue3.png","hash":"0891de9363a546dd806f5e5fe837d3082a27565b","modified":1582380659501},{"_id":"public/images/vue20.png","hash":"794fc3e74e23a5b18bd3c19a9347d2f699798a05","modified":1582380659501},{"_id":"public/images/vue4.png","hash":"1f7e4ea318bc779b25bf441aef2d7f257f4363cb","modified":1582380659501},{"_id":"public/images/vue5.png","hash":"c83cb6f0dac95e114a5b2707452ace8ea4ff034e","modified":1582380659501},{"_id":"public/images/vue6.png","hash":"7f16bda0e86a7497ad8cf8b151061f4a0e83bbac","modified":1582380659501},{"_id":"public/images/vue8.png","hash":"a5dd7b68dd393143acedbfab8198a731b16490c5","modified":1582380659501},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1582380659501},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1582380659501},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1582380659501},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1582380659501},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1582380659501},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1582380659501},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1582380659501},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1582380659501},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1582380659501},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1582380659501},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1582380659501},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1582380659501},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1582380659501},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1582380659501},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1582380659501},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1582380659501},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1582380659501},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1582380659501},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1582380659501},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1582380659501},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1582380659501},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1582380659501},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1582380659501},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1582380659501},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1582380659501},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1582380659501},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1582380659501},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1582380659501},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1582380659501},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1582380659501},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1582380659501},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1582380659501},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1582380659501},{"_id":"public/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1582380659501},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1582380659501},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1582380659501},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1582380659501},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1582380659501},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"5eb58f4263f87c543388bf66dec7d1f0b7c5b32c","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"38e6bd17442bb34e0e13a2c9bcbc5299f68be173","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"2e97930b520222ec3c2e4188ce07cc1904beba48","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"8b356dc021032d9380af47f7608a6b62a9b6f363","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1582380659501},{"_id":"public/images/post_banner.jpg","hash":"a2ea4715379e5a293bf751894b16734b1bf1663a","modified":1582380659501},{"_id":"public/images/20180127210359151.png","hash":"b328ce766e5d959221b06df896ae2d2559e961ac","modified":1582380659501},{"_id":"public/images/2.png","hash":"813b2e528a9395cdd427da48a5ce2a0d3b830a6c","modified":1582380659501},{"_id":"public/images/3.png","hash":"2aa599677842864f1c5d006393a7cd8bb44ea174","modified":1582380659501},{"_id":"public/images/author.jpg","hash":"bf13ddca01c2e6aec062848c81aa256f3a45c8b9","modified":1582380659501},{"_id":"public/images/author.png","hash":"f21db080ce6a437b2e60d179015889f6e0831b05","modified":1582380659501},{"_id":"public/images/docker2.png","hash":"dd3fc1cf3a2b234253cc58fe9ac5cf122552ea34","modified":1582380659501},{"_id":"public/images/classloader.png","hash":"4ca131fc56c4bc60ad5ed33d3f2448d343b17ad0","modified":1582380659501},{"_id":"public/images/docker5.png","hash":"29d91a9acd947ef4fbec7bdcce1c7519843f9841","modified":1582380659501},{"_id":"public/images/hash1.png","hash":"d00e6d851a6a0ff456541d5dcfdecf1a23ae37c5","modified":1582380659501},{"_id":"public/images/mybatis3.png","hash":"e7f90ca5a3f2ffe5592d98e481ccb4fdb2234562","modified":1582380659501},{"_id":"public/images/io.png","hash":"b328ce766e5d959221b06df896ae2d2559e961ac","modified":1582380659501},{"_id":"public/images/mybatis1.png","hash":"9a838351c61a62fe8132028bdfd29f6b275ab109","modified":1582380659501},{"_id":"public/images/nginx3.png","hash":"e43356b41a6bc6349ecb16fa9ad72e7b9b366adc","modified":1582380659501},{"_id":"public/images/nginx1.png","hash":"080a8c25ed0010ce129754e6dd87459ffdeedfba","modified":1582380659501},{"_id":"public/images/mybatisflow.png","hash":"09ce0b986c5ed5aae38f7f927ed48323de41d05d","modified":1582380659501},{"_id":"public/images/redis11.png","hash":"118b8703966ef0e7e5a6f43255d4360565776e05","modified":1582380659501},{"_id":"public/images/redis14.png","hash":"c8d8be3b6de877eebb5a71da5d3bb55eba9943b4","modified":1582380659501},{"_id":"public/images/redis15.png","hash":"d239aa4fe120cc9d393ac913a0a6e133cf1aa39f","modified":1582380659501},{"_id":"public/images/redis16.png","hash":"4cbe86bb02c82cb62c03b25d2fcb288273aae589","modified":1582380659501},{"_id":"public/images/spring-aop1.png","hash":"f1c3fa28aee06f181d42e0571a3d04f6f0add386","modified":1582380659501},{"_id":"public/images/vue11.png","hash":"a02aac351c4547ec35ce456b4aa5268039ec0847","modified":1582380659501},{"_id":"public/images/vue16.png","hash":"440b1133fee7a0d9d426531a5c1ce04688bf79bd","modified":1582380659501},{"_id":"public/images/vue15.png","hash":"79ff3d090e6b1bb59a49dcf486655fb8ac69e704","modified":1582380659501},{"_id":"public/images/vue17.png","hash":"9d0b9d78d7a427499e03f847034942c5e2e53ead","modified":1582380659501},{"_id":"public/images/tcp1.png","hash":"895c8be763dbd2d0dd9d9646e3b189cad241a583","modified":1582380659501},{"_id":"public/images/vue7.png","hash":"7c8e016f4d64ab9982bd0fbe6876c9930ff69fe4","modified":1582380659501},{"_id":"public/images/vue9.png","hash":"10e13fa4ec6044c65691a4368fb88eaa018cf8f0","modified":1582380659501},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1582380659501},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"2417fe03c7330a5160f070d6ab747a2bc4bbd41b","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"5d5d1448b199c38f1b39a49b1e9b3f1381a26cad","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"d378644ff0f7549fa6f217a08dfd2566a770638e","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"9465c5894ca2f93655fa5767b820b762aff6b518","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"453e71a65f2958480b74fdb75a53d41068699dbf","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"3fbe9822118e91350912f51f3080ce4aa9b3ec38","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1582380659501},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1582380659501},{"_id":"public/css/main.css","hash":"38d8c894437fc278d55b25017e92d339a0f2bc68","modified":1582380659501},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1582380659501},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1582380659501},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1582380659501},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1582380659501},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1582380659501},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1582380659501},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1582380659501},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1582380659501},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1582380659501},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1582380659501},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1582380659501},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1582380659501},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1582380659501},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1582380659501},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1582380659501},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1582380659501},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1582380659501},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1582380659501},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1582380659501},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1582380659501},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1582380659501},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1582380659501},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1582380659501},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1582380659501},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1582380659501},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1582380659501},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1582380659501},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1582380659501},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1582380659501},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1582380659501},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1582380659501},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1582380659501},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1582380659501},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1582380659501},{"_id":"public/js/local-search.js","hash":"66046f2ad85aa22fd64bbd0e968a498a2c5bfbaa","modified":1582380659501},{"_id":"public/js/lazyload.js","hash":"bb11c0a419de1fc4ce1ef633574ce0f9b91e1441","modified":1582380659501},{"_id":"public/js/main.js","hash":"c1bee0e5ba4f4fe121549bd1122266446810d6b2","modified":1582380659501},{"_id":"public/lib/anchor/anchor.min.js","hash":"0996588202bd062dad6f592615cb4791e1f8be91","modified":1582380659501},{"_id":"public/js/post.js","hash":"80bbd64dd5ab0873db0a5b96dc377103e1c42a78","modified":1582380659501},{"_id":"public/lib/prettify/prettify.min.js","hash":"03044b62cdb1c300537c14dcf424333fcf4c9110","modified":1582380659501},{"_id":"public/lib/github-markdown/github-markdown.min.css","hash":"23ec6f05c5b69aa8ffb12c59c9bf1325ee5a26d1","modified":1582380659501},{"_id":"public/lib/fancybox/jquery.fancybox.min.css","hash":"bfa13de0fab7defa3a25c3197e90b600c4897c34","modified":1582380659501},{"_id":"public/lib/smoothscroll/SmoothScroll.min.js","hash":"ee5dea9ea4c5edb110f30a277e5fca7993f948b5","modified":1582380659501},{"_id":"public/lib/prettify/tomorrow-night-eighties.min.css","hash":"a5f2102fc148359a92435b170f3bfb25e1221837","modified":1582380659501},{"_id":"public/lib/prettify/github-v2.min.css","hash":"da1b8e6d4df1f044d12f461880e677d65dbbf2d3","modified":1582380659501},{"_id":"public/lib/tocbot/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1582380659501},{"_id":"public/lib/typed/typed.min.js","hash":"38b792348023d55caabd7f888ae477ee143e6abe","modified":1582380659501},{"_id":"public/lib/prettify/tomorrow.min.css","hash":"ea61879c64ca73a5ea233b1315faf7f2fdfebca9","modified":1582380659501},{"_id":"public/lib/prettify/tomorrow-night.min.css","hash":"535256d676d247d3282e9a8ae2777c6f7df4fdc6","modified":1582380659501},{"_id":"public/lib/fastclick/README.html","hash":"b9e008af0866799103e596e2eda466a33d7dde18","modified":1582380659501},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"7eecc5e472416b9870580c53b7ed0c44474ed23a","modified":1582380659501},{"_id":"public/lib/jquery_lazyload/README.html","hash":"9c91bba4263a20004f2c10772d438cfa8312c308","modified":1582380659501},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1582380659501},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1582380659501},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1582380659501},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1582380659501},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1582380659501},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1582380659501},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1582380659501},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1582380659501},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1582380659501},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1582380659501},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1582380659501},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1582380659501},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1582380659501},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1582380659501},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1582380659501},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1582380659501},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1582380659501},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1582380659501},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1582380659501},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1582380659501},{"_id":"public/lib/popper/popper.min.js","hash":"27d61a7e89d12ce0744f34fa804230eeb13ff128","modified":1582380659501},{"_id":"public/lib/katex/katex.min.css","hash":"f29c27f5b804ec30acdebb8ec0488fc4a9e1538a","modified":1582380659501},{"_id":"public/lib/bootstrap/js/bootstrap.min.js","hash":"8260ff4bf54350c075bc10d18e349d158e1a4af1","modified":1582380659501},{"_id":"public/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1582380659501},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"6f4095f66e56d39ef0adefbe85a1dcfc13bd133b","modified":1582380659501},{"_id":"public/lib/fancybox/jquery.fancybox.min.js","hash":"211f4852cbb5662e11b9688bef8415ca328a88ef","modified":1582380659501},{"_id":"public/lib/mdbootstrap/js/mdb.min.js","hash":"fef8d611bbc14ad31ca9ec9e2990bfde4d873bb1","modified":1582380659501},{"_id":"public/lib/bootstrap/css/bootstrap.min.css","hash":"3665a5389b7a20dd3b2fe9cb0ed3d80bec1cf2a3","modified":1582380659501},{"_id":"public/lib/mdbootstrap/css/mdb.min.css","hash":"62818e7755b098a1c3b503425356570a2c7474d9","modified":1582380659501},{"_id":"public/images/execAfter.png","hash":"3278e77d428c21a8d1756a484e27ff2b9f3a69ac","modified":1582380659501},{"_id":"public/images/execAfter1.png","hash":"143420e95e363e944b40b011738903624f37d15c","modified":1582380659501},{"_id":"public/images/execResult2.png","hash":"cd74a1f0dba76be0c09caf36f957411c73f72e05","modified":1582380659501},{"_id":"public/images/execBefore.png","hash":"8bcd5183e9d05152ef6cb9ae8b145f0213297d76","modified":1582380659501},{"_id":"public/images/kafka1.png","hash":"8dfd3cae31730fad1ea02f3f2d07bfffaa96bb94","modified":1582380659501},{"_id":"public/images/kafka2.png","hash":"1b3ba1df82c5cd07680d211e8740403e6fa5263f","modified":1582380659501},{"_id":"public/images/redis13.png","hash":"5e580faad3222c6b681de2294398fa52c886e96d","modified":1582380659501},{"_id":"public/images/spring-ioc2.png","hash":"9ff8769766331773b52bdbd98587c8907a18d46c","modified":1582380659501},{"_id":"public/images/spring-ioc1.png","hash":"4ef7f43786dada656563c8d2f438a91eeea949c9","modified":1582380659501},{"_id":"public/images/vue19.png","hash":"29fb226b32c2c6556725a708caadec480ad5e796","modified":1582380659501},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1582380659501},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1582380659501},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"f9583bce6740a4125e14d0628ffbd946b7ddfdda","modified":1582380659501},{"_id":"public/images/redis12.png","hash":"61af62de36d91bb659b181b454c65d8a70643e3b","modified":1582380659501},{"_id":"public/images/nginx2.png","hash":"41ac22d5b004275b0c494fc82c73d472b689f935","modified":1582380659501},{"_id":"public/images/thread2.png","hash":"acd561fcd85184adfb9cd634f2698776f99f88cf","modified":1582380659501},{"_id":"public/images/redis21.png","hash":"43e27c147e57e29041764ff63a3625464e5af245","modified":1582380659501},{"_id":"public/images/mybatis4.png","hash":"24f9f9b58a7944de49211c1791486a4cdde52078","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"2b0ebea58a0bc895400dffe8c5e434c8b12338e3","modified":1582380659501},{"_id":"public/images/execResult1.png","hash":"152abfa8b8106a1f96b5ac5e1ed504f09172ed19","modified":1582380659501},{"_id":"public/images/docker7.png","hash":"a5925cf319047cf8e365b20e87adfb720fc83541","modified":1582380659501},{"_id":"public/images/mybatis2.png","hash":"04e416309a5093ee57bac52260b01796d2762f12","modified":1582380659501},{"_id":"public/images/redis20.png","hash":"2578d9e883d2200bac7ec18e0c08decaa0c0dbc0","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"7b280debee5800806092e35a6bc2c6fd9c51cf63","modified":1582380659501},{"_id":"public/images/1.png","hash":"dbaa036550e513533d58e64467adb126c6875146","modified":1582380659501},{"_id":"public/images/banner.jpg","hash":"725b3aaafe3338784a004d840e8751b27125d975","modified":1582380659501},{"_id":"public/images/testResult.png","hash":"051a44fb9aa93e5eb79b32057dc404dd47d6b1c0","modified":1582380659501},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1582380659501},{"_id":"public/images/vue1.png","hash":"3f8b94381119e0e93753bae326c2eb500f2333a0","modified":1582380659501},{"_id":"public/images/table.png","hash":"0a08748bb13db763c5977ea378124155c0d1cbd2","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"fcac55c6f9e9993cea6e2ecc729fffc36c7009b2","modified":1582380659501},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"3d24b0004b9dac32a46622cefa72cb3173b13115","modified":1582380659501},{"_id":"source/images/moon.jpg","hash":"52e6ad92f0e0d98f8a53d9bfdbde11dee5a53567","modified":1582382268286},{"_id":"public/images/moon.jpg","hash":"52e6ad92f0e0d98f8a53d9bfdbde11dee5a53567","modified":1582382312598}],"Category":[{"name":"算法","_id":"ck6xlmiyk0004v9s6fl2y529d"},{"name":"Java","_id":"ck6xlmiyp000av9s60yqe4f65"},{"name":"Mybatis","_id":"ck6xlmiyw000kv9s6ewc0ft4u"},{"name":"Java框架","_id":"ck6xlmiz1000wv9s6341naf2q"},{"name":"Web前端","_id":"ck6xlmiz8001fv9s624ute5p5"},{"name":"Docker","_id":"ck6xlmiza001qv9s68zld1x33"},{"name":"Interview","_id":"ck6xlmizd0024v9s67bno0sxr"},{"name":"Nginx","_id":"ck6xlmizg0029v9s60m0if0qy"},{"name":"数据库","_id":"ck6xlmizg002dv9s6duuc3cn7"},{"name":"Linux","_id":"ck6xlmizh002hv9s67x31dto4"}],"Data":[],"Page":[{"title":"序","date":"2018-08-01T06:40:40.000Z","tags":null,"_content":"\n<p style=\"text-align: center\">\n热衷于数学和开发\n2018年毕业\n有严重的代码洁癖\n如您所见\n技术很烂\n致此\n共勉\n</p>\n\n\n\n\n\n","source":"about/index.md","raw":"---\ntitle: 序\ndate: 2018-08-01 14:40:40\ntags: \n---\n\n<p style=\"text-align: center\">\n热衷于数学和开发\n2018年毕业\n有严重的代码洁癖\n如您所见\n技术很烂\n致此\n共勉\n</p>\n\n\n\n\n\n","updated":"2020-02-22T12:40:33.847Z","path":"about/index.html","_id":"ck6xlmiyh0001v9s6d6rh7lsc","comments":1,"layout":"page","content":"<p style=\"text-align: center\">\n热衷于数学和开发\n2018年毕业\n有严重的代码洁癖\n如您所见\n技术很烂\n致此\n共勉\n</p>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p style=\"text-align: center\">\n热衷于数学和开发\n2018年毕业\n有严重的代码洁癖\n如您所见\n技术很烂\n致此\n共勉\n</p>\n\n\n\n\n\n"},{"title":"tags","date":"2019-12-25T06:13:27.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-12-25 14:13:27\ntype: \"tags\"\n---\n","updated":"2019-12-25T06:14:00.531Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck6xlmiyj0003v9s6h28yck5g","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2019-12-25T06:05:28.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-12-25 14:05:28\ntype: \"categories\"\n---\n","updated":"2019-12-25T06:07:12.125Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck6xlmiyn0007v9s67zkbeqra","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"算法学习之各种排序算法","date":"2018-08-15T16:00:00.000Z","_content":"\n### 算法学习\n\n#### 时间复杂度\n算法有时间和空间的**复杂度**，这是可以衡量的。**时间复杂度**–运行它花了多少时间；**空间复杂度**–运行它需要多少内存。\n**常数时间**操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做**常数操作**。常数时间的操作记为**O(1)**\n\n##### 大O表示\n比如我们称算法 B 有与n²成比例的时间需求，我们说B是 **O(n²)**的(读作big O(n²))\n具体而言，在**常数操作**数量的表达式中，**只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分若记为f(N)**，那么在**最差情况下，算法流程的指标（时间复杂度**）为 O(f(N))。**\n比如符合 aN² + bN + C 操作的事件复杂度就是 **O(n²)**\n\n##### 示例\n**遍历算法：**\n比如有 1,2,3,4,5 这几个数，我们需要遍历得到这些数，那么每次遍历的时间复杂度称为**O(N)**的话，那么一共有M个数，就称遍历算法的事件复杂度是: O(M * N)。（区分 O(1) 表示常数操作，这里的 O(N) 表示时间复杂度）。\n**二分查找算法**\n比如有 1,2,3,4,5 二分查找算法，就是实现将已有数列分为Right Left 两列（不一定相等），然后依次从Right、Left中查找，如果找到了就不用找另一侧（比如在Right中查找，再将Right分为right left两列进行查找）。这种算法比遍历算法要简单。\n那么因为每次查找都是先将数列分为两列，再进行查找，那么一个数列一共可以分 logN 次，所以二分查找算法的事件复杂度就是 log(M * logN)\n\n#### 递归算法\n当解决一个问题的时候，将它划分为更小的问题且用相同的方法进行解决。这种特殊的处理称为**递归**。递归的关键是：最终你能到达一个较小的问题，且这个小问题是很容易解决的。\n故：**调用自己的方法称为递归方法**。调用是递归调用。\n设计一个递归方案，应该考虑哪些问题？\n方案的那个部分的工作能让你直接完成？\n哪些较小问题已经有了解决方案。\n该递归过程何时结束？\n若递归方法没有设计**终止情形**，将**永远执行**，这种情形称为**无穷递归**。\n总结来说：**递归函数**就是自己调用自己的函数。系统帮你压栈，将当前函数的所有信息储存到栈内存中，当调用**子过程**时，只储存每次子过程调用具体的变量值。若递归结束，调用栈顶的函数信息并还原函数的原始状态。\n\n##### 跟踪递归方法\n通常而言，跟中一个递归算法过程是比较复杂的，如果你按照一定的准则设计递归方法，一般是无需跟踪它们。这里我一个**倒计时**递归举例：\n```bash\npublic class Code_Recursive {\n\n    public static void countDown(int integer) {\n        if (integer >= 1) {\n            System.out.println(integer);\n            countDown(integer - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        countDown(3);\n    }\n}\n```\n这将打印出来3、2、1 倒计时数字，使用的正是递归的方法。它符合了以下设计准则：\n- 这个倒计时打印（显示）的工作是可以直接完成的。\n- 该递归方法最终是化小为打印一个数字，这是可以直接 sys 解决的。\n- 该递归方法执行到integer参数为1时就结束递归。\n\n**实现过程**\n![math](/images/math1.png)\n可以看到，图中是countDown(3)的递归调用过程，其中出现了多个countDown方法的副本，但其实我们就写了一个递归方法。\n也就是说对方法的每次调用（递归或非递归）Java都记录方法执行的当前状态，包含它的参数和局部变量的值，以及当前指令的位置。每个记录称为一个活动记录，它提供运行期间方法状态的快照。记录放入程序栈中。栈按照时间先后组织这些记录，所以当前正在执行的方法的记录位于栈顶。Java可以暂停递归方法的运行，并用新的变量值再次调用它。\n\n##### 时间复杂度\n**master公式**\n![math](/images/math2.png)\n\n#### 冒泡排序\n时间复杂度：O(N² )\n在一个一维数组中，冒泡排序就是实现数组中相邻两个索引位置值的大小比较，若条件符合就不动，如果条件不符合就将两个索引位置的值进行交换。且外层循环决定了外层一共需要循环多少次，且决定了外层循环一次内层需要循环多少次，外层一次循环才能排序好一个值（最大最小），下次循环就忽略掉这个极值从剩余的数据中得出极值，然后依次这样。\n![math](/images/math3.png)\n实现代码：\n```bash\npublic class Code_00_BubbleSort {\n\n    public static void bubbleSort(int[] arr) {\n        if (arr.length < 2 || arr == null) {\n            return;\n        }\n\n        for (int i = arr.length - 1; i > 0; i--) {\n            for (int j = 0; j < i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    swap(arr, j, j + 1);\n                }\n            }\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 0, 7, 4};\n        System.out.println(Arrays.toString(arr));\n        bubbleSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n其中我们对数组arr[3,2,0,7,4]进行从大到小的排序，在bubbleSort方法中，外层循环arr.length-1次，内层每次循环arr.length-1次。\n\n#### 选择排序\n时间复杂度：O(N²)\n选择排序，首先我们需要一个minIndex，记录最小值，然后将当前索引位置的值与后面索引位置的值依次比较,如果符合条件，就将此索引赋值给minIndex，再进行交换值（因为此时极限值minIndex改变了）。\n可以看到这种方式比上面的冒泡排序简单很多。\n![math](/images/math4.png)\n实现代码：\n```bash\npublic class Code_01_SelectionSort {\n\n    public static void selectionSort(int[] arr) {\n        if (arr.length < 2 || arr == null) {\n            return;\n        }\n        for (int i = 0; i < arr.length - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                minIndex = arr[j] < arr[minIndex] ? j : minIndex;\n            }\n            swap(arr, i, minIndex);\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 0, 7, 4};\n        System.out.println(Arrays.toString(arr));\n        selectionSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n#### 递归选择排序\n时间复杂度：O(N²)\n根据前面讲到的递归算法的设计，我们首先要明白：\n\n- 递归方案的哪些工作是可以直接完成的？\n\t- 1.动态替换minIndex的值；\n\t- 2.交换minIndex和当前索引；\n- 递归化到最小问题是什么？\n\t- 得到一个索引比minIndex索引对应的值要小，替换minIndex，并进行swap操作。\n- 递归何时结束？\n\t- 当循环到索引值和arr.length相等就停止递归。\n\n带着上面的思考问题，我们可以进行如下设计\n![math](/images/math5.png)\n想要通过递归实现选择排序，要知道**递归**是重复调用自己的过程。那么：\n- 首先你把sort函数理解为一个外层圈子，而其中的for()循环是内层的圈子，内层的圈子循环完毕一次（n~arr.length），就得到一个最小值。\n- 需要规定**minIndex**记录最小值的索引位置，这个值和外层的圈子有关，如果排序好的最小值不用管，直接从外层圈子范围开始循环内层圈子，所以定义for(int i=n)。\n- 如果满足内层圈子循环中arr[minIndex] > arr[i]说明此索引值比当前的minIndex还要小，那么就替换minIndex。\n- 内层圈子每**完全循环完毕**（n~arr.length），就swap替换对应索引位置的值。\n- 最后，因sort(arr, n + 1)，当n+1等于arr.length，就停止递归。\n\n实现代码：\n```bash\npublic class Code_01_Recursive_SelectionSort {\n\n    public static void sort(int[] arr, int n) {\n        int minIndex = n;\n        if (arr.length < 2 || arr == null || n >= arr.length) {\n            return;\n        }\n        for (int i = n; i < arr.length; i++) {\n            if (arr[minIndex] > arr[i]) {\n                minIndex = i;\n            }\n        }\n        swap(arr, n, minIndex);\n        sort(arr, n + 1);\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 0, 7, 4};\n        System.out.println(Arrays.toString(arr));\n        sort(arr, 0);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n#### 插入排序\n时间复杂度：O(N²)\n从无需集合的1位置开始，比较其01位置的值，如比较01、20、30、40……相当于整体是根据一个有序集合（索引），将无序集合（要排序的集合）往有序集合的区间中插入。\n![math](/images/math6.png)\n\n实现代码：\n```bash\npublic class Code_02_InsertionSort {\n\n    public static void insertionSort(int[] arr) {\n        if (arr.length < 2 || arr == null) {\n            return;\n        }\n\n        for (int i = 1; i < arr.length; i++) {\n            for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {\n                System.out.println(\"arr[\" + j + \"], arr[\" + (j + 1) + \"]\");\n                swap(arr, j, j + 1);\n            }\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 0, 7, 4};\n        System.out.println(Arrays.toString(arr));\n        insertionSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n#### 递归插入排序\n实现代码：\n```bash\npublic class Code_02_Recursive_InsertionSort {\n\n    public static void sort(int[] arr, int n) {\n        if (arr.length < 2 || arr == null || n >= arr.length) {\n            return;\n        }\n        for (int i = n; i < arr.length; i++) {\n            for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {\n                swap(arr, j, j + 1);\n            }\n        }\n        sort(arr, n + 1);\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 0, 7, 4};\n        System.out.println(Arrays.toString(arr));\n        sort(arr, 1);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n","source":"_posts/Algorithm.md","raw":"---\ntitle: 算法学习之各种排序算法\ncategories:\n    - 算法\n    \ndate: 2018-08-16\ntags:\n\t- 数据结构\n    - 算法\n---\n\n### 算法学习\n\n#### 时间复杂度\n算法有时间和空间的**复杂度**，这是可以衡量的。**时间复杂度**–运行它花了多少时间；**空间复杂度**–运行它需要多少内存。\n**常数时间**操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做**常数操作**。常数时间的操作记为**O(1)**\n\n##### 大O表示\n比如我们称算法 B 有与n²成比例的时间需求，我们说B是 **O(n²)**的(读作big O(n²))\n具体而言，在**常数操作**数量的表达式中，**只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分若记为f(N)**，那么在**最差情况下，算法流程的指标（时间复杂度**）为 O(f(N))。**\n比如符合 aN² + bN + C 操作的事件复杂度就是 **O(n²)**\n\n##### 示例\n**遍历算法：**\n比如有 1,2,3,4,5 这几个数，我们需要遍历得到这些数，那么每次遍历的时间复杂度称为**O(N)**的话，那么一共有M个数，就称遍历算法的事件复杂度是: O(M * N)。（区分 O(1) 表示常数操作，这里的 O(N) 表示时间复杂度）。\n**二分查找算法**\n比如有 1,2,3,4,5 二分查找算法，就是实现将已有数列分为Right Left 两列（不一定相等），然后依次从Right、Left中查找，如果找到了就不用找另一侧（比如在Right中查找，再将Right分为right left两列进行查找）。这种算法比遍历算法要简单。\n那么因为每次查找都是先将数列分为两列，再进行查找，那么一个数列一共可以分 logN 次，所以二分查找算法的事件复杂度就是 log(M * logN)\n\n#### 递归算法\n当解决一个问题的时候，将它划分为更小的问题且用相同的方法进行解决。这种特殊的处理称为**递归**。递归的关键是：最终你能到达一个较小的问题，且这个小问题是很容易解决的。\n故：**调用自己的方法称为递归方法**。调用是递归调用。\n设计一个递归方案，应该考虑哪些问题？\n方案的那个部分的工作能让你直接完成？\n哪些较小问题已经有了解决方案。\n该递归过程何时结束？\n若递归方法没有设计**终止情形**，将**永远执行**，这种情形称为**无穷递归**。\n总结来说：**递归函数**就是自己调用自己的函数。系统帮你压栈，将当前函数的所有信息储存到栈内存中，当调用**子过程**时，只储存每次子过程调用具体的变量值。若递归结束，调用栈顶的函数信息并还原函数的原始状态。\n\n##### 跟踪递归方法\n通常而言，跟中一个递归算法过程是比较复杂的，如果你按照一定的准则设计递归方法，一般是无需跟踪它们。这里我一个**倒计时**递归举例：\n```bash\npublic class Code_Recursive {\n\n    public static void countDown(int integer) {\n        if (integer >= 1) {\n            System.out.println(integer);\n            countDown(integer - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        countDown(3);\n    }\n}\n```\n这将打印出来3、2、1 倒计时数字，使用的正是递归的方法。它符合了以下设计准则：\n- 这个倒计时打印（显示）的工作是可以直接完成的。\n- 该递归方法最终是化小为打印一个数字，这是可以直接 sys 解决的。\n- 该递归方法执行到integer参数为1时就结束递归。\n\n**实现过程**\n![math](/images/math1.png)\n可以看到，图中是countDown(3)的递归调用过程，其中出现了多个countDown方法的副本，但其实我们就写了一个递归方法。\n也就是说对方法的每次调用（递归或非递归）Java都记录方法执行的当前状态，包含它的参数和局部变量的值，以及当前指令的位置。每个记录称为一个活动记录，它提供运行期间方法状态的快照。记录放入程序栈中。栈按照时间先后组织这些记录，所以当前正在执行的方法的记录位于栈顶。Java可以暂停递归方法的运行，并用新的变量值再次调用它。\n\n##### 时间复杂度\n**master公式**\n![math](/images/math2.png)\n\n#### 冒泡排序\n时间复杂度：O(N² )\n在一个一维数组中，冒泡排序就是实现数组中相邻两个索引位置值的大小比较，若条件符合就不动，如果条件不符合就将两个索引位置的值进行交换。且外层循环决定了外层一共需要循环多少次，且决定了外层循环一次内层需要循环多少次，外层一次循环才能排序好一个值（最大最小），下次循环就忽略掉这个极值从剩余的数据中得出极值，然后依次这样。\n![math](/images/math3.png)\n实现代码：\n```bash\npublic class Code_00_BubbleSort {\n\n    public static void bubbleSort(int[] arr) {\n        if (arr.length < 2 || arr == null) {\n            return;\n        }\n\n        for (int i = arr.length - 1; i > 0; i--) {\n            for (int j = 0; j < i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    swap(arr, j, j + 1);\n                }\n            }\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 0, 7, 4};\n        System.out.println(Arrays.toString(arr));\n        bubbleSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n其中我们对数组arr[3,2,0,7,4]进行从大到小的排序，在bubbleSort方法中，外层循环arr.length-1次，内层每次循环arr.length-1次。\n\n#### 选择排序\n时间复杂度：O(N²)\n选择排序，首先我们需要一个minIndex，记录最小值，然后将当前索引位置的值与后面索引位置的值依次比较,如果符合条件，就将此索引赋值给minIndex，再进行交换值（因为此时极限值minIndex改变了）。\n可以看到这种方式比上面的冒泡排序简单很多。\n![math](/images/math4.png)\n实现代码：\n```bash\npublic class Code_01_SelectionSort {\n\n    public static void selectionSort(int[] arr) {\n        if (arr.length < 2 || arr == null) {\n            return;\n        }\n        for (int i = 0; i < arr.length - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                minIndex = arr[j] < arr[minIndex] ? j : minIndex;\n            }\n            swap(arr, i, minIndex);\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 0, 7, 4};\n        System.out.println(Arrays.toString(arr));\n        selectionSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n#### 递归选择排序\n时间复杂度：O(N²)\n根据前面讲到的递归算法的设计，我们首先要明白：\n\n- 递归方案的哪些工作是可以直接完成的？\n\t- 1.动态替换minIndex的值；\n\t- 2.交换minIndex和当前索引；\n- 递归化到最小问题是什么？\n\t- 得到一个索引比minIndex索引对应的值要小，替换minIndex，并进行swap操作。\n- 递归何时结束？\n\t- 当循环到索引值和arr.length相等就停止递归。\n\n带着上面的思考问题，我们可以进行如下设计\n![math](/images/math5.png)\n想要通过递归实现选择排序，要知道**递归**是重复调用自己的过程。那么：\n- 首先你把sort函数理解为一个外层圈子，而其中的for()循环是内层的圈子，内层的圈子循环完毕一次（n~arr.length），就得到一个最小值。\n- 需要规定**minIndex**记录最小值的索引位置，这个值和外层的圈子有关，如果排序好的最小值不用管，直接从外层圈子范围开始循环内层圈子，所以定义for(int i=n)。\n- 如果满足内层圈子循环中arr[minIndex] > arr[i]说明此索引值比当前的minIndex还要小，那么就替换minIndex。\n- 内层圈子每**完全循环完毕**（n~arr.length），就swap替换对应索引位置的值。\n- 最后，因sort(arr, n + 1)，当n+1等于arr.length，就停止递归。\n\n实现代码：\n```bash\npublic class Code_01_Recursive_SelectionSort {\n\n    public static void sort(int[] arr, int n) {\n        int minIndex = n;\n        if (arr.length < 2 || arr == null || n >= arr.length) {\n            return;\n        }\n        for (int i = n; i < arr.length; i++) {\n            if (arr[minIndex] > arr[i]) {\n                minIndex = i;\n            }\n        }\n        swap(arr, n, minIndex);\n        sort(arr, n + 1);\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 0, 7, 4};\n        System.out.println(Arrays.toString(arr));\n        sort(arr, 0);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n#### 插入排序\n时间复杂度：O(N²)\n从无需集合的1位置开始，比较其01位置的值，如比较01、20、30、40……相当于整体是根据一个有序集合（索引），将无序集合（要排序的集合）往有序集合的区间中插入。\n![math](/images/math6.png)\n\n实现代码：\n```bash\npublic class Code_02_InsertionSort {\n\n    public static void insertionSort(int[] arr) {\n        if (arr.length < 2 || arr == null) {\n            return;\n        }\n\n        for (int i = 1; i < arr.length; i++) {\n            for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {\n                System.out.println(\"arr[\" + j + \"], arr[\" + (j + 1) + \"]\");\n                swap(arr, j, j + 1);\n            }\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 0, 7, 4};\n        System.out.println(Arrays.toString(arr));\n        insertionSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n#### 递归插入排序\n实现代码：\n```bash\npublic class Code_02_Recursive_InsertionSort {\n\n    public static void sort(int[] arr, int n) {\n        if (arr.length < 2 || arr == null || n >= arr.length) {\n            return;\n        }\n        for (int i = n; i < arr.length; i++) {\n            for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {\n                swap(arr, j, j + 1);\n            }\n        }\n        sort(arr, n + 1);\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 0, 7, 4};\n        System.out.println(Arrays.toString(arr));\n        sort(arr, 1);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n","slug":"Algorithm","published":1,"updated":"2020-02-21T15:29:49.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyb0000v9s65fq8aoqo","content":"<h3 id=\"算法学习\"><a href=\"#算法学习\" class=\"headerlink\" title=\"算法学习\"></a>算法学习</h3><h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>算法有时间和空间的<strong>复杂度</strong>，这是可以衡量的。<strong>时间复杂度</strong>–运行它花了多少时间；<strong>空间复杂度</strong>–运行它需要多少内存。<br><strong>常数时间</strong>操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做<strong>常数操作</strong>。常数时间的操作记为<strong>O(1)</strong></p>\n<h5 id=\"大O表示\"><a href=\"#大O表示\" class=\"headerlink\" title=\"大O表示\"></a>大O表示</h5><p>比如我们称算法 B 有与n²成比例的时间需求，我们说B是 <strong>O(n²)</strong>的(读作big O(n²))<br>具体而言，在<strong>常数操作</strong>数量的表达式中，<strong>只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分若记为f(N)</strong>，那么在<strong>最差情况下，算法流程的指标（时间复杂度</strong>）为 O(f(N))。**<br>比如符合 aN² + bN + C 操作的事件复杂度就是 <strong>O(n²)</strong></p>\n<h5 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h5><p><strong>遍历算法：</strong><br>比如有 1,2,3,4,5 这几个数，我们需要遍历得到这些数，那么每次遍历的时间复杂度称为<strong>O(N)</strong>的话，那么一共有M个数，就称遍历算法的事件复杂度是: O(M * N)。（区分 O(1) 表示常数操作，这里的 O(N) 表示时间复杂度）。<br><strong>二分查找算法</strong><br>比如有 1,2,3,4,5 二分查找算法，就是实现将已有数列分为Right Left 两列（不一定相等），然后依次从Right、Left中查找，如果找到了就不用找另一侧（比如在Right中查找，再将Right分为right left两列进行查找）。这种算法比遍历算法要简单。<br>那么因为每次查找都是先将数列分为两列，再进行查找，那么一个数列一共可以分 logN 次，所以二分查找算法的事件复杂度就是 log(M * logN)</p>\n<h4 id=\"递归算法\"><a href=\"#递归算法\" class=\"headerlink\" title=\"递归算法\"></a>递归算法</h4><p>当解决一个问题的时候，将它划分为更小的问题且用相同的方法进行解决。这种特殊的处理称为<strong>递归</strong>。递归的关键是：最终你能到达一个较小的问题，且这个小问题是很容易解决的。<br>故：<strong>调用自己的方法称为递归方法</strong>。调用是递归调用。<br>设计一个递归方案，应该考虑哪些问题？<br>方案的那个部分的工作能让你直接完成？<br>哪些较小问题已经有了解决方案。<br>该递归过程何时结束？<br>若递归方法没有设计<strong>终止情形</strong>，将<strong>永远执行</strong>，这种情形称为<strong>无穷递归</strong>。<br>总结来说：<strong>递归函数</strong>就是自己调用自己的函数。系统帮你压栈，将当前函数的所有信息储存到栈内存中，当调用<strong>子过程</strong>时，只储存每次子过程调用具体的变量值。若递归结束，调用栈顶的函数信息并还原函数的原始状态。</p>\n<h5 id=\"跟踪递归方法\"><a href=\"#跟踪递归方法\" class=\"headerlink\" title=\"跟踪递归方法\"></a>跟踪递归方法</h5><p>通常而言，跟中一个递归算法过程是比较复杂的，如果你按照一定的准则设计递归方法，一般是无需跟踪它们。这里我一个<strong>倒计时</strong>递归举例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_Recursive &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void countDown(int <span class=\"built_in\">integer</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">integer</span> &gt;= 1) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"built_in\">integer</span>);</span><br><span class=\"line\">            countDown(<span class=\"built_in\">integer</span> - 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        countDown(3);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这将打印出来3、2、1 倒计时数字，使用的正是递归的方法。它符合了以下设计准则：</p>\n<ul>\n<li>这个倒计时打印（显示）的工作是可以直接完成的。</li>\n<li>该递归方法最终是化小为打印一个数字，这是可以直接 sys 解决的。</li>\n<li>该递归方法执行到integer参数为1时就结束递归。</li>\n</ul>\n<p><strong>实现过程</strong><br><img src=\"/images/math1.png\" alt=\"math\"><br>可以看到，图中是countDown(3)的递归调用过程，其中出现了多个countDown方法的副本，但其实我们就写了一个递归方法。<br>也就是说对方法的每次调用（递归或非递归）Java都记录方法执行的当前状态，包含它的参数和局部变量的值，以及当前指令的位置。每个记录称为一个活动记录，它提供运行期间方法状态的快照。记录放入程序栈中。栈按照时间先后组织这些记录，所以当前正在执行的方法的记录位于栈顶。Java可以暂停递归方法的运行，并用新的变量值再次调用它。</p>\n<h5 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h5><p><strong>master公式</strong><br><img src=\"/images/math2.png\" alt=\"math\"></p>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p>时间复杂度：O(N² )<br>在一个一维数组中，冒泡排序就是实现数组中相邻两个索引位置值的大小比较，若条件符合就不动，如果条件不符合就将两个索引位置的值进行交换。且外层循环决定了外层一共需要循环多少次，且决定了外层循环一次内层需要循环多少次，外层一次循环才能排序好一个值（最大最小），下次循环就忽略掉这个极值从剩余的数据中得出极值，然后依次这样。<br><img src=\"/images/math3.png\" alt=\"math\"><br>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_00_BubbleSort &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void bubbleSort(int[] arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length &lt; 2 || arr == null) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int j = 0; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class=\"line\">                    swap(arr, j, j + 1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class=\"line\">        int tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        bubbleSort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中我们对数组arr[3,2,0,7,4]进行从大到小的排序，在bubbleSort方法中，外层循环arr.length-1次，内层每次循环arr.length-1次。</p>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><p>时间复杂度：O(N²)<br>选择排序，首先我们需要一个minIndex，记录最小值，然后将当前索引位置的值与后面索引位置的值依次比较,如果符合条件，就将此索引赋值给minIndex，再进行交换值（因为此时极限值minIndex改变了）。<br>可以看到这种方式比上面的冒泡排序简单很多。<br><img src=\"/images/math4.png\" alt=\"math\"><br>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_01_SelectionSort &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void selectionSort(int[] arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length &lt; 2 || arr == null) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class=\"line\">            int minIndex = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">                minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(arr, i, minIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class=\"line\">        int tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        selectionSort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"递归选择排序\"><a href=\"#递归选择排序\" class=\"headerlink\" title=\"递归选择排序\"></a>递归选择排序</h4><p>时间复杂度：O(N²)<br>根据前面讲到的递归算法的设计，我们首先要明白：</p>\n<ul>\n<li>递归方案的哪些工作是可以直接完成的？<ul>\n<li>1.动态替换minIndex的值；</li>\n<li>2.交换minIndex和当前索引；</li>\n</ul>\n</li>\n<li>递归化到最小问题是什么？<ul>\n<li>得到一个索引比minIndex索引对应的值要小，替换minIndex，并进行swap操作。</li>\n</ul>\n</li>\n<li>递归何时结束？<ul>\n<li>当循环到索引值和arr.length相等就停止递归。</li>\n</ul>\n</li>\n</ul>\n<p>带着上面的思考问题，我们可以进行如下设计<br><img src=\"/images/math5.png\" alt=\"math\"><br>想要通过递归实现选择排序，要知道<strong>递归</strong>是重复调用自己的过程。那么：</p>\n<ul>\n<li>首先你把sort函数理解为一个外层圈子，而其中的for()循环是内层的圈子，内层的圈子循环完毕一次（n~arr.length），就得到一个最小值。</li>\n<li>需要规定<strong>minIndex</strong>记录最小值的索引位置，这个值和外层的圈子有关，如果排序好的最小值不用管，直接从外层圈子范围开始循环内层圈子，所以定义for(int i=n)。</li>\n<li>如果满足内层圈子循环中arr[minIndex] &gt; arr[i]说明此索引值比当前的minIndex还要小，那么就替换minIndex。</li>\n<li>内层圈子每<strong>完全循环完毕</strong>（n~arr.length），就swap替换对应索引位置的值。</li>\n<li>最后，因sort(arr, n + 1)，当n+1等于arr.length，就停止递归。</li>\n</ul>\n<p>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_01_Recursive_SelectionSort &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void sort(int[] arr, int n) &#123;</span><br><span class=\"line\">        int minIndex = n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length &lt; 2 || arr == null || n &gt;= arr.length) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = n; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[minIndex] &gt; arr[i]) &#123;</span><br><span class=\"line\">                minIndex = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(arr, n, minIndex);</span><br><span class=\"line\">        sort(arr, n + 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class=\"line\">        int tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        sort(arr, 0);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p>时间复杂度：O(N²)<br>从无需集合的1位置开始，比较其01位置的值，如比较01、20、30、40……相当于整体是根据一个有序集合（索引），将无序集合（要排序的集合）往有序集合的区间中插入。<br><img src=\"/images/math6.png\" alt=\"math\"></p>\n<p>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_02_InsertionSort &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void insertionSort(int[] arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length &lt; 2 || arr == null) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"arr[\"</span> + j + <span class=\"string\">\"], arr[\"</span> + (j + 1) + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">                swap(arr, j, j + 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class=\"line\">        int tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        insertionSort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"递归插入排序\"><a href=\"#递归插入排序\" class=\"headerlink\" title=\"递归插入排序\"></a>递归插入排序</h4><p>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_02_Recursive_InsertionSort &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void sort(int[] arr, int n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length &lt; 2 || arr == null || n &gt;= arr.length) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = n; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;</span><br><span class=\"line\">                swap(arr, j, j + 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(arr, n + 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class=\"line\">        int tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        sort(arr, 1);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"算法学习\"><a href=\"#算法学习\" class=\"headerlink\" title=\"算法学习\"></a>算法学习</h3><h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>算法有时间和空间的<strong>复杂度</strong>，这是可以衡量的。<strong>时间复杂度</strong>–运行它花了多少时间；<strong>空间复杂度</strong>–运行它需要多少内存。<br><strong>常数时间</strong>操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做<strong>常数操作</strong>。常数时间的操作记为<strong>O(1)</strong></p>\n<h5 id=\"大O表示\"><a href=\"#大O表示\" class=\"headerlink\" title=\"大O表示\"></a>大O表示</h5><p>比如我们称算法 B 有与n²成比例的时间需求，我们说B是 <strong>O(n²)</strong>的(读作big O(n²))<br>具体而言，在<strong>常数操作</strong>数量的表达式中，<strong>只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分若记为f(N)</strong>，那么在<strong>最差情况下，算法流程的指标（时间复杂度</strong>）为 O(f(N))。**<br>比如符合 aN² + bN + C 操作的事件复杂度就是 <strong>O(n²)</strong></p>\n<h5 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h5><p><strong>遍历算法：</strong><br>比如有 1,2,3,4,5 这几个数，我们需要遍历得到这些数，那么每次遍历的时间复杂度称为<strong>O(N)</strong>的话，那么一共有M个数，就称遍历算法的事件复杂度是: O(M * N)。（区分 O(1) 表示常数操作，这里的 O(N) 表示时间复杂度）。<br><strong>二分查找算法</strong><br>比如有 1,2,3,4,5 二分查找算法，就是实现将已有数列分为Right Left 两列（不一定相等），然后依次从Right、Left中查找，如果找到了就不用找另一侧（比如在Right中查找，再将Right分为right left两列进行查找）。这种算法比遍历算法要简单。<br>那么因为每次查找都是先将数列分为两列，再进行查找，那么一个数列一共可以分 logN 次，所以二分查找算法的事件复杂度就是 log(M * logN)</p>\n<h4 id=\"递归算法\"><a href=\"#递归算法\" class=\"headerlink\" title=\"递归算法\"></a>递归算法</h4><p>当解决一个问题的时候，将它划分为更小的问题且用相同的方法进行解决。这种特殊的处理称为<strong>递归</strong>。递归的关键是：最终你能到达一个较小的问题，且这个小问题是很容易解决的。<br>故：<strong>调用自己的方法称为递归方法</strong>。调用是递归调用。<br>设计一个递归方案，应该考虑哪些问题？<br>方案的那个部分的工作能让你直接完成？<br>哪些较小问题已经有了解决方案。<br>该递归过程何时结束？<br>若递归方法没有设计<strong>终止情形</strong>，将<strong>永远执行</strong>，这种情形称为<strong>无穷递归</strong>。<br>总结来说：<strong>递归函数</strong>就是自己调用自己的函数。系统帮你压栈，将当前函数的所有信息储存到栈内存中，当调用<strong>子过程</strong>时，只储存每次子过程调用具体的变量值。若递归结束，调用栈顶的函数信息并还原函数的原始状态。</p>\n<h5 id=\"跟踪递归方法\"><a href=\"#跟踪递归方法\" class=\"headerlink\" title=\"跟踪递归方法\"></a>跟踪递归方法</h5><p>通常而言，跟中一个递归算法过程是比较复杂的，如果你按照一定的准则设计递归方法，一般是无需跟踪它们。这里我一个<strong>倒计时</strong>递归举例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_Recursive &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void countDown(int <span class=\"built_in\">integer</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">integer</span> &gt;= 1) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"built_in\">integer</span>);</span><br><span class=\"line\">            countDown(<span class=\"built_in\">integer</span> - 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        countDown(3);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这将打印出来3、2、1 倒计时数字，使用的正是递归的方法。它符合了以下设计准则：</p>\n<ul>\n<li>这个倒计时打印（显示）的工作是可以直接完成的。</li>\n<li>该递归方法最终是化小为打印一个数字，这是可以直接 sys 解决的。</li>\n<li>该递归方法执行到integer参数为1时就结束递归。</li>\n</ul>\n<p><strong>实现过程</strong><br><img src=\"/images/math1.png\" alt=\"math\"><br>可以看到，图中是countDown(3)的递归调用过程，其中出现了多个countDown方法的副本，但其实我们就写了一个递归方法。<br>也就是说对方法的每次调用（递归或非递归）Java都记录方法执行的当前状态，包含它的参数和局部变量的值，以及当前指令的位置。每个记录称为一个活动记录，它提供运行期间方法状态的快照。记录放入程序栈中。栈按照时间先后组织这些记录，所以当前正在执行的方法的记录位于栈顶。Java可以暂停递归方法的运行，并用新的变量值再次调用它。</p>\n<h5 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h5><p><strong>master公式</strong><br><img src=\"/images/math2.png\" alt=\"math\"></p>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p>时间复杂度：O(N² )<br>在一个一维数组中，冒泡排序就是实现数组中相邻两个索引位置值的大小比较，若条件符合就不动，如果条件不符合就将两个索引位置的值进行交换。且外层循环决定了外层一共需要循环多少次，且决定了外层循环一次内层需要循环多少次，外层一次循环才能排序好一个值（最大最小），下次循环就忽略掉这个极值从剩余的数据中得出极值，然后依次这样。<br><img src=\"/images/math3.png\" alt=\"math\"><br>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_00_BubbleSort &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void bubbleSort(int[] arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length &lt; 2 || arr == null) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int j = 0; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class=\"line\">                    swap(arr, j, j + 1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class=\"line\">        int tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        bubbleSort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中我们对数组arr[3,2,0,7,4]进行从大到小的排序，在bubbleSort方法中，外层循环arr.length-1次，内层每次循环arr.length-1次。</p>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><p>时间复杂度：O(N²)<br>选择排序，首先我们需要一个minIndex，记录最小值，然后将当前索引位置的值与后面索引位置的值依次比较,如果符合条件，就将此索引赋值给minIndex，再进行交换值（因为此时极限值minIndex改变了）。<br>可以看到这种方式比上面的冒泡排序简单很多。<br><img src=\"/images/math4.png\" alt=\"math\"><br>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_01_SelectionSort &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void selectionSort(int[] arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length &lt; 2 || arr == null) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class=\"line\">            int minIndex = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">                minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(arr, i, minIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class=\"line\">        int tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        selectionSort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"递归选择排序\"><a href=\"#递归选择排序\" class=\"headerlink\" title=\"递归选择排序\"></a>递归选择排序</h4><p>时间复杂度：O(N²)<br>根据前面讲到的递归算法的设计，我们首先要明白：</p>\n<ul>\n<li>递归方案的哪些工作是可以直接完成的？<ul>\n<li>1.动态替换minIndex的值；</li>\n<li>2.交换minIndex和当前索引；</li>\n</ul>\n</li>\n<li>递归化到最小问题是什么？<ul>\n<li>得到一个索引比minIndex索引对应的值要小，替换minIndex，并进行swap操作。</li>\n</ul>\n</li>\n<li>递归何时结束？<ul>\n<li>当循环到索引值和arr.length相等就停止递归。</li>\n</ul>\n</li>\n</ul>\n<p>带着上面的思考问题，我们可以进行如下设计<br><img src=\"/images/math5.png\" alt=\"math\"><br>想要通过递归实现选择排序，要知道<strong>递归</strong>是重复调用自己的过程。那么：</p>\n<ul>\n<li>首先你把sort函数理解为一个外层圈子，而其中的for()循环是内层的圈子，内层的圈子循环完毕一次（n~arr.length），就得到一个最小值。</li>\n<li>需要规定<strong>minIndex</strong>记录最小值的索引位置，这个值和外层的圈子有关，如果排序好的最小值不用管，直接从外层圈子范围开始循环内层圈子，所以定义for(int i=n)。</li>\n<li>如果满足内层圈子循环中arr[minIndex] &gt; arr[i]说明此索引值比当前的minIndex还要小，那么就替换minIndex。</li>\n<li>内层圈子每<strong>完全循环完毕</strong>（n~arr.length），就swap替换对应索引位置的值。</li>\n<li>最后，因sort(arr, n + 1)，当n+1等于arr.length，就停止递归。</li>\n</ul>\n<p>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_01_Recursive_SelectionSort &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void sort(int[] arr, int n) &#123;</span><br><span class=\"line\">        int minIndex = n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length &lt; 2 || arr == null || n &gt;= arr.length) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = n; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[minIndex] &gt; arr[i]) &#123;</span><br><span class=\"line\">                minIndex = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(arr, n, minIndex);</span><br><span class=\"line\">        sort(arr, n + 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class=\"line\">        int tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        sort(arr, 0);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p>时间复杂度：O(N²)<br>从无需集合的1位置开始，比较其01位置的值，如比较01、20、30、40……相当于整体是根据一个有序集合（索引），将无序集合（要排序的集合）往有序集合的区间中插入。<br><img src=\"/images/math6.png\" alt=\"math\"></p>\n<p>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_02_InsertionSort &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void insertionSort(int[] arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length &lt; 2 || arr == null) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"arr[\"</span> + j + <span class=\"string\">\"], arr[\"</span> + (j + 1) + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">                swap(arr, j, j + 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class=\"line\">        int tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        insertionSort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"递归插入排序\"><a href=\"#递归插入排序\" class=\"headerlink\" title=\"递归插入排序\"></a>递归插入排序</h4><p>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Code_02_Recursive_InsertionSort &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void sort(int[] arr, int n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length &lt; 2 || arr == null || n &gt;= arr.length) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = n; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;</span><br><span class=\"line\">                swap(arr, j, j + 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(arr, n + 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class=\"line\">        int tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">        sort(arr, 1);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Java基础（一）","date":"2018-07-31T16:00:00.000Z","_content":"\n记录一些Java基础的知识点，为了自己查阅资料的时候方便一些。\n\n---\n### Java基础\n\n#### JDK和JRE的区别？\n\n1、jre即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库\n2、jdk是Java开发工具包，例如：tools.jar\n\n---\n\n#### == 和 equals的区别\n\n1、==是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址\n2、equals是超类Object就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。equals方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。\nObject类equals方法源码：\n```bash\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\nnew对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，举个栗子：\n```bash\npublic class EqualsTest {\n\n    public static void main(String[] args) {\n        User a = new User();\n        User b = new User();\n        System.out.println(a == b); //false\n        System.out.println(a.equals(b)); //true\n    }\n}\n\nclass User {\n    private int age;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof User)) return false;\n        User user = (User) o;\n        return age == user.age;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(age);\n    }\n}\n```\n---\n\n#### 两个对象的hashCode()相同，则equals()一定为true？\n**如果两个对象相等(equals()为true)，那么他们的hashCode()一定相同**\n**如果两个对象的hashCode()相同，他们的equals()方法不一定相同**\n\nJVM虚拟机通过hashCode()方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过hashCode()获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用equals()与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用equals()方法比较的次数。\n\n```bash\npublic class EqualsTest {\n\n    public static void main(String[] args) {\n        User a = new User();\n        User b = new User();\n        System.out.println(a == b); //false\n        System.out.println(a.equals(b)); //false\n        System.out.println(a.hashCode() == b.hashCode()); //false\n    }\n}\n\nclass User {\n    private int age;\n}\n```\n---\n\n#### final的作用\n可修饰类、类属性、类方法。\n1、被final修饰的类不能被继承\n2、final修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。\n```bash\npublic class FinalTest {\n\n    private static final User USER = new User();\n\n    public static void main(String[] args) {\n        User u2 = new User();\n//        user = u2; // ERROR\n        USER.age = 23;\n    }\n}\n\nclass User {\n    int age = 12;\n}\n```\n3、类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。\n\n---\n\n#### String属于基本数据类型吗？\n\n**不，String属于特殊的引用类型**\n\nJava中基本数据类型有：int、short、long、char、boolean、float、double、byte\n\n1、String是特殊的引用类型并且是final的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。\n2、String s = \"a\"; s += \"b\";，这段代码执行前后，字符串常量池中将出现a和ab两个字符串常量，而原本s变量的引用指向了常量池中ab。\n3、String s = new String(\"ab\")，这段代码一共创建了几个对象？一个或两个。如果字符串常量池中有了ab这个字符串(比如在此之前已经使用了String str = \"ab\")，那么新的s对象引用其实仅仅是指向了字符串常量中的ab，并没有创建新的字符串对象。但是，每次调用new都会在堆内存开辟空间，创建一个String对象，这是肯定的。\n\n栗子：\n```bash\npublic class StringTest {\n\n    public static void main(String[] args) {\n        String a = \"abc\";\n        String b = \"abc\";\n        String c = new String(\"abc\");\n        System.out.println(a == b); //true\n        System.out.println(a.equals(b)); //true\n        System.out.println(a.equals(c)); //true\n    }\n}\n```\n\n**String和StringBuffer和StringBuilder的区别**\n1、String是不可变字符串，StringBuffer和StringBuilder是可变字符串。如果经常改变字符串的原始数据，最好使用StringBuffer代替。\n2、String默认重写了equals方法和hashCode()方法；而StringBuffer没有重写equals方法，使用new StringBuffer(\"\")会直接在堆内存中开辟空间储存对象。因此将StringBuffer对象储存仅Java集合中可能会出现问题。\n3、StringBuffer是线程安全的，效率低；StringBuilder是线程不安全的，效率高。\n\n---\n\n#### static关键字？是否可覆盖？\n\nstatic关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。\n\nstatic标记的方法只能访问static变量或方法\n非static标记的方法可以访问static或非static标记的变量或方法\n\n---\n\n#### 自动拆、装箱\n\n因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。\n具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)\n\n基本数据类型|引用数据类型\n:--:|:--:\nint|Integer\nbyte|Byte\nshort|Short\nlong|Long\nfloat|Float\ndouble|Double\nchar|Char\nboolean|Boolean\n\n栗子：\n```bash\npublic static void main(String[] args) {\n    Integer i1 = 100;\n    Integer i2 = 100;\n    Integer i3 = 200;\n    Integer i4 = 200;\n    System.out.println(i1 == i2);\n    System.out.println(i3 == i4);\n}\n```\n\n结果：\n```bash\ntrue\nfalse\n```\n\nJava中实现基本数据类型和引用类型之间的拆装箱一般都是用过valueOf()方法实现的。例如我们看下Integer类的valueOf()方法源码：\n```bash\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n\n可以看到：当声明一个新的整数型变量，编译时通过Integer类的valueOf()进行拆装箱计算，这个方法会首先比较这个整数值是否在IntegerCache的范围内，如果在就返回IntegerCache类中的数值；如果不在就直接new Integer。那么我们看下IntegerCache类源码：\n\n```bash\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n```\n所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在[-128, 127]之间，就直接返回IntegerCache中储存的常量值，否则就直接new一个新的Integer来保存这个常量值。所以上面才会出现false的结果。\n同理：其他的数据类型例如：long、short等都具有对应的LongCache、ShortCache等类。\n\n---\n\n#### Overriding和Overloaded\n方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。\nOverriding: 子类中定义了和父类中名称、参数列表相同的方法\nOverloaded: 方法名相同，参数列表不同\n\n---\n\n#### Java支持多继承吗？\n不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过多层继承实现。\n类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。\n从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。\n\n---\n\n#### 接口和抽象类的区别？\n\n+ 接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。\n+ 接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )\n+ 类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )\n+ 抽象类可以是不提供接口方法实现的情况下实现接口\n+ 接口中声明的变量默认都是final的；但抽象类可以包含非final的变量\n+ 接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public\n+ 接口是绝对抽象的，不可以被实例化；\n\n---\n\n#### 引用传递和值传递\n\n**Java中采用值传递的方式**\n栗子：\n```bash\npublic class TransferTest {\n\n\n    public static void main(String[] args) {\n        int a = 1;\n        Integer b = 2;\n        swap(a, b);\n        System.out.println(a);\n        System.out.println(b);\n\n        int[] arr = {1, 2};\n        swap(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    private static void swap(int[] arr) {\n        arr[0] = 10;\n    }\n\n    private static void swap(int a, Integer b) {\n        a = 10;\n        b = 20;\n    }\n}\n```\n\n方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。\n所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。\n\n---\n\n#### IO流\n\n![IO流](/images/io.png)\n\n**1、Java中有几种类型的流？**\n字符流和字节流。字节流继承InputStream和OutputStream；字符流继承自InputStreamReader和OutputStreamWriter。\n\n**2、谈谈Java IO中的方法阻塞**\nJava中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。\n\n**3、字符流和字节流的区别？**\n数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。\n而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。\n字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。\n\n**4、NIO**\n传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read()等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept()时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。\n而对于NIO，它是非阻塞式，核心类：\n+ Buffer： 为所有的原始类型提供Buffer缓冲支持\n+ Charset： 字符集编码解码解决方案\n+ Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接。\n\n---\n\n#### 说说List、Set、Map三者的区别\n\n+ List: List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素\n+ Set: 不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素\n+ Map: 使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。\n\n---\n\n#### Array和ArrayList有什么区别？\n\n+ Array可以包含基本类型和对象类型；ArrayList只能包含对象类型\n+ Array大小是固定的；ArrayList大小是动态变化的\n+ ArrayList提供了诸如addAll()、removeAll()、iterator()方法等\n+ 对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。\n\n---\n\n#### ArrayList和LinkedList的区别？\n\n1、**是否保证线程安全**： ArrayList和LinkedList都是不同步的，也就是不保证线程安全\n2、**底层数据结构**： ArrayList底层使用的是Object数组；LinkedList底层使用的是 双向链表 结构\n3、**插入和删除是否受元素位置影响？** ArrayList采用数组储存，所以插入和删除元素都受元素位置的影响；LinkedList 采用链表储存，所以插入、删除元素都不受元素位置影响。\n4、**是否支持快速随机访问？** LinkedList因为使用链表储存，无法通过元素索引快速访问；而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。\n5、**内存空间占用**： ArrayList的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而LinkedList的空间花费体现在他的每一个元素都需要消耗比ArrayList更多的空间（因为要储存直接后继和直接前驱以及数据）。\n\n---\n\n**什么是迭代器**\n*Iterator*接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法*iterator()*。迭代器在迭代的过程中可以删除底层集合的元素。\n\n**Iterator和ListIterator的区别？**\n+ Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List\n+ Iterator对集合只能向前遍历（next()）；而*ListIterator可以向前遍历（next()），也可以向后遍历（previous()）\n+ ListIterator实现了Iterator接口\n\n**RandomAccess接口**\n```bash\n//ArrayList\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{}\n\n//RandomAccess\npublic interface RandomAccess {\n}\n\n//LinkedList\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n{}\n```\n\n源码中ArrayList类实现了RandomAccess接口，LinkedList类中却没有实现这个接口，但是RandomAccess接口中却什么也没有定义。可以看RandomAccess接口上的注释：\n```bash\n/**\n * Marker interface used by <tt>List</tt> implementations to indicate that\n * they support fast (generally constant time) random access.  The primary\n * purpose of this interface is to allow generic algorithms to alter their\n * behavior to provide good performance when applied to either random or\n * sequential access lists.\n */\n```\n大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看Collections类中的binarySearch方法：\n```bash\npublic static <T>\nint binarySearch(List<? extends Comparable<? super T>> list, T key) {\n    if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key);\n    else\n        return Collections.iteratorBinarySearch(list, key);\n}\n\nprivate static <T>\nint indexedBinarySearch(List<? extends Comparable<? super T>> list, T key) {\n    int low = 0;\n    int high = list.size()-1;\n\n    while (low <= high) {\n        int mid = (low + high) >>> 1;\n        Comparable<? super T> midVal = list.get(mid);\n        int cmp = midVal.compareTo(key);\n\n        if (cmp < 0)\n            low = mid + 1;\n        else if (cmp > 0)\n            high = mid - 1;\n        else\n            return mid; // key found\n    }\n    return -(low + 1);  // key not found\n}\n\nprivate static <T>\nint iteratorBinarySearch(List<? extends Comparable<? super T>> list, T key)\n{\n    int low = 0;\n    int high = list.size()-1;\n    ListIterator<? extends Comparable<? super T>> i = list.listIterator();\n\n    while (low <= high) {\n        int mid = (low + high) >>> 1;\n        Comparable<? super T> midVal = get(i, mid);\n        int cmp = midVal.compareTo(key);\n\n        if (cmp < 0)\n            low = mid + 1;\n        else if (cmp > 0)\n            high = mid - 1;\n        else\n            return mid; // key found\n    }\n    return -(low + 1);  // key not found\n}\n```\n\nbinarySearch()方法是从List中查找指定元素，其中首先判断传入的List时候实现了RandomAccess接口，如果实现了就调用indexedBinarySearch()方法，否则就调用iteratorBinarySearch()方法。再看这两个方法的源码：\n如果传入的List实现了RandomAccess接口，采用普通for循环遍历\n若传入的List未实现RandomAccess接口，采用iterator遍历\n\n**链表**\n\n**链表（Linked List）**由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针\n>单向链表\n单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。\n+ 单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找\n![单向链表](/images/linktable1.png)\n\n+ 单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可\n![单向链表](/images/linktable2.png)\n\n+ 删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可\n![单向链表](/images/linktable3.png)\n\n>双向链表\n**双向链表** 包含两个指针，prev指向前一个节点，next指向后一个节点。\n![双向链表](/images/linktable4.png)\n\n>双向循环链表\n**双向循环链表** 最后一个节点的*next*指向*head*，而*head*的*prev*指向最后一个节点，形成一个环。\n![双向循环链表](/images/linktable5.png)\n\n---\n\n#### ArrayList和Vector和LinkedList的区别？\n+ **ArrayList**: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高\n+ **Vector**: 底层数据结构是数组，查询快，增删慢。线程安全，效率低\n+ **LinkedList**: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高\n\n---\n\n#### 谈谈ArrayList的扩容机制\nJava中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，ArrayList的出现就解决了这一问题。\nArrayList的扩容机制表现在add()方法上，先看add()方法的源码：\n```bash\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\n//获取最小容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\n//判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n```\n\n当向ArrayList对象中添加新元素时，首先会调用ensureCapacityInternal(size)方法，size为最小扩容量；ensureCapacityInternal()方法会首先调用calculateCapacity来确定需要的最小容量；最后调用ensureExplicitCapacity()方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用grow()方法扩容：\n```bash\nprivate void grow(int minCapacity) {\n    // 获取ArrayList中elementDaata数组的长度\n    int oldCapacity = elementData.length;\n    // 扩容至原来的1.5倍\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    // 判断新的数组容量够不够\n    // 够了就直接使用这个长度创建新数组\n    if (newCapacity - minCapacity < 0)\n        // 不够就将数组的长度设置为需要的长度\n        newCapacity = minCapacity;\n    // 检查此时的最大值是否溢出\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // 调用Arrays.copyOf()将elementData数组数据拷贝到新数组\n    // 并将elementData指向新数组newCapacity的内存地址\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n**总结**： ArrayList扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。\n\n---\n\n#### HashMap和HashTable的区别？\n1、HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度\n2、线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰。\n3、效率: HashMap线程不安全效率高，HashTable线程安全效率低。\n3、对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null\n5、底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制。\n\n---\n\n#### HashMap和HashSet区别?\n**HashSet底层采用HashMap实现**\nHashMap|HashSet\n:--|:--\n实现了Map接口|实现了Set接口\n储存键值堆|仅储存对象\n调用put()向Map中添加元素|调用add()向Set中添加元素\nHashMap使用Key计算HashCode|HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以用equals判断对象的相等性\n\n---\n\n#### HashSet如何检查重复？\n在前面讲hashCode和equals时就提到了，HashSet集合同样适用。向HashSet中存入一个元素，HashSet首先会根据对象的hashCode值判断当期集合中此hashCode对应的位置有没有值，如果没有就直接添加，如果有就再调用equals方法比较两个对象是否相同，相同就不再储存（保证了Set集合不重复的特性），否则就散列到其他位置储存。\n\n---\n\n#### HashMap底层实现？\nMap在Java中的实现由很多，HashMap便是其中之一，随着JDK版本的更新，HashMap的实现也在不断更新：\n+ <=JDK1.7: Table数组 + Entry链表\n+ >=JDK1.8: Table数组 + Entry链表/红黑树\n\n#### Hash\n\n**Hash（哈希、散列）**，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。\nHash函数的一种实现：\n直接取余法： f(x) = x mod max\n位运算法： f(x) = x & max\nHashMap采用 位运算法，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：\n```bash\n7 & 33 = 1\n    \n    000111\n  & 100001\n  --------\n    000001 = 1\n\n```\n\n---\n\n#### Hash冲突\n假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到HashMap集合中，若将多个K-V数据存入put，HashMap根据元素key计算到对应的hashCode值，如果计算得到多个不同的key对应的hashCode值相同（即要储存到同一位置），此时这种现象就称为 Hash冲突。\nHashMap默认采用了 链地址法 解决Hash冲突问题，即通过类似单链表的方式将 冲突的元素 串起来，搜索时遍历这个链表即可。注意： 如果冲突的Hash越来越多，这个链就会越来越长。\n\n---\n\n#### 实现原理\n![hash冲突与实现原理](/images/hash1.png)\n这里我们需要了解两个名词：\nTable: 哈希桶数组（哈希表），存放Node元素，底层是一个Node[] table\nNode: 节点元素，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（K-V）\nHashMap内部的一些关键属性需要了解：\nDEFAULT_INITIAL_CAPACITY: Tabale数组的初始化长度，默认是1 << 4，2^4 = 16\nMAXIMUM_CAPACITY: Table数组最高长度，默认为1 << 30，2^30 = 1073741824\nDEFAULT_LOAD_FACTOR: 负载因子，当总元素数 > 数组长度 * 负载因子时，Table数组将扩容，默认是0.75\nTREEIFY_THRESHOLD: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8\nUNTREEIFY_THRESHOLD: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6\nMIN_TREEIFY_CAPACITY: 最小树化阀值，当Table中所有元素超过该值，才会进行树化\nsize: 当前HashMap实际存在的键值对数量\nthreshold: HashMap所能容纳的最大数据量的Node（键值对）个数。Node[] table初始化长度length是16，loadFactor负载因子默认是0.75，threshold = length * loadFactor\nloadFactor: 负载因子，默认是0.17\nmodCount: 记录HashMap内部结构发生变化的次数\nHashMap内部存在一个NodeTable数组，这个数组的初始化长度是DEFAULT_INITIAL_CAPACITY，他是一个单向链表：\n```bash\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; //key的Hash值\n    final K key; //key\n    V value; //value\n    Node<K,V> next; //下一个节点\n}\n```\n\n参考单链表的结构，Table中每个Node节点包含两个部分，Node元素作为节点的header，next指向下一个节点。**这种链式结构的存在正是为了解决Hash冲突**\n\n栗子：\n```bash\nmap.put(\"loonycoder\", \"18\");\n```\nHashMap将根据\"loonycoder\"这个Key得到其hashCode值，然后经过Hash算法定位到其在HashMap储存的位置，如果两个不同的key定位到了同一个位置，此时就发生了Hash冲突。\n在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过TREEIFY_THRESHOLD阀值后，会将链表转换为红黑树的实现TreeNode:\n```bash\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n    TreeNode<K,V> parent;  // red-black tree links\n    TreeNode<K,V> left;\n    TreeNode<K,V> right;\n    TreeNode<K,V> prev;    // needed to unlink next upon deletion\n    boolean red;\n}\n```\n当发生**Hash冲突**时，根据HashMap默认采用的 **链地址法**，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。但是 随着Hash冲突越来越多，这个**链将越来越长**，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。\n![地址链法](http://cdn.tycoding.cn/JDK1.8之后的HashMap底层数据结构.jpg)\n\n**总结**\n到此，我们总结一下HashMap的实现原理：\n+ HashMap根据key的hashCode值存储元素。put新元素会遍历链表，根据新元素的key计算hashCode得到散列位置，如果该位置有值再调用equals判断value是否相同，相同就散列到其他位置储存。\n+ HashMap在put新元素时如果遇到key对应的hashCode相同，可能会产生Hash冲突问题。HashMap的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。\n+ 如果发生Hash冲突的元素很多，这个 **链** 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（TreeNode）存储元素。\n\n---\n\n#### Collection和Collections的区别？\n+ Collection是集合类的上级接口，继承他的接口主要有Set和List\n+ Collections仅是针对集合类封装的一个工具类，在java.util包下\n\n---\n\n#### Comparable和Comparator的区别？\n\n+ Comparable接口来自java.lang包，提供compareTo(Object obj) 方法排序\n+ Comparator接口来自java.util包，提供compare(Object obj1, Object obj2)方法排序\n当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。\n\n#### Java集合框架总结\n\n##### Collection\n![Collection](/images/collection1.png)\n\n**List**\n\nArrayList: Object数组，线程不安全，查询快，增删慢，效率高\nVector: Object数组，线程安全，查询快，增删慢，效率低\nLinkedList: 双向链表，线程不安全，查询慢，增删快，效率高\n\n**Set**\n\nHashSet: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素\nLinkedHashSet: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现\nTreeSet 有序、唯一，红黑树\n\n##### Map\n![Map](/images/map1.png)\n\n+ HashMap: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。\n+ LinkedHashMap: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。\n+ HashTable: 数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题\nTreeMap: 红黑树\n\n---\n\n### Java并发\n\n#### 线程和进程的区别？\n+ 进程是程序的一次执行过程，是系统运行程序的基本单位\n+ 线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，\n在Java中，启用一个main方法就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。\n\n---\n\n#### 从JVM角度分析进程和线程的关系？\n根据JVM的内存划分，对于线程而言：多个线程共享进程的堆、方法区资源，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。\n\n也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。\n\n##### 为什么方法区和堆是线程共享区？\n+ **方法区（Method Area）** 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 运行时常量池 ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。\n+ **堆（Heap）** 堆内存储存了对象实例（比如new关键字创建的实例对象），它是JVM中内存区最大的一块区域。\n所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。\n\n##### 为什么虚拟机栈和本地方法栈是线程独占区？\n+ **虚拟机栈**： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。\n+ **本地方法栈**： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。\n\n##### 程序计数器是什么？\n\n**程序计数器（Program Counter Register）**：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。\n\n---\n\n#### 说说并行和并发的区别？\n+ **并行**： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）\n+ **并发**： 单位时间内，多个任务同时执行。\n\n---\n\n#### 使用多线程可能带来什么问题？\n并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题\n\n---\n\n#### 说说线程的生命周期和状态？\n状态名称|状态说明\n:--|:--\nnew|初始状态，线程被创建，但还没有调用start()方法\nrunnable|运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”\nblocked|阻塞状态，表示线程阻塞于锁\nwaiting|等待状态，线程需要等待当前线程或其他线程执行完成\ntime_waiting|超时等待状态，他可以实现在指定时间后自动返回\nterminated|终止状态，表示当前线程已经执行完毕\n\n对应，程序会因为不同代码的执行产生不同的状态，如下图：\n![线程图](/images/thread2.png)\n如上，线程创建后将进入NEW（初始）状态，调用start()开始运行，当线程执行wait()方法后，线程将进入WAITING（等待）状态，可以通过wait(long)或join(long)等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED（阻塞）状态。\n\n---\n\n#### 什么是上下文切换？\n简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用**随机分配时间片并轮转**的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 **任务从保存到再加载的过程就是一次上下文切换**。\n\n---\n\n#### 什么是死锁？如何避免?\n举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。\n![死锁](/images/deadlock.png)\n栗子：\n```bash\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();//资源 1\n    private static Object resource2 = new Object();//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\nOutput：\n\n```bash\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n```\n线程1以resource1作为同步监视器，即可以轻松获取resource1同时也锁定了resource1，此时调用sleep让线程1等待1秒钟；此时线程2开始执行，他以resource2作为同步监视器同时也锁定了resource2，此时调用sleep让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取resource2时发现resource2已经被线程2锁定了，同理线程2结束等待后想要获取resource1时发现resource1已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。\n因此产生死锁需要具备以下四个条件：\n\n1、互斥条件：该资源任意一个时刻只能由一个线程占用\n2、请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放\n3、不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源\n4、循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。\n\n避免死锁就要破坏这四个条件中任意一个：\n1、破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥\n2、破坏请求与保持条件：一次性申请所有资源\n3、破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用\n\n解决方案: 修改线程2\n```bash\nnew Thread(() -> {\n    synchronized (resource1) {\n        System.out.println(Thread.currentThread() + \"get resource1\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread() + \"waiting get resource2\");\n        synchronized (resource2) {\n            System.out.println(Thread.currentThread() + \"get resource2\");\n        }\n    }\n}, \"线程 2\").start();\n```\n\nOutput：\n```bash\nThread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n\nProcess finished with exit code 0\n```\n\n---\n\n#### 说说sleep()方法和wait()方法的区别？\n两者最主要的区别在于：**sleep 方法没有释放锁，而 wait 方法释放了锁**\n+ 两者都可以暂停线程的执行\n+ wait()通常用于线程间交互/通信，sleep()通常用户暂停执行\n+ wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n---\n\n#### 调用start()方法会执行run()方法，为什么不能直接调用run()方法？\nnew一个Thread，线程进入了新建状态；调用start()方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这才是真正的多线程工作。而直接执行run()方法，会吧run()方法当做一个main线程下的一个普通方法去执行，并不会在某个线程中执行他。\n**总结：调用start方法可以启动线程并使线程进入就绪状态，而run()方法只是Thread的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行**\n\n---\n\n#### synchronized关键字\nsynchronized关键字解决多个线程之间访问资源的同步性，synchronized关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。\nsynchronized关键字最主要的三种使用方式：\n+ **修饰实例方法**： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁\n```bash\n// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象\npublic synchronized void add() {}\n```\n+ **修饰静态方法**： 给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。\n```bash\n// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)\npublic synchronized static void add() {}\n```\n\n+ **修饰代码块**：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁\n\n---\n","source":"_posts/JavaBasic1.md","raw":"---\ntitle: Java基础（一）\ncategories:\n    - Java\ndate: 2018-08-01\ntags:\n\t- Java\n\t- Java基础\n\n---\n\n记录一些Java基础的知识点，为了自己查阅资料的时候方便一些。\n\n---\n### Java基础\n\n#### JDK和JRE的区别？\n\n1、jre即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库\n2、jdk是Java开发工具包，例如：tools.jar\n\n---\n\n#### == 和 equals的区别\n\n1、==是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址\n2、equals是超类Object就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。equals方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。\nObject类equals方法源码：\n```bash\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\nnew对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，举个栗子：\n```bash\npublic class EqualsTest {\n\n    public static void main(String[] args) {\n        User a = new User();\n        User b = new User();\n        System.out.println(a == b); //false\n        System.out.println(a.equals(b)); //true\n    }\n}\n\nclass User {\n    private int age;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof User)) return false;\n        User user = (User) o;\n        return age == user.age;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(age);\n    }\n}\n```\n---\n\n#### 两个对象的hashCode()相同，则equals()一定为true？\n**如果两个对象相等(equals()为true)，那么他们的hashCode()一定相同**\n**如果两个对象的hashCode()相同，他们的equals()方法不一定相同**\n\nJVM虚拟机通过hashCode()方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过hashCode()获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用equals()与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用equals()方法比较的次数。\n\n```bash\npublic class EqualsTest {\n\n    public static void main(String[] args) {\n        User a = new User();\n        User b = new User();\n        System.out.println(a == b); //false\n        System.out.println(a.equals(b)); //false\n        System.out.println(a.hashCode() == b.hashCode()); //false\n    }\n}\n\nclass User {\n    private int age;\n}\n```\n---\n\n#### final的作用\n可修饰类、类属性、类方法。\n1、被final修饰的类不能被继承\n2、final修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。\n```bash\npublic class FinalTest {\n\n    private static final User USER = new User();\n\n    public static void main(String[] args) {\n        User u2 = new User();\n//        user = u2; // ERROR\n        USER.age = 23;\n    }\n}\n\nclass User {\n    int age = 12;\n}\n```\n3、类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。\n\n---\n\n#### String属于基本数据类型吗？\n\n**不，String属于特殊的引用类型**\n\nJava中基本数据类型有：int、short、long、char、boolean、float、double、byte\n\n1、String是特殊的引用类型并且是final的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。\n2、String s = \"a\"; s += \"b\";，这段代码执行前后，字符串常量池中将出现a和ab两个字符串常量，而原本s变量的引用指向了常量池中ab。\n3、String s = new String(\"ab\")，这段代码一共创建了几个对象？一个或两个。如果字符串常量池中有了ab这个字符串(比如在此之前已经使用了String str = \"ab\")，那么新的s对象引用其实仅仅是指向了字符串常量中的ab，并没有创建新的字符串对象。但是，每次调用new都会在堆内存开辟空间，创建一个String对象，这是肯定的。\n\n栗子：\n```bash\npublic class StringTest {\n\n    public static void main(String[] args) {\n        String a = \"abc\";\n        String b = \"abc\";\n        String c = new String(\"abc\");\n        System.out.println(a == b); //true\n        System.out.println(a.equals(b)); //true\n        System.out.println(a.equals(c)); //true\n    }\n}\n```\n\n**String和StringBuffer和StringBuilder的区别**\n1、String是不可变字符串，StringBuffer和StringBuilder是可变字符串。如果经常改变字符串的原始数据，最好使用StringBuffer代替。\n2、String默认重写了equals方法和hashCode()方法；而StringBuffer没有重写equals方法，使用new StringBuffer(\"\")会直接在堆内存中开辟空间储存对象。因此将StringBuffer对象储存仅Java集合中可能会出现问题。\n3、StringBuffer是线程安全的，效率低；StringBuilder是线程不安全的，效率高。\n\n---\n\n#### static关键字？是否可覆盖？\n\nstatic关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。\n\nstatic标记的方法只能访问static变量或方法\n非static标记的方法可以访问static或非static标记的变量或方法\n\n---\n\n#### 自动拆、装箱\n\n因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。\n具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)\n\n基本数据类型|引用数据类型\n:--:|:--:\nint|Integer\nbyte|Byte\nshort|Short\nlong|Long\nfloat|Float\ndouble|Double\nchar|Char\nboolean|Boolean\n\n栗子：\n```bash\npublic static void main(String[] args) {\n    Integer i1 = 100;\n    Integer i2 = 100;\n    Integer i3 = 200;\n    Integer i4 = 200;\n    System.out.println(i1 == i2);\n    System.out.println(i3 == i4);\n}\n```\n\n结果：\n```bash\ntrue\nfalse\n```\n\nJava中实现基本数据类型和引用类型之间的拆装箱一般都是用过valueOf()方法实现的。例如我们看下Integer类的valueOf()方法源码：\n```bash\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n\n可以看到：当声明一个新的整数型变量，编译时通过Integer类的valueOf()进行拆装箱计算，这个方法会首先比较这个整数值是否在IntegerCache的范围内，如果在就返回IntegerCache类中的数值；如果不在就直接new Integer。那么我们看下IntegerCache类源码：\n\n```bash\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n```\n所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在[-128, 127]之间，就直接返回IntegerCache中储存的常量值，否则就直接new一个新的Integer来保存这个常量值。所以上面才会出现false的结果。\n同理：其他的数据类型例如：long、short等都具有对应的LongCache、ShortCache等类。\n\n---\n\n#### Overriding和Overloaded\n方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。\nOverriding: 子类中定义了和父类中名称、参数列表相同的方法\nOverloaded: 方法名相同，参数列表不同\n\n---\n\n#### Java支持多继承吗？\n不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过多层继承实现。\n类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。\n从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。\n\n---\n\n#### 接口和抽象类的区别？\n\n+ 接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。\n+ 接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )\n+ 类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )\n+ 抽象类可以是不提供接口方法实现的情况下实现接口\n+ 接口中声明的变量默认都是final的；但抽象类可以包含非final的变量\n+ 接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public\n+ 接口是绝对抽象的，不可以被实例化；\n\n---\n\n#### 引用传递和值传递\n\n**Java中采用值传递的方式**\n栗子：\n```bash\npublic class TransferTest {\n\n\n    public static void main(String[] args) {\n        int a = 1;\n        Integer b = 2;\n        swap(a, b);\n        System.out.println(a);\n        System.out.println(b);\n\n        int[] arr = {1, 2};\n        swap(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    private static void swap(int[] arr) {\n        arr[0] = 10;\n    }\n\n    private static void swap(int a, Integer b) {\n        a = 10;\n        b = 20;\n    }\n}\n```\n\n方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。\n所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。\n\n---\n\n#### IO流\n\n![IO流](/images/io.png)\n\n**1、Java中有几种类型的流？**\n字符流和字节流。字节流继承InputStream和OutputStream；字符流继承自InputStreamReader和OutputStreamWriter。\n\n**2、谈谈Java IO中的方法阻塞**\nJava中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。\n\n**3、字符流和字节流的区别？**\n数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。\n而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。\n字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。\n\n**4、NIO**\n传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read()等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept()时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。\n而对于NIO，它是非阻塞式，核心类：\n+ Buffer： 为所有的原始类型提供Buffer缓冲支持\n+ Charset： 字符集编码解码解决方案\n+ Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接。\n\n---\n\n#### 说说List、Set、Map三者的区别\n\n+ List: List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素\n+ Set: 不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素\n+ Map: 使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。\n\n---\n\n#### Array和ArrayList有什么区别？\n\n+ Array可以包含基本类型和对象类型；ArrayList只能包含对象类型\n+ Array大小是固定的；ArrayList大小是动态变化的\n+ ArrayList提供了诸如addAll()、removeAll()、iterator()方法等\n+ 对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。\n\n---\n\n#### ArrayList和LinkedList的区别？\n\n1、**是否保证线程安全**： ArrayList和LinkedList都是不同步的，也就是不保证线程安全\n2、**底层数据结构**： ArrayList底层使用的是Object数组；LinkedList底层使用的是 双向链表 结构\n3、**插入和删除是否受元素位置影响？** ArrayList采用数组储存，所以插入和删除元素都受元素位置的影响；LinkedList 采用链表储存，所以插入、删除元素都不受元素位置影响。\n4、**是否支持快速随机访问？** LinkedList因为使用链表储存，无法通过元素索引快速访问；而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。\n5、**内存空间占用**： ArrayList的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而LinkedList的空间花费体现在他的每一个元素都需要消耗比ArrayList更多的空间（因为要储存直接后继和直接前驱以及数据）。\n\n---\n\n**什么是迭代器**\n*Iterator*接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法*iterator()*。迭代器在迭代的过程中可以删除底层集合的元素。\n\n**Iterator和ListIterator的区别？**\n+ Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List\n+ Iterator对集合只能向前遍历（next()）；而*ListIterator可以向前遍历（next()），也可以向后遍历（previous()）\n+ ListIterator实现了Iterator接口\n\n**RandomAccess接口**\n```bash\n//ArrayList\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{}\n\n//RandomAccess\npublic interface RandomAccess {\n}\n\n//LinkedList\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n{}\n```\n\n源码中ArrayList类实现了RandomAccess接口，LinkedList类中却没有实现这个接口，但是RandomAccess接口中却什么也没有定义。可以看RandomAccess接口上的注释：\n```bash\n/**\n * Marker interface used by <tt>List</tt> implementations to indicate that\n * they support fast (generally constant time) random access.  The primary\n * purpose of this interface is to allow generic algorithms to alter their\n * behavior to provide good performance when applied to either random or\n * sequential access lists.\n */\n```\n大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看Collections类中的binarySearch方法：\n```bash\npublic static <T>\nint binarySearch(List<? extends Comparable<? super T>> list, T key) {\n    if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key);\n    else\n        return Collections.iteratorBinarySearch(list, key);\n}\n\nprivate static <T>\nint indexedBinarySearch(List<? extends Comparable<? super T>> list, T key) {\n    int low = 0;\n    int high = list.size()-1;\n\n    while (low <= high) {\n        int mid = (low + high) >>> 1;\n        Comparable<? super T> midVal = list.get(mid);\n        int cmp = midVal.compareTo(key);\n\n        if (cmp < 0)\n            low = mid + 1;\n        else if (cmp > 0)\n            high = mid - 1;\n        else\n            return mid; // key found\n    }\n    return -(low + 1);  // key not found\n}\n\nprivate static <T>\nint iteratorBinarySearch(List<? extends Comparable<? super T>> list, T key)\n{\n    int low = 0;\n    int high = list.size()-1;\n    ListIterator<? extends Comparable<? super T>> i = list.listIterator();\n\n    while (low <= high) {\n        int mid = (low + high) >>> 1;\n        Comparable<? super T> midVal = get(i, mid);\n        int cmp = midVal.compareTo(key);\n\n        if (cmp < 0)\n            low = mid + 1;\n        else if (cmp > 0)\n            high = mid - 1;\n        else\n            return mid; // key found\n    }\n    return -(low + 1);  // key not found\n}\n```\n\nbinarySearch()方法是从List中查找指定元素，其中首先判断传入的List时候实现了RandomAccess接口，如果实现了就调用indexedBinarySearch()方法，否则就调用iteratorBinarySearch()方法。再看这两个方法的源码：\n如果传入的List实现了RandomAccess接口，采用普通for循环遍历\n若传入的List未实现RandomAccess接口，采用iterator遍历\n\n**链表**\n\n**链表（Linked List）**由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针\n>单向链表\n单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。\n+ 单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找\n![单向链表](/images/linktable1.png)\n\n+ 单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可\n![单向链表](/images/linktable2.png)\n\n+ 删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可\n![单向链表](/images/linktable3.png)\n\n>双向链表\n**双向链表** 包含两个指针，prev指向前一个节点，next指向后一个节点。\n![双向链表](/images/linktable4.png)\n\n>双向循环链表\n**双向循环链表** 最后一个节点的*next*指向*head*，而*head*的*prev*指向最后一个节点，形成一个环。\n![双向循环链表](/images/linktable5.png)\n\n---\n\n#### ArrayList和Vector和LinkedList的区别？\n+ **ArrayList**: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高\n+ **Vector**: 底层数据结构是数组，查询快，增删慢。线程安全，效率低\n+ **LinkedList**: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高\n\n---\n\n#### 谈谈ArrayList的扩容机制\nJava中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，ArrayList的出现就解决了这一问题。\nArrayList的扩容机制表现在add()方法上，先看add()方法的源码：\n```bash\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\n//获取最小容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\n//判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n```\n\n当向ArrayList对象中添加新元素时，首先会调用ensureCapacityInternal(size)方法，size为最小扩容量；ensureCapacityInternal()方法会首先调用calculateCapacity来确定需要的最小容量；最后调用ensureExplicitCapacity()方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用grow()方法扩容：\n```bash\nprivate void grow(int minCapacity) {\n    // 获取ArrayList中elementDaata数组的长度\n    int oldCapacity = elementData.length;\n    // 扩容至原来的1.5倍\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    // 判断新的数组容量够不够\n    // 够了就直接使用这个长度创建新数组\n    if (newCapacity - minCapacity < 0)\n        // 不够就将数组的长度设置为需要的长度\n        newCapacity = minCapacity;\n    // 检查此时的最大值是否溢出\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // 调用Arrays.copyOf()将elementData数组数据拷贝到新数组\n    // 并将elementData指向新数组newCapacity的内存地址\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n**总结**： ArrayList扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。\n\n---\n\n#### HashMap和HashTable的区别？\n1、HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度\n2、线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰。\n3、效率: HashMap线程不安全效率高，HashTable线程安全效率低。\n3、对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null\n5、底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制。\n\n---\n\n#### HashMap和HashSet区别?\n**HashSet底层采用HashMap实现**\nHashMap|HashSet\n:--|:--\n实现了Map接口|实现了Set接口\n储存键值堆|仅储存对象\n调用put()向Map中添加元素|调用add()向Set中添加元素\nHashMap使用Key计算HashCode|HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以用equals判断对象的相等性\n\n---\n\n#### HashSet如何检查重复？\n在前面讲hashCode和equals时就提到了，HashSet集合同样适用。向HashSet中存入一个元素，HashSet首先会根据对象的hashCode值判断当期集合中此hashCode对应的位置有没有值，如果没有就直接添加，如果有就再调用equals方法比较两个对象是否相同，相同就不再储存（保证了Set集合不重复的特性），否则就散列到其他位置储存。\n\n---\n\n#### HashMap底层实现？\nMap在Java中的实现由很多，HashMap便是其中之一，随着JDK版本的更新，HashMap的实现也在不断更新：\n+ <=JDK1.7: Table数组 + Entry链表\n+ >=JDK1.8: Table数组 + Entry链表/红黑树\n\n#### Hash\n\n**Hash（哈希、散列）**，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。\nHash函数的一种实现：\n直接取余法： f(x) = x mod max\n位运算法： f(x) = x & max\nHashMap采用 位运算法，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：\n```bash\n7 & 33 = 1\n    \n    000111\n  & 100001\n  --------\n    000001 = 1\n\n```\n\n---\n\n#### Hash冲突\n假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到HashMap集合中，若将多个K-V数据存入put，HashMap根据元素key计算到对应的hashCode值，如果计算得到多个不同的key对应的hashCode值相同（即要储存到同一位置），此时这种现象就称为 Hash冲突。\nHashMap默认采用了 链地址法 解决Hash冲突问题，即通过类似单链表的方式将 冲突的元素 串起来，搜索时遍历这个链表即可。注意： 如果冲突的Hash越来越多，这个链就会越来越长。\n\n---\n\n#### 实现原理\n![hash冲突与实现原理](/images/hash1.png)\n这里我们需要了解两个名词：\nTable: 哈希桶数组（哈希表），存放Node元素，底层是一个Node[] table\nNode: 节点元素，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（K-V）\nHashMap内部的一些关键属性需要了解：\nDEFAULT_INITIAL_CAPACITY: Tabale数组的初始化长度，默认是1 << 4，2^4 = 16\nMAXIMUM_CAPACITY: Table数组最高长度，默认为1 << 30，2^30 = 1073741824\nDEFAULT_LOAD_FACTOR: 负载因子，当总元素数 > 数组长度 * 负载因子时，Table数组将扩容，默认是0.75\nTREEIFY_THRESHOLD: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8\nUNTREEIFY_THRESHOLD: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6\nMIN_TREEIFY_CAPACITY: 最小树化阀值，当Table中所有元素超过该值，才会进行树化\nsize: 当前HashMap实际存在的键值对数量\nthreshold: HashMap所能容纳的最大数据量的Node（键值对）个数。Node[] table初始化长度length是16，loadFactor负载因子默认是0.75，threshold = length * loadFactor\nloadFactor: 负载因子，默认是0.17\nmodCount: 记录HashMap内部结构发生变化的次数\nHashMap内部存在一个NodeTable数组，这个数组的初始化长度是DEFAULT_INITIAL_CAPACITY，他是一个单向链表：\n```bash\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; //key的Hash值\n    final K key; //key\n    V value; //value\n    Node<K,V> next; //下一个节点\n}\n```\n\n参考单链表的结构，Table中每个Node节点包含两个部分，Node元素作为节点的header，next指向下一个节点。**这种链式结构的存在正是为了解决Hash冲突**\n\n栗子：\n```bash\nmap.put(\"loonycoder\", \"18\");\n```\nHashMap将根据\"loonycoder\"这个Key得到其hashCode值，然后经过Hash算法定位到其在HashMap储存的位置，如果两个不同的key定位到了同一个位置，此时就发生了Hash冲突。\n在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过TREEIFY_THRESHOLD阀值后，会将链表转换为红黑树的实现TreeNode:\n```bash\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n    TreeNode<K,V> parent;  // red-black tree links\n    TreeNode<K,V> left;\n    TreeNode<K,V> right;\n    TreeNode<K,V> prev;    // needed to unlink next upon deletion\n    boolean red;\n}\n```\n当发生**Hash冲突**时，根据HashMap默认采用的 **链地址法**，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。但是 随着Hash冲突越来越多，这个**链将越来越长**，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。\n![地址链法](http://cdn.tycoding.cn/JDK1.8之后的HashMap底层数据结构.jpg)\n\n**总结**\n到此，我们总结一下HashMap的实现原理：\n+ HashMap根据key的hashCode值存储元素。put新元素会遍历链表，根据新元素的key计算hashCode得到散列位置，如果该位置有值再调用equals判断value是否相同，相同就散列到其他位置储存。\n+ HashMap在put新元素时如果遇到key对应的hashCode相同，可能会产生Hash冲突问题。HashMap的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。\n+ 如果发生Hash冲突的元素很多，这个 **链** 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（TreeNode）存储元素。\n\n---\n\n#### Collection和Collections的区别？\n+ Collection是集合类的上级接口，继承他的接口主要有Set和List\n+ Collections仅是针对集合类封装的一个工具类，在java.util包下\n\n---\n\n#### Comparable和Comparator的区别？\n\n+ Comparable接口来自java.lang包，提供compareTo(Object obj) 方法排序\n+ Comparator接口来自java.util包，提供compare(Object obj1, Object obj2)方法排序\n当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。\n\n#### Java集合框架总结\n\n##### Collection\n![Collection](/images/collection1.png)\n\n**List**\n\nArrayList: Object数组，线程不安全，查询快，增删慢，效率高\nVector: Object数组，线程安全，查询快，增删慢，效率低\nLinkedList: 双向链表，线程不安全，查询慢，增删快，效率高\n\n**Set**\n\nHashSet: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素\nLinkedHashSet: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现\nTreeSet 有序、唯一，红黑树\n\n##### Map\n![Map](/images/map1.png)\n\n+ HashMap: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。\n+ LinkedHashMap: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。\n+ HashTable: 数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题\nTreeMap: 红黑树\n\n---\n\n### Java并发\n\n#### 线程和进程的区别？\n+ 进程是程序的一次执行过程，是系统运行程序的基本单位\n+ 线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，\n在Java中，启用一个main方法就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。\n\n---\n\n#### 从JVM角度分析进程和线程的关系？\n根据JVM的内存划分，对于线程而言：多个线程共享进程的堆、方法区资源，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。\n\n也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。\n\n##### 为什么方法区和堆是线程共享区？\n+ **方法区（Method Area）** 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 运行时常量池 ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。\n+ **堆（Heap）** 堆内存储存了对象实例（比如new关键字创建的实例对象），它是JVM中内存区最大的一块区域。\n所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。\n\n##### 为什么虚拟机栈和本地方法栈是线程独占区？\n+ **虚拟机栈**： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。\n+ **本地方法栈**： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。\n\n##### 程序计数器是什么？\n\n**程序计数器（Program Counter Register）**：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。\n\n---\n\n#### 说说并行和并发的区别？\n+ **并行**： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）\n+ **并发**： 单位时间内，多个任务同时执行。\n\n---\n\n#### 使用多线程可能带来什么问题？\n并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题\n\n---\n\n#### 说说线程的生命周期和状态？\n状态名称|状态说明\n:--|:--\nnew|初始状态，线程被创建，但还没有调用start()方法\nrunnable|运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”\nblocked|阻塞状态，表示线程阻塞于锁\nwaiting|等待状态，线程需要等待当前线程或其他线程执行完成\ntime_waiting|超时等待状态，他可以实现在指定时间后自动返回\nterminated|终止状态，表示当前线程已经执行完毕\n\n对应，程序会因为不同代码的执行产生不同的状态，如下图：\n![线程图](/images/thread2.png)\n如上，线程创建后将进入NEW（初始）状态，调用start()开始运行，当线程执行wait()方法后，线程将进入WAITING（等待）状态，可以通过wait(long)或join(long)等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED（阻塞）状态。\n\n---\n\n#### 什么是上下文切换？\n简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用**随机分配时间片并轮转**的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 **任务从保存到再加载的过程就是一次上下文切换**。\n\n---\n\n#### 什么是死锁？如何避免?\n举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。\n![死锁](/images/deadlock.png)\n栗子：\n```bash\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();//资源 1\n    private static Object resource2 = new Object();//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\nOutput：\n\n```bash\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n```\n线程1以resource1作为同步监视器，即可以轻松获取resource1同时也锁定了resource1，此时调用sleep让线程1等待1秒钟；此时线程2开始执行，他以resource2作为同步监视器同时也锁定了resource2，此时调用sleep让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取resource2时发现resource2已经被线程2锁定了，同理线程2结束等待后想要获取resource1时发现resource1已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。\n因此产生死锁需要具备以下四个条件：\n\n1、互斥条件：该资源任意一个时刻只能由一个线程占用\n2、请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放\n3、不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源\n4、循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。\n\n避免死锁就要破坏这四个条件中任意一个：\n1、破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥\n2、破坏请求与保持条件：一次性申请所有资源\n3、破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用\n\n解决方案: 修改线程2\n```bash\nnew Thread(() -> {\n    synchronized (resource1) {\n        System.out.println(Thread.currentThread() + \"get resource1\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread() + \"waiting get resource2\");\n        synchronized (resource2) {\n            System.out.println(Thread.currentThread() + \"get resource2\");\n        }\n    }\n}, \"线程 2\").start();\n```\n\nOutput：\n```bash\nThread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n\nProcess finished with exit code 0\n```\n\n---\n\n#### 说说sleep()方法和wait()方法的区别？\n两者最主要的区别在于：**sleep 方法没有释放锁，而 wait 方法释放了锁**\n+ 两者都可以暂停线程的执行\n+ wait()通常用于线程间交互/通信，sleep()通常用户暂停执行\n+ wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n---\n\n#### 调用start()方法会执行run()方法，为什么不能直接调用run()方法？\nnew一个Thread，线程进入了新建状态；调用start()方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这才是真正的多线程工作。而直接执行run()方法，会吧run()方法当做一个main线程下的一个普通方法去执行，并不会在某个线程中执行他。\n**总结：调用start方法可以启动线程并使线程进入就绪状态，而run()方法只是Thread的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行**\n\n---\n\n#### synchronized关键字\nsynchronized关键字解决多个线程之间访问资源的同步性，synchronized关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。\nsynchronized关键字最主要的三种使用方式：\n+ **修饰实例方法**： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁\n```bash\n// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象\npublic synchronized void add() {}\n```\n+ **修饰静态方法**： 给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。\n```bash\n// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)\npublic synchronized static void add() {}\n```\n\n+ **修饰代码块**：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁\n\n---\n","slug":"JavaBasic1","published":1,"updated":"2020-02-21T15:27:44.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyh0002v9s6d9bphoby","content":"<p>记录一些Java基础的知识点，为了自己查阅资料的时候方便一些。</p>\n<hr>\n<h3 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h3><h4 id=\"JDK和JRE的区别？\"><a href=\"#JDK和JRE的区别？\" class=\"headerlink\" title=\"JDK和JRE的区别？\"></a>JDK和JRE的区别？</h4><p>1、jre即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库<br>2、jdk是Java开发工具包，例如：tools.jar</p>\n<hr>\n<h4 id=\"和-equals的区别\"><a href=\"#和-equals的区别\" class=\"headerlink\" title=\"== 和 equals的区别\"></a>== 和 equals的区别</h4><p>1、==是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址<br>2、equals是超类Object就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。equals方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。<br>Object类equals方法源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object obj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> (this == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>new对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，举个栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class EqualsTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User a = new User();</span><br><span class=\"line\">        User b = new User();</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean equals(Object o) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (this == o) <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o instanceof User)) <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        User user = (User) o;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> age == user.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int <span class=\"function\"><span class=\"title\">hashCode</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Objects.hash(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"两个对象的hashCode-相同，则equals-一定为true？\"><a href=\"#两个对象的hashCode-相同，则equals-一定为true？\" class=\"headerlink\" title=\"两个对象的hashCode()相同，则equals()一定为true？\"></a>两个对象的hashCode()相同，则equals()一定为true？</h4><p><strong>如果两个对象相等(equals()为true)，那么他们的hashCode()一定相同</strong><br><strong>如果两个对象的hashCode()相同，他们的equals()方法不一定相同</strong></p>\n<p>JVM虚拟机通过hashCode()方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过hashCode()获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用equals()与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用equals()方法比较的次数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class EqualsTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User a = new User();</span><br><span class=\"line\">        User b = new User();</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.hashCode() == b.hashCode()); //<span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"final的作用\"><a href=\"#final的作用\" class=\"headerlink\" title=\"final的作用\"></a>final的作用</h4><p>可修饰类、类属性、类方法。<br>1、被final修饰的类不能被继承<br>2、final修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FinalTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final User USER = new User();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User u2 = new User();</span><br><span class=\"line\">//        user = u2; // ERROR</span><br><span class=\"line\">        USER.age = 23;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    int age = 12;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。</p>\n<hr>\n<h4 id=\"String属于基本数据类型吗？\"><a href=\"#String属于基本数据类型吗？\" class=\"headerlink\" title=\"String属于基本数据类型吗？\"></a>String属于基本数据类型吗？</h4><p><strong>不，String属于特殊的引用类型</strong></p>\n<p>Java中基本数据类型有：int、short、long、char、boolean、float、double、byte</p>\n<p>1、String是特殊的引用类型并且是final的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。<br>2、String s = “a”; s += “b”;，这段代码执行前后，字符串常量池中将出现a和ab两个字符串常量，而原本s变量的引用指向了常量池中ab。<br>3、String s = new String(“ab”)，这段代码一共创建了几个对象？一个或两个。如果字符串常量池中有了ab这个字符串(比如在此之前已经使用了String str = “ab”)，那么新的s对象引用其实仅仅是指向了字符串常量中的ab，并没有创建新的字符串对象。但是，每次调用new都会在堆内存开辟空间，创建一个String对象，这是肯定的。</p>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StringTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String a = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        String b = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        String c = new String(<span class=\"string\">\"abc\"</span>);</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">true</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">true</span></span><br><span class=\"line\">        System.out.println(a.equals(c)); //<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>String和StringBuffer和StringBuilder的区别</strong><br>1、String是不可变字符串，StringBuffer和StringBuilder是可变字符串。如果经常改变字符串的原始数据，最好使用StringBuffer代替。<br>2、String默认重写了equals方法和hashCode()方法；而StringBuffer没有重写equals方法，使用new StringBuffer(“”)会直接在堆内存中开辟空间储存对象。因此将StringBuffer对象储存仅Java集合中可能会出现问题。<br>3、StringBuffer是线程安全的，效率低；StringBuilder是线程不安全的，效率高。</p>\n<hr>\n<h4 id=\"static关键字？是否可覆盖？\"><a href=\"#static关键字？是否可覆盖？\" class=\"headerlink\" title=\"static关键字？是否可覆盖？\"></a>static关键字？是否可覆盖？</h4><p>static关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。</p>\n<p>static标记的方法只能访问static变量或方法<br>非static标记的方法可以访问static或非static标记的变量或方法</p>\n<hr>\n<h4 id=\"自动拆、装箱\"><a href=\"#自动拆、装箱\" class=\"headerlink\" title=\"自动拆、装箱\"></a>自动拆、装箱</h4><p>因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。<br>具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">引用数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">int</td>\n<td align=\"center\">Integer</td>\n</tr>\n<tr>\n<td align=\"center\">byte</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">Short</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">Long</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">Float</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">Double</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Char</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n</tbody></table>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Integer i1 = 100;</span><br><span class=\"line\">    Integer i2 = 100;</span><br><span class=\"line\">    Integer i3 = 200;</span><br><span class=\"line\">    Integer i4 = 200;</span><br><span class=\"line\">    System.out.println(i1 == i2);</span><br><span class=\"line\">    System.out.println(i3 == i4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>Java中实现基本数据类型和引用类型之间的拆装箱一般都是用过valueOf()方法实现的。例如我们看下Integer类的valueOf()方法源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"built_in\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到：当声明一个新的整数型变量，编译时通过Integer类的valueOf()进行拆装箱计算，这个方法会首先比较这个整数值是否在IntegerCache的范围内，如果在就返回IntegerCache类中的数值；如果不在就直接new Integer。那么我们看下IntegerCache类源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class IntegerCache &#123;</span><br><span class=\"line\">    static final int low = -128;</span><br><span class=\"line\">    static final int high;</span><br><span class=\"line\">    static final Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        // high value may be configured by property</span><br><span class=\"line\">        int h = 127;</span><br><span class=\"line\">        String integerCacheHighPropValue =</span><br><span class=\"line\">            sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (integerCacheHighPropValue != null) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                int i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                i = Math.max(i, 127);</span><br><span class=\"line\">                // Maximum array size is Integer.MAX_VALUE</span><br><span class=\"line\">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class=\"line\">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                // If the property cannot be parsed into an int, ignore it.</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">        cache = new Integer[(high - low) + 1];</span><br><span class=\"line\">        int j = low;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int k = 0; k &lt; cache.length; k++)</span><br><span class=\"line\">            cache[k] = new Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class=\"line\">        assert IntegerCache.high &gt;= 127;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private <span class=\"function\"><span class=\"title\">IntegerCache</span></span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在[-128, 127]之间，就直接返回IntegerCache中储存的常量值，否则就直接new一个新的Integer来保存这个常量值。所以上面才会出现false的结果。<br>同理：其他的数据类型例如：long、short等都具有对应的LongCache、ShortCache等类。</p>\n<hr>\n<h4 id=\"Overriding和Overloaded\"><a href=\"#Overriding和Overloaded\" class=\"headerlink\" title=\"Overriding和Overloaded\"></a>Overriding和Overloaded</h4><p>方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。<br>Overriding: 子类中定义了和父类中名称、参数列表相同的方法<br>Overloaded: 方法名相同，参数列表不同</p>\n<hr>\n<h4 id=\"Java支持多继承吗？\"><a href=\"#Java支持多继承吗？\" class=\"headerlink\" title=\"Java支持多继承吗？\"></a>Java支持多继承吗？</h4><p>不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过多层继承实现。<br>类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。<br>从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。</p>\n<hr>\n<h4 id=\"接口和抽象类的区别？\"><a href=\"#接口和抽象类的区别？\" class=\"headerlink\" title=\"接口和抽象类的区别？\"></a>接口和抽象类的区别？</h4><ul>\n<li>接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li>\n<li>接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )</li>\n<li>类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )</li>\n<li>抽象类可以是不提供接口方法实现的情况下实现接口</li>\n<li>接口中声明的变量默认都是final的；但抽象类可以包含非final的变量</li>\n<li>接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public</li>\n<li>接口是绝对抽象的，不可以被实例化；</li>\n</ul>\n<hr>\n<h4 id=\"引用传递和值传递\"><a href=\"#引用传递和值传递\" class=\"headerlink\" title=\"引用传递和值传递\"></a>引用传递和值传递</h4><p><strong>Java中采用值传递的方式</strong><br>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TransferTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a = 1;</span><br><span class=\"line\">        Integer b = 2;</span><br><span class=\"line\">        swap(a, b);</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">        System.out.println(b);</span><br><span class=\"line\"></span><br><span class=\"line\">        int[] arr = &#123;1, 2&#125;;</span><br><span class=\"line\">        swap(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void swap(int[] arr) &#123;</span><br><span class=\"line\">        arr[0] = 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void swap(int a, Integer b) &#123;</span><br><span class=\"line\">        a = 10;</span><br><span class=\"line\">        b = 20;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。<br>所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。</p>\n<hr>\n<h4 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h4><p><img src=\"/images/io.png\" alt=\"IO流\"></p>\n<p><strong>1、Java中有几种类型的流？</strong><br>字符流和字节流。字节流继承InputStream和OutputStream；字符流继承自InputStreamReader和OutputStreamWriter。</p>\n<p><strong>2、谈谈Java IO中的方法阻塞</strong><br>Java中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。</p>\n<p><strong>3、字符流和字节流的区别？</strong><br>数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。<br>而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。<br>字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。</p>\n<p><strong>4、NIO</strong><br>传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read()等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept()时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。<br>而对于NIO，它是非阻塞式，核心类：</p>\n<ul>\n<li>Buffer： 为所有的原始类型提供Buffer缓冲支持</li>\n<li>Charset： 字符集编码解码解决方案</li>\n<li>Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接。</li>\n</ul>\n<hr>\n<h4 id=\"说说List、Set、Map三者的区别\"><a href=\"#说说List、Set、Map三者的区别\" class=\"headerlink\" title=\"说说List、Set、Map三者的区别\"></a>说说List、Set、Map三者的区别</h4><ul>\n<li>List: List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素</li>\n<li>Set: 不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素</li>\n<li>Map: 使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。</li>\n</ul>\n<hr>\n<h4 id=\"Array和ArrayList有什么区别？\"><a href=\"#Array和ArrayList有什么区别？\" class=\"headerlink\" title=\"Array和ArrayList有什么区别？\"></a>Array和ArrayList有什么区别？</h4><ul>\n<li>Array可以包含基本类型和对象类型；ArrayList只能包含对象类型</li>\n<li>Array大小是固定的；ArrayList大小是动态变化的</li>\n<li>ArrayList提供了诸如addAll()、removeAll()、iterator()方法等</li>\n<li>对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。</li>\n</ul>\n<hr>\n<h4 id=\"ArrayList和LinkedList的区别？\"><a href=\"#ArrayList和LinkedList的区别？\" class=\"headerlink\" title=\"ArrayList和LinkedList的区别？\"></a>ArrayList和LinkedList的区别？</h4><p>1、<strong>是否保证线程安全</strong>： ArrayList和LinkedList都是不同步的，也就是不保证线程安全<br>2、<strong>底层数据结构</strong>： ArrayList底层使用的是Object数组；LinkedList底层使用的是 双向链表 结构<br>3、<strong>插入和删除是否受元素位置影响？</strong> ArrayList采用数组储存，所以插入和删除元素都受元素位置的影响；LinkedList 采用链表储存，所以插入、删除元素都不受元素位置影响。<br>4、<strong>是否支持快速随机访问？</strong> LinkedList因为使用链表储存，无法通过元素索引快速访问；而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。<br>5、<strong>内存空间占用</strong>： ArrayList的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而LinkedList的空间花费体现在他的每一个元素都需要消耗比ArrayList更多的空间（因为要储存直接后继和直接前驱以及数据）。</p>\n<hr>\n<p><strong>什么是迭代器</strong><br><em>Iterator</em>接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法<em>iterator()</em>。迭代器在迭代的过程中可以删除底层集合的元素。</p>\n<p><strong>Iterator和ListIterator的区别？</strong></p>\n<ul>\n<li>Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List</li>\n<li>Iterator对集合只能向前遍历（next()）；而*ListIterator可以向前遍历（next()），也可以向后遍历（previous()）</li>\n<li>ListIterator实现了Iterator接口</li>\n</ul>\n<p><strong>RandomAccess接口</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ArrayList</span><br><span class=\"line\">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class=\"line\">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//RandomAccess</span><br><span class=\"line\">public interface RandomAccess &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//LinkedList</span><br><span class=\"line\">public class LinkedList&lt;E&gt;</span><br><span class=\"line\">    extends AbstractSequentialList&lt;E&gt;</span><br><span class=\"line\">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码中ArrayList类实现了RandomAccess接口，LinkedList类中却没有实现这个接口，但是RandomAccess接口中却什么也没有定义。可以看RandomAccess接口上的注释：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that</span><br><span class=\"line\"> * they support fast (generally constant time) random access.  The primary</span><br><span class=\"line\"> * purpose of this interface is to allow generic algorithms to alter their</span><br><span class=\"line\"> * behavior to provide good performance when applied to either random or</span><br><span class=\"line\"> * sequential access lists.</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<p>大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看Collections类中的binarySearch方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt;</span><br><span class=\"line\">int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static &lt;T&gt;</span><br><span class=\"line\">int indexedBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class=\"line\">    int low = 0;</span><br><span class=\"line\">    int high = list.size()-1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class=\"line\">        Comparable&lt;? super T&gt; midVal = list.get(mid);</span><br><span class=\"line\">        int cmp = midVal.compareTo(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &lt; 0)</span><br><span class=\"line\">            low = mid + 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; 0)</span><br><span class=\"line\">            high = mid - 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> mid; // key found</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> -(low + 1);  // key not found</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static &lt;T&gt;</span><br><span class=\"line\">int iteratorBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int low = 0;</span><br><span class=\"line\">    int high = list.size()-1;</span><br><span class=\"line\">    ListIterator&lt;? extends Comparable&lt;? super T&gt;&gt; i = list.listIterator();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class=\"line\">        Comparable&lt;? super T&gt; midVal = get(i, mid);</span><br><span class=\"line\">        int cmp = midVal.compareTo(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &lt; 0)</span><br><span class=\"line\">            low = mid + 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; 0)</span><br><span class=\"line\">            high = mid - 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> mid; // key found</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> -(low + 1);  // key not found</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>binarySearch()方法是从List中查找指定元素，其中首先判断传入的List时候实现了RandomAccess接口，如果实现了就调用indexedBinarySearch()方法，否则就调用iteratorBinarySearch()方法。再看这两个方法的源码：<br>如果传入的List实现了RandomAccess接口，采用普通for循环遍历<br>若传入的List未实现RandomAccess接口，采用iterator遍历</p>\n<p><strong>链表</strong></p>\n<p><strong>链表（Linked List）</strong>由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针</p>\n<blockquote>\n<p>单向链表<br>单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。</p>\n</blockquote>\n<ul>\n<li><p>单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找<br><img src=\"/images/linktable1.png\" alt=\"单向链表\"></p>\n</li>\n<li><p>单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可<br><img src=\"/images/linktable2.png\" alt=\"单向链表\"></p>\n</li>\n<li><p>删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可<br><img src=\"/images/linktable3.png\" alt=\"单向链表\"></p>\n</li>\n</ul>\n<blockquote>\n<p>双向链表<br><strong>双向链表</strong> 包含两个指针，prev指向前一个节点，next指向后一个节点。<br><img src=\"/images/linktable4.png\" alt=\"双向链表\"></p>\n</blockquote>\n<blockquote>\n<p>双向循环链表<br><strong>双向循环链表</strong> 最后一个节点的<em>next</em>指向<em>head</em>，而<em>head</em>的<em>prev</em>指向最后一个节点，形成一个环。<br><img src=\"/images/linktable5.png\" alt=\"双向循环链表\"></p>\n</blockquote>\n<hr>\n<h4 id=\"ArrayList和Vector和LinkedList的区别？\"><a href=\"#ArrayList和Vector和LinkedList的区别？\" class=\"headerlink\" title=\"ArrayList和Vector和LinkedList的区别？\"></a>ArrayList和Vector和LinkedList的区别？</h4><ul>\n<li><strong>ArrayList</strong>: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高</li>\n<li><strong>Vector</strong>: 底层数据结构是数组，查询快，增删慢。线程安全，效率低</li>\n<li><strong>LinkedList</strong>: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高</li>\n</ul>\n<hr>\n<h4 id=\"谈谈ArrayList的扩容机制\"><a href=\"#谈谈ArrayList的扩容机制\" class=\"headerlink\" title=\"谈谈ArrayList的扩容机制\"></a>谈谈ArrayList的扩容机制</h4><p>Java中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，ArrayList的出现就解决了这一问题。<br>ArrayList的扩容机制表现在add()方法上，先看add()方法的源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//获取最小容量</span><br><span class=\"line\">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//判断是否需要扩容</span><br><span class=\"line\">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">    // overflow-conscious code</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; 0)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当向ArrayList对象中添加新元素时，首先会调用ensureCapacityInternal(size)方法，size为最小扩容量；ensureCapacityInternal()方法会首先调用calculateCapacity来确定需要的最小容量；最后调用ensureExplicitCapacity()方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用grow()方法扩容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void grow(int minCapacity) &#123;</span><br><span class=\"line\">    // 获取ArrayList中elementDaata数组的长度</span><br><span class=\"line\">    int oldCapacity = elementData.length;</span><br><span class=\"line\">    // 扩容至原来的1.5倍</span><br><span class=\"line\">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class=\"line\">    // 判断新的数组容量够不够</span><br><span class=\"line\">    // 够了就直接使用这个长度创建新数组</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class=\"line\">        // 不够就将数组的长度设置为需要的长度</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    // 检查此时的最大值是否溢出</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    // 调用Arrays.copyOf()将elementData数组数据拷贝到新数组</span><br><span class=\"line\">    // 并将elementData指向新数组newCapacity的内存地址</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结</strong>： ArrayList扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。</p>\n<hr>\n<h4 id=\"HashMap和HashTable的区别？\"><a href=\"#HashMap和HashTable的区别？\" class=\"headerlink\" title=\"HashMap和HashTable的区别？\"></a>HashMap和HashTable的区别？</h4><p>1、HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度<br>2、线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰。<br>3、效率: HashMap线程不安全效率高，HashTable线程安全效率低。<br>3、对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null<br>5、底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制。</p>\n<hr>\n<h4 id=\"HashMap和HashSet区别\"><a href=\"#HashMap和HashSet区别\" class=\"headerlink\" title=\"HashMap和HashSet区别?\"></a>HashMap和HashSet区别?</h4><p><strong>HashSet底层采用HashMap实现</strong><br>HashMap|HashSet<br>:–|:–<br>实现了Map接口|实现了Set接口<br>储存键值堆|仅储存对象<br>调用put()向Map中添加元素|调用add()向Set中添加元素<br>HashMap使用Key计算HashCode|HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以用equals判断对象的相等性</p>\n<hr>\n<h4 id=\"HashSet如何检查重复？\"><a href=\"#HashSet如何检查重复？\" class=\"headerlink\" title=\"HashSet如何检查重复？\"></a>HashSet如何检查重复？</h4><p>在前面讲hashCode和equals时就提到了，HashSet集合同样适用。向HashSet中存入一个元素，HashSet首先会根据对象的hashCode值判断当期集合中此hashCode对应的位置有没有值，如果没有就直接添加，如果有就再调用equals方法比较两个对象是否相同，相同就不再储存（保证了Set集合不重复的特性），否则就散列到其他位置储存。</p>\n<hr>\n<h4 id=\"HashMap底层实现？\"><a href=\"#HashMap底层实现？\" class=\"headerlink\" title=\"HashMap底层实现？\"></a>HashMap底层实现？</h4><p>Map在Java中的实现由很多，HashMap便是其中之一，随着JDK版本的更新，HashMap的实现也在不断更新：</p>\n<ul>\n<li>&lt;=JDK1.7: Table数组 + Entry链表</li>\n<li><blockquote>\n<p>=JDK1.8: Table数组 + Entry链表/红黑树</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h4><p><strong>Hash（哈希、散列）</strong>，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。<br>Hash函数的一种实现：<br>直接取余法： f(x) = x mod max<br>位运算法： f(x) = x &amp; max<br>HashMap采用 位运算法，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 &amp; 33 = 1</span><br><span class=\"line\">    </span><br><span class=\"line\">    000111</span><br><span class=\"line\">  &amp; 100001</span><br><span class=\"line\">  --------</span><br><span class=\"line\">    000001 = 1</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"Hash冲突\"><a href=\"#Hash冲突\" class=\"headerlink\" title=\"Hash冲突\"></a>Hash冲突</h4><p>假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到HashMap集合中，若将多个K-V数据存入put，HashMap根据元素key计算到对应的hashCode值，如果计算得到多个不同的key对应的hashCode值相同（即要储存到同一位置），此时这种现象就称为 Hash冲突。<br>HashMap默认采用了 链地址法 解决Hash冲突问题，即通过类似单链表的方式将 冲突的元素 串起来，搜索时遍历这个链表即可。注意： 如果冲突的Hash越来越多，这个链就会越来越长。</p>\n<hr>\n<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p><img src=\"/images/hash1.png\" alt=\"hash冲突与实现原理\"><br>这里我们需要了解两个名词：<br>Table: 哈希桶数组（哈希表），存放Node元素，底层是一个Node[] table<br>Node: 节点元素，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（K-V）<br>HashMap内部的一些关键属性需要了解：<br>DEFAULT_INITIAL_CAPACITY: Tabale数组的初始化长度，默认是1 &lt;&lt; 4，2^4 = 16<br>MAXIMUM_CAPACITY: Table数组最高长度，默认为1 &lt;&lt; 30，2^30 = 1073741824<br>DEFAULT_LOAD_FACTOR: 负载因子，当总元素数 &gt; 数组长度 * 负载因子时，Table数组将扩容，默认是0.75<br>TREEIFY_THRESHOLD: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8<br>UNTREEIFY_THRESHOLD: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6<br>MIN_TREEIFY_CAPACITY: 最小树化阀值，当Table中所有元素超过该值，才会进行树化<br>size: 当前HashMap实际存在的键值对数量<br>threshold: HashMap所能容纳的最大数据量的Node（键值对）个数。Node[] table初始化长度length是16，loadFactor负载因子默认是0.75，threshold = length * loadFactor<br>loadFactor: 负载因子，默认是0.17<br>modCount: 记录HashMap内部结构发生变化的次数<br>HashMap内部存在一个NodeTable数组，这个数组的初始化长度是DEFAULT_INITIAL_CAPACITY，他是一个单向链表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    final int <span class=\"built_in\">hash</span>; //key的Hash值</span><br><span class=\"line\">    final K key; //key</span><br><span class=\"line\">    V value; //value</span><br><span class=\"line\">    Node&lt;K,V&gt; next; //下一个节点</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考单链表的结构，Table中每个Node节点包含两个部分，Node元素作为节点的header，next指向下一个节点。<strong>这种链式结构的存在正是为了解决Hash冲突</strong></p>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.put(<span class=\"string\">\"loonycoder\"</span>, <span class=\"string\">\"18\"</span>);</span><br></pre></td></tr></table></figure>\n<p>HashMap将根据”loonycoder”这个Key得到其hashCode值，然后经过Hash算法定位到其在HashMap储存的位置，如果两个不同的key定位到了同一个位置，此时就发生了Hash冲突。<br>在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过TREEIFY_THRESHOLD阀值后，会将链表转换为红黑树的实现TreeNode:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class=\"line\">    boolean red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当发生<strong>Hash冲突</strong>时，根据HashMap默认采用的 <strong>链地址法</strong>，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。但是 随着Hash冲突越来越多，这个<strong>链将越来越长</strong>，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。<br><img src=\"http://cdn.tycoding.cn/JDK1.8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg\" alt=\"地址链法\"></p>\n<p><strong>总结</strong><br>到此，我们总结一下HashMap的实现原理：</p>\n<ul>\n<li>HashMap根据key的hashCode值存储元素。put新元素会遍历链表，根据新元素的key计算hashCode得到散列位置，如果该位置有值再调用equals判断value是否相同，相同就散列到其他位置储存。</li>\n<li>HashMap在put新元素时如果遇到key对应的hashCode相同，可能会产生Hash冲突问题。HashMap的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。</li>\n<li>如果发生Hash冲突的元素很多，这个 <strong>链</strong> 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（TreeNode）存储元素。</li>\n</ul>\n<hr>\n<h4 id=\"Collection和Collections的区别？\"><a href=\"#Collection和Collections的区别？\" class=\"headerlink\" title=\"Collection和Collections的区别？\"></a>Collection和Collections的区别？</h4><ul>\n<li>Collection是集合类的上级接口，继承他的接口主要有Set和List</li>\n<li>Collections仅是针对集合类封装的一个工具类，在java.util包下</li>\n</ul>\n<hr>\n<h4 id=\"Comparable和Comparator的区别？\"><a href=\"#Comparable和Comparator的区别？\" class=\"headerlink\" title=\"Comparable和Comparator的区别？\"></a>Comparable和Comparator的区别？</h4><ul>\n<li>Comparable接口来自java.lang包，提供compareTo(Object obj) 方法排序</li>\n<li>Comparator接口来自java.util包，提供compare(Object obj1, Object obj2)方法排序<br>当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。</li>\n</ul>\n<h4 id=\"Java集合框架总结\"><a href=\"#Java集合框架总结\" class=\"headerlink\" title=\"Java集合框架总结\"></a>Java集合框架总结</h4><h5 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h5><p><img src=\"/images/collection1.png\" alt=\"Collection\"></p>\n<p><strong>List</strong></p>\n<p>ArrayList: Object数组，线程不安全，查询快，增删慢，效率高<br>Vector: Object数组，线程安全，查询快，增删慢，效率低<br>LinkedList: 双向链表，线程不安全，查询慢，增删快，效率高</p>\n<p><strong>Set</strong></p>\n<p>HashSet: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素<br>LinkedHashSet: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现<br>TreeSet 有序、唯一，红黑树</p>\n<h5 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h5><p><img src=\"/images/map1.png\" alt=\"Map\"></p>\n<ul>\n<li>HashMap: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。</li>\n<li>LinkedHashMap: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li>\n<li>HashTable: 数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题<br>TreeMap: 红黑树</li>\n</ul>\n<hr>\n<h3 id=\"Java并发\"><a href=\"#Java并发\" class=\"headerlink\" title=\"Java并发\"></a>Java并发</h3><h4 id=\"线程和进程的区别？\"><a href=\"#线程和进程的区别？\" class=\"headerlink\" title=\"线程和进程的区别？\"></a>线程和进程的区别？</h4><ul>\n<li>进程是程序的一次执行过程，是系统运行程序的基本单位</li>\n<li>线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，<br>在Java中，启用一个main方法就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。</li>\n</ul>\n<hr>\n<h4 id=\"从JVM角度分析进程和线程的关系？\"><a href=\"#从JVM角度分析进程和线程的关系？\" class=\"headerlink\" title=\"从JVM角度分析进程和线程的关系？\"></a>从JVM角度分析进程和线程的关系？</h4><p>根据JVM的内存划分，对于线程而言：多个线程共享进程的堆、方法区资源，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。</p>\n<p>也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。</p>\n<h5 id=\"为什么方法区和堆是线程共享区？\"><a href=\"#为什么方法区和堆是线程共享区？\" class=\"headerlink\" title=\"为什么方法区和堆是线程共享区？\"></a>为什么方法区和堆是线程共享区？</h5><ul>\n<li><strong>方法区（Method Area）</strong> 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 运行时常量池 ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。</li>\n<li><strong>堆（Heap）</strong> 堆内存储存了对象实例（比如new关键字创建的实例对象），它是JVM中内存区最大的一块区域。<br>所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。</li>\n</ul>\n<h5 id=\"为什么虚拟机栈和本地方法栈是线程独占区？\"><a href=\"#为什么虚拟机栈和本地方法栈是线程独占区？\" class=\"headerlink\" title=\"为什么虚拟机栈和本地方法栈是线程独占区？\"></a>为什么虚拟机栈和本地方法栈是线程独占区？</h5><ul>\n<li><strong>虚拟机栈</strong>： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。</li>\n<li><strong>本地方法栈</strong>： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。</li>\n</ul>\n<h5 id=\"程序计数器是什么？\"><a href=\"#程序计数器是什么？\" class=\"headerlink\" title=\"程序计数器是什么？\"></a>程序计数器是什么？</h5><p><strong>程序计数器（Program Counter Register）</strong>：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。</p>\n<hr>\n<h4 id=\"说说并行和并发的区别？\"><a href=\"#说说并行和并发的区别？\" class=\"headerlink\" title=\"说说并行和并发的区别？\"></a>说说并行和并发的区别？</h4><ul>\n<li><strong>并行</strong>： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>\n<li><strong>并发</strong>： 单位时间内，多个任务同时执行。</li>\n</ul>\n<hr>\n<h4 id=\"使用多线程可能带来什么问题？\"><a href=\"#使用多线程可能带来什么问题？\" class=\"headerlink\" title=\"使用多线程可能带来什么问题？\"></a>使用多线程可能带来什么问题？</h4><p>并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题</p>\n<hr>\n<h4 id=\"说说线程的生命周期和状态？\"><a href=\"#说说线程的生命周期和状态？\" class=\"headerlink\" title=\"说说线程的生命周期和状态？\"></a>说说线程的生命周期和状态？</h4><table>\n<thead>\n<tr>\n<th align=\"left\">状态名称</th>\n<th align=\"left\">状态说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">new</td>\n<td align=\"left\">初始状态，线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td align=\"left\">runnable</td>\n<td align=\"left\">运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”</td>\n</tr>\n<tr>\n<td align=\"left\">blocked</td>\n<td align=\"left\">阻塞状态，表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td align=\"left\">waiting</td>\n<td align=\"left\">等待状态，线程需要等待当前线程或其他线程执行完成</td>\n</tr>\n<tr>\n<td align=\"left\">time_waiting</td>\n<td align=\"left\">超时等待状态，他可以实现在指定时间后自动返回</td>\n</tr>\n<tr>\n<td align=\"left\">terminated</td>\n<td align=\"left\">终止状态，表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p>对应，程序会因为不同代码的执行产生不同的状态，如下图：<br><img src=\"/images/thread2.png\" alt=\"线程图\"><br>如上，线程创建后将进入NEW（初始）状态，调用start()开始运行，当线程执行wait()方法后，线程将进入WAITING（等待）状态，可以通过wait(long)或join(long)等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED（阻塞）状态。</p>\n<hr>\n<h4 id=\"什么是上下文切换？\"><a href=\"#什么是上下文切换？\" class=\"headerlink\" title=\"什么是上下文切换？\"></a>什么是上下文切换？</h4><p>简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用<strong>随机分配时间片并轮转</strong>的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 <strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<hr>\n<h4 id=\"什么是死锁？如何避免\"><a href=\"#什么是死锁？如何避免\" class=\"headerlink\" title=\"什么是死锁？如何避免?\"></a>什么是死锁？如何避免?</h4><p>举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。<br><img src=\"/images/deadlock.png\" alt=\"死锁\"><br>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DeadLockDemo &#123;</span><br><span class=\"line\">    private static Object resource1 = new Object();//资源 1</span><br><span class=\"line\">    private static Object resource2 = new Object();//资源 2</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            synchronized (resource1) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource2\"</span>);</span><br><span class=\"line\">                synchronized (resource2) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 1\"</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            synchronized (resource2) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource1\"</span>);</span><br><span class=\"line\">                synchronized (resource1) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 2\"</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Output：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 1,5,main]get resource1</span><br><span class=\"line\">Thread[线程 2,5,main]get resource2</span><br><span class=\"line\">Thread[线程 1,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure>\n<p>线程1以resource1作为同步监视器，即可以轻松获取resource1同时也锁定了resource1，此时调用sleep让线程1等待1秒钟；此时线程2开始执行，他以resource2作为同步监视器同时也锁定了resource2，此时调用sleep让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取resource2时发现resource2已经被线程2锁定了，同理线程2结束等待后想要获取resource1时发现resource1已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。<br>因此产生死锁需要具备以下四个条件：</p>\n<p>1、互斥条件：该资源任意一个时刻只能由一个线程占用<br>2、请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放<br>3、不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源<br>4、循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。</p>\n<p>避免死锁就要破坏这四个条件中任意一个：<br>1、破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥<br>2、破坏请求与保持条件：一次性申请所有资源<br>3、破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用</p>\n<p>解决方案: 修改线程2</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(() -&gt; &#123;</span><br><span class=\"line\">    synchronized (resource1) &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource2\"</span>);</span><br><span class=\"line\">        synchronized (resource2) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">\"线程 2\"</span>).start();</span><br></pre></td></tr></table></figure>\n\n<p>Output：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 1,5,main]get resource1</span><br><span class=\"line\">Thread[线程 1,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 1,5,main]get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]get resource1</span><br><span class=\"line\">Thread[线程 2,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]get resource2</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with <span class=\"built_in\">exit</span> code 0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"说说sleep-方法和wait-方法的区别？\"><a href=\"#说说sleep-方法和wait-方法的区别？\" class=\"headerlink\" title=\"说说sleep()方法和wait()方法的区别？\"></a>说说sleep()方法和wait()方法的区别？</h4><p>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong></p>\n<ul>\n<li>两者都可以暂停线程的执行</li>\n<li>wait()通常用于线程间交互/通信，sleep()通常用户暂停执行</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<hr>\n<h4 id=\"调用start-方法会执行run-方法，为什么不能直接调用run-方法？\"><a href=\"#调用start-方法会执行run-方法，为什么不能直接调用run-方法？\" class=\"headerlink\" title=\"调用start()方法会执行run()方法，为什么不能直接调用run()方法？\"></a>调用start()方法会执行run()方法，为什么不能直接调用run()方法？</h4><p>new一个Thread，线程进入了新建状态；调用start()方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这才是真正的多线程工作。而直接执行run()方法，会吧run()方法当做一个main线程下的一个普通方法去执行，并不会在某个线程中执行他。<br><strong>总结：调用start方法可以启动线程并使线程进入就绪状态，而run()方法只是Thread的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行</strong></p>\n<hr>\n<h4 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h4><p>synchronized关键字解决多个线程之间访问资源的同步性，synchronized关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。<br>synchronized关键字最主要的三种使用方式：</p>\n<ul>\n<li><p><strong>修饰实例方法</strong>： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象</span><br><span class=\"line\">public synchronized void <span class=\"function\"><span class=\"title\">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>修饰静态方法</strong>： 给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)</span><br><span class=\"line\">public synchronized static void <span class=\"function\"><span class=\"title\">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁</p>\n</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p>记录一些Java基础的知识点，为了自己查阅资料的时候方便一些。</p>\n<hr>\n<h3 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h3><h4 id=\"JDK和JRE的区别？\"><a href=\"#JDK和JRE的区别？\" class=\"headerlink\" title=\"JDK和JRE的区别？\"></a>JDK和JRE的区别？</h4><p>1、jre即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库<br>2、jdk是Java开发工具包，例如：tools.jar</p>\n<hr>\n<h4 id=\"和-equals的区别\"><a href=\"#和-equals的区别\" class=\"headerlink\" title=\"== 和 equals的区别\"></a>== 和 equals的区别</h4><p>1、==是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址<br>2、equals是超类Object就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。equals方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。<br>Object类equals方法源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object obj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> (this == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>new对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，举个栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class EqualsTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User a = new User();</span><br><span class=\"line\">        User b = new User();</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean equals(Object o) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (this == o) <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o instanceof User)) <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        User user = (User) o;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> age == user.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int <span class=\"function\"><span class=\"title\">hashCode</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Objects.hash(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"两个对象的hashCode-相同，则equals-一定为true？\"><a href=\"#两个对象的hashCode-相同，则equals-一定为true？\" class=\"headerlink\" title=\"两个对象的hashCode()相同，则equals()一定为true？\"></a>两个对象的hashCode()相同，则equals()一定为true？</h4><p><strong>如果两个对象相等(equals()为true)，那么他们的hashCode()一定相同</strong><br><strong>如果两个对象的hashCode()相同，他们的equals()方法不一定相同</strong></p>\n<p>JVM虚拟机通过hashCode()方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过hashCode()获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用equals()与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用equals()方法比较的次数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class EqualsTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User a = new User();</span><br><span class=\"line\">        User b = new User();</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">false</span></span><br><span class=\"line\">        System.out.println(a.hashCode() == b.hashCode()); //<span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"final的作用\"><a href=\"#final的作用\" class=\"headerlink\" title=\"final的作用\"></a>final的作用</h4><p>可修饰类、类属性、类方法。<br>1、被final修饰的类不能被继承<br>2、final修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FinalTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final User USER = new User();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User u2 = new User();</span><br><span class=\"line\">//        user = u2; // ERROR</span><br><span class=\"line\">        USER.age = 23;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class User &#123;</span><br><span class=\"line\">    int age = 12;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。</p>\n<hr>\n<h4 id=\"String属于基本数据类型吗？\"><a href=\"#String属于基本数据类型吗？\" class=\"headerlink\" title=\"String属于基本数据类型吗？\"></a>String属于基本数据类型吗？</h4><p><strong>不，String属于特殊的引用类型</strong></p>\n<p>Java中基本数据类型有：int、short、long、char、boolean、float、double、byte</p>\n<p>1、String是特殊的引用类型并且是final的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。<br>2、String s = “a”; s += “b”;，这段代码执行前后，字符串常量池中将出现a和ab两个字符串常量，而原本s变量的引用指向了常量池中ab。<br>3、String s = new String(“ab”)，这段代码一共创建了几个对象？一个或两个。如果字符串常量池中有了ab这个字符串(比如在此之前已经使用了String str = “ab”)，那么新的s对象引用其实仅仅是指向了字符串常量中的ab，并没有创建新的字符串对象。但是，每次调用new都会在堆内存开辟空间，创建一个String对象，这是肯定的。</p>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StringTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String a = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        String b = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        String c = new String(<span class=\"string\">\"abc\"</span>);</span><br><span class=\"line\">        System.out.println(a == b); //<span class=\"literal\">true</span></span><br><span class=\"line\">        System.out.println(a.equals(b)); //<span class=\"literal\">true</span></span><br><span class=\"line\">        System.out.println(a.equals(c)); //<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>String和StringBuffer和StringBuilder的区别</strong><br>1、String是不可变字符串，StringBuffer和StringBuilder是可变字符串。如果经常改变字符串的原始数据，最好使用StringBuffer代替。<br>2、String默认重写了equals方法和hashCode()方法；而StringBuffer没有重写equals方法，使用new StringBuffer(“”)会直接在堆内存中开辟空间储存对象。因此将StringBuffer对象储存仅Java集合中可能会出现问题。<br>3、StringBuffer是线程安全的，效率低；StringBuilder是线程不安全的，效率高。</p>\n<hr>\n<h4 id=\"static关键字？是否可覆盖？\"><a href=\"#static关键字？是否可覆盖？\" class=\"headerlink\" title=\"static关键字？是否可覆盖？\"></a>static关键字？是否可覆盖？</h4><p>static关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。</p>\n<p>static标记的方法只能访问static变量或方法<br>非static标记的方法可以访问static或非static标记的变量或方法</p>\n<hr>\n<h4 id=\"自动拆、装箱\"><a href=\"#自动拆、装箱\" class=\"headerlink\" title=\"自动拆、装箱\"></a>自动拆、装箱</h4><p>因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。<br>具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">引用数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">int</td>\n<td align=\"center\">Integer</td>\n</tr>\n<tr>\n<td align=\"center\">byte</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">Short</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">Long</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">Float</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">Double</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Char</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n</tbody></table>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Integer i1 = 100;</span><br><span class=\"line\">    Integer i2 = 100;</span><br><span class=\"line\">    Integer i3 = 200;</span><br><span class=\"line\">    Integer i4 = 200;</span><br><span class=\"line\">    System.out.println(i1 == i2);</span><br><span class=\"line\">    System.out.println(i3 == i4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>Java中实现基本数据类型和引用类型之间的拆装箱一般都是用过valueOf()方法实现的。例如我们看下Integer类的valueOf()方法源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"built_in\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到：当声明一个新的整数型变量，编译时通过Integer类的valueOf()进行拆装箱计算，这个方法会首先比较这个整数值是否在IntegerCache的范围内，如果在就返回IntegerCache类中的数值；如果不在就直接new Integer。那么我们看下IntegerCache类源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class IntegerCache &#123;</span><br><span class=\"line\">    static final int low = -128;</span><br><span class=\"line\">    static final int high;</span><br><span class=\"line\">    static final Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        // high value may be configured by property</span><br><span class=\"line\">        int h = 127;</span><br><span class=\"line\">        String integerCacheHighPropValue =</span><br><span class=\"line\">            sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (integerCacheHighPropValue != null) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                int i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                i = Math.max(i, 127);</span><br><span class=\"line\">                // Maximum array size is Integer.MAX_VALUE</span><br><span class=\"line\">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class=\"line\">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                // If the property cannot be parsed into an int, ignore it.</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">        cache = new Integer[(high - low) + 1];</span><br><span class=\"line\">        int j = low;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int k = 0; k &lt; cache.length; k++)</span><br><span class=\"line\">            cache[k] = new Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class=\"line\">        assert IntegerCache.high &gt;= 127;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private <span class=\"function\"><span class=\"title\">IntegerCache</span></span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在[-128, 127]之间，就直接返回IntegerCache中储存的常量值，否则就直接new一个新的Integer来保存这个常量值。所以上面才会出现false的结果。<br>同理：其他的数据类型例如：long、short等都具有对应的LongCache、ShortCache等类。</p>\n<hr>\n<h4 id=\"Overriding和Overloaded\"><a href=\"#Overriding和Overloaded\" class=\"headerlink\" title=\"Overriding和Overloaded\"></a>Overriding和Overloaded</h4><p>方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。<br>Overriding: 子类中定义了和父类中名称、参数列表相同的方法<br>Overloaded: 方法名相同，参数列表不同</p>\n<hr>\n<h4 id=\"Java支持多继承吗？\"><a href=\"#Java支持多继承吗？\" class=\"headerlink\" title=\"Java支持多继承吗？\"></a>Java支持多继承吗？</h4><p>不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过多层继承实现。<br>类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。<br>从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。</p>\n<hr>\n<h4 id=\"接口和抽象类的区别？\"><a href=\"#接口和抽象类的区别？\" class=\"headerlink\" title=\"接口和抽象类的区别？\"></a>接口和抽象类的区别？</h4><ul>\n<li>接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li>\n<li>接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )</li>\n<li>类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )</li>\n<li>抽象类可以是不提供接口方法实现的情况下实现接口</li>\n<li>接口中声明的变量默认都是final的；但抽象类可以包含非final的变量</li>\n<li>接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public</li>\n<li>接口是绝对抽象的，不可以被实例化；</li>\n</ul>\n<hr>\n<h4 id=\"引用传递和值传递\"><a href=\"#引用传递和值传递\" class=\"headerlink\" title=\"引用传递和值传递\"></a>引用传递和值传递</h4><p><strong>Java中采用值传递的方式</strong><br>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TransferTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a = 1;</span><br><span class=\"line\">        Integer b = 2;</span><br><span class=\"line\">        swap(a, b);</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">        System.out.println(b);</span><br><span class=\"line\"></span><br><span class=\"line\">        int[] arr = &#123;1, 2&#125;;</span><br><span class=\"line\">        swap(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void swap(int[] arr) &#123;</span><br><span class=\"line\">        arr[0] = 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void swap(int a, Integer b) &#123;</span><br><span class=\"line\">        a = 10;</span><br><span class=\"line\">        b = 20;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。<br>所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。</p>\n<hr>\n<h4 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h4><p><img src=\"/images/io.png\" alt=\"IO流\"></p>\n<p><strong>1、Java中有几种类型的流？</strong><br>字符流和字节流。字节流继承InputStream和OutputStream；字符流继承自InputStreamReader和OutputStreamWriter。</p>\n<p><strong>2、谈谈Java IO中的方法阻塞</strong><br>Java中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。</p>\n<p><strong>3、字符流和字节流的区别？</strong><br>数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。<br>而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。<br>字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。</p>\n<p><strong>4、NIO</strong><br>传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read()等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept()时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。<br>而对于NIO，它是非阻塞式，核心类：</p>\n<ul>\n<li>Buffer： 为所有的原始类型提供Buffer缓冲支持</li>\n<li>Charset： 字符集编码解码解决方案</li>\n<li>Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接。</li>\n</ul>\n<hr>\n<h4 id=\"说说List、Set、Map三者的区别\"><a href=\"#说说List、Set、Map三者的区别\" class=\"headerlink\" title=\"说说List、Set、Map三者的区别\"></a>说说List、Set、Map三者的区别</h4><ul>\n<li>List: List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素</li>\n<li>Set: 不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素</li>\n<li>Map: 使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。</li>\n</ul>\n<hr>\n<h4 id=\"Array和ArrayList有什么区别？\"><a href=\"#Array和ArrayList有什么区别？\" class=\"headerlink\" title=\"Array和ArrayList有什么区别？\"></a>Array和ArrayList有什么区别？</h4><ul>\n<li>Array可以包含基本类型和对象类型；ArrayList只能包含对象类型</li>\n<li>Array大小是固定的；ArrayList大小是动态变化的</li>\n<li>ArrayList提供了诸如addAll()、removeAll()、iterator()方法等</li>\n<li>对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。</li>\n</ul>\n<hr>\n<h4 id=\"ArrayList和LinkedList的区别？\"><a href=\"#ArrayList和LinkedList的区别？\" class=\"headerlink\" title=\"ArrayList和LinkedList的区别？\"></a>ArrayList和LinkedList的区别？</h4><p>1、<strong>是否保证线程安全</strong>： ArrayList和LinkedList都是不同步的，也就是不保证线程安全<br>2、<strong>底层数据结构</strong>： ArrayList底层使用的是Object数组；LinkedList底层使用的是 双向链表 结构<br>3、<strong>插入和删除是否受元素位置影响？</strong> ArrayList采用数组储存，所以插入和删除元素都受元素位置的影响；LinkedList 采用链表储存，所以插入、删除元素都不受元素位置影响。<br>4、<strong>是否支持快速随机访问？</strong> LinkedList因为使用链表储存，无法通过元素索引快速访问；而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。<br>5、<strong>内存空间占用</strong>： ArrayList的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而LinkedList的空间花费体现在他的每一个元素都需要消耗比ArrayList更多的空间（因为要储存直接后继和直接前驱以及数据）。</p>\n<hr>\n<p><strong>什么是迭代器</strong><br><em>Iterator</em>接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法<em>iterator()</em>。迭代器在迭代的过程中可以删除底层集合的元素。</p>\n<p><strong>Iterator和ListIterator的区别？</strong></p>\n<ul>\n<li>Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List</li>\n<li>Iterator对集合只能向前遍历（next()）；而*ListIterator可以向前遍历（next()），也可以向后遍历（previous()）</li>\n<li>ListIterator实现了Iterator接口</li>\n</ul>\n<p><strong>RandomAccess接口</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ArrayList</span><br><span class=\"line\">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class=\"line\">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//RandomAccess</span><br><span class=\"line\">public interface RandomAccess &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//LinkedList</span><br><span class=\"line\">public class LinkedList&lt;E&gt;</span><br><span class=\"line\">    extends AbstractSequentialList&lt;E&gt;</span><br><span class=\"line\">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码中ArrayList类实现了RandomAccess接口，LinkedList类中却没有实现这个接口，但是RandomAccess接口中却什么也没有定义。可以看RandomAccess接口上的注释：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that</span><br><span class=\"line\"> * they support fast (generally constant time) random access.  The primary</span><br><span class=\"line\"> * purpose of this interface is to allow generic algorithms to alter their</span><br><span class=\"line\"> * behavior to provide good performance when applied to either random or</span><br><span class=\"line\"> * sequential access lists.</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<p>大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看Collections类中的binarySearch方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt;</span><br><span class=\"line\">int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static &lt;T&gt;</span><br><span class=\"line\">int indexedBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class=\"line\">    int low = 0;</span><br><span class=\"line\">    int high = list.size()-1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class=\"line\">        Comparable&lt;? super T&gt; midVal = list.get(mid);</span><br><span class=\"line\">        int cmp = midVal.compareTo(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &lt; 0)</span><br><span class=\"line\">            low = mid + 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; 0)</span><br><span class=\"line\">            high = mid - 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> mid; // key found</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> -(low + 1);  // key not found</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static &lt;T&gt;</span><br><span class=\"line\">int iteratorBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int low = 0;</span><br><span class=\"line\">    int high = list.size()-1;</span><br><span class=\"line\">    ListIterator&lt;? extends Comparable&lt;? super T&gt;&gt; i = list.listIterator();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class=\"line\">        Comparable&lt;? super T&gt; midVal = get(i, mid);</span><br><span class=\"line\">        int cmp = midVal.compareTo(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &lt; 0)</span><br><span class=\"line\">            low = mid + 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; 0)</span><br><span class=\"line\">            high = mid - 1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> mid; // key found</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> -(low + 1);  // key not found</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>binarySearch()方法是从List中查找指定元素，其中首先判断传入的List时候实现了RandomAccess接口，如果实现了就调用indexedBinarySearch()方法，否则就调用iteratorBinarySearch()方法。再看这两个方法的源码：<br>如果传入的List实现了RandomAccess接口，采用普通for循环遍历<br>若传入的List未实现RandomAccess接口，采用iterator遍历</p>\n<p><strong>链表</strong></p>\n<p><strong>链表（Linked List）</strong>由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针</p>\n<blockquote>\n<p>单向链表<br>单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。</p>\n</blockquote>\n<ul>\n<li><p>单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找<br><img src=\"/images/linktable1.png\" alt=\"单向链表\"></p>\n</li>\n<li><p>单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可<br><img src=\"/images/linktable2.png\" alt=\"单向链表\"></p>\n</li>\n<li><p>删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可<br><img src=\"/images/linktable3.png\" alt=\"单向链表\"></p>\n</li>\n</ul>\n<blockquote>\n<p>双向链表<br><strong>双向链表</strong> 包含两个指针，prev指向前一个节点，next指向后一个节点。<br><img src=\"/images/linktable4.png\" alt=\"双向链表\"></p>\n</blockquote>\n<blockquote>\n<p>双向循环链表<br><strong>双向循环链表</strong> 最后一个节点的<em>next</em>指向<em>head</em>，而<em>head</em>的<em>prev</em>指向最后一个节点，形成一个环。<br><img src=\"/images/linktable5.png\" alt=\"双向循环链表\"></p>\n</blockquote>\n<hr>\n<h4 id=\"ArrayList和Vector和LinkedList的区别？\"><a href=\"#ArrayList和Vector和LinkedList的区别？\" class=\"headerlink\" title=\"ArrayList和Vector和LinkedList的区别？\"></a>ArrayList和Vector和LinkedList的区别？</h4><ul>\n<li><strong>ArrayList</strong>: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高</li>\n<li><strong>Vector</strong>: 底层数据结构是数组，查询快，增删慢。线程安全，效率低</li>\n<li><strong>LinkedList</strong>: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高</li>\n</ul>\n<hr>\n<h4 id=\"谈谈ArrayList的扩容机制\"><a href=\"#谈谈ArrayList的扩容机制\" class=\"headerlink\" title=\"谈谈ArrayList的扩容机制\"></a>谈谈ArrayList的扩容机制</h4><p>Java中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，ArrayList的出现就解决了这一问题。<br>ArrayList的扩容机制表现在add()方法上，先看add()方法的源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//获取最小容量</span><br><span class=\"line\">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//判断是否需要扩容</span><br><span class=\"line\">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">    // overflow-conscious code</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; 0)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当向ArrayList对象中添加新元素时，首先会调用ensureCapacityInternal(size)方法，size为最小扩容量；ensureCapacityInternal()方法会首先调用calculateCapacity来确定需要的最小容量；最后调用ensureExplicitCapacity()方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用grow()方法扩容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void grow(int minCapacity) &#123;</span><br><span class=\"line\">    // 获取ArrayList中elementDaata数组的长度</span><br><span class=\"line\">    int oldCapacity = elementData.length;</span><br><span class=\"line\">    // 扩容至原来的1.5倍</span><br><span class=\"line\">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class=\"line\">    // 判断新的数组容量够不够</span><br><span class=\"line\">    // 够了就直接使用这个长度创建新数组</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class=\"line\">        // 不够就将数组的长度设置为需要的长度</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    // 检查此时的最大值是否溢出</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    // 调用Arrays.copyOf()将elementData数组数据拷贝到新数组</span><br><span class=\"line\">    // 并将elementData指向新数组newCapacity的内存地址</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结</strong>： ArrayList扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。</p>\n<hr>\n<h4 id=\"HashMap和HashTable的区别？\"><a href=\"#HashMap和HashTable的区别？\" class=\"headerlink\" title=\"HashMap和HashTable的区别？\"></a>HashMap和HashTable的区别？</h4><p>1、HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度<br>2、线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰。<br>3、效率: HashMap线程不安全效率高，HashTable线程安全效率低。<br>3、对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null<br>5、底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制。</p>\n<hr>\n<h4 id=\"HashMap和HashSet区别\"><a href=\"#HashMap和HashSet区别\" class=\"headerlink\" title=\"HashMap和HashSet区别?\"></a>HashMap和HashSet区别?</h4><p><strong>HashSet底层采用HashMap实现</strong><br>HashMap|HashSet<br>:–|:–<br>实现了Map接口|实现了Set接口<br>储存键值堆|仅储存对象<br>调用put()向Map中添加元素|调用add()向Set中添加元素<br>HashMap使用Key计算HashCode|HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以用equals判断对象的相等性</p>\n<hr>\n<h4 id=\"HashSet如何检查重复？\"><a href=\"#HashSet如何检查重复？\" class=\"headerlink\" title=\"HashSet如何检查重复？\"></a>HashSet如何检查重复？</h4><p>在前面讲hashCode和equals时就提到了，HashSet集合同样适用。向HashSet中存入一个元素，HashSet首先会根据对象的hashCode值判断当期集合中此hashCode对应的位置有没有值，如果没有就直接添加，如果有就再调用equals方法比较两个对象是否相同，相同就不再储存（保证了Set集合不重复的特性），否则就散列到其他位置储存。</p>\n<hr>\n<h4 id=\"HashMap底层实现？\"><a href=\"#HashMap底层实现？\" class=\"headerlink\" title=\"HashMap底层实现？\"></a>HashMap底层实现？</h4><p>Map在Java中的实现由很多，HashMap便是其中之一，随着JDK版本的更新，HashMap的实现也在不断更新：</p>\n<ul>\n<li>&lt;=JDK1.7: Table数组 + Entry链表</li>\n<li><blockquote>\n<p>=JDK1.8: Table数组 + Entry链表/红黑树</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h4><p><strong>Hash（哈希、散列）</strong>，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。<br>Hash函数的一种实现：<br>直接取余法： f(x) = x mod max<br>位运算法： f(x) = x &amp; max<br>HashMap采用 位运算法，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 &amp; 33 = 1</span><br><span class=\"line\">    </span><br><span class=\"line\">    000111</span><br><span class=\"line\">  &amp; 100001</span><br><span class=\"line\">  --------</span><br><span class=\"line\">    000001 = 1</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"Hash冲突\"><a href=\"#Hash冲突\" class=\"headerlink\" title=\"Hash冲突\"></a>Hash冲突</h4><p>假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到HashMap集合中，若将多个K-V数据存入put，HashMap根据元素key计算到对应的hashCode值，如果计算得到多个不同的key对应的hashCode值相同（即要储存到同一位置），此时这种现象就称为 Hash冲突。<br>HashMap默认采用了 链地址法 解决Hash冲突问题，即通过类似单链表的方式将 冲突的元素 串起来，搜索时遍历这个链表即可。注意： 如果冲突的Hash越来越多，这个链就会越来越长。</p>\n<hr>\n<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p><img src=\"/images/hash1.png\" alt=\"hash冲突与实现原理\"><br>这里我们需要了解两个名词：<br>Table: 哈希桶数组（哈希表），存放Node元素，底层是一个Node[] table<br>Node: 节点元素，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（K-V）<br>HashMap内部的一些关键属性需要了解：<br>DEFAULT_INITIAL_CAPACITY: Tabale数组的初始化长度，默认是1 &lt;&lt; 4，2^4 = 16<br>MAXIMUM_CAPACITY: Table数组最高长度，默认为1 &lt;&lt; 30，2^30 = 1073741824<br>DEFAULT_LOAD_FACTOR: 负载因子，当总元素数 &gt; 数组长度 * 负载因子时，Table数组将扩容，默认是0.75<br>TREEIFY_THRESHOLD: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8<br>UNTREEIFY_THRESHOLD: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6<br>MIN_TREEIFY_CAPACITY: 最小树化阀值，当Table中所有元素超过该值，才会进行树化<br>size: 当前HashMap实际存在的键值对数量<br>threshold: HashMap所能容纳的最大数据量的Node（键值对）个数。Node[] table初始化长度length是16，loadFactor负载因子默认是0.75，threshold = length * loadFactor<br>loadFactor: 负载因子，默认是0.17<br>modCount: 记录HashMap内部结构发生变化的次数<br>HashMap内部存在一个NodeTable数组，这个数组的初始化长度是DEFAULT_INITIAL_CAPACITY，他是一个单向链表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    final int <span class=\"built_in\">hash</span>; //key的Hash值</span><br><span class=\"line\">    final K key; //key</span><br><span class=\"line\">    V value; //value</span><br><span class=\"line\">    Node&lt;K,V&gt; next; //下一个节点</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考单链表的结构，Table中每个Node节点包含两个部分，Node元素作为节点的header，next指向下一个节点。<strong>这种链式结构的存在正是为了解决Hash冲突</strong></p>\n<p>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.put(<span class=\"string\">\"loonycoder\"</span>, <span class=\"string\">\"18\"</span>);</span><br></pre></td></tr></table></figure>\n<p>HashMap将根据”loonycoder”这个Key得到其hashCode值，然后经过Hash算法定位到其在HashMap储存的位置，如果两个不同的key定位到了同一个位置，此时就发生了Hash冲突。<br>在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过TREEIFY_THRESHOLD阀值后，会将链表转换为红黑树的实现TreeNode:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class=\"line\">    boolean red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当发生<strong>Hash冲突</strong>时，根据HashMap默认采用的 <strong>链地址法</strong>，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。但是 随着Hash冲突越来越多，这个<strong>链将越来越长</strong>，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。<br><img src=\"http://cdn.tycoding.cn/JDK1.8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg\" alt=\"地址链法\"></p>\n<p><strong>总结</strong><br>到此，我们总结一下HashMap的实现原理：</p>\n<ul>\n<li>HashMap根据key的hashCode值存储元素。put新元素会遍历链表，根据新元素的key计算hashCode得到散列位置，如果该位置有值再调用equals判断value是否相同，相同就散列到其他位置储存。</li>\n<li>HashMap在put新元素时如果遇到key对应的hashCode相同，可能会产生Hash冲突问题。HashMap的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。</li>\n<li>如果发生Hash冲突的元素很多，这个 <strong>链</strong> 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（TreeNode）存储元素。</li>\n</ul>\n<hr>\n<h4 id=\"Collection和Collections的区别？\"><a href=\"#Collection和Collections的区别？\" class=\"headerlink\" title=\"Collection和Collections的区别？\"></a>Collection和Collections的区别？</h4><ul>\n<li>Collection是集合类的上级接口，继承他的接口主要有Set和List</li>\n<li>Collections仅是针对集合类封装的一个工具类，在java.util包下</li>\n</ul>\n<hr>\n<h4 id=\"Comparable和Comparator的区别？\"><a href=\"#Comparable和Comparator的区别？\" class=\"headerlink\" title=\"Comparable和Comparator的区别？\"></a>Comparable和Comparator的区别？</h4><ul>\n<li>Comparable接口来自java.lang包，提供compareTo(Object obj) 方法排序</li>\n<li>Comparator接口来自java.util包，提供compare(Object obj1, Object obj2)方法排序<br>当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。</li>\n</ul>\n<h4 id=\"Java集合框架总结\"><a href=\"#Java集合框架总结\" class=\"headerlink\" title=\"Java集合框架总结\"></a>Java集合框架总结</h4><h5 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h5><p><img src=\"/images/collection1.png\" alt=\"Collection\"></p>\n<p><strong>List</strong></p>\n<p>ArrayList: Object数组，线程不安全，查询快，增删慢，效率高<br>Vector: Object数组，线程安全，查询快，增删慢，效率低<br>LinkedList: 双向链表，线程不安全，查询慢，增删快，效率高</p>\n<p><strong>Set</strong></p>\n<p>HashSet: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素<br>LinkedHashSet: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现<br>TreeSet 有序、唯一，红黑树</p>\n<h5 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h5><p><img src=\"/images/map1.png\" alt=\"Map\"></p>\n<ul>\n<li>HashMap: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。</li>\n<li>LinkedHashMap: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li>\n<li>HashTable: 数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题<br>TreeMap: 红黑树</li>\n</ul>\n<hr>\n<h3 id=\"Java并发\"><a href=\"#Java并发\" class=\"headerlink\" title=\"Java并发\"></a>Java并发</h3><h4 id=\"线程和进程的区别？\"><a href=\"#线程和进程的区别？\" class=\"headerlink\" title=\"线程和进程的区别？\"></a>线程和进程的区别？</h4><ul>\n<li>进程是程序的一次执行过程，是系统运行程序的基本单位</li>\n<li>线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，<br>在Java中，启用一个main方法就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。</li>\n</ul>\n<hr>\n<h4 id=\"从JVM角度分析进程和线程的关系？\"><a href=\"#从JVM角度分析进程和线程的关系？\" class=\"headerlink\" title=\"从JVM角度分析进程和线程的关系？\"></a>从JVM角度分析进程和线程的关系？</h4><p>根据JVM的内存划分，对于线程而言：多个线程共享进程的堆、方法区资源，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。</p>\n<p>也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。</p>\n<h5 id=\"为什么方法区和堆是线程共享区？\"><a href=\"#为什么方法区和堆是线程共享区？\" class=\"headerlink\" title=\"为什么方法区和堆是线程共享区？\"></a>为什么方法区和堆是线程共享区？</h5><ul>\n<li><strong>方法区（Method Area）</strong> 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 运行时常量池 ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。</li>\n<li><strong>堆（Heap）</strong> 堆内存储存了对象实例（比如new关键字创建的实例对象），它是JVM中内存区最大的一块区域。<br>所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。</li>\n</ul>\n<h5 id=\"为什么虚拟机栈和本地方法栈是线程独占区？\"><a href=\"#为什么虚拟机栈和本地方法栈是线程独占区？\" class=\"headerlink\" title=\"为什么虚拟机栈和本地方法栈是线程独占区？\"></a>为什么虚拟机栈和本地方法栈是线程独占区？</h5><ul>\n<li><strong>虚拟机栈</strong>： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。</li>\n<li><strong>本地方法栈</strong>： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。</li>\n</ul>\n<h5 id=\"程序计数器是什么？\"><a href=\"#程序计数器是什么？\" class=\"headerlink\" title=\"程序计数器是什么？\"></a>程序计数器是什么？</h5><p><strong>程序计数器（Program Counter Register）</strong>：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。</p>\n<hr>\n<h4 id=\"说说并行和并发的区别？\"><a href=\"#说说并行和并发的区别？\" class=\"headerlink\" title=\"说说并行和并发的区别？\"></a>说说并行和并发的区别？</h4><ul>\n<li><strong>并行</strong>： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>\n<li><strong>并发</strong>： 单位时间内，多个任务同时执行。</li>\n</ul>\n<hr>\n<h4 id=\"使用多线程可能带来什么问题？\"><a href=\"#使用多线程可能带来什么问题？\" class=\"headerlink\" title=\"使用多线程可能带来什么问题？\"></a>使用多线程可能带来什么问题？</h4><p>并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题</p>\n<hr>\n<h4 id=\"说说线程的生命周期和状态？\"><a href=\"#说说线程的生命周期和状态？\" class=\"headerlink\" title=\"说说线程的生命周期和状态？\"></a>说说线程的生命周期和状态？</h4><table>\n<thead>\n<tr>\n<th align=\"left\">状态名称</th>\n<th align=\"left\">状态说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">new</td>\n<td align=\"left\">初始状态，线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td align=\"left\">runnable</td>\n<td align=\"left\">运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”</td>\n</tr>\n<tr>\n<td align=\"left\">blocked</td>\n<td align=\"left\">阻塞状态，表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td align=\"left\">waiting</td>\n<td align=\"left\">等待状态，线程需要等待当前线程或其他线程执行完成</td>\n</tr>\n<tr>\n<td align=\"left\">time_waiting</td>\n<td align=\"left\">超时等待状态，他可以实现在指定时间后自动返回</td>\n</tr>\n<tr>\n<td align=\"left\">terminated</td>\n<td align=\"left\">终止状态，表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p>对应，程序会因为不同代码的执行产生不同的状态，如下图：<br><img src=\"/images/thread2.png\" alt=\"线程图\"><br>如上，线程创建后将进入NEW（初始）状态，调用start()开始运行，当线程执行wait()方法后，线程将进入WAITING（等待）状态，可以通过wait(long)或join(long)等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED（阻塞）状态。</p>\n<hr>\n<h4 id=\"什么是上下文切换？\"><a href=\"#什么是上下文切换？\" class=\"headerlink\" title=\"什么是上下文切换？\"></a>什么是上下文切换？</h4><p>简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用<strong>随机分配时间片并轮转</strong>的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 <strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<hr>\n<h4 id=\"什么是死锁？如何避免\"><a href=\"#什么是死锁？如何避免\" class=\"headerlink\" title=\"什么是死锁？如何避免?\"></a>什么是死锁？如何避免?</h4><p>举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。<br><img src=\"/images/deadlock.png\" alt=\"死锁\"><br>栗子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DeadLockDemo &#123;</span><br><span class=\"line\">    private static Object resource1 = new Object();//资源 1</span><br><span class=\"line\">    private static Object resource2 = new Object();//资源 2</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            synchronized (resource1) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource2\"</span>);</span><br><span class=\"line\">                synchronized (resource2) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 1\"</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            synchronized (resource2) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource1\"</span>);</span><br><span class=\"line\">                synchronized (resource1) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 2\"</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Output：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 1,5,main]get resource1</span><br><span class=\"line\">Thread[线程 2,5,main]get resource2</span><br><span class=\"line\">Thread[线程 1,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure>\n<p>线程1以resource1作为同步监视器，即可以轻松获取resource1同时也锁定了resource1，此时调用sleep让线程1等待1秒钟；此时线程2开始执行，他以resource2作为同步监视器同时也锁定了resource2，此时调用sleep让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取resource2时发现resource2已经被线程2锁定了，同理线程2结束等待后想要获取resource1时发现resource1已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。<br>因此产生死锁需要具备以下四个条件：</p>\n<p>1、互斥条件：该资源任意一个时刻只能由一个线程占用<br>2、请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放<br>3、不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源<br>4、循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。</p>\n<p>避免死锁就要破坏这四个条件中任意一个：<br>1、破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥<br>2、破坏请求与保持条件：一次性申请所有资源<br>3、破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用</p>\n<p>解决方案: 修改线程2</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(() -&gt; &#123;</span><br><span class=\"line\">    synchronized (resource1) &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource2\"</span>);</span><br><span class=\"line\">        synchronized (resource2) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">\"线程 2\"</span>).start();</span><br></pre></td></tr></table></figure>\n\n<p>Output：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 1,5,main]get resource1</span><br><span class=\"line\">Thread[线程 1,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 1,5,main]get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]get resource1</span><br><span class=\"line\">Thread[线程 2,5,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 2,5,main]get resource2</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with <span class=\"built_in\">exit</span> code 0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"说说sleep-方法和wait-方法的区别？\"><a href=\"#说说sleep-方法和wait-方法的区别？\" class=\"headerlink\" title=\"说说sleep()方法和wait()方法的区别？\"></a>说说sleep()方法和wait()方法的区别？</h4><p>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong></p>\n<ul>\n<li>两者都可以暂停线程的执行</li>\n<li>wait()通常用于线程间交互/通信，sleep()通常用户暂停执行</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<hr>\n<h4 id=\"调用start-方法会执行run-方法，为什么不能直接调用run-方法？\"><a href=\"#调用start-方法会执行run-方法，为什么不能直接调用run-方法？\" class=\"headerlink\" title=\"调用start()方法会执行run()方法，为什么不能直接调用run()方法？\"></a>调用start()方法会执行run()方法，为什么不能直接调用run()方法？</h4><p>new一个Thread，线程进入了新建状态；调用start()方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这才是真正的多线程工作。而直接执行run()方法，会吧run()方法当做一个main线程下的一个普通方法去执行，并不会在某个线程中执行他。<br><strong>总结：调用start方法可以启动线程并使线程进入就绪状态，而run()方法只是Thread的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行</strong></p>\n<hr>\n<h4 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h4><p>synchronized关键字解决多个线程之间访问资源的同步性，synchronized关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。<br>synchronized关键字最主要的三种使用方式：</p>\n<ul>\n<li><p><strong>修饰实例方法</strong>： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象</span><br><span class=\"line\">public synchronized void <span class=\"function\"><span class=\"title\">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>修饰静态方法</strong>： 给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)</span><br><span class=\"line\">public synchronized static void <span class=\"function\"><span class=\"title\">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁</p>\n</li>\n</ul>\n<hr>\n"},{"title":"Java基础（二）","date":"2018-08-07T16:00:00.000Z","_content":"\n###对象与类\n\n#### 对象的创建\n\n比如Student s = new Student()实例化一个对象，其实经历了如下几个过程：\n将Student.class加载到内存中\n在栈内存中给s开辟内存空间。\n在堆内存给Student类申请一个内存空间。\n给成员变量进行默认初始化，0 null false…\n自定义给成员变量初始化赋值\n初始化完毕，把堆内存地址赋值给栈内存的s变量\n\n#### Main方法剖析\n\n```bash\npublic static void main(String[] args) { ... }\n```\n\n- public: 公共的，访问权限最大，因为main方法是被JVM调用的。\n- static：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。\n- void: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。\n- main: 常见的方法入口，很多语言的入口方法都是main方法。\n- String[] args: 字符串数组，是作为命令行参数调用的。\n\n##### static关键字\n\n**static关键字特点：（可以修饰成员变量，也可修饰成员方法）**\n\n- 随着类的加载而加载\n- 优先于对象存在\n- 被类中的所有对象共享\n- 可直接通过类名调用\n\n**拓展**\n\n静态方法中没有this关键字，因为this代表当前方法对象，但static优于对象存在，所以在对象还未创建完毕static修饰的方法就被调用，此时this代表的对象还未创建。\n\n#### String\n\nString底层定义为public final class String，说明String是常量，一旦被创建就不能修改。可以查看如Integer LongString这些类的源码：\n```bash\npublic final class Integer {}\npublic final class Long {}\npublic final class String {}\n\n```\n\n这些**基本类型**，在初始化值、赋值时都是先从**常量池**中取数据，如果常量池中没有该数据，就new对象初始化为新数据。\n比如常见的一个面试题：\n```bash\nString s = \"ab\";\ns = \"abc\";\nString ss = \"ab\";\nss = new String(\"ab\");\n```\n\n这个s和ss各自创建了几个对象？答案：s创建两个对象；ss创建一个对象。因为s的常量池中有值ab，而重新赋值s = \"abc\"这个abc在s的常量池中不存在，所以new String()创建了一个新对象。ss同理分析。可以通过如下方式验证：\n```bash\nString ss = \"ab\";\nSystem.out.println(ss.hashCode());\nss = \"abc\";\nSystem.out.println(ss.hashCode());\n```\n[stack](/images/String1.png)\n\n##### StringBuffer\nString是不可变的字符串，StringBuffer是线程安全的可变字符串，用StringBuffer做字符串的拼接可以避免资源的浪费，因为String每次拼接新的字符串都是创建一个新的String对象。\n\n**String转换为StringBuffer**\n```bash\n//方式一\nString s = \"hello\";\nStringBuffer sb = new StringBuffer(s);\n//方式二\nStringBuffer sb = new StringBuffer();\nsb.append(s);\n```\n\n**StringBuffer转换成String**\n```bash\n//方式一\nStringBuffer sb = new StringBuffer(\"hello\");\nString s = new String(sb);\n//方式二\nString s = sb.toString();\n```\n\n##### 面试题\n\n> String, StringBuffer, StringBuilder 的区别？\n- String的内容不可变，StringBuffer和StringBuilder的内容都可变。\n- StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。\n\n> StringBuffer和数组的区别？\n- 二者都是一个容器，装其他数据\n- 但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。\n\n> String和StringBuffer作为参数传递\n- String可理解为特殊的引用类型，和基本类型一样，参数传递不会改变原数据内容。\n- StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。\n\n```bash\npublic class StringBufferDemo {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        String s2 = \"world\";\n        System.out.println(s1 + \"---\" + s2);// hello---world\n        change(s1, s2);\n        System.out.println(s1 + \"---\" + s2);// hello---world\n\n        StringBuffer sb1 = new StringBuffer(\"hello\");\n        StringBuffer sb2 = new StringBuffer(\"world\");\n        System.out.println(sb1 + \"---\" + sb2);// hello---world\n        change(sb1, sb2);\n        System.out.println(sb1 + \"---\" + sb2);// hello---worldworld\n\n    }\n\n    public static void change(StringBuffer sb1, StringBuffer sb2) {\n        sb1 = sb2;\n        sb2.append(sb1);\n    }\n\n    public static void change(String s1, String s2) {\n        s1 = s2;\n        s2 = s1 + s2;\n    }\n}\n```\n\n#### 参数传递\n\nJava中的参数传递：\n- 基本类型：形式参数的改变对实际参数没有影响。\n- 引用类型：形式参数的改变直接影响实际参数。\n\n例如：\n```bash\npublic class Demo01_Object {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 20;\n        change(a, b);\n        System.out.println(\"main: a:\" + a + \", b:\" + b); //10, 20\n        int[] arr = {1, 2, 3};\n        change(arr);\n        System.out.println(\"main: \" + arr[0]); //2\n    }\n\n    private static void change(int a, int b) {\n        a = b;\n        b = a + b;\n        System.out.println(\"change: a:\" + a + \", b:\" + b); //20, 40\n    }\n\n    private static void change(int[] arr) {\n        arr[0] = arr[1];\n        System.out.println(\"change\" + arr[0]); //2\n    }\n}\n```\n\n**引入概念**：\n在Java中**一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。所有的Java对象都储存在堆内存中**。例如：Date t = new Date()其中的t就是一个对象变量，new Date()是在堆内存中开辟了一个空间，而t指向new Date()的堆内存地址。\n因此，在上述代码中a b都是基本类型，而int[]是一个引用类型，那**基本类型形式参数改变对实际参数没有影响；对象类型形式参数改变直接影响实际参数。**\n\n[stack](/images/stack.png)\n\n##### 总结\n**Java程序语言总是采用按值调用**，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。\n- 一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。\n- 一个方法可以改变一个对象的引用状态\n- 一个方法不能让对象参数引用一个新对象\n\n比如：下列是无意义的：\n```bash\npublic static void swap(Employee x, Employee y) {\n    Employee temp = x;\n    x = y;\n    y = temp;\n}\n```\n\n当调用swap(e1, e2)时并不会改变e1和e2的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。\n\n- **基本类型**（包括Integer String Long）传递的参数是参数**值**的拷贝\n\n特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如IntgerCache LongCache，如果常量池中没有就重新new对象，例如：\n```bash\npublic static void main(String[] args) {\n    String s = \"123\";\n    System.out.println(\"main: \" + s.hashCode()); //48690\n    change(s);\n    change2(s);\n}\nprivate static void change(String s) {\n    s = \"123\";\n    System.out.println(\"change: \" + s.hashCode()); //48690\n}\nprivate static change2(String s) {\n    s = \"456\";\n    System.out.println(\"change2: \" + s.hashCode()); //51669\n}\n```\n\n- **引用类型**传递的参数是原对象在**堆内存的地址**的拷贝\n\n对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。\n\n#### 成员变量和局部变量\n成员变量和局部变量的区别：\n* 在类中的位置不同：\n   - 成员变量：在类中方法外\n   - 局部变量：在方法定义中或方法声明上\n* 在内存中的位置不同：\n   - 成员变量：在堆内存\n   - 局部变量：在栈内存\n* 声明周期不同：\n   - 成员变量：随着对象的创建而存在，随着对象的消失而消失。\n   - 局部变量：随着方法的调用而存在，随着方法调用完毕而消失\n* 初始化值不同：\n   - 成员变量：有默认初始化值\n   - 局部变量：没有默认初始化值，必须定义、赋值后才能使用\n\n#### 构造方法\n在Java中，当需要调用构造方法时，**若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义**。举例：\n```bash\npublic class Demo2_Construct {\n    public static void main(String[] args) {\n        Demo2Student student = new Demo2Student();\n        student.show();\n        // Demo2School school = new Demo2School(); //error\n    }\n}\n\nclass Demo2Student {\n    public void show() {\n        System.out.println(\"this student show\");\n    }\n}\n\nclass Demo2School {\n    private int size = 1000;\n    public Demo2School(int size) {\n        this.size = size;\n    }\n}\n```\n\n##### final\nfinal可以修改类、方法、变量。\n\n**特点**：\n- final可以修饰类，该类不能被继承。\n- final可以修饰方法，该方法不能被重写。\n- final可以修饰变量，该变量不能被重新赋值。\n\n**面试题**：final修饰局部变量的问题\n- 基本类型：被final修饰的基本类型的值不能被改变\n- 引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。\n\n**初始化时机**\n被final修饰的变量必须在构造方法完毕前被初始化，比如\n```bash\npublic class Demo {\n    final int WIDTH = 12;\n    //final int HEIGHT; //error\n    final int AREA;\n    {\n        AREA = 120;\n    }\n}\n```\n\n#### 继承\n1、Java支持单继承不支持多继承，但Java支持多层继承\n2、子类只能继承父类非私有成员（成员变量、成员方法）\n3、子类不能继承父类的构造方法，但可以通过super关键字访问父类的构造方法。\n\n##### 子类和父类的关系\n**子类中的所有构造方法都默认访问父类的无参构造方法**。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是super()。\n```bash\npublic class Demo04_Extends {\n    public static void main(String[] args) {\n        Demo04Son son = new Demo04Son();\n        son.show();\n    }\n}\n\nclass Demo04Son extends Demo04Parent{\n    private int num = 10;\n    public Demo04Son() {\n        super();\n    }\n\n    public void show() {\n        int num = 100;\n        System.out.println(num);\n        System.out.println(this.num);\n        System.out.println(super.num);\n    }\n}\n\nclass Demo04Parent {\n    public int num = 1;\n\n    public Demo04Parent() {\n        System.out.println(\"这是父类的无参构造函数\");\n    }\n}\n```\n\n##### this-super\nthis和super关键字的区别和使用场景？\n区别：\n- this: 代表当前类的对象引用\n- super: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）\n场景：\n- this.成员变量/方法\n- super.成员变量/方法\n- this(…) super(…)\n\n##### 加载顺序\n```bash\npublic class Demo04_Extends2 {\n    public static void main(String[] args) {\n        Demo04Zi zi = new Demo04Zi();\n    }\n}\nclass Demo04Fu {\n    static {\n        System.out.println(\"Fu 静态代码块\");\n    }\n    {\n        System.out.println(\"Fu 构造代码块\");\n    }\n    public Demo04Fu() {\n        System.out.println(\"Fu 构造方法\");\n    }\n}\nclass Demo04Zi extends Demo04Fu{\n    static {\n        System.out.println(\"Zi 静态代码块\");\n    }\n    {\n        System.out.println(\"Zi 构造代码块\");\n    }\n    public Demo04Zi() {\n        System.out.println(\"Zi 构造方法\");\n    }\n}\n```\n\n结果：\n```bash\nFu 静态代码块\nZi 静态代码块\nFu 构造代码块\nFu 构造方法\nZi 构造代码块\nZi 构造方法\n```\n\n##### 动态绑定\n**调用对象方法的执行过程：**\n[DomaticBind](/images/DomaticBind.png)\n1.编译器首先查看对象的声明类型和方法名。如调用change(a)方法，由于存在多个change()方法，JVM会先列举该类以及其超类中访问属性为public且名为change的方法。\n2.接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个方法表**（method table）**，JVM会直接从这个方法表中寻找名为change的方法中存在一个与提供的参数类型匹配的方法，这个过程称为**重载解析**。\n3.如果是private、static、final方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为**静态绑定**。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现**动态绑定**。\n4.当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。\n\n##### 强制类型转换\n将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接(int) double这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。\n- **向上转型**：将一个子类的引用赋值给一个超类变量。\n- **向下转型**：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。\n\n**注意**\n\n- 只能在继承层次内进行类型转换。\n- 在将超类转换成子类之前，应该使用instanceof进行检查。\n\n##### 内部类\n\n一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。\n- 内部类可以直接访问外部类的成员，包括私有\n- 外部类可以访问内部类的成员，必须创建对象\n- 直接访问内部类的成员：Outer.Inner in = new Outer().new Inner()\n\n**局部内部类**\n局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。\n\n> 局部内部类访问局部变量注意事项?\n​局部内部类访问局部变量必须用final修饰。因为**局部内部类的声明周期比局部变量长**，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。\n\n```bash\npublic class InnerClass {\n    public static void main(String[] args) {\n        Outer outer = new Outer();\n        outer.show();\n    }\n}\n\nclass Outer {\n    public void show() {\n        int num2 = 10;\n        class Inner {\n            private void show() {\n                System.out.println(num2);\n            }\n        }\n        Inner inner = new Inner();\n        inner.show();\n    }\n}\n```\n此时调用不会报错，但并没有加final修饰。这个类编译后会生成InnerClass.class和Outer.class两个文件，我们来看下Outer.class:\n```bash\nclass Outer {\n    Outer() {}\n    public void show() {\n        final int num2 = 10;\n        class Inner {\n            Inner() {}\n            private void show() {\n                System.out.println(num2);\n            }\n        }\n        Inner inner = new Inner();\n        inner.show();\n    }\n}\n```\n其中的num2被自动加上了final修饰（这是因为JDK1.8的原因），所以如果你再添上num2 = 1000就会报错。\n\n> 解决办法\n上面说过了应该将num2用final修饰。其原因就是Inner类的生命周期要比num2的声明周期长，当show()方法调用完毕后num2就已经消失了，但此时Inner类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用final修饰，这个变量成为常量，在初始化内部类的时候，final num2就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。","source":"_posts/JavaBasic2.md","raw":"---\ntitle: Java基础（二）\ncategories:\n    - Java\ndate: 2018-08-08\ntags:\n\t- Java\n\t- Java基础\n\n---\n\n###对象与类\n\n#### 对象的创建\n\n比如Student s = new Student()实例化一个对象，其实经历了如下几个过程：\n将Student.class加载到内存中\n在栈内存中给s开辟内存空间。\n在堆内存给Student类申请一个内存空间。\n给成员变量进行默认初始化，0 null false…\n自定义给成员变量初始化赋值\n初始化完毕，把堆内存地址赋值给栈内存的s变量\n\n#### Main方法剖析\n\n```bash\npublic static void main(String[] args) { ... }\n```\n\n- public: 公共的，访问权限最大，因为main方法是被JVM调用的。\n- static：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。\n- void: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。\n- main: 常见的方法入口，很多语言的入口方法都是main方法。\n- String[] args: 字符串数组，是作为命令行参数调用的。\n\n##### static关键字\n\n**static关键字特点：（可以修饰成员变量，也可修饰成员方法）**\n\n- 随着类的加载而加载\n- 优先于对象存在\n- 被类中的所有对象共享\n- 可直接通过类名调用\n\n**拓展**\n\n静态方法中没有this关键字，因为this代表当前方法对象，但static优于对象存在，所以在对象还未创建完毕static修饰的方法就被调用，此时this代表的对象还未创建。\n\n#### String\n\nString底层定义为public final class String，说明String是常量，一旦被创建就不能修改。可以查看如Integer LongString这些类的源码：\n```bash\npublic final class Integer {}\npublic final class Long {}\npublic final class String {}\n\n```\n\n这些**基本类型**，在初始化值、赋值时都是先从**常量池**中取数据，如果常量池中没有该数据，就new对象初始化为新数据。\n比如常见的一个面试题：\n```bash\nString s = \"ab\";\ns = \"abc\";\nString ss = \"ab\";\nss = new String(\"ab\");\n```\n\n这个s和ss各自创建了几个对象？答案：s创建两个对象；ss创建一个对象。因为s的常量池中有值ab，而重新赋值s = \"abc\"这个abc在s的常量池中不存在，所以new String()创建了一个新对象。ss同理分析。可以通过如下方式验证：\n```bash\nString ss = \"ab\";\nSystem.out.println(ss.hashCode());\nss = \"abc\";\nSystem.out.println(ss.hashCode());\n```\n[stack](/images/String1.png)\n\n##### StringBuffer\nString是不可变的字符串，StringBuffer是线程安全的可变字符串，用StringBuffer做字符串的拼接可以避免资源的浪费，因为String每次拼接新的字符串都是创建一个新的String对象。\n\n**String转换为StringBuffer**\n```bash\n//方式一\nString s = \"hello\";\nStringBuffer sb = new StringBuffer(s);\n//方式二\nStringBuffer sb = new StringBuffer();\nsb.append(s);\n```\n\n**StringBuffer转换成String**\n```bash\n//方式一\nStringBuffer sb = new StringBuffer(\"hello\");\nString s = new String(sb);\n//方式二\nString s = sb.toString();\n```\n\n##### 面试题\n\n> String, StringBuffer, StringBuilder 的区别？\n- String的内容不可变，StringBuffer和StringBuilder的内容都可变。\n- StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。\n\n> StringBuffer和数组的区别？\n- 二者都是一个容器，装其他数据\n- 但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。\n\n> String和StringBuffer作为参数传递\n- String可理解为特殊的引用类型，和基本类型一样，参数传递不会改变原数据内容。\n- StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。\n\n```bash\npublic class StringBufferDemo {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        String s2 = \"world\";\n        System.out.println(s1 + \"---\" + s2);// hello---world\n        change(s1, s2);\n        System.out.println(s1 + \"---\" + s2);// hello---world\n\n        StringBuffer sb1 = new StringBuffer(\"hello\");\n        StringBuffer sb2 = new StringBuffer(\"world\");\n        System.out.println(sb1 + \"---\" + sb2);// hello---world\n        change(sb1, sb2);\n        System.out.println(sb1 + \"---\" + sb2);// hello---worldworld\n\n    }\n\n    public static void change(StringBuffer sb1, StringBuffer sb2) {\n        sb1 = sb2;\n        sb2.append(sb1);\n    }\n\n    public static void change(String s1, String s2) {\n        s1 = s2;\n        s2 = s1 + s2;\n    }\n}\n```\n\n#### 参数传递\n\nJava中的参数传递：\n- 基本类型：形式参数的改变对实际参数没有影响。\n- 引用类型：形式参数的改变直接影响实际参数。\n\n例如：\n```bash\npublic class Demo01_Object {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 20;\n        change(a, b);\n        System.out.println(\"main: a:\" + a + \", b:\" + b); //10, 20\n        int[] arr = {1, 2, 3};\n        change(arr);\n        System.out.println(\"main: \" + arr[0]); //2\n    }\n\n    private static void change(int a, int b) {\n        a = b;\n        b = a + b;\n        System.out.println(\"change: a:\" + a + \", b:\" + b); //20, 40\n    }\n\n    private static void change(int[] arr) {\n        arr[0] = arr[1];\n        System.out.println(\"change\" + arr[0]); //2\n    }\n}\n```\n\n**引入概念**：\n在Java中**一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。所有的Java对象都储存在堆内存中**。例如：Date t = new Date()其中的t就是一个对象变量，new Date()是在堆内存中开辟了一个空间，而t指向new Date()的堆内存地址。\n因此，在上述代码中a b都是基本类型，而int[]是一个引用类型，那**基本类型形式参数改变对实际参数没有影响；对象类型形式参数改变直接影响实际参数。**\n\n[stack](/images/stack.png)\n\n##### 总结\n**Java程序语言总是采用按值调用**，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。\n- 一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。\n- 一个方法可以改变一个对象的引用状态\n- 一个方法不能让对象参数引用一个新对象\n\n比如：下列是无意义的：\n```bash\npublic static void swap(Employee x, Employee y) {\n    Employee temp = x;\n    x = y;\n    y = temp;\n}\n```\n\n当调用swap(e1, e2)时并不会改变e1和e2的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。\n\n- **基本类型**（包括Integer String Long）传递的参数是参数**值**的拷贝\n\n特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如IntgerCache LongCache，如果常量池中没有就重新new对象，例如：\n```bash\npublic static void main(String[] args) {\n    String s = \"123\";\n    System.out.println(\"main: \" + s.hashCode()); //48690\n    change(s);\n    change2(s);\n}\nprivate static void change(String s) {\n    s = \"123\";\n    System.out.println(\"change: \" + s.hashCode()); //48690\n}\nprivate static change2(String s) {\n    s = \"456\";\n    System.out.println(\"change2: \" + s.hashCode()); //51669\n}\n```\n\n- **引用类型**传递的参数是原对象在**堆内存的地址**的拷贝\n\n对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。\n\n#### 成员变量和局部变量\n成员变量和局部变量的区别：\n* 在类中的位置不同：\n   - 成员变量：在类中方法外\n   - 局部变量：在方法定义中或方法声明上\n* 在内存中的位置不同：\n   - 成员变量：在堆内存\n   - 局部变量：在栈内存\n* 声明周期不同：\n   - 成员变量：随着对象的创建而存在，随着对象的消失而消失。\n   - 局部变量：随着方法的调用而存在，随着方法调用完毕而消失\n* 初始化值不同：\n   - 成员变量：有默认初始化值\n   - 局部变量：没有默认初始化值，必须定义、赋值后才能使用\n\n#### 构造方法\n在Java中，当需要调用构造方法时，**若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义**。举例：\n```bash\npublic class Demo2_Construct {\n    public static void main(String[] args) {\n        Demo2Student student = new Demo2Student();\n        student.show();\n        // Demo2School school = new Demo2School(); //error\n    }\n}\n\nclass Demo2Student {\n    public void show() {\n        System.out.println(\"this student show\");\n    }\n}\n\nclass Demo2School {\n    private int size = 1000;\n    public Demo2School(int size) {\n        this.size = size;\n    }\n}\n```\n\n##### final\nfinal可以修改类、方法、变量。\n\n**特点**：\n- final可以修饰类，该类不能被继承。\n- final可以修饰方法，该方法不能被重写。\n- final可以修饰变量，该变量不能被重新赋值。\n\n**面试题**：final修饰局部变量的问题\n- 基本类型：被final修饰的基本类型的值不能被改变\n- 引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。\n\n**初始化时机**\n被final修饰的变量必须在构造方法完毕前被初始化，比如\n```bash\npublic class Demo {\n    final int WIDTH = 12;\n    //final int HEIGHT; //error\n    final int AREA;\n    {\n        AREA = 120;\n    }\n}\n```\n\n#### 继承\n1、Java支持单继承不支持多继承，但Java支持多层继承\n2、子类只能继承父类非私有成员（成员变量、成员方法）\n3、子类不能继承父类的构造方法，但可以通过super关键字访问父类的构造方法。\n\n##### 子类和父类的关系\n**子类中的所有构造方法都默认访问父类的无参构造方法**。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是super()。\n```bash\npublic class Demo04_Extends {\n    public static void main(String[] args) {\n        Demo04Son son = new Demo04Son();\n        son.show();\n    }\n}\n\nclass Demo04Son extends Demo04Parent{\n    private int num = 10;\n    public Demo04Son() {\n        super();\n    }\n\n    public void show() {\n        int num = 100;\n        System.out.println(num);\n        System.out.println(this.num);\n        System.out.println(super.num);\n    }\n}\n\nclass Demo04Parent {\n    public int num = 1;\n\n    public Demo04Parent() {\n        System.out.println(\"这是父类的无参构造函数\");\n    }\n}\n```\n\n##### this-super\nthis和super关键字的区别和使用场景？\n区别：\n- this: 代表当前类的对象引用\n- super: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）\n场景：\n- this.成员变量/方法\n- super.成员变量/方法\n- this(…) super(…)\n\n##### 加载顺序\n```bash\npublic class Demo04_Extends2 {\n    public static void main(String[] args) {\n        Demo04Zi zi = new Demo04Zi();\n    }\n}\nclass Demo04Fu {\n    static {\n        System.out.println(\"Fu 静态代码块\");\n    }\n    {\n        System.out.println(\"Fu 构造代码块\");\n    }\n    public Demo04Fu() {\n        System.out.println(\"Fu 构造方法\");\n    }\n}\nclass Demo04Zi extends Demo04Fu{\n    static {\n        System.out.println(\"Zi 静态代码块\");\n    }\n    {\n        System.out.println(\"Zi 构造代码块\");\n    }\n    public Demo04Zi() {\n        System.out.println(\"Zi 构造方法\");\n    }\n}\n```\n\n结果：\n```bash\nFu 静态代码块\nZi 静态代码块\nFu 构造代码块\nFu 构造方法\nZi 构造代码块\nZi 构造方法\n```\n\n##### 动态绑定\n**调用对象方法的执行过程：**\n[DomaticBind](/images/DomaticBind.png)\n1.编译器首先查看对象的声明类型和方法名。如调用change(a)方法，由于存在多个change()方法，JVM会先列举该类以及其超类中访问属性为public且名为change的方法。\n2.接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个方法表**（method table）**，JVM会直接从这个方法表中寻找名为change的方法中存在一个与提供的参数类型匹配的方法，这个过程称为**重载解析**。\n3.如果是private、static、final方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为**静态绑定**。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现**动态绑定**。\n4.当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。\n\n##### 强制类型转换\n将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接(int) double这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。\n- **向上转型**：将一个子类的引用赋值给一个超类变量。\n- **向下转型**：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。\n\n**注意**\n\n- 只能在继承层次内进行类型转换。\n- 在将超类转换成子类之前，应该使用instanceof进行检查。\n\n##### 内部类\n\n一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。\n- 内部类可以直接访问外部类的成员，包括私有\n- 外部类可以访问内部类的成员，必须创建对象\n- 直接访问内部类的成员：Outer.Inner in = new Outer().new Inner()\n\n**局部内部类**\n局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。\n\n> 局部内部类访问局部变量注意事项?\n​局部内部类访问局部变量必须用final修饰。因为**局部内部类的声明周期比局部变量长**，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。\n\n```bash\npublic class InnerClass {\n    public static void main(String[] args) {\n        Outer outer = new Outer();\n        outer.show();\n    }\n}\n\nclass Outer {\n    public void show() {\n        int num2 = 10;\n        class Inner {\n            private void show() {\n                System.out.println(num2);\n            }\n        }\n        Inner inner = new Inner();\n        inner.show();\n    }\n}\n```\n此时调用不会报错，但并没有加final修饰。这个类编译后会生成InnerClass.class和Outer.class两个文件，我们来看下Outer.class:\n```bash\nclass Outer {\n    Outer() {}\n    public void show() {\n        final int num2 = 10;\n        class Inner {\n            Inner() {}\n            private void show() {\n                System.out.println(num2);\n            }\n        }\n        Inner inner = new Inner();\n        inner.show();\n    }\n}\n```\n其中的num2被自动加上了final修饰（这是因为JDK1.8的原因），所以如果你再添上num2 = 1000就会报错。\n\n> 解决办法\n上面说过了应该将num2用final修饰。其原因就是Inner类的生命周期要比num2的声明周期长，当show()方法调用完毕后num2就已经消失了，但此时Inner类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用final修饰，这个变量成为常量，在初始化内部类的时候，final num2就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。","slug":"JavaBasic2","published":1,"updated":"2020-02-21T15:28:00.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyl0006v9s62zjt1tpo","content":"<p>###对象与类</p>\n<h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><p>比如Student s = new Student()实例化一个对象，其实经历了如下几个过程：<br>将Student.class加载到内存中<br>在栈内存中给s开辟内存空间。<br>在堆内存给Student类申请一个内存空间。<br>给成员变量进行默认初始化，0 null false…<br>自定义给成员变量初始化赋值<br>初始化完毕，把堆内存地址赋值给栈内存的s变量</p>\n<h4 id=\"Main方法剖析\"><a href=\"#Main方法剖析\" class=\"headerlink\" title=\"Main方法剖析\"></a>Main方法剖析</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>public: 公共的，访问权限最大，因为main方法是被JVM调用的。</li>\n<li>static：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。</li>\n<li>void: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。</li>\n<li>main: 常见的方法入口，很多语言的入口方法都是main方法。</li>\n<li>String[] args: 字符串数组，是作为命令行参数调用的。</li>\n</ul>\n<h5 id=\"static关键字\"><a href=\"#static关键字\" class=\"headerlink\" title=\"static关键字\"></a>static关键字</h5><p><strong>static关键字特点：（可以修饰成员变量，也可修饰成员方法）</strong></p>\n<ul>\n<li>随着类的加载而加载</li>\n<li>优先于对象存在</li>\n<li>被类中的所有对象共享</li>\n<li>可直接通过类名调用</li>\n</ul>\n<p><strong>拓展</strong></p>\n<p>静态方法中没有this关键字，因为this代表当前方法对象，但static优于对象存在，所以在对象还未创建完毕static修饰的方法就被调用，此时this代表的对象还未创建。</p>\n<h4 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h4><p>String底层定义为public final class String，说明String是常量，一旦被创建就不能修改。可以查看如Integer LongString这些类的源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class Integer &#123;&#125;</span><br><span class=\"line\">public final class Long &#123;&#125;</span><br><span class=\"line\">public final class String &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这些<strong>基本类型</strong>，在初始化值、赋值时都是先从<strong>常量池</strong>中取数据，如果常量池中没有该数据，就new对象初始化为新数据。<br>比如常见的一个面试题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">s = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">String ss = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">ss = new String(<span class=\"string\">\"ab\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个s和ss各自创建了几个对象？答案：s创建两个对象；ss创建一个对象。因为s的常量池中有值ab，而重新赋值s = “abc”这个abc在s的常量池中不存在，所以new String()创建了一个新对象。ss同理分析。可以通过如下方式验证：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String ss = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">System.out.println(ss.hashCode());</span><br><span class=\"line\">ss = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">System.out.println(ss.hashCode());</span><br></pre></td></tr></table></figure>\n<p><a href=\"/images/String1.png\">stack</a></p>\n<h5 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h5><p>String是不可变的字符串，StringBuffer是线程安全的可变字符串，用StringBuffer做字符串的拼接可以避免资源的浪费，因为String每次拼接新的字符串都是创建一个新的String对象。</p>\n<p><strong>String转换为StringBuffer</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式一</span><br><span class=\"line\">String s = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">StringBuffer sb = new StringBuffer(s);</span><br><span class=\"line\">//方式二</span><br><span class=\"line\">StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">sb.append(s);</span><br></pre></td></tr></table></figure>\n\n<p><strong>StringBuffer转换成String</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式一</span><br><span class=\"line\">StringBuffer sb = new StringBuffer(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">String s = new String(sb);</span><br><span class=\"line\">//方式二</span><br><span class=\"line\">String s = sb.toString();</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h5><blockquote>\n<p>String, StringBuffer, StringBuilder 的区别？</p>\n</blockquote>\n<ul>\n<li>String的内容不可变，StringBuffer和StringBuilder的内容都可变。</li>\n<li>StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。</li>\n</ul>\n<blockquote>\n<p>StringBuffer和数组的区别？</p>\n</blockquote>\n<ul>\n<li>二者都是一个容器，装其他数据</li>\n<li>但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。</li>\n</ul>\n<blockquote>\n<p>String和StringBuffer作为参数传递</p>\n</blockquote>\n<ul>\n<li>String可理解为特殊的引用类型，和基本类型一样，参数传递不会改变原数据内容。</li>\n<li>StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StringBufferDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String s1 = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">        String s2 = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\">        System.out.println(s1 + <span class=\"string\">\"---\"</span> + s2);// hello---world</span><br><span class=\"line\">        change(s1, s2);</span><br><span class=\"line\">        System.out.println(s1 + <span class=\"string\">\"---\"</span> + s2);// hello---world</span><br><span class=\"line\"></span><br><span class=\"line\">        StringBuffer sb1 = new StringBuffer(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">        StringBuffer sb2 = new StringBuffer(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">        System.out.println(sb1 + <span class=\"string\">\"---\"</span> + sb2);// hello---world</span><br><span class=\"line\">        change(sb1, sb2);</span><br><span class=\"line\">        System.out.println(sb1 + <span class=\"string\">\"---\"</span> + sb2);// hello---worldworld</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void change(StringBuffer sb1, StringBuffer sb2) &#123;</span><br><span class=\"line\">        sb1 = sb2;</span><br><span class=\"line\">        sb2.append(sb1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void change(String s1, String s2) &#123;</span><br><span class=\"line\">        s1 = s2;</span><br><span class=\"line\">        s2 = s1 + s2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><p>Java中的参数传递：</p>\n<ul>\n<li>基本类型：形式参数的改变对实际参数没有影响。</li>\n<li>引用类型：形式参数的改变直接影响实际参数。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo01_Object &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a = 10;</span><br><span class=\"line\">        int b = 20;</span><br><span class=\"line\">        change(a, b);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"main: a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b); //10, 20</span><br><span class=\"line\">        int[] arr = &#123;1, 2, 3&#125;;</span><br><span class=\"line\">        change(arr);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"main: \"</span> + arr[0]); //2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void change(int a, int b) &#123;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">        b = a + b;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"change: a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b); //20, 40</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void change(int[] arr) &#123;</span><br><span class=\"line\">        arr[0] = arr[1];</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"change\"</span> + arr[0]); //2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>引入概念</strong>：<br>在Java中<strong>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。所有的Java对象都储存在堆内存中</strong>。例如：Date t = new Date()其中的t就是一个对象变量，new Date()是在堆内存中开辟了一个空间，而t指向new Date()的堆内存地址。<br>因此，在上述代码中a b都是基本类型，而int[]是一个引用类型，那<strong>基本类型形式参数改变对实际参数没有影响；对象类型形式参数改变直接影响实际参数。</strong></p>\n<p><a href=\"/images/stack.png\">stack</a></p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p><strong>Java程序语言总是采用按值调用</strong>，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。</li>\n<li>一个方法可以改变一个对象的引用状态</li>\n<li>一个方法不能让对象参数引用一个新对象</li>\n</ul>\n<p>比如：下列是无意义的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void swap(Employee x, Employee y) &#123;</span><br><span class=\"line\">    Employee temp = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用swap(e1, e2)时并不会改变e1和e2的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</p>\n<ul>\n<li><strong>基本类型</strong>（包括Integer String Long）传递的参数是参数<strong>值</strong>的拷贝</li>\n</ul>\n<p>特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如IntgerCache LongCache，如果常量池中没有就重新new对象，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    String s = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"main: \"</span> + s.hashCode()); //48690</span><br><span class=\"line\">    change(s);</span><br><span class=\"line\">    change2(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static void change(String s) &#123;</span><br><span class=\"line\">    s = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"change: \"</span> + s.hashCode()); //48690</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static change2(String s) &#123;</span><br><span class=\"line\">    s = <span class=\"string\">\"456\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"change2: \"</span> + s.hashCode()); //51669</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>引用类型</strong>传递的参数是原对象在<strong>堆内存的地址</strong>的拷贝</li>\n</ul>\n<p>对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。</p>\n<h4 id=\"成员变量和局部变量\"><a href=\"#成员变量和局部变量\" class=\"headerlink\" title=\"成员变量和局部变量\"></a>成员变量和局部变量</h4><p>成员变量和局部变量的区别：</p>\n<ul>\n<li>在类中的位置不同：<ul>\n<li>成员变量：在类中方法外</li>\n<li>局部变量：在方法定义中或方法声明上</li>\n</ul>\n</li>\n<li>在内存中的位置不同：<ul>\n<li>成员变量：在堆内存</li>\n<li>局部变量：在栈内存</li>\n</ul>\n</li>\n<li>声明周期不同：<ul>\n<li>成员变量：随着对象的创建而存在，随着对象的消失而消失。</li>\n<li>局部变量：随着方法的调用而存在，随着方法调用完毕而消失</li>\n</ul>\n</li>\n<li>初始化值不同：<ul>\n<li>成员变量：有默认初始化值</li>\n<li>局部变量：没有默认初始化值，必须定义、赋值后才能使用</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p>在Java中，当需要调用构造方法时，<strong>若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义</strong>。举例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo2_Construct &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo2Student student = new Demo2Student();</span><br><span class=\"line\">        student.show();</span><br><span class=\"line\">        // Demo2School school = new Demo2School(); //error</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo2Student &#123;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"this student show\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo2School &#123;</span><br><span class=\"line\">    private int size = 1000;</span><br><span class=\"line\">    public Demo2School(int size) &#123;</span><br><span class=\"line\">        this.size = size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h5><p>final可以修改类、方法、变量。</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>final可以修饰类，该类不能被继承。</li>\n<li>final可以修饰方法，该方法不能被重写。</li>\n<li>final可以修饰变量，该变量不能被重新赋值。</li>\n</ul>\n<p><strong>面试题</strong>：final修饰局部变量的问题</p>\n<ul>\n<li>基本类型：被final修饰的基本类型的值不能被改变</li>\n<li>引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。</li>\n</ul>\n<p><strong>初始化时机</strong><br>被final修饰的变量必须在构造方法完毕前被初始化，比如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\">    final int WIDTH = 12;</span><br><span class=\"line\">    //final int HEIGHT; //error</span><br><span class=\"line\">    final int AREA;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AREA = 120;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>1、Java支持单继承不支持多继承，但Java支持多层继承<br>2、子类只能继承父类非私有成员（成员变量、成员方法）<br>3、子类不能继承父类的构造方法，但可以通过super关键字访问父类的构造方法。</p>\n<h5 id=\"子类和父类的关系\"><a href=\"#子类和父类的关系\" class=\"headerlink\" title=\"子类和父类的关系\"></a>子类和父类的关系</h5><p><strong>子类中的所有构造方法都默认访问父类的无参构造方法</strong>。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是super()。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo04_Extends &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo04Son son = new Demo04Son();</span><br><span class=\"line\">        son.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo04Son extends Demo04Parent&#123;</span><br><span class=\"line\">    private int num = 10;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Son</span></span>() &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        int num = 100;</span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">        System.out.println(this.num);</span><br><span class=\"line\">        System.out.println(super.num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo04Parent &#123;</span><br><span class=\"line\">    public int num = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Parent</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"这是父类的无参构造函数\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"this-super\"><a href=\"#this-super\" class=\"headerlink\" title=\"this-super\"></a>this-super</h5><p>this和super关键字的区别和使用场景？<br>区别：</p>\n<ul>\n<li>this: 代表当前类的对象引用</li>\n<li>super: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）<br>场景：</li>\n<li>this.成员变量/方法</li>\n<li>super.成员变量/方法</li>\n<li>this(…) super(…)</li>\n</ul>\n<h5 id=\"加载顺序\"><a href=\"#加载顺序\" class=\"headerlink\" title=\"加载顺序\"></a>加载顺序</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo04_Extends2 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo04Zi zi = new Demo04Zi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Demo04Fu &#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 构造代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Fu</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Demo04Zi extends Demo04Fu&#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 构造代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Zi</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fu 静态代码块</span><br><span class=\"line\">Zi 静态代码块</span><br><span class=\"line\">Fu 构造代码块</span><br><span class=\"line\">Fu 构造方法</span><br><span class=\"line\">Zi 构造代码块</span><br><span class=\"line\">Zi 构造方法</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h5><p><strong>调用对象方法的执行过程：</strong><br><a href=\"/images/DomaticBind.png\">DomaticBind</a><br>1.编译器首先查看对象的声明类型和方法名。如调用change(a)方法，由于存在多个change()方法，JVM会先列举该类以及其超类中访问属性为public且名为change的方法。<br>2.接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个方法表<strong>（method table）</strong>，JVM会直接从这个方法表中寻找名为change的方法中存在一个与提供的参数类型匹配的方法，这个过程称为<strong>重载解析</strong>。<br>3.如果是private、static、final方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为<strong>静态绑定</strong>。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现<strong>动态绑定</strong>。<br>4.当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。</p>\n<h5 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h5><p>将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接(int) double这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。</p>\n<ul>\n<li><strong>向上转型</strong>：将一个子类的引用赋值给一个超类变量。</li>\n<li><strong>向下转型</strong>：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>只能在继承层次内进行类型转换。</li>\n<li>在将超类转换成子类之前，应该使用instanceof进行检查。</li>\n</ul>\n<h5 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h5><p>一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。</p>\n<ul>\n<li>内部类可以直接访问外部类的成员，包括私有</li>\n<li>外部类可以访问内部类的成员，必须创建对象</li>\n<li>直接访问内部类的成员：Outer.Inner in = new Outer().new Inner()</li>\n</ul>\n<p><strong>局部内部类</strong><br>局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。</p>\n<blockquote>\n<p>局部内部类访问局部变量注意事项?<br>​局部内部类访问局部变量必须用final修饰。因为<strong>局部内部类的声明周期比局部变量长</strong>，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class InnerClass &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Outer outer = new Outer();</span><br><span class=\"line\">        outer.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Outer &#123;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        int num2 = 10;</span><br><span class=\"line\">        class Inner &#123;</span><br><span class=\"line\">            private void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">                System.out.println(num2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Inner inner = new Inner();</span><br><span class=\"line\">        inner.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时调用不会报错，但并没有加final修饰。这个类编译后会生成InnerClass.class和Outer.class两个文件，我们来看下Outer.class:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Outer &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">Outer</span></span>() &#123;&#125;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        final int num2 = 10;</span><br><span class=\"line\">        class Inner &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">Inner</span></span>() &#123;&#125;</span><br><span class=\"line\">            private void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">                System.out.println(num2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Inner inner = new Inner();</span><br><span class=\"line\">        inner.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中的num2被自动加上了final修饰（这是因为JDK1.8的原因），所以如果你再添上num2 = 1000就会报错。</p>\n<blockquote>\n<p>解决办法<br>上面说过了应该将num2用final修饰。其原因就是Inner类的生命周期要比num2的声明周期长，当show()方法调用完毕后num2就已经消失了，但此时Inner类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用final修饰，这个变量成为常量，在初始化内部类的时候，final num2就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>###对象与类</p>\n<h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><p>比如Student s = new Student()实例化一个对象，其实经历了如下几个过程：<br>将Student.class加载到内存中<br>在栈内存中给s开辟内存空间。<br>在堆内存给Student类申请一个内存空间。<br>给成员变量进行默认初始化，0 null false…<br>自定义给成员变量初始化赋值<br>初始化完毕，把堆内存地址赋值给栈内存的s变量</p>\n<h4 id=\"Main方法剖析\"><a href=\"#Main方法剖析\" class=\"headerlink\" title=\"Main方法剖析\"></a>Main方法剖析</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>public: 公共的，访问权限最大，因为main方法是被JVM调用的。</li>\n<li>static：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。</li>\n<li>void: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。</li>\n<li>main: 常见的方法入口，很多语言的入口方法都是main方法。</li>\n<li>String[] args: 字符串数组，是作为命令行参数调用的。</li>\n</ul>\n<h5 id=\"static关键字\"><a href=\"#static关键字\" class=\"headerlink\" title=\"static关键字\"></a>static关键字</h5><p><strong>static关键字特点：（可以修饰成员变量，也可修饰成员方法）</strong></p>\n<ul>\n<li>随着类的加载而加载</li>\n<li>优先于对象存在</li>\n<li>被类中的所有对象共享</li>\n<li>可直接通过类名调用</li>\n</ul>\n<p><strong>拓展</strong></p>\n<p>静态方法中没有this关键字，因为this代表当前方法对象，但static优于对象存在，所以在对象还未创建完毕static修饰的方法就被调用，此时this代表的对象还未创建。</p>\n<h4 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h4><p>String底层定义为public final class String，说明String是常量，一旦被创建就不能修改。可以查看如Integer LongString这些类的源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class Integer &#123;&#125;</span><br><span class=\"line\">public final class Long &#123;&#125;</span><br><span class=\"line\">public final class String &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这些<strong>基本类型</strong>，在初始化值、赋值时都是先从<strong>常量池</strong>中取数据，如果常量池中没有该数据，就new对象初始化为新数据。<br>比如常见的一个面试题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">s = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">String ss = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">ss = new String(<span class=\"string\">\"ab\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个s和ss各自创建了几个对象？答案：s创建两个对象；ss创建一个对象。因为s的常量池中有值ab，而重新赋值s = “abc”这个abc在s的常量池中不存在，所以new String()创建了一个新对象。ss同理分析。可以通过如下方式验证：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String ss = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">System.out.println(ss.hashCode());</span><br><span class=\"line\">ss = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">System.out.println(ss.hashCode());</span><br></pre></td></tr></table></figure>\n<p><a href=\"/images/String1.png\">stack</a></p>\n<h5 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h5><p>String是不可变的字符串，StringBuffer是线程安全的可变字符串，用StringBuffer做字符串的拼接可以避免资源的浪费，因为String每次拼接新的字符串都是创建一个新的String对象。</p>\n<p><strong>String转换为StringBuffer</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式一</span><br><span class=\"line\">String s = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">StringBuffer sb = new StringBuffer(s);</span><br><span class=\"line\">//方式二</span><br><span class=\"line\">StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">sb.append(s);</span><br></pre></td></tr></table></figure>\n\n<p><strong>StringBuffer转换成String</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式一</span><br><span class=\"line\">StringBuffer sb = new StringBuffer(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">String s = new String(sb);</span><br><span class=\"line\">//方式二</span><br><span class=\"line\">String s = sb.toString();</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h5><blockquote>\n<p>String, StringBuffer, StringBuilder 的区别？</p>\n</blockquote>\n<ul>\n<li>String的内容不可变，StringBuffer和StringBuilder的内容都可变。</li>\n<li>StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。</li>\n</ul>\n<blockquote>\n<p>StringBuffer和数组的区别？</p>\n</blockquote>\n<ul>\n<li>二者都是一个容器，装其他数据</li>\n<li>但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。</li>\n</ul>\n<blockquote>\n<p>String和StringBuffer作为参数传递</p>\n</blockquote>\n<ul>\n<li>String可理解为特殊的引用类型，和基本类型一样，参数传递不会改变原数据内容。</li>\n<li>StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StringBufferDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String s1 = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">        String s2 = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\">        System.out.println(s1 + <span class=\"string\">\"---\"</span> + s2);// hello---world</span><br><span class=\"line\">        change(s1, s2);</span><br><span class=\"line\">        System.out.println(s1 + <span class=\"string\">\"---\"</span> + s2);// hello---world</span><br><span class=\"line\"></span><br><span class=\"line\">        StringBuffer sb1 = new StringBuffer(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">        StringBuffer sb2 = new StringBuffer(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">        System.out.println(sb1 + <span class=\"string\">\"---\"</span> + sb2);// hello---world</span><br><span class=\"line\">        change(sb1, sb2);</span><br><span class=\"line\">        System.out.println(sb1 + <span class=\"string\">\"---\"</span> + sb2);// hello---worldworld</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void change(StringBuffer sb1, StringBuffer sb2) &#123;</span><br><span class=\"line\">        sb1 = sb2;</span><br><span class=\"line\">        sb2.append(sb1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void change(String s1, String s2) &#123;</span><br><span class=\"line\">        s1 = s2;</span><br><span class=\"line\">        s2 = s1 + s2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><p>Java中的参数传递：</p>\n<ul>\n<li>基本类型：形式参数的改变对实际参数没有影响。</li>\n<li>引用类型：形式参数的改变直接影响实际参数。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo01_Object &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a = 10;</span><br><span class=\"line\">        int b = 20;</span><br><span class=\"line\">        change(a, b);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"main: a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b); //10, 20</span><br><span class=\"line\">        int[] arr = &#123;1, 2, 3&#125;;</span><br><span class=\"line\">        change(arr);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"main: \"</span> + arr[0]); //2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void change(int a, int b) &#123;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">        b = a + b;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"change: a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b); //20, 40</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void change(int[] arr) &#123;</span><br><span class=\"line\">        arr[0] = arr[1];</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"change\"</span> + arr[0]); //2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>引入概念</strong>：<br>在Java中<strong>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。所有的Java对象都储存在堆内存中</strong>。例如：Date t = new Date()其中的t就是一个对象变量，new Date()是在堆内存中开辟了一个空间，而t指向new Date()的堆内存地址。<br>因此，在上述代码中a b都是基本类型，而int[]是一个引用类型，那<strong>基本类型形式参数改变对实际参数没有影响；对象类型形式参数改变直接影响实际参数。</strong></p>\n<p><a href=\"/images/stack.png\">stack</a></p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p><strong>Java程序语言总是采用按值调用</strong>，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。</li>\n<li>一个方法可以改变一个对象的引用状态</li>\n<li>一个方法不能让对象参数引用一个新对象</li>\n</ul>\n<p>比如：下列是无意义的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void swap(Employee x, Employee y) &#123;</span><br><span class=\"line\">    Employee temp = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用swap(e1, e2)时并不会改变e1和e2的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</p>\n<ul>\n<li><strong>基本类型</strong>（包括Integer String Long）传递的参数是参数<strong>值</strong>的拷贝</li>\n</ul>\n<p>特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如IntgerCache LongCache，如果常量池中没有就重新new对象，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    String s = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"main: \"</span> + s.hashCode()); //48690</span><br><span class=\"line\">    change(s);</span><br><span class=\"line\">    change2(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static void change(String s) &#123;</span><br><span class=\"line\">    s = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"change: \"</span> + s.hashCode()); //48690</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static change2(String s) &#123;</span><br><span class=\"line\">    s = <span class=\"string\">\"456\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"change2: \"</span> + s.hashCode()); //51669</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>引用类型</strong>传递的参数是原对象在<strong>堆内存的地址</strong>的拷贝</li>\n</ul>\n<p>对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。</p>\n<h4 id=\"成员变量和局部变量\"><a href=\"#成员变量和局部变量\" class=\"headerlink\" title=\"成员变量和局部变量\"></a>成员变量和局部变量</h4><p>成员变量和局部变量的区别：</p>\n<ul>\n<li>在类中的位置不同：<ul>\n<li>成员变量：在类中方法外</li>\n<li>局部变量：在方法定义中或方法声明上</li>\n</ul>\n</li>\n<li>在内存中的位置不同：<ul>\n<li>成员变量：在堆内存</li>\n<li>局部变量：在栈内存</li>\n</ul>\n</li>\n<li>声明周期不同：<ul>\n<li>成员变量：随着对象的创建而存在，随着对象的消失而消失。</li>\n<li>局部变量：随着方法的调用而存在，随着方法调用完毕而消失</li>\n</ul>\n</li>\n<li>初始化值不同：<ul>\n<li>成员变量：有默认初始化值</li>\n<li>局部变量：没有默认初始化值，必须定义、赋值后才能使用</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p>在Java中，当需要调用构造方法时，<strong>若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义</strong>。举例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo2_Construct &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo2Student student = new Demo2Student();</span><br><span class=\"line\">        student.show();</span><br><span class=\"line\">        // Demo2School school = new Demo2School(); //error</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo2Student &#123;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"this student show\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo2School &#123;</span><br><span class=\"line\">    private int size = 1000;</span><br><span class=\"line\">    public Demo2School(int size) &#123;</span><br><span class=\"line\">        this.size = size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h5><p>final可以修改类、方法、变量。</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>final可以修饰类，该类不能被继承。</li>\n<li>final可以修饰方法，该方法不能被重写。</li>\n<li>final可以修饰变量，该变量不能被重新赋值。</li>\n</ul>\n<p><strong>面试题</strong>：final修饰局部变量的问题</p>\n<ul>\n<li>基本类型：被final修饰的基本类型的值不能被改变</li>\n<li>引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。</li>\n</ul>\n<p><strong>初始化时机</strong><br>被final修饰的变量必须在构造方法完毕前被初始化，比如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo &#123;</span><br><span class=\"line\">    final int WIDTH = 12;</span><br><span class=\"line\">    //final int HEIGHT; //error</span><br><span class=\"line\">    final int AREA;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AREA = 120;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>1、Java支持单继承不支持多继承，但Java支持多层继承<br>2、子类只能继承父类非私有成员（成员变量、成员方法）<br>3、子类不能继承父类的构造方法，但可以通过super关键字访问父类的构造方法。</p>\n<h5 id=\"子类和父类的关系\"><a href=\"#子类和父类的关系\" class=\"headerlink\" title=\"子类和父类的关系\"></a>子类和父类的关系</h5><p><strong>子类中的所有构造方法都默认访问父类的无参构造方法</strong>。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是super()。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo04_Extends &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo04Son son = new Demo04Son();</span><br><span class=\"line\">        son.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo04Son extends Demo04Parent&#123;</span><br><span class=\"line\">    private int num = 10;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Son</span></span>() &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        int num = 100;</span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">        System.out.println(this.num);</span><br><span class=\"line\">        System.out.println(super.num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo04Parent &#123;</span><br><span class=\"line\">    public int num = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Parent</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"这是父类的无参构造函数\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"this-super\"><a href=\"#this-super\" class=\"headerlink\" title=\"this-super\"></a>this-super</h5><p>this和super关键字的区别和使用场景？<br>区别：</p>\n<ul>\n<li>this: 代表当前类的对象引用</li>\n<li>super: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）<br>场景：</li>\n<li>this.成员变量/方法</li>\n<li>super.成员变量/方法</li>\n<li>this(…) super(…)</li>\n</ul>\n<h5 id=\"加载顺序\"><a href=\"#加载顺序\" class=\"headerlink\" title=\"加载顺序\"></a>加载顺序</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Demo04_Extends2 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Demo04Zi zi = new Demo04Zi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Demo04Fu &#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 构造代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Fu</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Fu 构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Demo04Zi extends Demo04Fu&#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 构造代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"function\"><span class=\"title\">Demo04Zi</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Zi 构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fu 静态代码块</span><br><span class=\"line\">Zi 静态代码块</span><br><span class=\"line\">Fu 构造代码块</span><br><span class=\"line\">Fu 构造方法</span><br><span class=\"line\">Zi 构造代码块</span><br><span class=\"line\">Zi 构造方法</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h5><p><strong>调用对象方法的执行过程：</strong><br><a href=\"/images/DomaticBind.png\">DomaticBind</a><br>1.编译器首先查看对象的声明类型和方法名。如调用change(a)方法，由于存在多个change()方法，JVM会先列举该类以及其超类中访问属性为public且名为change的方法。<br>2.接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个方法表<strong>（method table）</strong>，JVM会直接从这个方法表中寻找名为change的方法中存在一个与提供的参数类型匹配的方法，这个过程称为<strong>重载解析</strong>。<br>3.如果是private、static、final方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为<strong>静态绑定</strong>。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现<strong>动态绑定</strong>。<br>4.当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。</p>\n<h5 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h5><p>将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接(int) double这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。</p>\n<ul>\n<li><strong>向上转型</strong>：将一个子类的引用赋值给一个超类变量。</li>\n<li><strong>向下转型</strong>：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>只能在继承层次内进行类型转换。</li>\n<li>在将超类转换成子类之前，应该使用instanceof进行检查。</li>\n</ul>\n<h5 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h5><p>一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。</p>\n<ul>\n<li>内部类可以直接访问外部类的成员，包括私有</li>\n<li>外部类可以访问内部类的成员，必须创建对象</li>\n<li>直接访问内部类的成员：Outer.Inner in = new Outer().new Inner()</li>\n</ul>\n<p><strong>局部内部类</strong><br>局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。</p>\n<blockquote>\n<p>局部内部类访问局部变量注意事项?<br>​局部内部类访问局部变量必须用final修饰。因为<strong>局部内部类的声明周期比局部变量长</strong>，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class InnerClass &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Outer outer = new Outer();</span><br><span class=\"line\">        outer.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Outer &#123;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        int num2 = 10;</span><br><span class=\"line\">        class Inner &#123;</span><br><span class=\"line\">            private void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">                System.out.println(num2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Inner inner = new Inner();</span><br><span class=\"line\">        inner.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时调用不会报错，但并没有加final修饰。这个类编译后会生成InnerClass.class和Outer.class两个文件，我们来看下Outer.class:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Outer &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">Outer</span></span>() &#123;&#125;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">        final int num2 = 10;</span><br><span class=\"line\">        class Inner &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">Inner</span></span>() &#123;&#125;</span><br><span class=\"line\">            private void <span class=\"function\"><span class=\"title\">show</span></span>() &#123;</span><br><span class=\"line\">                System.out.println(num2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Inner inner = new Inner();</span><br><span class=\"line\">        inner.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中的num2被自动加上了final修饰（这是因为JDK1.8的原因），所以如果你再添上num2 = 1000就会报错。</p>\n<blockquote>\n<p>解决办法<br>上面说过了应该将num2用final修饰。其原因就是Inner类的生命周期要比num2的声明周期长，当show()方法调用完毕后num2就已经消失了，但此时Inner类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用final修饰，这个变量成为常量，在初始化内部类的时候，final num2就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。</p>\n</blockquote>\n"},{"title":"Mybatis入门及搭建","date":"2018-09-29T16:00:00.000Z","_content":"\n上大学的时候自学过一段时间mybatis框架，感觉很好用。\n但是在工作中并没有用到，于是翻出之前的视频重新复习了一下。\n\n---\n\n### Mybatis的配置方式开发\n\n#### 一、准备工作\n\n因为Mybatis是持久层框架，所以在此之前我们要做一些准备工作，首先我们要在Mysql中建好表并插入数据。\n建表及导入sql\n```bash\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL auto_increment,\n  `username` varchar(32) NOT NULL COMMENT '用户名称',\n  `birthday` datetime default NULL COMMENT '生日',\n  `sex` char(1) default NULL COMMENT '性别',\n  `address` varchar(256) default NULL COMMENT '地址',\n  PRIMARY KEY  (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\ninsert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,'张三','2018-02-27 17:47:08','男','北京'),(2,'李四','2018-03-02 15:09:37','女','深圳'),(3,'王五','2018-03-04 11:34:34','女','成都'),(4,'赵六','2018-03-04 12:04:06','男','上海'),(5,'loonycoder','2018-03-07 17:37:26','男','西安'),(6,'望月','2018-03-08 11:44:00','女','杭州');\n\n```\n\n如图：\n![建表](/images/table.png)\n\n#### 二、新建项目\n\n我们这里要新建一个maven项目。\n![创建Maven项目](/images/1.png)\n\n![创建Maven项目](/images/2.png)\n\n![创建Maven项目](/images/3.png)\n\n创建完成之后，我们打开pom.xml文件引入依赖。\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.loonycoder</groupId>\n    <artifactId>MybatisDemo</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <packaging>jar</packaging>\n    <dependencies>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.4.4</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.6</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n---\n\n#### 三、创建表对象的映射实体类\n\n因为mybatis是一个ORM（Object Relational Mapping）框架，所以我们要准备一个和表字段一一对应的实体类。\n\n**注意**：\n**表中的字段名和实体类中的字段名字一定要一致！**\n**实体类一定要实现Serializable接口**\n\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\npublic class User implements Serializable {\n    private Integer id;\n    private String username;\n    private Date birthday;\n    private String address;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", birthday=\" + birthday +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n\n```\n\n--- \n\n#### 四、新建dao接口\n\n这里直接上代码，我在此新建了一个查询所有的方法，此处记住方法名和返回值类型，后续会用到。\n\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.User;\n\nimport java.util.List;\n\npublic interface IUserDao {\n    List<User> findAll();\n}\n\n```\n\n---\n\n#### 五、创建mybatis的主配置文件\n\n该配置文件需要放在/resources目录下，配置文件的名称在具有规范性的前提下是随意起的，我这里采用了默认的规范(我发现很多人都这么起)\n\nSqlMapConfig.xml\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<!--mybatis的主配置文件-->\n<configuration>\n    <!--配置环境-->\n    <environments default=\"mysql\">\n        <!--配置mysql的环境-->\n        <environment id=\"mysql\">\n            <!--配置事务类型-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置数据源(连接池)-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\" />\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/MybatisDemo/\" />\n                <property name=\"username\" value=\"root\" />\n                <property name=\"password\" value=\"20141016\" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件-->\n    <mappers>\n        <mapper resource=\"com/loonycoder/dao/IUserDao.xml\" />\n    </mappers>\n</configuration>\n```\n\n配置数据源的时候，把url、username、password 修改成你自己的数据库链接、用户名和密码即可。\n\n注意：\n**下方的mapper部分的配置我接下来会讲，后续按照你自己配置的路径配置即可。**\n\n---\n\n#### 六、配置mapper文件\n\n前面虽然配置了mybatis主配置文件，但是我们在实际操作中如果存在多个对象的dao接口，主配置文件需要怎么准确找到该接口呢？\n我们就需要为每个dao配置一个独立的配置文件\n我习惯上把文件命名成 **xxxMapper.xml**，这里命名成xxxDao.xml是为了方便理解。\n文件存放目录为/resources目录下，与实体对象dao接口的包同级。\n![xml文件配置](/images/mapperxml.png)\n\n代码如下：\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace需要配置dao的全限定类名-->\n<mapper namespace=\"com.loonycoder.dao.IUserDao\">\n    <!--配置查询所有-->\n    <!--id一定要是方法的名称-->\n    <select id=\"findAll\" resultType=\"com.loonycoder.domain.User\">\n        select * from user;\n    </select>\n</mapper>\n```\n\n---\n\n#### 七、引入log4j\n\n这个是可选操作，为了后期记录日志，我们可以采用log4j去实现。此处只是了解。\n将log4j.properties文件放在/resources目录下即可。\n\n```bash\n# Set root category priority to INFO and its only appender to CONSOLE.\n#log4j.rootCategory=INFO,CONSOLE             debug  info  warn  error  fatal\nlog4j.rootCategory=debug, CONSOLE, LOGFILE\n\n# Set the enterprise logger category to FATAL and its only appender to CONSOLE.\nlog4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE\n\n# CONSOLE is set to be a ConsoleAppender using a PatternLayout.\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n\n# LOGFILE is set to be a File appender using a PatternLayout.\nlog.appender.LOGFILE=org.apache.log4j.FileAppender\nlog.appender.LOGFILE.FILE=/usr/gmx/LearnWorkspace\nlog.appender.LOGFILE.Append=true\nlog.appender.LOGFILE.layout=org.apache.log4j.PatternLayout\nlog.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n```\n\n---\n\n#### 八、测试案例\n\n如此，我们的mybatis就搭建完成了，我们接下来测试一下。\n在/test/java目录下新建一个test类\n如图：\n![test类](/images/test.png)\n\n代码如下：\n```bash\npackage com.loonycoder;\n\n\nimport com.loonycoder.dao.IUserDao;\nimport com.loonycoder.domain.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\n\nimport java.io.InputStream;\nimport java.util.List;\n\npublic class MybatisTest {\n\n    public static void main(String[] args) throws Exception{\n        //1.读取配置文件\n        InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        //2.创建SqlSessionFactory工厂\n        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);\n        //3.使用工厂创建SqlSession对象\n        SqlSession session = sqlSessionFactory.openSession();\n        //4.使用SqlSession创建dao接口的代理对象\n        IUserDao userDao = session.getMapper(IUserDao.class);\n        //5.使用代理对象执行方法\n        List<User> users= userDao.findAll();\n        for (User user: users) {\n            System.out.println(user);\n        }\n        //6.释放资源\n        session.close();\n        inputStream.close();\n    }\n}\n```\n\n运行结果：\n![运行结果](/images/testResult.png)\n\n\n---\n\n### Mybaits的注解方式开发\n\nMybatis也为我们提供了基于注解的开发方式\n基于注解开发意味着脱离xml配置，所以我们在上述项目中可以直接移除com/loonycoder/dao/IUserDao.xml文件\n同时需要修改SqlMapConfig.xml中的映射配置文件部分\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<!--mybatis的主配置文件-->\n<configuration>\n    <!--配置环境-->\n    <environments default=\"mysql\">\n        <environment id=\"mysql\">\n            <!--配置事务-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置数据源（连接池）-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\" />\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\" />\n                <property name=\"username\" value=\"root\" />\n                <property name=\"password\" value=\"root\" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!--配置映射文件（mapper类的映射文件）-->\n    <mappers>\n        <!--此处做了修改，之前的属性是resource，现在改为class，并且指定到dao接口的全限定类名-->\n        <mapper class=\"com.loonycoder.dao.IUserDao\" />\n    </mappers>\n</configuration>\n```\n\n同时需要在dao接口的方法上添加注解@Select\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.User;\n\nimport java.util.List;\n\npublic interface IUserDao {\n    @Select(\"select * from user\")\n    List<User> findAll();\n}\n```\n\n运行结果：\n![运行结果](/images/testResult.png)\n\n\n\n","source":"_posts/Mybatis-1.md","raw":"---\ntitle: Mybatis入门及搭建\ncategories:\n    - Mybatis\n    \ndate: 2018-09-30\ntags:\n\t- Java\n\t- Java框架\n    - 数据库\n\n---\n\n上大学的时候自学过一段时间mybatis框架，感觉很好用。\n但是在工作中并没有用到，于是翻出之前的视频重新复习了一下。\n\n---\n\n### Mybatis的配置方式开发\n\n#### 一、准备工作\n\n因为Mybatis是持久层框架，所以在此之前我们要做一些准备工作，首先我们要在Mysql中建好表并插入数据。\n建表及导入sql\n```bash\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL auto_increment,\n  `username` varchar(32) NOT NULL COMMENT '用户名称',\n  `birthday` datetime default NULL COMMENT '生日',\n  `sex` char(1) default NULL COMMENT '性别',\n  `address` varchar(256) default NULL COMMENT '地址',\n  PRIMARY KEY  (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\ninsert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,'张三','2018-02-27 17:47:08','男','北京'),(2,'李四','2018-03-02 15:09:37','女','深圳'),(3,'王五','2018-03-04 11:34:34','女','成都'),(4,'赵六','2018-03-04 12:04:06','男','上海'),(5,'loonycoder','2018-03-07 17:37:26','男','西安'),(6,'望月','2018-03-08 11:44:00','女','杭州');\n\n```\n\n如图：\n![建表](/images/table.png)\n\n#### 二、新建项目\n\n我们这里要新建一个maven项目。\n![创建Maven项目](/images/1.png)\n\n![创建Maven项目](/images/2.png)\n\n![创建Maven项目](/images/3.png)\n\n创建完成之后，我们打开pom.xml文件引入依赖。\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.loonycoder</groupId>\n    <artifactId>MybatisDemo</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <packaging>jar</packaging>\n    <dependencies>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.4.4</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.6</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n---\n\n#### 三、创建表对象的映射实体类\n\n因为mybatis是一个ORM（Object Relational Mapping）框架，所以我们要准备一个和表字段一一对应的实体类。\n\n**注意**：\n**表中的字段名和实体类中的字段名字一定要一致！**\n**实体类一定要实现Serializable接口**\n\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\npublic class User implements Serializable {\n    private Integer id;\n    private String username;\n    private Date birthday;\n    private String address;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", birthday=\" + birthday +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n\n```\n\n--- \n\n#### 四、新建dao接口\n\n这里直接上代码，我在此新建了一个查询所有的方法，此处记住方法名和返回值类型，后续会用到。\n\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.User;\n\nimport java.util.List;\n\npublic interface IUserDao {\n    List<User> findAll();\n}\n\n```\n\n---\n\n#### 五、创建mybatis的主配置文件\n\n该配置文件需要放在/resources目录下，配置文件的名称在具有规范性的前提下是随意起的，我这里采用了默认的规范(我发现很多人都这么起)\n\nSqlMapConfig.xml\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<!--mybatis的主配置文件-->\n<configuration>\n    <!--配置环境-->\n    <environments default=\"mysql\">\n        <!--配置mysql的环境-->\n        <environment id=\"mysql\">\n            <!--配置事务类型-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置数据源(连接池)-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\" />\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/MybatisDemo/\" />\n                <property name=\"username\" value=\"root\" />\n                <property name=\"password\" value=\"20141016\" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件-->\n    <mappers>\n        <mapper resource=\"com/loonycoder/dao/IUserDao.xml\" />\n    </mappers>\n</configuration>\n```\n\n配置数据源的时候，把url、username、password 修改成你自己的数据库链接、用户名和密码即可。\n\n注意：\n**下方的mapper部分的配置我接下来会讲，后续按照你自己配置的路径配置即可。**\n\n---\n\n#### 六、配置mapper文件\n\n前面虽然配置了mybatis主配置文件，但是我们在实际操作中如果存在多个对象的dao接口，主配置文件需要怎么准确找到该接口呢？\n我们就需要为每个dao配置一个独立的配置文件\n我习惯上把文件命名成 **xxxMapper.xml**，这里命名成xxxDao.xml是为了方便理解。\n文件存放目录为/resources目录下，与实体对象dao接口的包同级。\n![xml文件配置](/images/mapperxml.png)\n\n代码如下：\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace需要配置dao的全限定类名-->\n<mapper namespace=\"com.loonycoder.dao.IUserDao\">\n    <!--配置查询所有-->\n    <!--id一定要是方法的名称-->\n    <select id=\"findAll\" resultType=\"com.loonycoder.domain.User\">\n        select * from user;\n    </select>\n</mapper>\n```\n\n---\n\n#### 七、引入log4j\n\n这个是可选操作，为了后期记录日志，我们可以采用log4j去实现。此处只是了解。\n将log4j.properties文件放在/resources目录下即可。\n\n```bash\n# Set root category priority to INFO and its only appender to CONSOLE.\n#log4j.rootCategory=INFO,CONSOLE             debug  info  warn  error  fatal\nlog4j.rootCategory=debug, CONSOLE, LOGFILE\n\n# Set the enterprise logger category to FATAL and its only appender to CONSOLE.\nlog4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE\n\n# CONSOLE is set to be a ConsoleAppender using a PatternLayout.\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n\n# LOGFILE is set to be a File appender using a PatternLayout.\nlog.appender.LOGFILE=org.apache.log4j.FileAppender\nlog.appender.LOGFILE.FILE=/usr/gmx/LearnWorkspace\nlog.appender.LOGFILE.Append=true\nlog.appender.LOGFILE.layout=org.apache.log4j.PatternLayout\nlog.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n```\n\n---\n\n#### 八、测试案例\n\n如此，我们的mybatis就搭建完成了，我们接下来测试一下。\n在/test/java目录下新建一个test类\n如图：\n![test类](/images/test.png)\n\n代码如下：\n```bash\npackage com.loonycoder;\n\n\nimport com.loonycoder.dao.IUserDao;\nimport com.loonycoder.domain.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\n\nimport java.io.InputStream;\nimport java.util.List;\n\npublic class MybatisTest {\n\n    public static void main(String[] args) throws Exception{\n        //1.读取配置文件\n        InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        //2.创建SqlSessionFactory工厂\n        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);\n        //3.使用工厂创建SqlSession对象\n        SqlSession session = sqlSessionFactory.openSession();\n        //4.使用SqlSession创建dao接口的代理对象\n        IUserDao userDao = session.getMapper(IUserDao.class);\n        //5.使用代理对象执行方法\n        List<User> users= userDao.findAll();\n        for (User user: users) {\n            System.out.println(user);\n        }\n        //6.释放资源\n        session.close();\n        inputStream.close();\n    }\n}\n```\n\n运行结果：\n![运行结果](/images/testResult.png)\n\n\n---\n\n### Mybaits的注解方式开发\n\nMybatis也为我们提供了基于注解的开发方式\n基于注解开发意味着脱离xml配置，所以我们在上述项目中可以直接移除com/loonycoder/dao/IUserDao.xml文件\n同时需要修改SqlMapConfig.xml中的映射配置文件部分\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<!--mybatis的主配置文件-->\n<configuration>\n    <!--配置环境-->\n    <environments default=\"mysql\">\n        <environment id=\"mysql\">\n            <!--配置事务-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置数据源（连接池）-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\" />\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\" />\n                <property name=\"username\" value=\"root\" />\n                <property name=\"password\" value=\"root\" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!--配置映射文件（mapper类的映射文件）-->\n    <mappers>\n        <!--此处做了修改，之前的属性是resource，现在改为class，并且指定到dao接口的全限定类名-->\n        <mapper class=\"com.loonycoder.dao.IUserDao\" />\n    </mappers>\n</configuration>\n```\n\n同时需要在dao接口的方法上添加注解@Select\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.User;\n\nimport java.util.List;\n\npublic interface IUserDao {\n    @Select(\"select * from user\")\n    List<User> findAll();\n}\n```\n\n运行结果：\n![运行结果](/images/testResult.png)\n\n\n\n","slug":"Mybatis-1","published":1,"updated":"2020-02-21T15:30:46.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyn0008v9s68nefb2yx","content":"<p>上大学的时候自学过一段时间mybatis框架，感觉很好用。<br>但是在工作中并没有用到，于是翻出之前的视频重新复习了一下。</p>\n<hr>\n<h3 id=\"Mybatis的配置方式开发\"><a href=\"#Mybatis的配置方式开发\" class=\"headerlink\" title=\"Mybatis的配置方式开发\"></a>Mybatis的配置方式开发</h3><h4 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h4><p>因为Mybatis是持久层框架，所以在此之前我们要做一些准备工作，首先我们要在Mysql中建好表并插入数据。<br>建表及导入sql</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `user` (</span><br><span class=\"line\">  `id` int(11) NOT NULL auto_increment,</span><br><span class=\"line\">  `username` varchar(32) NOT NULL COMMENT <span class=\"string\">'用户名称'</span>,</span><br><span class=\"line\">  `birthday` datetime default NULL COMMENT <span class=\"string\">'生日'</span>,</span><br><span class=\"line\">  `sex` char(1) default NULL COMMENT <span class=\"string\">'性别'</span>,</span><br><span class=\"line\">  `address` varchar(256) default NULL COMMENT <span class=\"string\">'地址'</span>,</span><br><span class=\"line\">  PRIMARY KEY  (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,<span class=\"string\">'张三'</span>,<span class=\"string\">'2018-02-27 17:47:08'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'北京'</span>),(2,<span class=\"string\">'李四'</span>,<span class=\"string\">'2018-03-02 15:09:37'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'深圳'</span>),(3,<span class=\"string\">'王五'</span>,<span class=\"string\">'2018-03-04 11:34:34'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'成都'</span>),(4,<span class=\"string\">'赵六'</span>,<span class=\"string\">'2018-03-04 12:04:06'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'上海'</span>),(5,<span class=\"string\">'loonycoder'</span>,<span class=\"string\">'2018-03-07 17:37:26'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'西安'</span>),(6,<span class=\"string\">'望月'</span>,<span class=\"string\">'2018-03-08 11:44:00'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'杭州'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如图：<br><img src=\"/images/table.png\" alt=\"建表\"></p>\n<h4 id=\"二、新建项目\"><a href=\"#二、新建项目\" class=\"headerlink\" title=\"二、新建项目\"></a>二、新建项目</h4><p>我们这里要新建一个maven项目。<br><img src=\"/images/1.png\" alt=\"创建Maven项目\"></p>\n<p><img src=\"/images/2.png\" alt=\"创建Maven项目\"></p>\n<p><img src=\"/images/3.png\" alt=\"创建Maven项目\"></p>\n<p>创建完成之后，我们打开pom.xml文件引入依赖。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;project xmlns=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span></span><br><span class=\"line\">         xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">         xsi:schemaLocation=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;groupId&gt;com.loonycoder&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;MybatisDemo&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;3.4.4&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"三、创建表对象的映射实体类\"><a href=\"#三、创建表对象的映射实体类\" class=\"headerlink\" title=\"三、创建表对象的映射实体类\"></a>三、创建表对象的映射实体类</h4><p>因为mybatis是一个ORM（Object Relational Mapping）框架，所以我们要准备一个和表字段一一对应的实体类。</p>\n<p><strong>注意</strong>：<br><strong>表中的字段名和实体类中的字段名字一定要一致！</strong><br><strong>实体类一定要实现Serializable接口</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\">public class User implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private String username;</span><br><span class=\"line\">    private Date birthday;</span><br><span class=\"line\">    private String address;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(Integer id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getUsername</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUsername(String username) &#123;</span><br><span class=\"line\">        this.username = username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date <span class=\"function\"><span class=\"title\">getBirthday</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setBirthday(Date birthday) &#123;</span><br><span class=\"line\">        this.birthday = birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getAddress</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddress(String address) &#123;</span><br><span class=\"line\">        this.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"id=\"</span> + id +</span><br><span class=\"line\">                <span class=\"string\">\", username='\"</span> + username + <span class=\"string\">'\\'</span><span class=\"string\">' +</span></span><br><span class=\"line\"><span class=\"string\">                \", birthday=\" + birthday +</span></span><br><span class=\"line\"><span class=\"string\">                \", address='</span><span class=\"string\">\" + address + '\\'' +</span></span><br><span class=\"line\"><span class=\"string\">                '&#125;';</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"四、新建dao接口\"><a href=\"#四、新建dao接口\" class=\"headerlink\" title=\"四、新建dao接口\"></a>四、新建dao接口</h4><p>这里直接上代码，我在此新建了一个查询所有的方法，此处记住方法名和返回值类型，后续会用到。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IUserDao &#123;</span><br><span class=\"line\">    List&lt;User&gt; findAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"五、创建mybatis的主配置文件\"><a href=\"#五、创建mybatis的主配置文件\" class=\"headerlink\" title=\"五、创建mybatis的主配置文件\"></a>五、创建mybatis的主配置文件</h4><p>该配置文件需要放在/resources目录下，配置文件的名称在具有规范性的前提下是随意起的，我这里采用了默认的规范(我发现很多人都这么起)</p>\n<p>SqlMapConfig.xml</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span> ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Config 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--mybatis的主配置文件--&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;!--配置环境--&gt;</span><br><span class=\"line\">    &lt;environments default=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">        &lt;!--配置mysql的环境--&gt;</span><br><span class=\"line\">        &lt;environment id=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">            &lt;!--配置事务类型--&gt;</span><br><span class=\"line\">            &lt;transactionManager <span class=\"built_in\">type</span>=<span class=\"string\">\"JDBC\"</span>&gt;&lt;/transactionManager&gt;</span><br><span class=\"line\">            &lt;!--配置数据源(连接池)--&gt;</span><br><span class=\"line\">            &lt;dataSource <span class=\"built_in\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"driver\"</span> value=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"url\"</span> value=<span class=\"string\">\"jdbc:mysql://localhost:3306/MybatisDemo/\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"username\"</span> value=<span class=\"string\">\"root\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"password\"</span> value=<span class=\"string\">\"20141016\"</span> /&gt;</span><br><span class=\"line\">            &lt;/dataSource&gt;</span><br><span class=\"line\">        &lt;/environment&gt;</span><br><span class=\"line\">    &lt;/environments&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件--&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IUserDao.xml\"</span> /&gt;</span><br><span class=\"line\">    &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<p>配置数据源的时候，把url、username、password 修改成你自己的数据库链接、用户名和密码即可。</p>\n<p>注意：<br><strong>下方的mapper部分的配置我接下来会讲，后续按照你自己配置的路径配置即可。</strong></p>\n<hr>\n<h4 id=\"六、配置mapper文件\"><a href=\"#六、配置mapper文件\" class=\"headerlink\" title=\"六、配置mapper文件\"></a>六、配置mapper文件</h4><p>前面虽然配置了mybatis主配置文件，但是我们在实际操作中如果存在多个对象的dao接口，主配置文件需要怎么准确找到该接口呢？<br>我们就需要为每个dao配置一个独立的配置文件<br>我习惯上把文件命名成 <strong>xxxMapper.xml</strong>，这里命名成xxxDao.xml是为了方便理解。<br>文件存放目录为/resources目录下，与实体对象dao接口的包同级。<br><img src=\"/images/mapperxml.png\" alt=\"xml文件配置\"></p>\n<p>代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span> ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--namespace需要配置dao的全限定类名--&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IUserDao\"</span>&gt;</span><br><span class=\"line\">    &lt;!--配置查询所有--&gt;</span><br><span class=\"line\">    &lt;!--id一定要是方法的名称--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"findAll\"</span> resultType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        select * from user;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"七、引入log4j\"><a href=\"#七、引入log4j\" class=\"headerlink\" title=\"七、引入log4j\"></a>七、引入log4j</h4><p>这个是可选操作，为了后期记录日志，我们可以采用log4j去实现。此处只是了解。<br>将log4j.properties文件放在/resources目录下即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Set root category priority to INFO and its only appender to CONSOLE.</span></span><br><span class=\"line\"><span class=\"comment\">#log4j.rootCategory=INFO,CONSOLE             debug  info  warn  error  fatal</span></span><br><span class=\"line\">log4j.rootCategory=debug, CONSOLE, LOGFILE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span></span><br><span class=\"line\">log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span></span><br><span class=\"line\">log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\\n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># LOGFILE is set to be a File appender using a PatternLayout.</span></span><br><span class=\"line\">log.appender.LOGFILE=org.apache.log4j.FileAppender</span><br><span class=\"line\">log.appender.LOGFILE.FILE=/usr/gmx/LearnWorkspace</span><br><span class=\"line\">log.appender.LOGFILE.Append=<span class=\"literal\">true</span></span><br><span class=\"line\">log.appender.LOGFILE.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\\n</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"八、测试案例\"><a href=\"#八、测试案例\" class=\"headerlink\" title=\"八、测试案例\"></a>八、测试案例</h4><p>如此，我们的mybatis就搭建完成了，我们接下来测试一下。<br>在/test/java目录下新建一个test类<br>如图：<br><img src=\"/images/test.png\" alt=\"test类\"></p>\n<p>代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.dao.IUserDao;</span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\">import org.apache.ibatis.io.Resources;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSession;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MybatisTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception&#123;</span><br><span class=\"line\">        //1.读取配置文件</span><br><span class=\"line\">        InputStream inputStream = Resources.getResourceAsStream(<span class=\"string\">\"SqlMapConfig.xml\"</span>);</span><br><span class=\"line\">        //2.创建SqlSessionFactory工厂</span><br><span class=\"line\">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class=\"line\">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class=\"line\">        //3.使用工厂创建SqlSession对象</span><br><span class=\"line\">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">        //4.使用SqlSession创建dao接口的代理对象</span><br><span class=\"line\">        IUserDao userDao = session.getMapper(IUserDao.class);</span><br><span class=\"line\">        //5.使用代理对象执行方法</span><br><span class=\"line\">        List&lt;User&gt; users= userDao.findAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (User user: users) &#123;</span><br><span class=\"line\">            System.out.println(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //6.释放资源</span><br><span class=\"line\">        session.close();</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：<br><img src=\"/images/testResult.png\" alt=\"运行结果\"></p>\n<hr>\n<h3 id=\"Mybaits的注解方式开发\"><a href=\"#Mybaits的注解方式开发\" class=\"headerlink\" title=\"Mybaits的注解方式开发\"></a>Mybaits的注解方式开发</h3><p>Mybatis也为我们提供了基于注解的开发方式<br>基于注解开发意味着脱离xml配置，所以我们在上述项目中可以直接移除com/loonycoder/dao/IUserDao.xml文件<br>同时需要修改SqlMapConfig.xml中的映射配置文件部分</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Config 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--mybatis的主配置文件--&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;!--配置环境--&gt;</span><br><span class=\"line\">    &lt;environments default=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">        &lt;environment id=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">            &lt;!--配置事务--&gt;</span><br><span class=\"line\">            &lt;transactionManager <span class=\"built_in\">type</span>=<span class=\"string\">\"JDBC\"</span>&gt;&lt;/transactionManager&gt;</span><br><span class=\"line\">            &lt;!--配置数据源（连接池）--&gt;</span><br><span class=\"line\">            &lt;dataSource <span class=\"built_in\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"driver\"</span> value=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"url\"</span> value=<span class=\"string\">\"jdbc:mysql://localhost:3306/mybatis\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"username\"</span> value=<span class=\"string\">\"root\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"password\"</span> value=<span class=\"string\">\"root\"</span> /&gt;</span><br><span class=\"line\">            &lt;/dataSource&gt;</span><br><span class=\"line\">        &lt;/environment&gt;</span><br><span class=\"line\">    &lt;/environments&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;!--此处做了修改，之前的属性是resource，现在改为class，并且指定到dao接口的全限定类名--&gt;</span><br><span class=\"line\">        &lt;mapper class=<span class=\"string\">\"com.loonycoder.dao.IUserDao\"</span> /&gt;</span><br><span class=\"line\">    &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<p>同时需要在dao接口的方法上添加注解@Select</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IUserDao &#123;</span><br><span class=\"line\">    @Select(<span class=\"string\">\"select * from user\"</span>)</span><br><span class=\"line\">    List&lt;User&gt; findAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：<br><img src=\"/images/testResult.png\" alt=\"运行结果\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>上大学的时候自学过一段时间mybatis框架，感觉很好用。<br>但是在工作中并没有用到，于是翻出之前的视频重新复习了一下。</p>\n<hr>\n<h3 id=\"Mybatis的配置方式开发\"><a href=\"#Mybatis的配置方式开发\" class=\"headerlink\" title=\"Mybatis的配置方式开发\"></a>Mybatis的配置方式开发</h3><h4 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h4><p>因为Mybatis是持久层框架，所以在此之前我们要做一些准备工作，首先我们要在Mysql中建好表并插入数据。<br>建表及导入sql</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `user` (</span><br><span class=\"line\">  `id` int(11) NOT NULL auto_increment,</span><br><span class=\"line\">  `username` varchar(32) NOT NULL COMMENT <span class=\"string\">'用户名称'</span>,</span><br><span class=\"line\">  `birthday` datetime default NULL COMMENT <span class=\"string\">'生日'</span>,</span><br><span class=\"line\">  `sex` char(1) default NULL COMMENT <span class=\"string\">'性别'</span>,</span><br><span class=\"line\">  `address` varchar(256) default NULL COMMENT <span class=\"string\">'地址'</span>,</span><br><span class=\"line\">  PRIMARY KEY  (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,<span class=\"string\">'张三'</span>,<span class=\"string\">'2018-02-27 17:47:08'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'北京'</span>),(2,<span class=\"string\">'李四'</span>,<span class=\"string\">'2018-03-02 15:09:37'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'深圳'</span>),(3,<span class=\"string\">'王五'</span>,<span class=\"string\">'2018-03-04 11:34:34'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'成都'</span>),(4,<span class=\"string\">'赵六'</span>,<span class=\"string\">'2018-03-04 12:04:06'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'上海'</span>),(5,<span class=\"string\">'loonycoder'</span>,<span class=\"string\">'2018-03-07 17:37:26'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'西安'</span>),(6,<span class=\"string\">'望月'</span>,<span class=\"string\">'2018-03-08 11:44:00'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'杭州'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如图：<br><img src=\"/images/table.png\" alt=\"建表\"></p>\n<h4 id=\"二、新建项目\"><a href=\"#二、新建项目\" class=\"headerlink\" title=\"二、新建项目\"></a>二、新建项目</h4><p>我们这里要新建一个maven项目。<br><img src=\"/images/1.png\" alt=\"创建Maven项目\"></p>\n<p><img src=\"/images/2.png\" alt=\"创建Maven项目\"></p>\n<p><img src=\"/images/3.png\" alt=\"创建Maven项目\"></p>\n<p>创建完成之后，我们打开pom.xml文件引入依赖。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;project xmlns=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span></span><br><span class=\"line\">         xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">         xsi:schemaLocation=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;groupId&gt;com.loonycoder&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;MybatisDemo&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;3.4.4&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"三、创建表对象的映射实体类\"><a href=\"#三、创建表对象的映射实体类\" class=\"headerlink\" title=\"三、创建表对象的映射实体类\"></a>三、创建表对象的映射实体类</h4><p>因为mybatis是一个ORM（Object Relational Mapping）框架，所以我们要准备一个和表字段一一对应的实体类。</p>\n<p><strong>注意</strong>：<br><strong>表中的字段名和实体类中的字段名字一定要一致！</strong><br><strong>实体类一定要实现Serializable接口</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\">public class User implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private String username;</span><br><span class=\"line\">    private Date birthday;</span><br><span class=\"line\">    private String address;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(Integer id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getUsername</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUsername(String username) &#123;</span><br><span class=\"line\">        this.username = username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date <span class=\"function\"><span class=\"title\">getBirthday</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setBirthday(Date birthday) &#123;</span><br><span class=\"line\">        this.birthday = birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getAddress</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddress(String address) &#123;</span><br><span class=\"line\">        this.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"id=\"</span> + id +</span><br><span class=\"line\">                <span class=\"string\">\", username='\"</span> + username + <span class=\"string\">'\\'</span><span class=\"string\">' +</span></span><br><span class=\"line\"><span class=\"string\">                \", birthday=\" + birthday +</span></span><br><span class=\"line\"><span class=\"string\">                \", address='</span><span class=\"string\">\" + address + '\\'' +</span></span><br><span class=\"line\"><span class=\"string\">                '&#125;';</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"四、新建dao接口\"><a href=\"#四、新建dao接口\" class=\"headerlink\" title=\"四、新建dao接口\"></a>四、新建dao接口</h4><p>这里直接上代码，我在此新建了一个查询所有的方法，此处记住方法名和返回值类型，后续会用到。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IUserDao &#123;</span><br><span class=\"line\">    List&lt;User&gt; findAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"五、创建mybatis的主配置文件\"><a href=\"#五、创建mybatis的主配置文件\" class=\"headerlink\" title=\"五、创建mybatis的主配置文件\"></a>五、创建mybatis的主配置文件</h4><p>该配置文件需要放在/resources目录下，配置文件的名称在具有规范性的前提下是随意起的，我这里采用了默认的规范(我发现很多人都这么起)</p>\n<p>SqlMapConfig.xml</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span> ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Config 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--mybatis的主配置文件--&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;!--配置环境--&gt;</span><br><span class=\"line\">    &lt;environments default=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">        &lt;!--配置mysql的环境--&gt;</span><br><span class=\"line\">        &lt;environment id=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">            &lt;!--配置事务类型--&gt;</span><br><span class=\"line\">            &lt;transactionManager <span class=\"built_in\">type</span>=<span class=\"string\">\"JDBC\"</span>&gt;&lt;/transactionManager&gt;</span><br><span class=\"line\">            &lt;!--配置数据源(连接池)--&gt;</span><br><span class=\"line\">            &lt;dataSource <span class=\"built_in\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"driver\"</span> value=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"url\"</span> value=<span class=\"string\">\"jdbc:mysql://localhost:3306/MybatisDemo/\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"username\"</span> value=<span class=\"string\">\"root\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"password\"</span> value=<span class=\"string\">\"20141016\"</span> /&gt;</span><br><span class=\"line\">            &lt;/dataSource&gt;</span><br><span class=\"line\">        &lt;/environment&gt;</span><br><span class=\"line\">    &lt;/environments&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件--&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IUserDao.xml\"</span> /&gt;</span><br><span class=\"line\">    &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<p>配置数据源的时候，把url、username、password 修改成你自己的数据库链接、用户名和密码即可。</p>\n<p>注意：<br><strong>下方的mapper部分的配置我接下来会讲，后续按照你自己配置的路径配置即可。</strong></p>\n<hr>\n<h4 id=\"六、配置mapper文件\"><a href=\"#六、配置mapper文件\" class=\"headerlink\" title=\"六、配置mapper文件\"></a>六、配置mapper文件</h4><p>前面虽然配置了mybatis主配置文件，但是我们在实际操作中如果存在多个对象的dao接口，主配置文件需要怎么准确找到该接口呢？<br>我们就需要为每个dao配置一个独立的配置文件<br>我习惯上把文件命名成 <strong>xxxMapper.xml</strong>，这里命名成xxxDao.xml是为了方便理解。<br>文件存放目录为/resources目录下，与实体对象dao接口的包同级。<br><img src=\"/images/mapperxml.png\" alt=\"xml文件配置\"></p>\n<p>代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span> ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--namespace需要配置dao的全限定类名--&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IUserDao\"</span>&gt;</span><br><span class=\"line\">    &lt;!--配置查询所有--&gt;</span><br><span class=\"line\">    &lt;!--id一定要是方法的名称--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"findAll\"</span> resultType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        select * from user;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"七、引入log4j\"><a href=\"#七、引入log4j\" class=\"headerlink\" title=\"七、引入log4j\"></a>七、引入log4j</h4><p>这个是可选操作，为了后期记录日志，我们可以采用log4j去实现。此处只是了解。<br>将log4j.properties文件放在/resources目录下即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Set root category priority to INFO and its only appender to CONSOLE.</span></span><br><span class=\"line\"><span class=\"comment\">#log4j.rootCategory=INFO,CONSOLE             debug  info  warn  error  fatal</span></span><br><span class=\"line\">log4j.rootCategory=debug, CONSOLE, LOGFILE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span></span><br><span class=\"line\">log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span></span><br><span class=\"line\">log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\\n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># LOGFILE is set to be a File appender using a PatternLayout.</span></span><br><span class=\"line\">log.appender.LOGFILE=org.apache.log4j.FileAppender</span><br><span class=\"line\">log.appender.LOGFILE.FILE=/usr/gmx/LearnWorkspace</span><br><span class=\"line\">log.appender.LOGFILE.Append=<span class=\"literal\">true</span></span><br><span class=\"line\">log.appender.LOGFILE.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\\n</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"八、测试案例\"><a href=\"#八、测试案例\" class=\"headerlink\" title=\"八、测试案例\"></a>八、测试案例</h4><p>如此，我们的mybatis就搭建完成了，我们接下来测试一下。<br>在/test/java目录下新建一个test类<br>如图：<br><img src=\"/images/test.png\" alt=\"test类\"></p>\n<p>代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.dao.IUserDao;</span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\">import org.apache.ibatis.io.Resources;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSession;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MybatisTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception&#123;</span><br><span class=\"line\">        //1.读取配置文件</span><br><span class=\"line\">        InputStream inputStream = Resources.getResourceAsStream(<span class=\"string\">\"SqlMapConfig.xml\"</span>);</span><br><span class=\"line\">        //2.创建SqlSessionFactory工厂</span><br><span class=\"line\">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class=\"line\">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class=\"line\">        //3.使用工厂创建SqlSession对象</span><br><span class=\"line\">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">        //4.使用SqlSession创建dao接口的代理对象</span><br><span class=\"line\">        IUserDao userDao = session.getMapper(IUserDao.class);</span><br><span class=\"line\">        //5.使用代理对象执行方法</span><br><span class=\"line\">        List&lt;User&gt; users= userDao.findAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (User user: users) &#123;</span><br><span class=\"line\">            System.out.println(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //6.释放资源</span><br><span class=\"line\">        session.close();</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：<br><img src=\"/images/testResult.png\" alt=\"运行结果\"></p>\n<hr>\n<h3 id=\"Mybaits的注解方式开发\"><a href=\"#Mybaits的注解方式开发\" class=\"headerlink\" title=\"Mybaits的注解方式开发\"></a>Mybaits的注解方式开发</h3><p>Mybatis也为我们提供了基于注解的开发方式<br>基于注解开发意味着脱离xml配置，所以我们在上述项目中可以直接移除com/loonycoder/dao/IUserDao.xml文件<br>同时需要修改SqlMapConfig.xml中的映射配置文件部分</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Config 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--mybatis的主配置文件--&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;!--配置环境--&gt;</span><br><span class=\"line\">    &lt;environments default=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">        &lt;environment id=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">            &lt;!--配置事务--&gt;</span><br><span class=\"line\">            &lt;transactionManager <span class=\"built_in\">type</span>=<span class=\"string\">\"JDBC\"</span>&gt;&lt;/transactionManager&gt;</span><br><span class=\"line\">            &lt;!--配置数据源（连接池）--&gt;</span><br><span class=\"line\">            &lt;dataSource <span class=\"built_in\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"driver\"</span> value=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"url\"</span> value=<span class=\"string\">\"jdbc:mysql://localhost:3306/mybatis\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"username\"</span> value=<span class=\"string\">\"root\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"password\"</span> value=<span class=\"string\">\"root\"</span> /&gt;</span><br><span class=\"line\">            &lt;/dataSource&gt;</span><br><span class=\"line\">        &lt;/environment&gt;</span><br><span class=\"line\">    &lt;/environments&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;!--此处做了修改，之前的属性是resource，现在改为class，并且指定到dao接口的全限定类名--&gt;</span><br><span class=\"line\">        &lt;mapper class=<span class=\"string\">\"com.loonycoder.dao.IUserDao\"</span> /&gt;</span><br><span class=\"line\">    &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<p>同时需要在dao接口的方法上添加注解@Select</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IUserDao &#123;</span><br><span class=\"line\">    @Select(<span class=\"string\">\"select * from user\"</span>)</span><br><span class=\"line\">    List&lt;User&gt; findAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：<br><img src=\"/images/testResult.png\" alt=\"运行结果\"></p>\n"},{"title":"Mybatis的增删改查操作","date":"2018-10-05T16:00:00.000Z","_content":"\n### 准备工作\n\n基于我们之前创建的Mybatis项目即可，我在此采用的依旧是基于xml的开发方式。\n\n---\n\n### Mybatis的查询操作\n\n#### 在mapper接口中新增查询方法\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.User;\n\nimport java.util.List;\n\npublic interface IUserMapper {\n\n    /**\n     * 查询用户\n     * @return\n     */\n    public List<User> selectAll();\n    \n    \n}\n\n```\n\n#### 在IUserMapper.xml中添加查询sql语句\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace里面要配置mapper接口的全限定类名-->\n<mapper namespace=\"com.loonycoder.dao.IUserMapper\">\n    <!--id要保持和方法名一致-->\n    <!--resultType指定返回值类型，如果是List类型 配置List的泛型即可-->\n    <select id=\"selectAll\" resultType=\"com.loonycoder.domain.User\">\n        select * from user;\n    </select>\n</mapper>\n```\n\n#### 新建测试类执行\n\n由于读取配置文件、创建SqlSessionFactory工厂等步骤复用性较高，我们在这里进行了抽取。\n```bash\npackage com.loonycoder;\n\n\nimport com.loonycoder.dao.IUserMapper;\nimport com.loonycoder.domain.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\nimport java.io.InputStream;\nimport java.util.Date;\nimport java.util.List;\n\npublic class MybatisTest {\n\n    private InputStream inputStream;\n    private SqlSessionFactory sqlSessionFactory;\n    private SqlSession session;\n    private IUserMapper userDao;\n\n    //before注解代表在测试方法执行前执行\n    @Before\n    public void init() throws Exception{\n        //1.读取配置文件\n        inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        //2.创建SqlSessionFactory工厂\n        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);\n        //3.使用工厂创建SqlSession对象\n        session = sqlSessionFactory.openSession();\n        //4.使用SqlSession创建dao接口的代理对象\n        userDao = session.getMapper(IUserMapper.class);\n    }\n\n\n    //after注解代表在测试方法执行后执行\n    @After\n    public void destroy() throws Exception{\n        //6.释放资源\n        session.close();\n        inputStream.close();\n    }\n\n\n    @Test\n    public void selectTest() throws Exception{\n\n        //5.使用代理对象执行方法\n        List<User> users= userDao.selectAll();\n        for (User user: users) {\n            System.out.println(user);\n        }\n\n    }\n\n}\n\n```\n\n#### 执行结果\n![执行结果](/images/execResult1.png)\n\n---\n\n### Mybatis的保存操作\n\n#### 在mapper接口中新增保存方法\n```bash\n    /**\n     * 保存用户\n     * @param user\n     */\n    public void saveUser(User user);\n```\n\n#### 在IUserMapper.xml中添加保存sql语句\n```bash\n<insert id=\"saveUser\" parameterType=\"com.loonycoder.domain.User\">\n        insert into user (username,sex,birthday,address) values (#{userName},#{sex},#{birthday},#{address});\n    </insert>\n```\n\n**注意：\n#{}为mybatis的固定用法，用于取值。如果User实体类中的属性是自动生成的get/set，则直接写属性名称即可。\n其次，参数一定要一一对应上**\n\n#### 新建测试类执行\n```bash\n    @Test\n    public void insertTest(){\n        User user = new User();\n        user.setUserName(\"Lisa\");\n        user.setBirthday(new Date());\n        user.setAddress(\"广东\");\n        user.setSex(\"女\");\n        userDao.saveUser(user);\n        session.commit();//记得手动提交事务\n    }\n```\n\n**注意：一定要手动提交事务，否则虽然不会报错，但是不会入表！！！**\n\n#### 执行结果\n![执行结果](/images/execResult2.png)\n\n---\n\n### Mybatis的删除操作\n\n#### 在mapper接口中新增删除方法\n```bash\n /**\n     * 删除用户\n     * @param userId\n     */\n    public void deleteUser(Integer userId);\n```\n\n#### 在IUserMapper.xml中添加删除sql语句\n```bash\n<delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id = #{uid};\n    </delete>\n```\n\n**注意：因为该方法只有一个参数，所以我们在sql中标注的uid部分其实是可以随便写的，因为mybatis只会找到这一个参数**\n\n#### 新建测试类执行\n```bash\n @Test\n    public void deleteTest(){\n        userDao.deleteUser(53);\n        session.commit();//记得手动提交事务\n    }\n```\n\n#### 执行结果\n删除前：\n![执行结果](/images/execBefore.png)\n删除后：\n![执行结果](/images/execAfter.png)\n\n---\n\n### Mybatis的修改操作\n\n#### 在mapper接口中新增修改方法\n```bash\n    /**\n     * 修改用户\n     * @param user\n     */\n    public void updateUser(User user);\n```\n\n#### 在IUserMapper.xml中添加修改sql语句\n```bash\n    <update id=\"updateUser\" parameterType=\"com.loonycoder.domain.User\">\n        update user set username = #{username},sex = #{sex},birthday = #{birthday},address = #{address} where id = #{id};\n    </update>\n```\n\n#### 新建测试类执行\n```bash\n    @Test\n    public void updateTest(){\n        User user = new User();\n        user.setId(41);\n        user.setUserName(\"张三丰\");\n        session.commit();//记得手动提交事务\n    }\n```\n\n#### 执行结果\n修改前：\n![执行结果](/images/execAfter.png)\n修改后：\n![执行结果](/images/execAfter1.png)\n\n\n\n","source":"_posts/Mybatis-2.md","raw":"---\ntitle: Mybatis的增删改查操作\ncategories:\n    - Mybatis\n    \ndate: 2018-10-6\ntags:\n\t- Java\n\t- Java框架\n    - 数据库\n\n---\n\n### 准备工作\n\n基于我们之前创建的Mybatis项目即可，我在此采用的依旧是基于xml的开发方式。\n\n---\n\n### Mybatis的查询操作\n\n#### 在mapper接口中新增查询方法\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.User;\n\nimport java.util.List;\n\npublic interface IUserMapper {\n\n    /**\n     * 查询用户\n     * @return\n     */\n    public List<User> selectAll();\n    \n    \n}\n\n```\n\n#### 在IUserMapper.xml中添加查询sql语句\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace里面要配置mapper接口的全限定类名-->\n<mapper namespace=\"com.loonycoder.dao.IUserMapper\">\n    <!--id要保持和方法名一致-->\n    <!--resultType指定返回值类型，如果是List类型 配置List的泛型即可-->\n    <select id=\"selectAll\" resultType=\"com.loonycoder.domain.User\">\n        select * from user;\n    </select>\n</mapper>\n```\n\n#### 新建测试类执行\n\n由于读取配置文件、创建SqlSessionFactory工厂等步骤复用性较高，我们在这里进行了抽取。\n```bash\npackage com.loonycoder;\n\n\nimport com.loonycoder.dao.IUserMapper;\nimport com.loonycoder.domain.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\nimport java.io.InputStream;\nimport java.util.Date;\nimport java.util.List;\n\npublic class MybatisTest {\n\n    private InputStream inputStream;\n    private SqlSessionFactory sqlSessionFactory;\n    private SqlSession session;\n    private IUserMapper userDao;\n\n    //before注解代表在测试方法执行前执行\n    @Before\n    public void init() throws Exception{\n        //1.读取配置文件\n        inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        //2.创建SqlSessionFactory工厂\n        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);\n        //3.使用工厂创建SqlSession对象\n        session = sqlSessionFactory.openSession();\n        //4.使用SqlSession创建dao接口的代理对象\n        userDao = session.getMapper(IUserMapper.class);\n    }\n\n\n    //after注解代表在测试方法执行后执行\n    @After\n    public void destroy() throws Exception{\n        //6.释放资源\n        session.close();\n        inputStream.close();\n    }\n\n\n    @Test\n    public void selectTest() throws Exception{\n\n        //5.使用代理对象执行方法\n        List<User> users= userDao.selectAll();\n        for (User user: users) {\n            System.out.println(user);\n        }\n\n    }\n\n}\n\n```\n\n#### 执行结果\n![执行结果](/images/execResult1.png)\n\n---\n\n### Mybatis的保存操作\n\n#### 在mapper接口中新增保存方法\n```bash\n    /**\n     * 保存用户\n     * @param user\n     */\n    public void saveUser(User user);\n```\n\n#### 在IUserMapper.xml中添加保存sql语句\n```bash\n<insert id=\"saveUser\" parameterType=\"com.loonycoder.domain.User\">\n        insert into user (username,sex,birthday,address) values (#{userName},#{sex},#{birthday},#{address});\n    </insert>\n```\n\n**注意：\n#{}为mybatis的固定用法，用于取值。如果User实体类中的属性是自动生成的get/set，则直接写属性名称即可。\n其次，参数一定要一一对应上**\n\n#### 新建测试类执行\n```bash\n    @Test\n    public void insertTest(){\n        User user = new User();\n        user.setUserName(\"Lisa\");\n        user.setBirthday(new Date());\n        user.setAddress(\"广东\");\n        user.setSex(\"女\");\n        userDao.saveUser(user);\n        session.commit();//记得手动提交事务\n    }\n```\n\n**注意：一定要手动提交事务，否则虽然不会报错，但是不会入表！！！**\n\n#### 执行结果\n![执行结果](/images/execResult2.png)\n\n---\n\n### Mybatis的删除操作\n\n#### 在mapper接口中新增删除方法\n```bash\n /**\n     * 删除用户\n     * @param userId\n     */\n    public void deleteUser(Integer userId);\n```\n\n#### 在IUserMapper.xml中添加删除sql语句\n```bash\n<delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id = #{uid};\n    </delete>\n```\n\n**注意：因为该方法只有一个参数，所以我们在sql中标注的uid部分其实是可以随便写的，因为mybatis只会找到这一个参数**\n\n#### 新建测试类执行\n```bash\n @Test\n    public void deleteTest(){\n        userDao.deleteUser(53);\n        session.commit();//记得手动提交事务\n    }\n```\n\n#### 执行结果\n删除前：\n![执行结果](/images/execBefore.png)\n删除后：\n![执行结果](/images/execAfter.png)\n\n---\n\n### Mybatis的修改操作\n\n#### 在mapper接口中新增修改方法\n```bash\n    /**\n     * 修改用户\n     * @param user\n     */\n    public void updateUser(User user);\n```\n\n#### 在IUserMapper.xml中添加修改sql语句\n```bash\n    <update id=\"updateUser\" parameterType=\"com.loonycoder.domain.User\">\n        update user set username = #{username},sex = #{sex},birthday = #{birthday},address = #{address} where id = #{id};\n    </update>\n```\n\n#### 新建测试类执行\n```bash\n    @Test\n    public void updateTest(){\n        User user = new User();\n        user.setId(41);\n        user.setUserName(\"张三丰\");\n        session.commit();//记得手动提交事务\n    }\n```\n\n#### 执行结果\n修改前：\n![执行结果](/images/execAfter.png)\n修改后：\n![执行结果](/images/execAfter1.png)\n\n\n\n","slug":"Mybatis-2","published":1,"updated":"2020-02-21T15:30:59.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyo0009v9s6g3vr7hzl","content":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>基于我们之前创建的Mybatis项目即可，我在此采用的依旧是基于xml的开发方式。</p>\n<hr>\n<h3 id=\"Mybatis的查询操作\"><a href=\"#Mybatis的查询操作\" class=\"headerlink\" title=\"Mybatis的查询操作\"></a>Mybatis的查询操作</h3><h4 id=\"在mapper接口中新增查询方法\"><a href=\"#在mapper接口中新增查询方法\" class=\"headerlink\" title=\"在mapper接口中新增查询方法\"></a>在mapper接口中新增查询方法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IUserMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 查询用户</span><br><span class=\"line\">     * @<span class=\"built_in\">return</span></span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;User&gt; selectAll();</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在IUserMapper-xml中添加查询sql语句\"><a href=\"#在IUserMapper-xml中添加查询sql语句\" class=\"headerlink\" title=\"在IUserMapper.xml中添加查询sql语句\"></a>在IUserMapper.xml中添加查询sql语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IUserMapper\"</span>&gt;</span><br><span class=\"line\">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class=\"line\">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectAll\"</span> resultType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        select * from user;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新建测试类执行\"><a href=\"#新建测试类执行\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h4><p>由于读取配置文件、创建SqlSessionFactory工厂等步骤复用性较高，我们在这里进行了抽取。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.dao.IUserMapper;</span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\">import org.apache.ibatis.io.Resources;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSession;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class=\"line\">import org.junit.After;</span><br><span class=\"line\">import org.junit.Before;</span><br><span class=\"line\">import org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MybatisTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private InputStream inputStream;</span><br><span class=\"line\">    private SqlSessionFactory sqlSessionFactory;</span><br><span class=\"line\">    private SqlSession session;</span><br><span class=\"line\">    private IUserMapper userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    //before注解代表在测试方法执行前执行</span><br><span class=\"line\">    @Before</span><br><span class=\"line\">    public void init() throws Exception&#123;</span><br><span class=\"line\">        //1.读取配置文件</span><br><span class=\"line\">        inputStream = Resources.getResourceAsStream(<span class=\"string\">\"SqlMapConfig.xml\"</span>);</span><br><span class=\"line\">        //2.创建SqlSessionFactory工厂</span><br><span class=\"line\">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class=\"line\">        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class=\"line\">        //3.使用工厂创建SqlSession对象</span><br><span class=\"line\">        session = sqlSessionFactory.openSession();</span><br><span class=\"line\">        //4.使用SqlSession创建dao接口的代理对象</span><br><span class=\"line\">        userDao = session.getMapper(IUserMapper.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //after注解代表在测试方法执行后执行</span><br><span class=\"line\">    @After</span><br><span class=\"line\">    public void destroy() throws Exception&#123;</span><br><span class=\"line\">        //6.释放资源</span><br><span class=\"line\">        session.close();</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void selectTest() throws Exception&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        //5.使用代理对象执行方法</span><br><span class=\"line\">        List&lt;User&gt; users= userDao.selectAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (User user: users) &#123;</span><br><span class=\"line\">            System.out.println(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><p><img src=\"/images/execResult1.png\" alt=\"执行结果\"></p>\n<hr>\n<h3 id=\"Mybatis的保存操作\"><a href=\"#Mybatis的保存操作\" class=\"headerlink\" title=\"Mybatis的保存操作\"></a>Mybatis的保存操作</h3><h4 id=\"在mapper接口中新增保存方法\"><a href=\"#在mapper接口中新增保存方法\" class=\"headerlink\" title=\"在mapper接口中新增保存方法\"></a>在mapper接口中新增保存方法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 保存用户</span><br><span class=\"line\"> * @param user</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void saveUser(User user);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在IUserMapper-xml中添加保存sql语句\"><a href=\"#在IUserMapper-xml中添加保存sql语句\" class=\"headerlink\" title=\"在IUserMapper.xml中添加保存sql语句\"></a>在IUserMapper.xml中添加保存sql语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;insert id=<span class=\"string\">\"saveUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        insert into user (username,sex,birthday,address) values (<span class=\"comment\">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class=\"line\">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：<br>#{}为mybatis的固定用法，用于取值。如果User实体类中的属性是自动生成的get/set，则直接写属性名称即可。<br>其次，参数一定要一一对应上</strong></p>\n<h4 id=\"新建测试类执行-1\"><a href=\"#新建测试类执行-1\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">insertTest</span></span>()&#123;</span><br><span class=\"line\">    User user = new User();</span><br><span class=\"line\">    user.setUserName(<span class=\"string\">\"Lisa\"</span>);</span><br><span class=\"line\">    user.setBirthday(new Date());</span><br><span class=\"line\">    user.setAddress(<span class=\"string\">\"广东\"</span>);</span><br><span class=\"line\">    user.setSex(<span class=\"string\">\"女\"</span>);</span><br><span class=\"line\">    userDao.saveUser(user);</span><br><span class=\"line\">    session.commit();//记得手动提交事务</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：一定要手动提交事务，否则虽然不会报错，但是不会入表！！！</strong></p>\n<h4 id=\"执行结果-1\"><a href=\"#执行结果-1\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><p><img src=\"/images/execResult2.png\" alt=\"执行结果\"></p>\n<hr>\n<h3 id=\"Mybatis的删除操作\"><a href=\"#Mybatis的删除操作\" class=\"headerlink\" title=\"Mybatis的删除操作\"></a>Mybatis的删除操作</h3><h4 id=\"在mapper接口中新增删除方法\"><a href=\"#在mapper接口中新增删除方法\" class=\"headerlink\" title=\"在mapper接口中新增删除方法\"></a>在mapper接口中新增删除方法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * 删除用户</span><br><span class=\"line\">    * @param userId</span><br><span class=\"line\">    */</span><br><span class=\"line\">   public void deleteUser(Integer userId);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在IUserMapper-xml中添加删除sql语句\"><a href=\"#在IUserMapper-xml中添加删除sql语句\" class=\"headerlink\" title=\"在IUserMapper.xml中添加删除sql语句\"></a>在IUserMapper.xml中添加删除sql语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;delete id=<span class=\"string\">\"deleteUser\"</span> parameterType=<span class=\"string\">\"java.lang.Integer\"</span>&gt;</span><br><span class=\"line\">        delete from user <span class=\"built_in\">where</span> id = <span class=\"comment\">#&#123;uid&#125;;</span></span><br><span class=\"line\">    &lt;/delete&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：因为该方法只有一个参数，所以我们在sql中标注的uid部分其实是可以随便写的，因为mybatis只会找到这一个参数</strong></p>\n<h4 id=\"新建测试类执行-2\"><a href=\"#新建测试类执行-2\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">   public void <span class=\"function\"><span class=\"title\">deleteTest</span></span>()&#123;</span><br><span class=\"line\">       userDao.deleteUser(53);</span><br><span class=\"line\">       session.commit();//记得手动提交事务</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"执行结果-2\"><a href=\"#执行结果-2\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><p>删除前：<br><img src=\"/images/execBefore.png\" alt=\"执行结果\"><br>删除后：<br><img src=\"/images/execAfter.png\" alt=\"执行结果\"></p>\n<hr>\n<h3 id=\"Mybatis的修改操作\"><a href=\"#Mybatis的修改操作\" class=\"headerlink\" title=\"Mybatis的修改操作\"></a>Mybatis的修改操作</h3><h4 id=\"在mapper接口中新增修改方法\"><a href=\"#在mapper接口中新增修改方法\" class=\"headerlink\" title=\"在mapper接口中新增修改方法\"></a>在mapper接口中新增修改方法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 修改用户</span><br><span class=\"line\"> * @param user</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void updateUser(User user);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在IUserMapper-xml中添加修改sql语句\"><a href=\"#在IUserMapper-xml中添加修改sql语句\" class=\"headerlink\" title=\"在IUserMapper.xml中添加修改sql语句\"></a>在IUserMapper.xml中添加修改sql语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;update id=<span class=\"string\">\"updateUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">    update user <span class=\"built_in\">set</span> username = <span class=\"comment\">#&#123;username&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class=\"line\">&lt;/update&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新建测试类执行-3\"><a href=\"#新建测试类执行-3\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">updateTest</span></span>()&#123;</span><br><span class=\"line\">    User user = new User();</span><br><span class=\"line\">    user.setId(41);</span><br><span class=\"line\">    user.setUserName(<span class=\"string\">\"张三丰\"</span>);</span><br><span class=\"line\">    session.commit();//记得手动提交事务</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"执行结果-3\"><a href=\"#执行结果-3\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><p>修改前：<br><img src=\"/images/execAfter.png\" alt=\"执行结果\"><br>修改后：<br><img src=\"/images/execAfter1.png\" alt=\"执行结果\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>基于我们之前创建的Mybatis项目即可，我在此采用的依旧是基于xml的开发方式。</p>\n<hr>\n<h3 id=\"Mybatis的查询操作\"><a href=\"#Mybatis的查询操作\" class=\"headerlink\" title=\"Mybatis的查询操作\"></a>Mybatis的查询操作</h3><h4 id=\"在mapper接口中新增查询方法\"><a href=\"#在mapper接口中新增查询方法\" class=\"headerlink\" title=\"在mapper接口中新增查询方法\"></a>在mapper接口中新增查询方法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IUserMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 查询用户</span><br><span class=\"line\">     * @<span class=\"built_in\">return</span></span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;User&gt; selectAll();</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在IUserMapper-xml中添加查询sql语句\"><a href=\"#在IUserMapper-xml中添加查询sql语句\" class=\"headerlink\" title=\"在IUserMapper.xml中添加查询sql语句\"></a>在IUserMapper.xml中添加查询sql语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IUserMapper\"</span>&gt;</span><br><span class=\"line\">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class=\"line\">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectAll\"</span> resultType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        select * from user;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新建测试类执行\"><a href=\"#新建测试类执行\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h4><p>由于读取配置文件、创建SqlSessionFactory工厂等步骤复用性较高，我们在这里进行了抽取。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.dao.IUserMapper;</span><br><span class=\"line\">import com.loonycoder.domain.User;</span><br><span class=\"line\">import org.apache.ibatis.io.Resources;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSession;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class=\"line\">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class=\"line\">import org.junit.After;</span><br><span class=\"line\">import org.junit.Before;</span><br><span class=\"line\">import org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MybatisTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private InputStream inputStream;</span><br><span class=\"line\">    private SqlSessionFactory sqlSessionFactory;</span><br><span class=\"line\">    private SqlSession session;</span><br><span class=\"line\">    private IUserMapper userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    //before注解代表在测试方法执行前执行</span><br><span class=\"line\">    @Before</span><br><span class=\"line\">    public void init() throws Exception&#123;</span><br><span class=\"line\">        //1.读取配置文件</span><br><span class=\"line\">        inputStream = Resources.getResourceAsStream(<span class=\"string\">\"SqlMapConfig.xml\"</span>);</span><br><span class=\"line\">        //2.创建SqlSessionFactory工厂</span><br><span class=\"line\">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class=\"line\">        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class=\"line\">        //3.使用工厂创建SqlSession对象</span><br><span class=\"line\">        session = sqlSessionFactory.openSession();</span><br><span class=\"line\">        //4.使用SqlSession创建dao接口的代理对象</span><br><span class=\"line\">        userDao = session.getMapper(IUserMapper.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //after注解代表在测试方法执行后执行</span><br><span class=\"line\">    @After</span><br><span class=\"line\">    public void destroy() throws Exception&#123;</span><br><span class=\"line\">        //6.释放资源</span><br><span class=\"line\">        session.close();</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void selectTest() throws Exception&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        //5.使用代理对象执行方法</span><br><span class=\"line\">        List&lt;User&gt; users= userDao.selectAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (User user: users) &#123;</span><br><span class=\"line\">            System.out.println(user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><p><img src=\"/images/execResult1.png\" alt=\"执行结果\"></p>\n<hr>\n<h3 id=\"Mybatis的保存操作\"><a href=\"#Mybatis的保存操作\" class=\"headerlink\" title=\"Mybatis的保存操作\"></a>Mybatis的保存操作</h3><h4 id=\"在mapper接口中新增保存方法\"><a href=\"#在mapper接口中新增保存方法\" class=\"headerlink\" title=\"在mapper接口中新增保存方法\"></a>在mapper接口中新增保存方法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 保存用户</span><br><span class=\"line\"> * @param user</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void saveUser(User user);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在IUserMapper-xml中添加保存sql语句\"><a href=\"#在IUserMapper-xml中添加保存sql语句\" class=\"headerlink\" title=\"在IUserMapper.xml中添加保存sql语句\"></a>在IUserMapper.xml中添加保存sql语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;insert id=<span class=\"string\">\"saveUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        insert into user (username,sex,birthday,address) values (<span class=\"comment\">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class=\"line\">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：<br>#{}为mybatis的固定用法，用于取值。如果User实体类中的属性是自动生成的get/set，则直接写属性名称即可。<br>其次，参数一定要一一对应上</strong></p>\n<h4 id=\"新建测试类执行-1\"><a href=\"#新建测试类执行-1\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">insertTest</span></span>()&#123;</span><br><span class=\"line\">    User user = new User();</span><br><span class=\"line\">    user.setUserName(<span class=\"string\">\"Lisa\"</span>);</span><br><span class=\"line\">    user.setBirthday(new Date());</span><br><span class=\"line\">    user.setAddress(<span class=\"string\">\"广东\"</span>);</span><br><span class=\"line\">    user.setSex(<span class=\"string\">\"女\"</span>);</span><br><span class=\"line\">    userDao.saveUser(user);</span><br><span class=\"line\">    session.commit();//记得手动提交事务</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：一定要手动提交事务，否则虽然不会报错，但是不会入表！！！</strong></p>\n<h4 id=\"执行结果-1\"><a href=\"#执行结果-1\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><p><img src=\"/images/execResult2.png\" alt=\"执行结果\"></p>\n<hr>\n<h3 id=\"Mybatis的删除操作\"><a href=\"#Mybatis的删除操作\" class=\"headerlink\" title=\"Mybatis的删除操作\"></a>Mybatis的删除操作</h3><h4 id=\"在mapper接口中新增删除方法\"><a href=\"#在mapper接口中新增删除方法\" class=\"headerlink\" title=\"在mapper接口中新增删除方法\"></a>在mapper接口中新增删除方法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * 删除用户</span><br><span class=\"line\">    * @param userId</span><br><span class=\"line\">    */</span><br><span class=\"line\">   public void deleteUser(Integer userId);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在IUserMapper-xml中添加删除sql语句\"><a href=\"#在IUserMapper-xml中添加删除sql语句\" class=\"headerlink\" title=\"在IUserMapper.xml中添加删除sql语句\"></a>在IUserMapper.xml中添加删除sql语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;delete id=<span class=\"string\">\"deleteUser\"</span> parameterType=<span class=\"string\">\"java.lang.Integer\"</span>&gt;</span><br><span class=\"line\">        delete from user <span class=\"built_in\">where</span> id = <span class=\"comment\">#&#123;uid&#125;;</span></span><br><span class=\"line\">    &lt;/delete&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：因为该方法只有一个参数，所以我们在sql中标注的uid部分其实是可以随便写的，因为mybatis只会找到这一个参数</strong></p>\n<h4 id=\"新建测试类执行-2\"><a href=\"#新建测试类执行-2\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">   public void <span class=\"function\"><span class=\"title\">deleteTest</span></span>()&#123;</span><br><span class=\"line\">       userDao.deleteUser(53);</span><br><span class=\"line\">       session.commit();//记得手动提交事务</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"执行结果-2\"><a href=\"#执行结果-2\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><p>删除前：<br><img src=\"/images/execBefore.png\" alt=\"执行结果\"><br>删除后：<br><img src=\"/images/execAfter.png\" alt=\"执行结果\"></p>\n<hr>\n<h3 id=\"Mybatis的修改操作\"><a href=\"#Mybatis的修改操作\" class=\"headerlink\" title=\"Mybatis的修改操作\"></a>Mybatis的修改操作</h3><h4 id=\"在mapper接口中新增修改方法\"><a href=\"#在mapper接口中新增修改方法\" class=\"headerlink\" title=\"在mapper接口中新增修改方法\"></a>在mapper接口中新增修改方法</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 修改用户</span><br><span class=\"line\"> * @param user</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void updateUser(User user);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在IUserMapper-xml中添加修改sql语句\"><a href=\"#在IUserMapper-xml中添加修改sql语句\" class=\"headerlink\" title=\"在IUserMapper.xml中添加修改sql语句\"></a>在IUserMapper.xml中添加修改sql语句</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;update id=<span class=\"string\">\"updateUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">    update user <span class=\"built_in\">set</span> username = <span class=\"comment\">#&#123;username&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class=\"line\">&lt;/update&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新建测试类执行-3\"><a href=\"#新建测试类执行-3\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">updateTest</span></span>()&#123;</span><br><span class=\"line\">    User user = new User();</span><br><span class=\"line\">    user.setId(41);</span><br><span class=\"line\">    user.setUserName(<span class=\"string\">\"张三丰\"</span>);</span><br><span class=\"line\">    session.commit();//记得手动提交事务</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"执行结果-3\"><a href=\"#执行结果-3\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><p>修改前：<br><img src=\"/images/execAfter.png\" alt=\"执行结果\"><br>修改后：<br><img src=\"/images/execAfter1.png\" alt=\"执行结果\"></p>\n"},{"title":"Shiro会话管理","date":"2018-09-22T16:00:00.000Z","_content":"\n### Shiro在线会话管理\n\n参考文章：\n- [跟我学Shrio-在线会话](https://www.iteye.com/blog/jinnianshilongnian-2047643)\n- [Spring Boot Shiro在线会话管理](https://mrbird.cc/Spring-Boot-Shiro%20session.html)\n\n实现效果预览：\n![实现效果预览](/images/shiro1.png)\n\nShiro提供一个对象org.apache.shiro.session.mgt.eis.SessionDAO，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。\n\n![目录](/images/shiro2.png)\n\n下面我们实现两个功能：\n- 获取在线会话列表\n- 实现强制下线功能\n\n#### 准备\n\n##### ShiroConfig\n这里我使用的是Redis来储存Shiro的Session信息，修改SessionDAO配置：\n```bash\n@Bean\npublic RedisSessionDAO redisSessionDAO() {\n    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();\n    redisSessionDAO.setRedisManager(redisManager());\n    return redisSessionDAO;\n}\n\n@ConfigurationProperties(prefix = \"redis.shiro\")\npublic RedisManager redisManager() {\n    return new RedisManager();\n}\n```\n\n还需要将SessionDAO注入到SessionManager中：\n```bash\n@Bean\npublic SessionManager sessionManager() {\n    DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();\n    defaultWebSessionManager.setCacheManager(cacheManager());\n    defaultWebSessionManager.setSessionDAO(sessionDAO());\n    return sessionManager;\n}\n```\n\n最后将SessionManager注入到SecurityManager中：\n```bash\n@Bean\npublic SecurityManager securityManager() {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    securityManager.setRealm(realm());\n\n    //自定义sessionManager\n    securityManager.setSessionManager(sessionManager());\n    //自定义缓存实现\n    securityManager.setCacheManager(cacheManager());\n\n    return securityManager;\n}\n```\n\n#### 获取在线会话列表\n\n##### OnlineUser.java\n```bash\n@Data\npublic class OnlineUser implements Serializable {\n\n    private String id; //sessionId\n\n    private String uid; //用户ID\n\n    private String username; //用户名\n\n    private String host; //主机地址\n\n    private String address; //地理位置\n\n    @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private Date startTime; //用户开始访问时间\n\n    @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private Date endTime; //用户最后访问时间\n\n    private Long timeout; //超时时间\n\n    private String status; //状态\n\n    public void setHost(String host) {\n        this.host = host.equals(\"0:0:0:0:0:0:0:1\") ? \"127.0.0.1\" : host;\n    }\n}\n```\n\n##### Service\n编写获取在线会话列表的service层实现：\n```bash\n@Override\npublic List<OnlineUser> list() {\n    List<OnlineUser> list = new ArrayList<>();\n    Collection<Session> sessions = sessionDAO.getActiveSessions(); //获取在线会话的集合\n    for (Session session : sessions) {\n        if (session != null) {\n            OnlineUser onlineUser = new OnlineUser();\n            SimplePrincipalCollection principalCollection;\n            User user;\n            //判断此session是否还在登录状态\n            if (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) {\n                continue;\n            } else {\n                //如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据\n                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);\n                user = (User) principalCollection.getPrimaryPrincipal();\n                onlineUser.setUid(user.getId().toString());\n                onlineUser.setUsername(user.getUsername());\n            }\n            onlineUser.setId(session.getId().toString());\n            onlineUser.setHost(session.getHost());\n            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));\n            onlineUser.setStartTime(session.getStartTimestamp());\n            onlineUser.setEndTime(session.getLastAccessTime());\n            long timeout = session.getTimeout();\n            onlineUser.setTimeout(timeout);\n            onlineUser.setStatus(timeout == 0L ? \"0\" : \"1\"); //0在线 1下线\n            list.add(onlineUser);\n        }\n    }\n    return list;\n}\n```\n\ngetActiveSessions()将获取到所有有效的Session集合，通过DefaultSubjectContext.PRINCIPALS_SESSION_KEY可以判断当前系统Subject中的session key和sessions列表中的session是否匹配，不匹配则session无效。\nsession.getHost()顾名思义就是获取Host主机地址即IP地址。\nAddressUtil.getAddress(session.getHost())是通过IP地址查询其详细的地理位置，使用了ip2region开源库。\n\n##### 根据IP查询地址位置\n\n开源地址：https://github.com/lionsoul2014/ip2region\n引入ip2region的依赖：\n```bash\n<dependency>\n    <groupId>org.lionsoul</groupId>\n    <artifactId>ip2region</artifactId>\n    <version>1.7.2</version>\n</dependency>\n```\n拷贝ip2region.db文件（开源仓库中找）到项目的resources/config/下\n参考官方实例代码写工具类AddressUtil.java\n官方实例：https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java\n\n```bash\npublic class AddressUtil {\n\n    public static String getAddress(String ip) {\n        //db\n        String dbPath = AddressUtil.class.getResource(\"/config/ip2region.db\").getPath();\n\n        File file = new File(dbPath);\n\n        if (!file.exists()) {\n            throw new GlobalException(\"缺少 ip2region.db库\");\n        }\n\n        int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree\n\n        try {\n            DbConfig config = new DbConfig();\n            DbSearcher searcher = new DbSearcher(config, file.getPath());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n            //define the method\n            Method method = null;\n            switch (algorithm) {\n                case DbSearcher.BTREE_ALGORITHM:\n                    method = searcher.getClass().getMethod(\"btreeSearch\", String.class);\n                    break;\n                case DbSearcher.BINARY_ALGORITHM:\n                    method = searcher.getClass().getMethod(\"binarySearch\", String.class);\n                    break;\n                case DbSearcher.MEMORY_ALGORITYM:\n                    method = searcher.getClass().getMethod(\"memorySearch\", String.class);\n                    break;\n            }\n\n            DataBlock dataBlock = null;\n            if (!Util.isIpAddress(ip)) {\n                System.out.println(\"Error: Invalid ip address\");\n            }\n            dataBlock = (DataBlock) method.invoke(searcher, ip);\n            reader.close();\n            searcher.close();\n            return dataBlock.getRegion();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\n```\n\n##### 结\n当前端请求/online/list接口时，将List<OnlineUser>结合数据返回给前端渲染即可。\n\n#### 实现强制下线功能\n\n##### controller\n```bash\n@GetMapping(\"/forceLogout\")\npublic ResponseCode forceLogout(String id) {\n    try {\n        sessionService.forceLogout(id);\n        return ResponseCode.SUCCESS();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return ResponseCode.ERROR();\n    }\n}\n```\n\n注意这个id是sessionID\n\n##### service实现\n```bash\n@Override\npublic void forceLogout(String id) {\n    Session session = sessionDAO.readSession(id);\n    session.setTimeout(0L);\n    session.stop();\n    sessionDAO.delete(session);\n}\n```\n\n\n","source":"_posts/Shiro.md","raw":"---\ntitle: Shiro会话管理\ncategories:\n    - Java框架\ndate: 2018-09-23\ntags:\n\t- 框架\n\t- 权限框架\t\n---\n\n### Shiro在线会话管理\n\n参考文章：\n- [跟我学Shrio-在线会话](https://www.iteye.com/blog/jinnianshilongnian-2047643)\n- [Spring Boot Shiro在线会话管理](https://mrbird.cc/Spring-Boot-Shiro%20session.html)\n\n实现效果预览：\n![实现效果预览](/images/shiro1.png)\n\nShiro提供一个对象org.apache.shiro.session.mgt.eis.SessionDAO，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。\n\n![目录](/images/shiro2.png)\n\n下面我们实现两个功能：\n- 获取在线会话列表\n- 实现强制下线功能\n\n#### 准备\n\n##### ShiroConfig\n这里我使用的是Redis来储存Shiro的Session信息，修改SessionDAO配置：\n```bash\n@Bean\npublic RedisSessionDAO redisSessionDAO() {\n    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();\n    redisSessionDAO.setRedisManager(redisManager());\n    return redisSessionDAO;\n}\n\n@ConfigurationProperties(prefix = \"redis.shiro\")\npublic RedisManager redisManager() {\n    return new RedisManager();\n}\n```\n\n还需要将SessionDAO注入到SessionManager中：\n```bash\n@Bean\npublic SessionManager sessionManager() {\n    DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();\n    defaultWebSessionManager.setCacheManager(cacheManager());\n    defaultWebSessionManager.setSessionDAO(sessionDAO());\n    return sessionManager;\n}\n```\n\n最后将SessionManager注入到SecurityManager中：\n```bash\n@Bean\npublic SecurityManager securityManager() {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    securityManager.setRealm(realm());\n\n    //自定义sessionManager\n    securityManager.setSessionManager(sessionManager());\n    //自定义缓存实现\n    securityManager.setCacheManager(cacheManager());\n\n    return securityManager;\n}\n```\n\n#### 获取在线会话列表\n\n##### OnlineUser.java\n```bash\n@Data\npublic class OnlineUser implements Serializable {\n\n    private String id; //sessionId\n\n    private String uid; //用户ID\n\n    private String username; //用户名\n\n    private String host; //主机地址\n\n    private String address; //地理位置\n\n    @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private Date startTime; //用户开始访问时间\n\n    @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private Date endTime; //用户最后访问时间\n\n    private Long timeout; //超时时间\n\n    private String status; //状态\n\n    public void setHost(String host) {\n        this.host = host.equals(\"0:0:0:0:0:0:0:1\") ? \"127.0.0.1\" : host;\n    }\n}\n```\n\n##### Service\n编写获取在线会话列表的service层实现：\n```bash\n@Override\npublic List<OnlineUser> list() {\n    List<OnlineUser> list = new ArrayList<>();\n    Collection<Session> sessions = sessionDAO.getActiveSessions(); //获取在线会话的集合\n    for (Session session : sessions) {\n        if (session != null) {\n            OnlineUser onlineUser = new OnlineUser();\n            SimplePrincipalCollection principalCollection;\n            User user;\n            //判断此session是否还在登录状态\n            if (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) {\n                continue;\n            } else {\n                //如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据\n                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);\n                user = (User) principalCollection.getPrimaryPrincipal();\n                onlineUser.setUid(user.getId().toString());\n                onlineUser.setUsername(user.getUsername());\n            }\n            onlineUser.setId(session.getId().toString());\n            onlineUser.setHost(session.getHost());\n            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));\n            onlineUser.setStartTime(session.getStartTimestamp());\n            onlineUser.setEndTime(session.getLastAccessTime());\n            long timeout = session.getTimeout();\n            onlineUser.setTimeout(timeout);\n            onlineUser.setStatus(timeout == 0L ? \"0\" : \"1\"); //0在线 1下线\n            list.add(onlineUser);\n        }\n    }\n    return list;\n}\n```\n\ngetActiveSessions()将获取到所有有效的Session集合，通过DefaultSubjectContext.PRINCIPALS_SESSION_KEY可以判断当前系统Subject中的session key和sessions列表中的session是否匹配，不匹配则session无效。\nsession.getHost()顾名思义就是获取Host主机地址即IP地址。\nAddressUtil.getAddress(session.getHost())是通过IP地址查询其详细的地理位置，使用了ip2region开源库。\n\n##### 根据IP查询地址位置\n\n开源地址：https://github.com/lionsoul2014/ip2region\n引入ip2region的依赖：\n```bash\n<dependency>\n    <groupId>org.lionsoul</groupId>\n    <artifactId>ip2region</artifactId>\n    <version>1.7.2</version>\n</dependency>\n```\n拷贝ip2region.db文件（开源仓库中找）到项目的resources/config/下\n参考官方实例代码写工具类AddressUtil.java\n官方实例：https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java\n\n```bash\npublic class AddressUtil {\n\n    public static String getAddress(String ip) {\n        //db\n        String dbPath = AddressUtil.class.getResource(\"/config/ip2region.db\").getPath();\n\n        File file = new File(dbPath);\n\n        if (!file.exists()) {\n            throw new GlobalException(\"缺少 ip2region.db库\");\n        }\n\n        int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree\n\n        try {\n            DbConfig config = new DbConfig();\n            DbSearcher searcher = new DbSearcher(config, file.getPath());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n            //define the method\n            Method method = null;\n            switch (algorithm) {\n                case DbSearcher.BTREE_ALGORITHM:\n                    method = searcher.getClass().getMethod(\"btreeSearch\", String.class);\n                    break;\n                case DbSearcher.BINARY_ALGORITHM:\n                    method = searcher.getClass().getMethod(\"binarySearch\", String.class);\n                    break;\n                case DbSearcher.MEMORY_ALGORITYM:\n                    method = searcher.getClass().getMethod(\"memorySearch\", String.class);\n                    break;\n            }\n\n            DataBlock dataBlock = null;\n            if (!Util.isIpAddress(ip)) {\n                System.out.println(\"Error: Invalid ip address\");\n            }\n            dataBlock = (DataBlock) method.invoke(searcher, ip);\n            reader.close();\n            searcher.close();\n            return dataBlock.getRegion();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\n```\n\n##### 结\n当前端请求/online/list接口时，将List<OnlineUser>结合数据返回给前端渲染即可。\n\n#### 实现强制下线功能\n\n##### controller\n```bash\n@GetMapping(\"/forceLogout\")\npublic ResponseCode forceLogout(String id) {\n    try {\n        sessionService.forceLogout(id);\n        return ResponseCode.SUCCESS();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return ResponseCode.ERROR();\n    }\n}\n```\n\n注意这个id是sessionID\n\n##### service实现\n```bash\n@Override\npublic void forceLogout(String id) {\n    Session session = sessionDAO.readSession(id);\n    session.setTimeout(0L);\n    session.stop();\n    sessionDAO.delete(session);\n}\n```\n\n\n","slug":"Shiro","published":1,"updated":"2020-02-21T15:30:34.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyq000dv9s61eieelkt","content":"<h3 id=\"Shiro在线会话管理\"><a href=\"#Shiro在线会话管理\" class=\"headerlink\" title=\"Shiro在线会话管理\"></a>Shiro在线会话管理</h3><p>参考文章：</p>\n<ul>\n<li><a href=\"https://www.iteye.com/blog/jinnianshilongnian-2047643\" target=\"_blank\" rel=\"noopener\">跟我学Shrio-在线会话</a></li>\n<li><a href=\"https://mrbird.cc/Spring-Boot-Shiro%20session.html\" target=\"_blank\" rel=\"noopener\">Spring Boot Shiro在线会话管理</a></li>\n</ul>\n<p>实现效果预览：<br><img src=\"/images/shiro1.png\" alt=\"实现效果预览\"></p>\n<p>Shiro提供一个对象org.apache.shiro.session.mgt.eis.SessionDAO，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。</p>\n<p><img src=\"/images/shiro2.png\" alt=\"目录\"></p>\n<p>下面我们实现两个功能：</p>\n<ul>\n<li>获取在线会话列表</li>\n<li>实现强制下线功能</li>\n</ul>\n<h4 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h4><h5 id=\"ShiroConfig\"><a href=\"#ShiroConfig\" class=\"headerlink\" title=\"ShiroConfig\"></a>ShiroConfig</h5><p>这里我使用的是Redis来储存Shiro的Session信息，修改SessionDAO配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public RedisSessionDAO <span class=\"function\"><span class=\"title\">redisSessionDAO</span></span>() &#123;</span><br><span class=\"line\">    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();</span><br><span class=\"line\">    redisSessionDAO.setRedisManager(redisManager());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> redisSessionDAO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@ConfigurationProperties(prefix = <span class=\"string\">\"redis.shiro\"</span>)</span><br><span class=\"line\">public RedisManager <span class=\"function\"><span class=\"title\">redisManager</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new RedisManager();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还需要将SessionDAO注入到SessionManager中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public SessionManager <span class=\"function\"><span class=\"title\">sessionManager</span></span>() &#123;</span><br><span class=\"line\">    DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();</span><br><span class=\"line\">    defaultWebSessionManager.setCacheManager(cacheManager());</span><br><span class=\"line\">    defaultWebSessionManager.setSessionDAO(sessionDAO());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> sessionManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后将SessionManager注入到SecurityManager中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public SecurityManager <span class=\"function\"><span class=\"title\">securityManager</span></span>() &#123;</span><br><span class=\"line\">    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class=\"line\">    securityManager.setRealm(realm());</span><br><span class=\"line\"></span><br><span class=\"line\">    //自定义sessionManager</span><br><span class=\"line\">    securityManager.setSessionManager(sessionManager());</span><br><span class=\"line\">    //自定义缓存实现</span><br><span class=\"line\">    securityManager.setCacheManager(cacheManager());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> securityManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"获取在线会话列表\"><a href=\"#获取在线会话列表\" class=\"headerlink\" title=\"获取在线会话列表\"></a>获取在线会话列表</h4><h5 id=\"OnlineUser-java\"><a href=\"#OnlineUser-java\" class=\"headerlink\" title=\"OnlineUser.java\"></a>OnlineUser.java</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Data</span><br><span class=\"line\">public class OnlineUser implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id; //sessionId</span><br><span class=\"line\"></span><br><span class=\"line\">    private String uid; //用户ID</span><br><span class=\"line\"></span><br><span class=\"line\">    private String username; //用户名</span><br><span class=\"line\"></span><br><span class=\"line\">    private String host; //主机地址</span><br><span class=\"line\"></span><br><span class=\"line\">    private String address; //地理位置</span><br><span class=\"line\"></span><br><span class=\"line\">    @DateTimeFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">    @JsonFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>, timezone = <span class=\"string\">\"GMT+8\"</span>)</span><br><span class=\"line\">    private Date startTime; //用户开始访问时间</span><br><span class=\"line\"></span><br><span class=\"line\">    @DateTimeFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">    @JsonFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>, timezone = <span class=\"string\">\"GMT+8\"</span>)</span><br><span class=\"line\">    private Date endTime; //用户最后访问时间</span><br><span class=\"line\"></span><br><span class=\"line\">    private Long timeout; //超时时间</span><br><span class=\"line\"></span><br><span class=\"line\">    private String status; //状态</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setHost(String host) &#123;</span><br><span class=\"line\">        this.host = host.equals(<span class=\"string\">\"0:0:0:0:0:0:0:1\"</span>) ? <span class=\"string\">\"127.0.0.1\"</span> : host;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h5><p>编写获取在线会话列表的service层实现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public List&lt;OnlineUser&gt; <span class=\"function\"><span class=\"title\">list</span></span>() &#123;</span><br><span class=\"line\">    List&lt;OnlineUser&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    Collection&lt;Session&gt; sessions = sessionDAO.getActiveSessions(); //获取在线会话的集合</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Session session : sessions) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (session != null) &#123;</span><br><span class=\"line\">            OnlineUser onlineUser = new OnlineUser();</span><br><span class=\"line\">            SimplePrincipalCollection principalCollection;</span><br><span class=\"line\">            User user;</span><br><span class=\"line\">            //判断此session是否还在登录状态</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                //如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据</span><br><span class=\"line\">                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);</span><br><span class=\"line\">                user = (User) principalCollection.getPrimaryPrincipal();</span><br><span class=\"line\">                onlineUser.setUid(user.getId().toString());</span><br><span class=\"line\">                onlineUser.setUsername(user.getUsername());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            onlineUser.setId(session.getId().toString());</span><br><span class=\"line\">            onlineUser.setHost(session.getHost());</span><br><span class=\"line\">            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));</span><br><span class=\"line\">            onlineUser.setStartTime(session.getStartTimestamp());</span><br><span class=\"line\">            onlineUser.setEndTime(session.getLastAccessTime());</span><br><span class=\"line\">            long timeout = session.getTimeout();</span><br><span class=\"line\">            onlineUser.setTimeout(timeout);</span><br><span class=\"line\">            onlineUser.setStatus(timeout == 0L ? <span class=\"string\">\"0\"</span> : <span class=\"string\">\"1\"</span>); //0在线 1下线</span><br><span class=\"line\">            list.add(onlineUser);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getActiveSessions()将获取到所有有效的Session集合，通过DefaultSubjectContext.PRINCIPALS_SESSION_KEY可以判断当前系统Subject中的session key和sessions列表中的session是否匹配，不匹配则session无效。<br>session.getHost()顾名思义就是获取Host主机地址即IP地址。<br>AddressUtil.getAddress(session.getHost())是通过IP地址查询其详细的地理位置，使用了ip2region开源库。</p>\n<h5 id=\"根据IP查询地址位置\"><a href=\"#根据IP查询地址位置\" class=\"headerlink\" title=\"根据IP查询地址位置\"></a>根据IP查询地址位置</h5><p>开源地址：<a href=\"https://github.com/lionsoul2014/ip2region\" target=\"_blank\" rel=\"noopener\">https://github.com/lionsoul2014/ip2region</a><br>引入ip2region的依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.lionsoul&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;ip2region&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.2&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>拷贝ip2region.db文件（开源仓库中找）到项目的resources/config/下<br>参考官方实例代码写工具类AddressUtil.java<br>官方实例：<a href=\"https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java\" target=\"_blank\" rel=\"noopener\">https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AddressUtil &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static String getAddress(String ip) &#123;</span><br><span class=\"line\">        //db</span><br><span class=\"line\">        String dbPath = AddressUtil.class.getResource(<span class=\"string\">\"/config/ip2region.db\"</span>).getPath();</span><br><span class=\"line\"></span><br><span class=\"line\">        File file = new File(dbPath);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file.exists()) &#123;</span><br><span class=\"line\">            throw new GlobalException(<span class=\"string\">\"缺少 ip2region.db库\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            DbConfig config = new DbConfig();</span><br><span class=\"line\">            DbSearcher searcher = new DbSearcher(config, file.getPath());</span><br><span class=\"line\">            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span><br><span class=\"line\"></span><br><span class=\"line\">            //define the method</span><br><span class=\"line\">            Method method = null;</span><br><span class=\"line\">            switch (algorithm) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.BTREE_ALGORITHM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"btreeSearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.BINARY_ALGORITHM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"binarySearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.MEMORY_ALGORITYM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"memorySearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            DataBlock dataBlock = null;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Util.isIpAddress(ip)) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Error: Invalid ip address\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dataBlock = (DataBlock) method.invoke(searcher, ip);</span><br><span class=\"line\">            reader.close();</span><br><span class=\"line\">            searcher.close();</span><br><span class=\"line\">            <span class=\"built_in\">return</span> dataBlock.getRegion();</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"结\"><a href=\"#结\" class=\"headerlink\" title=\"结\"></a>结</h5><p>当前端请求/online/list接口时，将List<OnlineUser>结合数据返回给前端渲染即可。</p>\n<h4 id=\"实现强制下线功能\"><a href=\"#实现强制下线功能\" class=\"headerlink\" title=\"实现强制下线功能\"></a>实现强制下线功能</h4><h5 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(<span class=\"string\">\"/forceLogout\"</span>)</span><br><span class=\"line\">public ResponseCode forceLogout(String id) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        sessionService.forceLogout(id);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ResponseCode.SUCCESS();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ResponseCode.ERROR();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意这个id是sessionID</p>\n<h5 id=\"service实现\"><a href=\"#service实现\" class=\"headerlink\" title=\"service实现\"></a>service实现</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void forceLogout(String id) &#123;</span><br><span class=\"line\">    Session session = sessionDAO.readSession(id);</span><br><span class=\"line\">    session.setTimeout(0L);</span><br><span class=\"line\">    session.stop();</span><br><span class=\"line\">    sessionDAO.delete(session);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Shiro在线会话管理\"><a href=\"#Shiro在线会话管理\" class=\"headerlink\" title=\"Shiro在线会话管理\"></a>Shiro在线会话管理</h3><p>参考文章：</p>\n<ul>\n<li><a href=\"https://www.iteye.com/blog/jinnianshilongnian-2047643\" target=\"_blank\" rel=\"noopener\">跟我学Shrio-在线会话</a></li>\n<li><a href=\"https://mrbird.cc/Spring-Boot-Shiro%20session.html\" target=\"_blank\" rel=\"noopener\">Spring Boot Shiro在线会话管理</a></li>\n</ul>\n<p>实现效果预览：<br><img src=\"/images/shiro1.png\" alt=\"实现效果预览\"></p>\n<p>Shiro提供一个对象org.apache.shiro.session.mgt.eis.SessionDAO，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。</p>\n<p><img src=\"/images/shiro2.png\" alt=\"目录\"></p>\n<p>下面我们实现两个功能：</p>\n<ul>\n<li>获取在线会话列表</li>\n<li>实现强制下线功能</li>\n</ul>\n<h4 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h4><h5 id=\"ShiroConfig\"><a href=\"#ShiroConfig\" class=\"headerlink\" title=\"ShiroConfig\"></a>ShiroConfig</h5><p>这里我使用的是Redis来储存Shiro的Session信息，修改SessionDAO配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public RedisSessionDAO <span class=\"function\"><span class=\"title\">redisSessionDAO</span></span>() &#123;</span><br><span class=\"line\">    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();</span><br><span class=\"line\">    redisSessionDAO.setRedisManager(redisManager());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> redisSessionDAO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@ConfigurationProperties(prefix = <span class=\"string\">\"redis.shiro\"</span>)</span><br><span class=\"line\">public RedisManager <span class=\"function\"><span class=\"title\">redisManager</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new RedisManager();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还需要将SessionDAO注入到SessionManager中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public SessionManager <span class=\"function\"><span class=\"title\">sessionManager</span></span>() &#123;</span><br><span class=\"line\">    DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();</span><br><span class=\"line\">    defaultWebSessionManager.setCacheManager(cacheManager());</span><br><span class=\"line\">    defaultWebSessionManager.setSessionDAO(sessionDAO());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> sessionManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后将SessionManager注入到SecurityManager中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public SecurityManager <span class=\"function\"><span class=\"title\">securityManager</span></span>() &#123;</span><br><span class=\"line\">    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class=\"line\">    securityManager.setRealm(realm());</span><br><span class=\"line\"></span><br><span class=\"line\">    //自定义sessionManager</span><br><span class=\"line\">    securityManager.setSessionManager(sessionManager());</span><br><span class=\"line\">    //自定义缓存实现</span><br><span class=\"line\">    securityManager.setCacheManager(cacheManager());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> securityManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"获取在线会话列表\"><a href=\"#获取在线会话列表\" class=\"headerlink\" title=\"获取在线会话列表\"></a>获取在线会话列表</h4><h5 id=\"OnlineUser-java\"><a href=\"#OnlineUser-java\" class=\"headerlink\" title=\"OnlineUser.java\"></a>OnlineUser.java</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Data</span><br><span class=\"line\">public class OnlineUser implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id; //sessionId</span><br><span class=\"line\"></span><br><span class=\"line\">    private String uid; //用户ID</span><br><span class=\"line\"></span><br><span class=\"line\">    private String username; //用户名</span><br><span class=\"line\"></span><br><span class=\"line\">    private String host; //主机地址</span><br><span class=\"line\"></span><br><span class=\"line\">    private String address; //地理位置</span><br><span class=\"line\"></span><br><span class=\"line\">    @DateTimeFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">    @JsonFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>, timezone = <span class=\"string\">\"GMT+8\"</span>)</span><br><span class=\"line\">    private Date startTime; //用户开始访问时间</span><br><span class=\"line\"></span><br><span class=\"line\">    @DateTimeFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">    @JsonFormat(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>, timezone = <span class=\"string\">\"GMT+8\"</span>)</span><br><span class=\"line\">    private Date endTime; //用户最后访问时间</span><br><span class=\"line\"></span><br><span class=\"line\">    private Long timeout; //超时时间</span><br><span class=\"line\"></span><br><span class=\"line\">    private String status; //状态</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setHost(String host) &#123;</span><br><span class=\"line\">        this.host = host.equals(<span class=\"string\">\"0:0:0:0:0:0:0:1\"</span>) ? <span class=\"string\">\"127.0.0.1\"</span> : host;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h5><p>编写获取在线会话列表的service层实现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public List&lt;OnlineUser&gt; <span class=\"function\"><span class=\"title\">list</span></span>() &#123;</span><br><span class=\"line\">    List&lt;OnlineUser&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    Collection&lt;Session&gt; sessions = sessionDAO.getActiveSessions(); //获取在线会话的集合</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Session session : sessions) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (session != null) &#123;</span><br><span class=\"line\">            OnlineUser onlineUser = new OnlineUser();</span><br><span class=\"line\">            SimplePrincipalCollection principalCollection;</span><br><span class=\"line\">            User user;</span><br><span class=\"line\">            //判断此session是否还在登录状态</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                //如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据</span><br><span class=\"line\">                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);</span><br><span class=\"line\">                user = (User) principalCollection.getPrimaryPrincipal();</span><br><span class=\"line\">                onlineUser.setUid(user.getId().toString());</span><br><span class=\"line\">                onlineUser.setUsername(user.getUsername());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            onlineUser.setId(session.getId().toString());</span><br><span class=\"line\">            onlineUser.setHost(session.getHost());</span><br><span class=\"line\">            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));</span><br><span class=\"line\">            onlineUser.setStartTime(session.getStartTimestamp());</span><br><span class=\"line\">            onlineUser.setEndTime(session.getLastAccessTime());</span><br><span class=\"line\">            long timeout = session.getTimeout();</span><br><span class=\"line\">            onlineUser.setTimeout(timeout);</span><br><span class=\"line\">            onlineUser.setStatus(timeout == 0L ? <span class=\"string\">\"0\"</span> : <span class=\"string\">\"1\"</span>); //0在线 1下线</span><br><span class=\"line\">            list.add(onlineUser);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getActiveSessions()将获取到所有有效的Session集合，通过DefaultSubjectContext.PRINCIPALS_SESSION_KEY可以判断当前系统Subject中的session key和sessions列表中的session是否匹配，不匹配则session无效。<br>session.getHost()顾名思义就是获取Host主机地址即IP地址。<br>AddressUtil.getAddress(session.getHost())是通过IP地址查询其详细的地理位置，使用了ip2region开源库。</p>\n<h5 id=\"根据IP查询地址位置\"><a href=\"#根据IP查询地址位置\" class=\"headerlink\" title=\"根据IP查询地址位置\"></a>根据IP查询地址位置</h5><p>开源地址：<a href=\"https://github.com/lionsoul2014/ip2region\" target=\"_blank\" rel=\"noopener\">https://github.com/lionsoul2014/ip2region</a><br>引入ip2region的依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.lionsoul&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;ip2region&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.2&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>拷贝ip2region.db文件（开源仓库中找）到项目的resources/config/下<br>参考官方实例代码写工具类AddressUtil.java<br>官方实例：<a href=\"https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java\" target=\"_blank\" rel=\"noopener\">https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AddressUtil &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static String getAddress(String ip) &#123;</span><br><span class=\"line\">        //db</span><br><span class=\"line\">        String dbPath = AddressUtil.class.getResource(<span class=\"string\">\"/config/ip2region.db\"</span>).getPath();</span><br><span class=\"line\"></span><br><span class=\"line\">        File file = new File(dbPath);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file.exists()) &#123;</span><br><span class=\"line\">            throw new GlobalException(<span class=\"string\">\"缺少 ip2region.db库\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            DbConfig config = new DbConfig();</span><br><span class=\"line\">            DbSearcher searcher = new DbSearcher(config, file.getPath());</span><br><span class=\"line\">            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span><br><span class=\"line\"></span><br><span class=\"line\">            //define the method</span><br><span class=\"line\">            Method method = null;</span><br><span class=\"line\">            switch (algorithm) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.BTREE_ALGORITHM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"btreeSearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.BINARY_ALGORITHM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"binarySearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> DbSearcher.MEMORY_ALGORITYM:</span><br><span class=\"line\">                    method = searcher.getClass().getMethod(<span class=\"string\">\"memorySearch\"</span>, String.class);</span><br><span class=\"line\">                    <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            DataBlock dataBlock = null;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Util.isIpAddress(ip)) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Error: Invalid ip address\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dataBlock = (DataBlock) method.invoke(searcher, ip);</span><br><span class=\"line\">            reader.close();</span><br><span class=\"line\">            searcher.close();</span><br><span class=\"line\">            <span class=\"built_in\">return</span> dataBlock.getRegion();</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"结\"><a href=\"#结\" class=\"headerlink\" title=\"结\"></a>结</h5><p>当前端请求/online/list接口时，将List<OnlineUser>结合数据返回给前端渲染即可。</p>\n<h4 id=\"实现强制下线功能\"><a href=\"#实现强制下线功能\" class=\"headerlink\" title=\"实现强制下线功能\"></a>实现强制下线功能</h4><h5 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GetMapping(<span class=\"string\">\"/forceLogout\"</span>)</span><br><span class=\"line\">public ResponseCode forceLogout(String id) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        sessionService.forceLogout(id);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ResponseCode.SUCCESS();</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ResponseCode.ERROR();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意这个id是sessionID</p>\n<h5 id=\"service实现\"><a href=\"#service实现\" class=\"headerlink\" title=\"service实现\"></a>service实现</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void forceLogout(String id) &#123;</span><br><span class=\"line\">    Session session = sessionDAO.readSession(id);</span><br><span class=\"line\">    session.setTimeout(0L);</span><br><span class=\"line\">    session.stop();</span><br><span class=\"line\">    sessionDAO.delete(session);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Mybatis的多表查询","date":"2018-10-14T16:00:00.000Z","_content":"\n### 场景(一对多)\n\n用户和账户\n一个用户可以有多个账户\n一个账户只能属于一个用户（多个账户也可以属于同一个用户）\n\n需要实现：\n查询账户时，可以查询到归属的用户信息。\n\n\n#### 准备工作\n\n##### 建表\n建立用户表和账户表：让用户表和账户表之间具备一对多的关系（需要在账户表中添加外键）\n建表语句\n```bash\nDROP TABLE IF EXISTS `user`;\n\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL auto_increment,\n  `username` varchar(32) NOT NULL COMMENT '用户名称',\n  `birthday` datetime default NULL COMMENT '生日',\n  `sex` char(1) default NULL COMMENT '性别',\n  `address` varchar(256) default NULL COMMENT '地址',\n  PRIMARY KEY  (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\ninsert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,'张三','2018-02-27 17:47:08','男','北京'),(2,'李四','2018-03-02 15:09:37','女','深圳'),(3,'王五','2018-03-04 11:34:34','女','上海'),(4,'赵六','2018-03-04 12:04:06','男','成都'),(4,'刘七','2018-03-07 17:37:26','男','西安'),(48,'孙八','2018-03-08 11:44:00','女','杭州');\n\n\n\n\n\nDROP TABLE IF EXISTS `account`;\n\nCREATE TABLE `account` (\n  `ID` int(11) NOT NULL COMMENT '编号',\n  `UID` int(11) default NULL COMMENT '用户编号',\n  `MONEY` double default NULL COMMENT '金额',\n  PRIMARY KEY  (`ID`),\n  KEY `FK_Reference_8` (`UID`),\n  CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\ninsert  into `account`(`ID`,`UID`,`MONEY`) values (1,1,1000),(2,3,1000),(3,5,2000);\n```\n\n##### 建实体类\n用户实体类和账户实体类：让用户和账户的实体类能体现出一对多的关系\n由于我们之前新建过用户的实体类，所以我们在这里只新建一个账户实体类即可，和用户实体类一样放在com.loonycoder.domain包下\n此处在从表实体类中引用主表的对象。\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\n\npublic class Account implements Serializable {\n    private Integer id;\n    private Integer uid;\n    private Double money;\n\n    //从表实体应该包含一个主表实体的对象引用\n    private User user;\n\n    public User getUser() {\n        return user;\n    }\n\n    public void setUser(User user) {\n        this.user = user;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public Integer getUid() {\n        return uid;\n    }\n\n    public void setUid(Integer uid) {\n        this.uid = uid;\n    }\n\n    public Double getMoney() {\n        return money;\n    }\n\n    public void setMoney(Double money) {\n        this.money = money;\n    }\n\n    @Override\n    public String toString() {\n        return \"Account{\" +\n                \"id=\" + id +\n                \", uid=\" + uid +\n                \", money=\" + money +\n                '}';\n    }\n}\n\n```\n\n\n\n接下来我们新建一个Account的Mapper接口类，并提供查询所有账户的方法。\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.Account;\nimport com.loonycoder.domain.AccountUser;\n\nimport java.util.List;\n\npublic interface IAccountMapper {\n\n\n    /**\n     * 查询所有账户\n     * @return\n     */\n    List<Account> selectAll();\n\n    /**\n     * 查询所有账户，并且包含账户对应的用户下的姓名和地址信息\n     * @return\n     */\n    List<AccountUser> selectAccountUser();\n}\n\n\n```\n\n##### 配置文件\n用户的配置文件和账户的配置文件\n用户的配置文件用之前的就可以了，我们在此只新建账户的配置文件。\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.loonycoder.dao.IAccountMapper\">\n\n    <!--定义封装account和user的resultMap-->\n    <resultMap id=\"accountUserMap\" type=\"account\">\n        <id property=\"id\" column=\"aid\"></id>\n        <result property=\"uid\" column=\"uid\"></result>\n        <result property=\"money\" column=\"money\"></result>\n        <!--一对一的关系映射，配置封装user的内容-->\n        <association property=\"user\" column=\"uid\" javaType=\"user\">\n            <id property=\"id\" column=\"id\"></id>\n            <result property=\"userName\" column=\"username\"></result>\n            <result property=\"address\" column=\"address\"></result>\n            <result property=\"sex\" column=\"sex\"></result>\n            <result property=\"birthday\" column=\"birthday\"></result>\n        </association>\n    </resultMap>\n\n\n    <select id=\"selectAll\" resultMap=\"accountUserMap\">\n        select u.*,a.id as aid,a.uid,a.money from account a,user u where u.id = a.uid;\n    </select>\n</mapper>\n```\n\n当然我们还需要修改一下SqlMapConfig.xml中的别名和mapper映射配置\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<!--mybatis的主配置文件-->\n<configuration>\n    <!--引用外部配置文件配置数据源信息，下面的取值部分需要用${}方式取值-->\n    <properties resource=\"jdbcConfig.properties\">\n    </properties>\n    <!--配置别名 type属性指定实体类，alias指定别名-->\n    <typeAliases >\n        <!--package标签可以指定具体到某个包下所有类都使用别名，默认别名是类的名字，不区分大小写-->\n        <package name=\"com.loonycoder.domain\"></package>\n        <!--<typeAlias type=\"com.loonycoder.domain.User\" alias=\"user\"></typeAlias>-->\n    </typeAliases>\n    <!--配置环境-->\n    <environments default=\"mysql\">\n        <environment id=\"mysql\">\n            <!--配置事务-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置数据源（连接池）-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${jdbc.driver}\" />\n                <property name=\"url\" value=\"${jdbc.url}\" />\n                <property name=\"username\" value=\"${jdbc.username}\" />\n                <property name=\"password\" value=\"${jdbc.password}\" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!--配置映射文件（mapper类的映射文件）-->\n    <mappers>\n        <mapper resource=\"com/loonycoder/dao/IUserMapper.xml\" />\n        <mapper resource=\"com/loonycoder/dao/IAccountMapper.xml\" />\n        <!--<mapper class=\"com.loonycoder.dao.IUserMapper\" />-->\n    </mappers>\n</configuration>\n```\n\n##### 新建测试类执行\n```bash\n    @Test\n    public void selectAllAccount(){\n        List<Account> accts = accountMapper.selectAll();\n        for (Account acct : accts) {\n            System.out.println(\"每个账户下的用户信息\");\n            System.out.println(acct);\n            System.out.println(acct.getUser());\n        }\n    }\n```\n\n##### 执行结果\n![result](/images/mybatis1.png)\n\n---\n\n### 场景(多对一)\n\n需要实现：\n- 查询用户时，可以同时查询出用户下的所有账户信息\n\n##### 修改实体类\n我们修改User实体类，让主表包含从表的集合引用\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.List;\n\npublic class User implements Serializable {\n    private Integer id;\n    private String userName;\n    private Date birthday;\n    private String sex;\n    private String address;\n\n    private List<Account> accounts;\n\n    public List<Account> getAccounts() {\n        return accounts;\n    }\n\n    public void setAccounts(List<Account> accounts) {\n        this.accounts = accounts;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", userName='\" + userName + '\\'' +\n                \", birthday=\" + birthday +\n                \", sex='\" + sex + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n\n```\n\n##### 修改配置文件\n\nUser接口类我们不做修改，直接用原来的查询所有用户的方法即可，我们只需要改动映射配置文件。\n修改IUserMapper.xml内容如下：\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace里面要配置mapper接口的全限定类名-->\n<mapper namespace=\"com.loonycoder.dao.IUserMapper\">\n    <!--配置列名和实体类属性对应关系 type属性不区分大小写-->\n    <resultMap id=\"userMap\" type=\"com.loonycoder.domain.User\">\n        <!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名-->\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"username\"></result>\n        <result property=\"birthday\" column=\"birthday\"></result>\n        <result property=\"address\" column=\"address\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n    </resultMap>\n    <!--定义User的resultMap-->\n    <resultMap id=\"userAccountMap\" type=\"user\">\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"username\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n        <result property=\"address\" column=\"address\"></result>\n        <result property=\"birthday\" column=\"birthday\"></result>\n        <!--配置user对象中accounts集合的映射-->\n        <!--ofType指的是集合的泛型-->\n        <collection property=\"accounts\" ofType=\"account\">\n            <id property=\"id\" column=\"aid\"></id>\n            <result property=\"uid\" column=\"uid\"></result>\n            <result property=\"money\" column=\"money\"></result>\n        </collection>\n    </resultMap>\n    <!--id要保持和方法名一致-->\n    <!--resultType指定返回值类型，如果是List类型 配置List的泛型即可-->\n    <!--此处使用左外连接查询-->\n    <select id=\"selectAll\" resultMap=\"userAccountMap\">\n        select * from user u left outer join account a on u.id = a.uid;\n    </select>\n\n    <insert id=\"saveUser\" parameterType=\"com.loonycoder.domain.User\">\n        insert into user (username,sex,birthday,address) values (#{userName},#{sex},#{birthday},#{address});\n    </insert>\n\n    <delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id = #{uid};\n    </delete>\n\n    <update id=\"updateUser\" parameterType=\"com.loonycoder.domain.User\">\n        update user set username = #{userName},sex = #{sex},birthday = #{birthday},address = #{address} where id = #{id};\n    </update>\n    \n    <select id=\"selectUserByCondition\" resultMap=\"userMap\" parameterType=\"user\">\n          select * from user\n          <where>\n            <if test=\"sex != null and sex != '' \">\n                and sex = #{sex}\n            </if>\n          </where>\n\n    </select>\n</mapper>\n```\n\n##### 新建测试类执行\n```bash\n    @Test\n    public void selectTest() throws Exception{\n\n        //5.使用代理对象执行方法\n        List<User> users= userDao.selectAll();\n        for (User user: users) {\n            System.out.println(\"每个用户下账户的信息：\");\n            System.out.println(user);\n            System.out.println(user.getAccounts());\n        }\n\n    }\n```\n\n##### 执行结果\n![result](/images/mybatis2.png)\n\n---\n\n### 场景(多对多)\n用户和角色\n一个用户有多个角色\n一个角色有多个用户\n需要实现：\n- 当我们查询用户时，可以同时得到用户的角色信息\n- 当我们查询角色时，可以同时得到角色所属的用户信息\n\n##### 新建角色表和中间表\n建表语句：\n```bash\nDROP TABLE IF EXISTS `role`;\n\nCREATE TABLE `role` (\n  `ID` int(11) NOT NULL COMMENT '编号',\n  `ROLE_NAME` varchar(30) default NULL COMMENT '角色名称',\n  `ROLE_DESC` varchar(60) default NULL COMMENT '角色描述',\n  PRIMARY KEY  (`ID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\ninsert  into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,'董事长','管理整个公司'),(2,'总裁','管理整个公司'),(3,'部门经理','管理某个部门');\n\n\n\n\n\nDROP TABLE IF EXISTS `user_role`;\n\nCREATE TABLE `user_role` (\n  `UID` int(11) NOT NULL COMMENT '用户编号',\n  `RID` int(11) NOT NULL COMMENT '角色编号',\n  PRIMARY KEY  (`UID`,`RID`),\n  KEY `FK_Reference_10` (`RID`),\n  CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`),\n  CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\ninsert  into `user_role`(`UID`,`RID`) values (1,1),(3,1),(3,2);\n\n```\n\n##### 新建角色实体类\n此处注意也要让用户和角色体现出多对多关系：需要各自包含对方的一个集合引用。\n\n新建角色实体类：\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\n\npublic class Role implements Serializable {\n    private Integer roleId;\n    private String roleName;\n    private String roleDesc;\n\n    public Integer getRoleId() {\n        return roleId;\n    }\n\n    public void setRoleId(Integer roleId) {\n        this.roleId = roleId;\n    }\n\n    public String getRoleName() {\n        return roleName;\n    }\n\n    public void setRoleName(String roleName) {\n        this.roleName = roleName;\n    }\n\n    public String getRoleDesc() {\n        return roleDesc;\n    }\n\n    public void setRoleDesc(String roleDesc) {\n        this.roleDesc = roleDesc;\n    }\n\n    @Override\n    public String toString() {\n        return \"Role{\" +\n                \"roleId=\" + roleId +\n                \", roleName='\" + roleName + '\\'' +\n                \", roleDesc='\" + roleDesc + '\\'' +\n                '}';\n    }\n}\n\n```\n\n##### 新建实体类接口\n新建RoleMapper接口类：\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.Role;\n\nimport java.util.List;\n\npublic interface IRoleMapper {\n\n\n    /**\n     * 查询所有角色信息\n     * @return\n     */\n    public List<Role> selectAll();\n}\n\n```\n\n##### 新建角色实体配置文件\n一、新建IRoleMapper.xml\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.loonycoder.dao.IRoleMapper\">\n    <!--定义role表的resultMap-->\n    <resultMap id=\"roleMap\" type=\"role\">\n        <id property=\"roleId\" column=\"rid\"></id>\n        <result property=\"roleName\" column=\"role_name\"></result>\n        <result property=\"roleDesc\" column=\"role_desc\"></result>\n        <collection property=\"users\" ofType=\"user\">\n            <id property=\"id\" column=\"id\"></id>\n            <result property=\"userName\" column=\"username\"></result>\n            <result property=\"address\" column=\"address\"></result>\n            <result property=\"sex\" column=\"sex\"></result>\n            <result property=\"birthday\" column=\"birthday\"></result>\n        </collection>\n    </resultMap>\n\n    <!--查询所有角色信息-->\n    <!--使用两次左外连接查询-->\n    <select id=\"selectAll\" resultMap=\"roleMap\">\n        select u.*,r.id as rid,r.role_name,r.role_desc from role r\n        left outer join user_role ur on r.id = ur.rid\n        left outer join user u on u.id = ur.uid\n    </select>\n</mapper>\n\n```\n\n二、在SqlMapConfig.xml中添加映射配置\n```bash\n<!--配置映射文件（mapper类的映射文件）-->\n    <mappers>\n        <mapper resource=\"com/loonycoder/dao/IUserMapper.xml\" />\n        <mapper resource=\"com/loonycoder/dao/IAccountMapper.xml\" />\n        <mapper resource=\"com/loonycoder/dao/IRoleMapper.xml\" />\n        <!--<mapper class=\"com.loonycoder.dao.IUserMapper\" />-->\n    </mappers>\n```\n\n##### 新建测试类执行\n\n```bash\n    @Test\n    public void selectRoleAll(){\n        List<Role> roles = roleMapper.selectAll();\n        for (Role role:roles) {\n            System.out.println(\"每个角色的用户信息：\");\n            System.out.println(role);\n            System.out.println(role.getUsers());\n        }\n    }\n```\n\n##### 执行结果\n![result](/images/mybatis3.png)\n\n---\n\n##### 根据用户查询角色\n\n同理，我们修改用户实体类，添加多对多的关系映射：一个用户具备多个角色\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.List;\n\npublic class User implements Serializable {\n    private Integer id;\n    private String userName;\n    private Date birthday;\n    private String sex;\n    private String address;\n\n\n//    多对多关系映射：一个用户具备多个角色\n    private List<Role> roles;\n\n    public List<Role> getRoles() {\n        return roles;\n    }\n\n    public void setRoles(List<Role> roles) {\n        this.roles = roles;\n    }\n\n    private List<Account> accounts;\n\n    public List<Account> getAccounts() {\n        return accounts;\n    }\n\n    public void setAccounts(List<Account> accounts) {\n        this.accounts = accounts;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", userName='\" + userName + '\\'' +\n                \", birthday=\" + birthday +\n                \", sex='\" + sex + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n\n```\n\n其次，修改用户实体映射配置文件。\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace里面要配置mapper接口的全限定类名-->\n<mapper namespace=\"com.loonycoder.dao.IUserMapper\">\n    <!--配置列名和实体类属性对应关系 type属性不区分大小写-->\n    <resultMap id=\"userMap\" type=\"com.loonycoder.domain.User\">\n        <!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名-->\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"username\"></result>\n        <result property=\"birthday\" column=\"birthday\"></result>\n        <result property=\"address\" column=\"address\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n    </resultMap>\n    <!--定义User的resultMap-->\n    <resultMap id=\"userAccountMap\" type=\"user\">\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"username\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n        <result property=\"address\" column=\"address\"></result>\n        <result property=\"birthday\" column=\"birthday\"></result>\n        <!--配置user对象中accounts集合的映射-->\n        <!--ofType指的是集合的泛型-->\n        <collection property=\"accounts\" ofType=\"account\">\n            <id property=\"id\" column=\"aid\"></id>\n            <result property=\"uid\" column=\"uid\"></result>\n            <result property=\"money\" column=\"money\"></result>\n        </collection>\n    </resultMap>\n    \n    <!--配置user的userRoleMap-->\n    <resultMap id=\"userRoleMap\" type=\"user\">\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"username\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n        <result property=\"address\" column=\"address\"></result>\n        <result property=\"birthday\" column=\"birthday\"></result>\n        <collection property=\"roles\" ofType=\"role\">\n            <id property=\"roleId\" column=\"rid\"></id>\n            <result property=\"roleName\" column=\"role_name\"></result>\n            <result property=\"roleDesc\" column=\"role_desc\"></result>\n        </collection>\n    </resultMap>\n    <!--id要保持和方法名一致-->\n    <!--resultType指定返回值类型，如果是List类型 配置List的泛型即可-->\n    <!--此处使用左外连接查询-->\n    <select id=\"selectAll\" resultMap=\"userAccountMap\">\n        select * from user u left outer join account a on u.id = a.uid;\n    </select>\n\n    <select id=\"selectUserRoleAll\" resultMap=\"userRoleMap\">\n        select u.*,r.id as rid,r.role_name,r.role_desc from user u\n        left outer join user_role ur on u.id = ur.uid\n        left outer join role r on r.id = ur.rid\n    </select>\n\n    <insert id=\"saveUser\" parameterType=\"com.loonycoder.domain.User\">\n        insert into user (username,sex,birthday,address) values (#{userName},#{sex},#{birthday},#{address});\n    </insert>\n\n    <delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id = #{uid};\n    </delete>\n\n    <update id=\"updateUser\" parameterType=\"com.loonycoder.domain.User\">\n        update user set username = #{userName},sex = #{sex},birthday = #{birthday},address = #{address} where id = #{id};\n    </update>\n    \n    <select id=\"selectUserByCondition\" resultMap=\"userMap\" parameterType=\"user\">\n          select * from user\n          <where>\n            <if test=\"sex != null and sex != '' \">\n                and sex = #{sex}\n            </if>\n          </where>\n\n    </select>\n</mapper>\n```\n\n在UserMapper接口中添加查询方法：\n```bash\n/**\n     * 查询用户及用户下所有的角色信息\n     * @return\n     */\n    public List<User> selectUserRoleAll();\n```\n\n新建测试方法：\n```bash\n    @Test\n    public void selectUserRoleAll(){\n        List<User> users = userDao.selectUserRoleAll();\n        for (User user:users) {\n            System.out.println(\"每个用户的角色信息：\");\n            System.out.println(user);\n            System.out.println(user.getRoles());\n        }\n    }\n```\n\n执行结果：\n![result](/images/mybatis4.png)\n","source":"_posts/Mybatis-3.md","raw":"---\ntitle: Mybatis的多表查询\ncategories:\n    - Mybatis\n    \ndate: 2018-10-15\ntags:\n\t- Java\n\t- Java框架\n    - 数据库\n\n---\n\n### 场景(一对多)\n\n用户和账户\n一个用户可以有多个账户\n一个账户只能属于一个用户（多个账户也可以属于同一个用户）\n\n需要实现：\n查询账户时，可以查询到归属的用户信息。\n\n\n#### 准备工作\n\n##### 建表\n建立用户表和账户表：让用户表和账户表之间具备一对多的关系（需要在账户表中添加外键）\n建表语句\n```bash\nDROP TABLE IF EXISTS `user`;\n\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL auto_increment,\n  `username` varchar(32) NOT NULL COMMENT '用户名称',\n  `birthday` datetime default NULL COMMENT '生日',\n  `sex` char(1) default NULL COMMENT '性别',\n  `address` varchar(256) default NULL COMMENT '地址',\n  PRIMARY KEY  (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\ninsert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,'张三','2018-02-27 17:47:08','男','北京'),(2,'李四','2018-03-02 15:09:37','女','深圳'),(3,'王五','2018-03-04 11:34:34','女','上海'),(4,'赵六','2018-03-04 12:04:06','男','成都'),(4,'刘七','2018-03-07 17:37:26','男','西安'),(48,'孙八','2018-03-08 11:44:00','女','杭州');\n\n\n\n\n\nDROP TABLE IF EXISTS `account`;\n\nCREATE TABLE `account` (\n  `ID` int(11) NOT NULL COMMENT '编号',\n  `UID` int(11) default NULL COMMENT '用户编号',\n  `MONEY` double default NULL COMMENT '金额',\n  PRIMARY KEY  (`ID`),\n  KEY `FK_Reference_8` (`UID`),\n  CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\ninsert  into `account`(`ID`,`UID`,`MONEY`) values (1,1,1000),(2,3,1000),(3,5,2000);\n```\n\n##### 建实体类\n用户实体类和账户实体类：让用户和账户的实体类能体现出一对多的关系\n由于我们之前新建过用户的实体类，所以我们在这里只新建一个账户实体类即可，和用户实体类一样放在com.loonycoder.domain包下\n此处在从表实体类中引用主表的对象。\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\n\npublic class Account implements Serializable {\n    private Integer id;\n    private Integer uid;\n    private Double money;\n\n    //从表实体应该包含一个主表实体的对象引用\n    private User user;\n\n    public User getUser() {\n        return user;\n    }\n\n    public void setUser(User user) {\n        this.user = user;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public Integer getUid() {\n        return uid;\n    }\n\n    public void setUid(Integer uid) {\n        this.uid = uid;\n    }\n\n    public Double getMoney() {\n        return money;\n    }\n\n    public void setMoney(Double money) {\n        this.money = money;\n    }\n\n    @Override\n    public String toString() {\n        return \"Account{\" +\n                \"id=\" + id +\n                \", uid=\" + uid +\n                \", money=\" + money +\n                '}';\n    }\n}\n\n```\n\n\n\n接下来我们新建一个Account的Mapper接口类，并提供查询所有账户的方法。\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.Account;\nimport com.loonycoder.domain.AccountUser;\n\nimport java.util.List;\n\npublic interface IAccountMapper {\n\n\n    /**\n     * 查询所有账户\n     * @return\n     */\n    List<Account> selectAll();\n\n    /**\n     * 查询所有账户，并且包含账户对应的用户下的姓名和地址信息\n     * @return\n     */\n    List<AccountUser> selectAccountUser();\n}\n\n\n```\n\n##### 配置文件\n用户的配置文件和账户的配置文件\n用户的配置文件用之前的就可以了，我们在此只新建账户的配置文件。\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.loonycoder.dao.IAccountMapper\">\n\n    <!--定义封装account和user的resultMap-->\n    <resultMap id=\"accountUserMap\" type=\"account\">\n        <id property=\"id\" column=\"aid\"></id>\n        <result property=\"uid\" column=\"uid\"></result>\n        <result property=\"money\" column=\"money\"></result>\n        <!--一对一的关系映射，配置封装user的内容-->\n        <association property=\"user\" column=\"uid\" javaType=\"user\">\n            <id property=\"id\" column=\"id\"></id>\n            <result property=\"userName\" column=\"username\"></result>\n            <result property=\"address\" column=\"address\"></result>\n            <result property=\"sex\" column=\"sex\"></result>\n            <result property=\"birthday\" column=\"birthday\"></result>\n        </association>\n    </resultMap>\n\n\n    <select id=\"selectAll\" resultMap=\"accountUserMap\">\n        select u.*,a.id as aid,a.uid,a.money from account a,user u where u.id = a.uid;\n    </select>\n</mapper>\n```\n\n当然我们还需要修改一下SqlMapConfig.xml中的别名和mapper映射配置\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<!--mybatis的主配置文件-->\n<configuration>\n    <!--引用外部配置文件配置数据源信息，下面的取值部分需要用${}方式取值-->\n    <properties resource=\"jdbcConfig.properties\">\n    </properties>\n    <!--配置别名 type属性指定实体类，alias指定别名-->\n    <typeAliases >\n        <!--package标签可以指定具体到某个包下所有类都使用别名，默认别名是类的名字，不区分大小写-->\n        <package name=\"com.loonycoder.domain\"></package>\n        <!--<typeAlias type=\"com.loonycoder.domain.User\" alias=\"user\"></typeAlias>-->\n    </typeAliases>\n    <!--配置环境-->\n    <environments default=\"mysql\">\n        <environment id=\"mysql\">\n            <!--配置事务-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置数据源（连接池）-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${jdbc.driver}\" />\n                <property name=\"url\" value=\"${jdbc.url}\" />\n                <property name=\"username\" value=\"${jdbc.username}\" />\n                <property name=\"password\" value=\"${jdbc.password}\" />\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!--配置映射文件（mapper类的映射文件）-->\n    <mappers>\n        <mapper resource=\"com/loonycoder/dao/IUserMapper.xml\" />\n        <mapper resource=\"com/loonycoder/dao/IAccountMapper.xml\" />\n        <!--<mapper class=\"com.loonycoder.dao.IUserMapper\" />-->\n    </mappers>\n</configuration>\n```\n\n##### 新建测试类执行\n```bash\n    @Test\n    public void selectAllAccount(){\n        List<Account> accts = accountMapper.selectAll();\n        for (Account acct : accts) {\n            System.out.println(\"每个账户下的用户信息\");\n            System.out.println(acct);\n            System.out.println(acct.getUser());\n        }\n    }\n```\n\n##### 执行结果\n![result](/images/mybatis1.png)\n\n---\n\n### 场景(多对一)\n\n需要实现：\n- 查询用户时，可以同时查询出用户下的所有账户信息\n\n##### 修改实体类\n我们修改User实体类，让主表包含从表的集合引用\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.List;\n\npublic class User implements Serializable {\n    private Integer id;\n    private String userName;\n    private Date birthday;\n    private String sex;\n    private String address;\n\n    private List<Account> accounts;\n\n    public List<Account> getAccounts() {\n        return accounts;\n    }\n\n    public void setAccounts(List<Account> accounts) {\n        this.accounts = accounts;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", userName='\" + userName + '\\'' +\n                \", birthday=\" + birthday +\n                \", sex='\" + sex + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n\n```\n\n##### 修改配置文件\n\nUser接口类我们不做修改，直接用原来的查询所有用户的方法即可，我们只需要改动映射配置文件。\n修改IUserMapper.xml内容如下：\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace里面要配置mapper接口的全限定类名-->\n<mapper namespace=\"com.loonycoder.dao.IUserMapper\">\n    <!--配置列名和实体类属性对应关系 type属性不区分大小写-->\n    <resultMap id=\"userMap\" type=\"com.loonycoder.domain.User\">\n        <!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名-->\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"username\"></result>\n        <result property=\"birthday\" column=\"birthday\"></result>\n        <result property=\"address\" column=\"address\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n    </resultMap>\n    <!--定义User的resultMap-->\n    <resultMap id=\"userAccountMap\" type=\"user\">\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"username\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n        <result property=\"address\" column=\"address\"></result>\n        <result property=\"birthday\" column=\"birthday\"></result>\n        <!--配置user对象中accounts集合的映射-->\n        <!--ofType指的是集合的泛型-->\n        <collection property=\"accounts\" ofType=\"account\">\n            <id property=\"id\" column=\"aid\"></id>\n            <result property=\"uid\" column=\"uid\"></result>\n            <result property=\"money\" column=\"money\"></result>\n        </collection>\n    </resultMap>\n    <!--id要保持和方法名一致-->\n    <!--resultType指定返回值类型，如果是List类型 配置List的泛型即可-->\n    <!--此处使用左外连接查询-->\n    <select id=\"selectAll\" resultMap=\"userAccountMap\">\n        select * from user u left outer join account a on u.id = a.uid;\n    </select>\n\n    <insert id=\"saveUser\" parameterType=\"com.loonycoder.domain.User\">\n        insert into user (username,sex,birthday,address) values (#{userName},#{sex},#{birthday},#{address});\n    </insert>\n\n    <delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id = #{uid};\n    </delete>\n\n    <update id=\"updateUser\" parameterType=\"com.loonycoder.domain.User\">\n        update user set username = #{userName},sex = #{sex},birthday = #{birthday},address = #{address} where id = #{id};\n    </update>\n    \n    <select id=\"selectUserByCondition\" resultMap=\"userMap\" parameterType=\"user\">\n          select * from user\n          <where>\n            <if test=\"sex != null and sex != '' \">\n                and sex = #{sex}\n            </if>\n          </where>\n\n    </select>\n</mapper>\n```\n\n##### 新建测试类执行\n```bash\n    @Test\n    public void selectTest() throws Exception{\n\n        //5.使用代理对象执行方法\n        List<User> users= userDao.selectAll();\n        for (User user: users) {\n            System.out.println(\"每个用户下账户的信息：\");\n            System.out.println(user);\n            System.out.println(user.getAccounts());\n        }\n\n    }\n```\n\n##### 执行结果\n![result](/images/mybatis2.png)\n\n---\n\n### 场景(多对多)\n用户和角色\n一个用户有多个角色\n一个角色有多个用户\n需要实现：\n- 当我们查询用户时，可以同时得到用户的角色信息\n- 当我们查询角色时，可以同时得到角色所属的用户信息\n\n##### 新建角色表和中间表\n建表语句：\n```bash\nDROP TABLE IF EXISTS `role`;\n\nCREATE TABLE `role` (\n  `ID` int(11) NOT NULL COMMENT '编号',\n  `ROLE_NAME` varchar(30) default NULL COMMENT '角色名称',\n  `ROLE_DESC` varchar(60) default NULL COMMENT '角色描述',\n  PRIMARY KEY  (`ID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\ninsert  into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,'董事长','管理整个公司'),(2,'总裁','管理整个公司'),(3,'部门经理','管理某个部门');\n\n\n\n\n\nDROP TABLE IF EXISTS `user_role`;\n\nCREATE TABLE `user_role` (\n  `UID` int(11) NOT NULL COMMENT '用户编号',\n  `RID` int(11) NOT NULL COMMENT '角色编号',\n  PRIMARY KEY  (`UID`,`RID`),\n  KEY `FK_Reference_10` (`RID`),\n  CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`),\n  CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\ninsert  into `user_role`(`UID`,`RID`) values (1,1),(3,1),(3,2);\n\n```\n\n##### 新建角色实体类\n此处注意也要让用户和角色体现出多对多关系：需要各自包含对方的一个集合引用。\n\n新建角色实体类：\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\n\npublic class Role implements Serializable {\n    private Integer roleId;\n    private String roleName;\n    private String roleDesc;\n\n    public Integer getRoleId() {\n        return roleId;\n    }\n\n    public void setRoleId(Integer roleId) {\n        this.roleId = roleId;\n    }\n\n    public String getRoleName() {\n        return roleName;\n    }\n\n    public void setRoleName(String roleName) {\n        this.roleName = roleName;\n    }\n\n    public String getRoleDesc() {\n        return roleDesc;\n    }\n\n    public void setRoleDesc(String roleDesc) {\n        this.roleDesc = roleDesc;\n    }\n\n    @Override\n    public String toString() {\n        return \"Role{\" +\n                \"roleId=\" + roleId +\n                \", roleName='\" + roleName + '\\'' +\n                \", roleDesc='\" + roleDesc + '\\'' +\n                '}';\n    }\n}\n\n```\n\n##### 新建实体类接口\n新建RoleMapper接口类：\n```bash\npackage com.loonycoder.dao;\n\nimport com.loonycoder.domain.Role;\n\nimport java.util.List;\n\npublic interface IRoleMapper {\n\n\n    /**\n     * 查询所有角色信息\n     * @return\n     */\n    public List<Role> selectAll();\n}\n\n```\n\n##### 新建角色实体配置文件\n一、新建IRoleMapper.xml\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.loonycoder.dao.IRoleMapper\">\n    <!--定义role表的resultMap-->\n    <resultMap id=\"roleMap\" type=\"role\">\n        <id property=\"roleId\" column=\"rid\"></id>\n        <result property=\"roleName\" column=\"role_name\"></result>\n        <result property=\"roleDesc\" column=\"role_desc\"></result>\n        <collection property=\"users\" ofType=\"user\">\n            <id property=\"id\" column=\"id\"></id>\n            <result property=\"userName\" column=\"username\"></result>\n            <result property=\"address\" column=\"address\"></result>\n            <result property=\"sex\" column=\"sex\"></result>\n            <result property=\"birthday\" column=\"birthday\"></result>\n        </collection>\n    </resultMap>\n\n    <!--查询所有角色信息-->\n    <!--使用两次左外连接查询-->\n    <select id=\"selectAll\" resultMap=\"roleMap\">\n        select u.*,r.id as rid,r.role_name,r.role_desc from role r\n        left outer join user_role ur on r.id = ur.rid\n        left outer join user u on u.id = ur.uid\n    </select>\n</mapper>\n\n```\n\n二、在SqlMapConfig.xml中添加映射配置\n```bash\n<!--配置映射文件（mapper类的映射文件）-->\n    <mappers>\n        <mapper resource=\"com/loonycoder/dao/IUserMapper.xml\" />\n        <mapper resource=\"com/loonycoder/dao/IAccountMapper.xml\" />\n        <mapper resource=\"com/loonycoder/dao/IRoleMapper.xml\" />\n        <!--<mapper class=\"com.loonycoder.dao.IUserMapper\" />-->\n    </mappers>\n```\n\n##### 新建测试类执行\n\n```bash\n    @Test\n    public void selectRoleAll(){\n        List<Role> roles = roleMapper.selectAll();\n        for (Role role:roles) {\n            System.out.println(\"每个角色的用户信息：\");\n            System.out.println(role);\n            System.out.println(role.getUsers());\n        }\n    }\n```\n\n##### 执行结果\n![result](/images/mybatis3.png)\n\n---\n\n##### 根据用户查询角色\n\n同理，我们修改用户实体类，添加多对多的关系映射：一个用户具备多个角色\n```bash\npackage com.loonycoder.domain;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.List;\n\npublic class User implements Serializable {\n    private Integer id;\n    private String userName;\n    private Date birthday;\n    private String sex;\n    private String address;\n\n\n//    多对多关系映射：一个用户具备多个角色\n    private List<Role> roles;\n\n    public List<Role> getRoles() {\n        return roles;\n    }\n\n    public void setRoles(List<Role> roles) {\n        this.roles = roles;\n    }\n\n    private List<Account> accounts;\n\n    public List<Account> getAccounts() {\n        return accounts;\n    }\n\n    public void setAccounts(List<Account> accounts) {\n        this.accounts = accounts;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", userName='\" + userName + '\\'' +\n                \", birthday=\" + birthday +\n                \", sex='\" + sex + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n\n```\n\n其次，修改用户实体映射配置文件。\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace里面要配置mapper接口的全限定类名-->\n<mapper namespace=\"com.loonycoder.dao.IUserMapper\">\n    <!--配置列名和实体类属性对应关系 type属性不区分大小写-->\n    <resultMap id=\"userMap\" type=\"com.loonycoder.domain.User\">\n        <!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名-->\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"username\"></result>\n        <result property=\"birthday\" column=\"birthday\"></result>\n        <result property=\"address\" column=\"address\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n    </resultMap>\n    <!--定义User的resultMap-->\n    <resultMap id=\"userAccountMap\" type=\"user\">\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"username\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n        <result property=\"address\" column=\"address\"></result>\n        <result property=\"birthday\" column=\"birthday\"></result>\n        <!--配置user对象中accounts集合的映射-->\n        <!--ofType指的是集合的泛型-->\n        <collection property=\"accounts\" ofType=\"account\">\n            <id property=\"id\" column=\"aid\"></id>\n            <result property=\"uid\" column=\"uid\"></result>\n            <result property=\"money\" column=\"money\"></result>\n        </collection>\n    </resultMap>\n    \n    <!--配置user的userRoleMap-->\n    <resultMap id=\"userRoleMap\" type=\"user\">\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"username\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n        <result property=\"address\" column=\"address\"></result>\n        <result property=\"birthday\" column=\"birthday\"></result>\n        <collection property=\"roles\" ofType=\"role\">\n            <id property=\"roleId\" column=\"rid\"></id>\n            <result property=\"roleName\" column=\"role_name\"></result>\n            <result property=\"roleDesc\" column=\"role_desc\"></result>\n        </collection>\n    </resultMap>\n    <!--id要保持和方法名一致-->\n    <!--resultType指定返回值类型，如果是List类型 配置List的泛型即可-->\n    <!--此处使用左外连接查询-->\n    <select id=\"selectAll\" resultMap=\"userAccountMap\">\n        select * from user u left outer join account a on u.id = a.uid;\n    </select>\n\n    <select id=\"selectUserRoleAll\" resultMap=\"userRoleMap\">\n        select u.*,r.id as rid,r.role_name,r.role_desc from user u\n        left outer join user_role ur on u.id = ur.uid\n        left outer join role r on r.id = ur.rid\n    </select>\n\n    <insert id=\"saveUser\" parameterType=\"com.loonycoder.domain.User\">\n        insert into user (username,sex,birthday,address) values (#{userName},#{sex},#{birthday},#{address});\n    </insert>\n\n    <delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id = #{uid};\n    </delete>\n\n    <update id=\"updateUser\" parameterType=\"com.loonycoder.domain.User\">\n        update user set username = #{userName},sex = #{sex},birthday = #{birthday},address = #{address} where id = #{id};\n    </update>\n    \n    <select id=\"selectUserByCondition\" resultMap=\"userMap\" parameterType=\"user\">\n          select * from user\n          <where>\n            <if test=\"sex != null and sex != '' \">\n                and sex = #{sex}\n            </if>\n          </where>\n\n    </select>\n</mapper>\n```\n\n在UserMapper接口中添加查询方法：\n```bash\n/**\n     * 查询用户及用户下所有的角色信息\n     * @return\n     */\n    public List<User> selectUserRoleAll();\n```\n\n新建测试方法：\n```bash\n    @Test\n    public void selectUserRoleAll(){\n        List<User> users = userDao.selectUserRoleAll();\n        for (User user:users) {\n            System.out.println(\"每个用户的角色信息：\");\n            System.out.println(user);\n            System.out.println(user.getRoles());\n        }\n    }\n```\n\n执行结果：\n![result](/images/mybatis4.png)\n","slug":"Mybatis-3","published":1,"updated":"2020-02-21T15:31:14.115Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyr000ev9s6ezn75w6f","content":"<h3 id=\"场景-一对多\"><a href=\"#场景-一对多\" class=\"headerlink\" title=\"场景(一对多)\"></a>场景(一对多)</h3><p>用户和账户<br>一个用户可以有多个账户<br>一个账户只能属于一个用户（多个账户也可以属于同一个用户）</p>\n<p>需要实现：<br>查询账户时，可以查询到归属的用户信息。</p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><h5 id=\"建表\"><a href=\"#建表\" class=\"headerlink\" title=\"建表\"></a>建表</h5><p>建立用户表和账户表：让用户表和账户表之间具备一对多的关系（需要在账户表中添加外键）<br>建表语句</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP TABLE IF EXISTS `user`;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `user` (</span><br><span class=\"line\">  `id` int(11) NOT NULL auto_increment,</span><br><span class=\"line\">  `username` varchar(32) NOT NULL COMMENT <span class=\"string\">'用户名称'</span>,</span><br><span class=\"line\">  `birthday` datetime default NULL COMMENT <span class=\"string\">'生日'</span>,</span><br><span class=\"line\">  `sex` char(1) default NULL COMMENT <span class=\"string\">'性别'</span>,</span><br><span class=\"line\">  `address` varchar(256) default NULL COMMENT <span class=\"string\">'地址'</span>,</span><br><span class=\"line\">  PRIMARY KEY  (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,<span class=\"string\">'张三'</span>,<span class=\"string\">'2018-02-27 17:47:08'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'北京'</span>),(2,<span class=\"string\">'李四'</span>,<span class=\"string\">'2018-03-02 15:09:37'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'深圳'</span>),(3,<span class=\"string\">'王五'</span>,<span class=\"string\">'2018-03-04 11:34:34'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'上海'</span>),(4,<span class=\"string\">'赵六'</span>,<span class=\"string\">'2018-03-04 12:04:06'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'成都'</span>),(4,<span class=\"string\">'刘七'</span>,<span class=\"string\">'2018-03-07 17:37:26'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'西安'</span>),(48,<span class=\"string\">'孙八'</span>,<span class=\"string\">'2018-03-08 11:44:00'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'杭州'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">DROP TABLE IF EXISTS `account`;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `account` (</span><br><span class=\"line\">  `ID` int(11) NOT NULL COMMENT <span class=\"string\">'编号'</span>,</span><br><span class=\"line\">  `UID` int(11) default NULL COMMENT <span class=\"string\">'用户编号'</span>,</span><br><span class=\"line\">  `MONEY` double default NULL COMMENT <span class=\"string\">'金额'</span>,</span><br><span class=\"line\">  PRIMARY KEY  (`ID`),</span><br><span class=\"line\">  KEY `FK_Reference_8` (`UID`),</span><br><span class=\"line\">  CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `account`(`ID`,`UID`,`MONEY`) values (1,1,1000),(2,3,1000),(3,5,2000);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"建实体类\"><a href=\"#建实体类\" class=\"headerlink\" title=\"建实体类\"></a>建实体类</h5><p>用户实体类和账户实体类：让用户和账户的实体类能体现出一对多的关系<br>由于我们之前新建过用户的实体类，所以我们在这里只新建一个账户实体类即可，和用户实体类一样放在com.loonycoder.domain包下<br>此处在从表实体类中引用主表的对象。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Account implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private Integer uid;</span><br><span class=\"line\">    private Double money;</span><br><span class=\"line\"></span><br><span class=\"line\">    //从表实体应该包含一个主表实体的对象引用</span><br><span class=\"line\">    private User user;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User <span class=\"function\"><span class=\"title\">getUser</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUser(User user) &#123;</span><br><span class=\"line\">        this.user = user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(Integer id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getUid</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> uid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUid(Integer uid) &#123;</span><br><span class=\"line\">        this.uid = uid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Double <span class=\"function\"><span class=\"title\">getMoney</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setMoney(Double money) &#123;</span><br><span class=\"line\">        this.money = money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"Account&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"id=\"</span> + id +</span><br><span class=\"line\">                <span class=\"string\">\", uid=\"</span> + uid +</span><br><span class=\"line\">                <span class=\"string\">\", money=\"</span> + money +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来我们新建一个Account的Mapper接口类，并提供查询所有账户的方法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.Account;</span><br><span class=\"line\">import com.loonycoder.domain.AccountUser;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IAccountMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 查询所有账户</span><br><span class=\"line\">     * @<span class=\"built_in\">return</span></span><br><span class=\"line\">     */</span><br><span class=\"line\">    List&lt;Account&gt; selectAll();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 查询所有账户，并且包含账户对应的用户下的姓名和地址信息</span><br><span class=\"line\">     * @<span class=\"built_in\">return</span></span><br><span class=\"line\">     */</span><br><span class=\"line\">    List&lt;AccountUser&gt; selectAccountUser();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h5><p>用户的配置文件和账户的配置文件<br>用户的配置文件用之前的就可以了，我们在此只新建账户的配置文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IAccountMapper\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--定义封装account和user的resultMap--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"accountUserMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"account\"</span>&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"aid\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"uid\"</span> column=<span class=\"string\">\"uid\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"money\"</span> column=<span class=\"string\">\"money\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;!--一对一的关系映射，配置封装user的内容--&gt;</span><br><span class=\"line\">        &lt;association property=<span class=\"string\">\"user\"</span> column=<span class=\"string\">\"uid\"</span> javaType=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">            &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;/association&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectAll\"</span> resultMap=<span class=\"string\">\"accountUserMap\"</span>&gt;</span><br><span class=\"line\">        select u.*,a.id as aid,a.uid,a.money from account a,user u <span class=\"built_in\">where</span> u.id = a.uid;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当然我们还需要修改一下SqlMapConfig.xml中的别名和mapper映射配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Config 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--mybatis的主配置文件--&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;!--引用外部配置文件配置数据源信息，下面的取值部分需要用<span class=\"variable\">$&#123;&#125;</span>方式取值--&gt;</span><br><span class=\"line\">    &lt;properties resource=<span class=\"string\">\"jdbcConfig.properties\"</span>&gt;</span><br><span class=\"line\">    &lt;/properties&gt;</span><br><span class=\"line\">    &lt;!--配置别名 <span class=\"built_in\">type</span>属性指定实体类，<span class=\"built_in\">alias</span>指定别名--&gt;</span><br><span class=\"line\">    &lt;typeAliases &gt;</span><br><span class=\"line\">        &lt;!--package标签可以指定具体到某个包下所有类都使用别名，默认别名是类的名字，不区分大小写--&gt;</span><br><span class=\"line\">        &lt;package name=<span class=\"string\">\"com.loonycoder.domain\"</span>&gt;&lt;/package&gt;</span><br><span class=\"line\">        &lt;!--&lt;typeAlias <span class=\"built_in\">type</span>=<span class=\"string\">\"com.loonycoder.domain.User\"</span> <span class=\"built_in\">alias</span>=<span class=\"string\">\"user\"</span>&gt;&lt;/typeAlias&gt;--&gt;</span><br><span class=\"line\">    &lt;/typeAliases&gt;</span><br><span class=\"line\">    &lt;!--配置环境--&gt;</span><br><span class=\"line\">    &lt;environments default=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">        &lt;environment id=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">            &lt;!--配置事务--&gt;</span><br><span class=\"line\">            &lt;transactionManager <span class=\"built_in\">type</span>=<span class=\"string\">\"JDBC\"</span>&gt;&lt;/transactionManager&gt;</span><br><span class=\"line\">            &lt;!--配置数据源（连接池）--&gt;</span><br><span class=\"line\">            &lt;dataSource <span class=\"built_in\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"driver\"</span> value=<span class=\"string\">\"<span class=\"variable\">$&#123;jdbc.driver&#125;</span>\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"url\"</span> value=<span class=\"string\">\"<span class=\"variable\">$&#123;jdbc.url&#125;</span>\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"username\"</span> value=<span class=\"string\">\"<span class=\"variable\">$&#123;jdbc.username&#125;</span>\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"password\"</span> value=<span class=\"string\">\"<span class=\"variable\">$&#123;jdbc.password&#125;</span>\"</span> /&gt;</span><br><span class=\"line\">            &lt;/dataSource&gt;</span><br><span class=\"line\">        &lt;/environment&gt;</span><br><span class=\"line\">    &lt;/environments&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IUserMapper.xml\"</span> /&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IAccountMapper.xml\"</span> /&gt;</span><br><span class=\"line\">        &lt;!--&lt;mapper class=<span class=\"string\">\"com.loonycoder.dao.IUserMapper\"</span> /&gt;--&gt;</span><br><span class=\"line\">    &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建测试类执行\"><a href=\"#新建测试类执行\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">selectAllAccount</span></span>()&#123;</span><br><span class=\"line\">    List&lt;Account&gt; accts = accountMapper.selectAll();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Account acct : accts) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"每个账户下的用户信息\"</span>);</span><br><span class=\"line\">        System.out.println(acct);</span><br><span class=\"line\">        System.out.println(acct.getUser());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h5><p><img src=\"/images/mybatis1.png\" alt=\"result\"></p>\n<hr>\n<h3 id=\"场景-多对一\"><a href=\"#场景-多对一\" class=\"headerlink\" title=\"场景(多对一)\"></a>场景(多对一)</h3><p>需要实现：</p>\n<ul>\n<li>查询用户时，可以同时查询出用户下的所有账户信息</li>\n</ul>\n<h5 id=\"修改实体类\"><a href=\"#修改实体类\" class=\"headerlink\" title=\"修改实体类\"></a>修改实体类</h5><p>我们修改User实体类，让主表包含从表的集合引用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class User implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private String userName;</span><br><span class=\"line\">    private Date birthday;</span><br><span class=\"line\">    private String sex;</span><br><span class=\"line\">    private String address;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;Account&gt; accounts;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Account&gt; <span class=\"function\"><span class=\"title\">getAccounts</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> accounts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class=\"line\">        this.accounts = accounts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(Integer id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getUserName</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUserName(String userName) &#123;</span><br><span class=\"line\">        this.userName = userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date <span class=\"function\"><span class=\"title\">getBirthday</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setBirthday(Date birthday) &#123;</span><br><span class=\"line\">        this.birthday = birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getSex</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setSex(String sex) &#123;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getAddress</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddress(String address) &#123;</span><br><span class=\"line\">        this.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"id=\"</span> + id +</span><br><span class=\"line\">                <span class=\"string\">\", userName='\"</span> + userName + <span class=\"string\">'\\'</span><span class=\"string\">' +</span></span><br><span class=\"line\"><span class=\"string\">                \", birthday=\" + birthday +</span></span><br><span class=\"line\"><span class=\"string\">                \", sex='</span><span class=\"string\">\" + sex + '\\'' +</span></span><br><span class=\"line\"><span class=\"string\">                \"</span>, address=<span class=\"string\">'\" + address + '</span>\\<span class=\"string\">''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h5><p>User接口类我们不做修改，直接用原来的查询所有用户的方法即可，我们只需要改动映射配置文件。<br>修改IUserMapper.xml内容如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IUserMapper\"</span>&gt;</span><br><span class=\"line\">    &lt;!--配置列名和实体类属性对应关系 <span class=\"built_in\">type</span>属性不区分大小写--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"userMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        &lt;!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名--&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\">    &lt;!--定义User的resultMap--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"userAccountMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;!--配置user对象中accounts集合的映射--&gt;</span><br><span class=\"line\">        &lt;!--ofType指的是集合的泛型--&gt;</span><br><span class=\"line\">        &lt;collection property=<span class=\"string\">\"accounts\"</span> ofType=<span class=\"string\">\"account\"</span>&gt;</span><br><span class=\"line\">            &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"aid\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"uid\"</span> column=<span class=\"string\">\"uid\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"money\"</span> column=<span class=\"string\">\"money\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;/collection&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class=\"line\">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class=\"line\">    &lt;!--此处使用左外连接查询--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectAll\"</span> resultMap=<span class=\"string\">\"userAccountMap\"</span>&gt;</span><br><span class=\"line\">        select * from user u left outer join account a on u.id = a.uid;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;insert id=<span class=\"string\">\"saveUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        insert into user (username,sex,birthday,address) values (<span class=\"comment\">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class=\"line\">    &lt;/insert&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;delete id=<span class=\"string\">\"deleteUser\"</span> parameterType=<span class=\"string\">\"java.lang.Integer\"</span>&gt;</span><br><span class=\"line\">        delete from user <span class=\"built_in\">where</span> id = <span class=\"comment\">#&#123;uid&#125;;</span></span><br><span class=\"line\">    &lt;/delete&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;update id=<span class=\"string\">\"updateUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        update user <span class=\"built_in\">set</span> username = <span class=\"comment\">#&#123;userName&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class=\"line\">    &lt;/update&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectUserByCondition\"</span> resultMap=<span class=\"string\">\"userMap\"</span> parameterType=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">          select * from user</span><br><span class=\"line\">          &lt;<span class=\"built_in\">where</span>&gt;</span><br><span class=\"line\">            &lt;<span class=\"keyword\">if</span> <span class=\"built_in\">test</span>=<span class=\"string\">\"sex != null and sex != '' \"</span>&gt;</span><br><span class=\"line\">                and sex = <span class=\"comment\">#&#123;sex&#125;</span></span><br><span class=\"line\">            &lt;/<span class=\"keyword\">if</span>&gt;</span><br><span class=\"line\">          &lt;/<span class=\"built_in\">where</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建测试类执行-1\"><a href=\"#新建测试类执行-1\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void selectTest() throws Exception&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //5.使用代理对象执行方法</span><br><span class=\"line\">    List&lt;User&gt; users= userDao.selectAll();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (User user: users) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"每个用户下账户的信息：\"</span>);</span><br><span class=\"line\">        System.out.println(user);</span><br><span class=\"line\">        System.out.println(user.getAccounts());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"执行结果-1\"><a href=\"#执行结果-1\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h5><p><img src=\"/images/mybatis2.png\" alt=\"result\"></p>\n<hr>\n<h3 id=\"场景-多对多\"><a href=\"#场景-多对多\" class=\"headerlink\" title=\"场景(多对多)\"></a>场景(多对多)</h3><p>用户和角色<br>一个用户有多个角色<br>一个角色有多个用户<br>需要实现：</p>\n<ul>\n<li>当我们查询用户时，可以同时得到用户的角色信息</li>\n<li>当我们查询角色时，可以同时得到角色所属的用户信息</li>\n</ul>\n<h5 id=\"新建角色表和中间表\"><a href=\"#新建角色表和中间表\" class=\"headerlink\" title=\"新建角色表和中间表\"></a>新建角色表和中间表</h5><p>建表语句：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP TABLE IF EXISTS `role`;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `role` (</span><br><span class=\"line\">  `ID` int(11) NOT NULL COMMENT <span class=\"string\">'编号'</span>,</span><br><span class=\"line\">  `ROLE_NAME` varchar(30) default NULL COMMENT <span class=\"string\">'角色名称'</span>,</span><br><span class=\"line\">  `ROLE_DESC` varchar(60) default NULL COMMENT <span class=\"string\">'角色描述'</span>,</span><br><span class=\"line\">  PRIMARY KEY  (`ID`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,<span class=\"string\">'董事长'</span>,<span class=\"string\">'管理整个公司'</span>),(2,<span class=\"string\">'总裁'</span>,<span class=\"string\">'管理整个公司'</span>),(3,<span class=\"string\">'部门经理'</span>,<span class=\"string\">'管理某个部门'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">DROP TABLE IF EXISTS `user_role`;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `user_role` (</span><br><span class=\"line\">  `UID` int(11) NOT NULL COMMENT <span class=\"string\">'用户编号'</span>,</span><br><span class=\"line\">  `RID` int(11) NOT NULL COMMENT <span class=\"string\">'角色编号'</span>,</span><br><span class=\"line\">  PRIMARY KEY  (`UID`,`RID`),</span><br><span class=\"line\">  KEY `FK_Reference_10` (`RID`),</span><br><span class=\"line\">  CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`),</span><br><span class=\"line\">  CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `user_role`(`UID`,`RID`) values (1,1),(3,1),(3,2);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建角色实体类\"><a href=\"#新建角色实体类\" class=\"headerlink\" title=\"新建角色实体类\"></a>新建角色实体类</h5><p>此处注意也要让用户和角色体现出多对多关系：需要各自包含对方的一个集合引用。</p>\n<p>新建角色实体类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Role implements Serializable &#123;</span><br><span class=\"line\">    private Integer roleId;</span><br><span class=\"line\">    private String roleName;</span><br><span class=\"line\">    private String roleDesc;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getRoleId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> roleId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setRoleId(Integer roleId) &#123;</span><br><span class=\"line\">        this.roleId = roleId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getRoleName</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> roleName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setRoleName(String roleName) &#123;</span><br><span class=\"line\">        this.roleName = roleName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getRoleDesc</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> roleDesc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setRoleDesc(String roleDesc) &#123;</span><br><span class=\"line\">        this.roleDesc = roleDesc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"Role&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"roleId=\"</span> + roleId +</span><br><span class=\"line\">                <span class=\"string\">\", roleName='\"</span> + roleName + <span class=\"string\">'\\'</span><span class=\"string\">' +</span></span><br><span class=\"line\"><span class=\"string\">                \", roleDesc='</span><span class=\"string\">\" + roleDesc + '\\'' +</span></span><br><span class=\"line\"><span class=\"string\">                '&#125;';</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建实体类接口\"><a href=\"#新建实体类接口\" class=\"headerlink\" title=\"新建实体类接口\"></a>新建实体类接口</h5><p>新建RoleMapper接口类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.Role;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IRoleMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 查询所有角色信息</span><br><span class=\"line\">     * @<span class=\"built_in\">return</span></span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;Role&gt; selectAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建角色实体配置文件\"><a href=\"#新建角色实体配置文件\" class=\"headerlink\" title=\"新建角色实体配置文件\"></a>新建角色实体配置文件</h5><p>一、新建IRoleMapper.xml</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IRoleMapper\"</span>&gt;</span><br><span class=\"line\">    &lt;!--定义role表的resultMap--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"roleMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"role\"</span>&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"roleId\"</span> column=<span class=\"string\">\"rid\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"roleName\"</span> column=<span class=\"string\">\"role_name\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"roleDesc\"</span> column=<span class=\"string\">\"role_desc\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;collection property=<span class=\"string\">\"users\"</span> ofType=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">            &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;/collection&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--查询所有角色信息--&gt;</span><br><span class=\"line\">    &lt;!--使用两次左外连接查询--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectAll\"</span> resultMap=<span class=\"string\">\"roleMap\"</span>&gt;</span><br><span class=\"line\">        select u.*,r.id as rid,r.role_name,r.role_desc from role r</span><br><span class=\"line\">        left outer join user_role ur on r.id = ur.rid</span><br><span class=\"line\">        left outer join user u on u.id = ur.uid</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<p>二、在SqlMapConfig.xml中添加映射配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IUserMapper.xml\"</span> /&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IAccountMapper.xml\"</span> /&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IRoleMapper.xml\"</span> /&gt;</span><br><span class=\"line\">        &lt;!--&lt;mapper class=<span class=\"string\">\"com.loonycoder.dao.IUserMapper\"</span> /&gt;--&gt;</span><br><span class=\"line\">    &lt;/mappers&gt;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建测试类执行-2\"><a href=\"#新建测试类执行-2\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">selectRoleAll</span></span>()&#123;</span><br><span class=\"line\">    List&lt;Role&gt; roles = roleMapper.selectAll();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Role role:roles) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"每个角色的用户信息：\"</span>);</span><br><span class=\"line\">        System.out.println(role);</span><br><span class=\"line\">        System.out.println(role.getUsers());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"执行结果-2\"><a href=\"#执行结果-2\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h5><p><img src=\"/images/mybatis3.png\" alt=\"result\"></p>\n<hr>\n<h5 id=\"根据用户查询角色\"><a href=\"#根据用户查询角色\" class=\"headerlink\" title=\"根据用户查询角色\"></a>根据用户查询角色</h5><p>同理，我们修改用户实体类，添加多对多的关系映射：一个用户具备多个角色</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class User implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private String userName;</span><br><span class=\"line\">    private Date birthday;</span><br><span class=\"line\">    private String sex;</span><br><span class=\"line\">    private String address;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//    多对多关系映射：一个用户具备多个角色</span><br><span class=\"line\">    private List&lt;Role&gt; roles;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Role&gt; <span class=\"function\"><span class=\"title\">getRoles</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setRoles(List&lt;Role&gt; roles) &#123;</span><br><span class=\"line\">        this.roles = roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;Account&gt; accounts;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Account&gt; <span class=\"function\"><span class=\"title\">getAccounts</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> accounts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class=\"line\">        this.accounts = accounts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(Integer id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getUserName</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUserName(String userName) &#123;</span><br><span class=\"line\">        this.userName = userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date <span class=\"function\"><span class=\"title\">getBirthday</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setBirthday(Date birthday) &#123;</span><br><span class=\"line\">        this.birthday = birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getSex</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setSex(String sex) &#123;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getAddress</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddress(String address) &#123;</span><br><span class=\"line\">        this.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"id=\"</span> + id +</span><br><span class=\"line\">                <span class=\"string\">\", userName='\"</span> + userName + <span class=\"string\">'\\'</span><span class=\"string\">' +</span></span><br><span class=\"line\"><span class=\"string\">                \", birthday=\" + birthday +</span></span><br><span class=\"line\"><span class=\"string\">                \", sex='</span><span class=\"string\">\" + sex + '\\'' +</span></span><br><span class=\"line\"><span class=\"string\">                \"</span>, address=<span class=\"string\">'\" + address + '</span>\\<span class=\"string\">''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次，修改用户实体映射配置文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IUserMapper\"</span>&gt;</span><br><span class=\"line\">    &lt;!--配置列名和实体类属性对应关系 <span class=\"built_in\">type</span>属性不区分大小写--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"userMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        &lt;!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名--&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\">    &lt;!--定义User的resultMap--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"userAccountMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;!--配置user对象中accounts集合的映射--&gt;</span><br><span class=\"line\">        &lt;!--ofType指的是集合的泛型--&gt;</span><br><span class=\"line\">        &lt;collection property=<span class=\"string\">\"accounts\"</span> ofType=<span class=\"string\">\"account\"</span>&gt;</span><br><span class=\"line\">            &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"aid\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"uid\"</span> column=<span class=\"string\">\"uid\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"money\"</span> column=<span class=\"string\">\"money\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;/collection&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;!--配置user的userRoleMap--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"userRoleMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;collection property=<span class=\"string\">\"roles\"</span> ofType=<span class=\"string\">\"role\"</span>&gt;</span><br><span class=\"line\">            &lt;id property=<span class=\"string\">\"roleId\"</span> column=<span class=\"string\">\"rid\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"roleName\"</span> column=<span class=\"string\">\"role_name\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"roleDesc\"</span> column=<span class=\"string\">\"role_desc\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;/collection&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class=\"line\">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class=\"line\">    &lt;!--此处使用左外连接查询--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectAll\"</span> resultMap=<span class=\"string\">\"userAccountMap\"</span>&gt;</span><br><span class=\"line\">        select * from user u left outer join account a on u.id = a.uid;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectUserRoleAll\"</span> resultMap=<span class=\"string\">\"userRoleMap\"</span>&gt;</span><br><span class=\"line\">        select u.*,r.id as rid,r.role_name,r.role_desc from user u</span><br><span class=\"line\">        left outer join user_role ur on u.id = ur.uid</span><br><span class=\"line\">        left outer join role r on r.id = ur.rid</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;insert id=<span class=\"string\">\"saveUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        insert into user (username,sex,birthday,address) values (<span class=\"comment\">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class=\"line\">    &lt;/insert&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;delete id=<span class=\"string\">\"deleteUser\"</span> parameterType=<span class=\"string\">\"java.lang.Integer\"</span>&gt;</span><br><span class=\"line\">        delete from user <span class=\"built_in\">where</span> id = <span class=\"comment\">#&#123;uid&#125;;</span></span><br><span class=\"line\">    &lt;/delete&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;update id=<span class=\"string\">\"updateUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        update user <span class=\"built_in\">set</span> username = <span class=\"comment\">#&#123;userName&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class=\"line\">    &lt;/update&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectUserByCondition\"</span> resultMap=<span class=\"string\">\"userMap\"</span> parameterType=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">          select * from user</span><br><span class=\"line\">          &lt;<span class=\"built_in\">where</span>&gt;</span><br><span class=\"line\">            &lt;<span class=\"keyword\">if</span> <span class=\"built_in\">test</span>=<span class=\"string\">\"sex != null and sex != '' \"</span>&gt;</span><br><span class=\"line\">                and sex = <span class=\"comment\">#&#123;sex&#125;</span></span><br><span class=\"line\">            &lt;/<span class=\"keyword\">if</span>&gt;</span><br><span class=\"line\">          &lt;/<span class=\"built_in\">where</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在UserMapper接口中添加查询方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 查询用户及用户下所有的角色信息</span><br><span class=\"line\">     * @<span class=\"built_in\">return</span></span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;User&gt; selectUserRoleAll();</span><br></pre></td></tr></table></figure>\n\n<p>新建测试方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">selectUserRoleAll</span></span>()&#123;</span><br><span class=\"line\">    List&lt;User&gt; users = userDao.selectUserRoleAll();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (User user:users) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"每个用户的角色信息：\"</span>);</span><br><span class=\"line\">        System.out.println(user);</span><br><span class=\"line\">        System.out.println(user.getRoles());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：<br><img src=\"/images/mybatis4.png\" alt=\"result\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"场景-一对多\"><a href=\"#场景-一对多\" class=\"headerlink\" title=\"场景(一对多)\"></a>场景(一对多)</h3><p>用户和账户<br>一个用户可以有多个账户<br>一个账户只能属于一个用户（多个账户也可以属于同一个用户）</p>\n<p>需要实现：<br>查询账户时，可以查询到归属的用户信息。</p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><h5 id=\"建表\"><a href=\"#建表\" class=\"headerlink\" title=\"建表\"></a>建表</h5><p>建立用户表和账户表：让用户表和账户表之间具备一对多的关系（需要在账户表中添加外键）<br>建表语句</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP TABLE IF EXISTS `user`;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `user` (</span><br><span class=\"line\">  `id` int(11) NOT NULL auto_increment,</span><br><span class=\"line\">  `username` varchar(32) NOT NULL COMMENT <span class=\"string\">'用户名称'</span>,</span><br><span class=\"line\">  `birthday` datetime default NULL COMMENT <span class=\"string\">'生日'</span>,</span><br><span class=\"line\">  `sex` char(1) default NULL COMMENT <span class=\"string\">'性别'</span>,</span><br><span class=\"line\">  `address` varchar(256) default NULL COMMENT <span class=\"string\">'地址'</span>,</span><br><span class=\"line\">  PRIMARY KEY  (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,<span class=\"string\">'张三'</span>,<span class=\"string\">'2018-02-27 17:47:08'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'北京'</span>),(2,<span class=\"string\">'李四'</span>,<span class=\"string\">'2018-03-02 15:09:37'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'深圳'</span>),(3,<span class=\"string\">'王五'</span>,<span class=\"string\">'2018-03-04 11:34:34'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'上海'</span>),(4,<span class=\"string\">'赵六'</span>,<span class=\"string\">'2018-03-04 12:04:06'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'成都'</span>),(4,<span class=\"string\">'刘七'</span>,<span class=\"string\">'2018-03-07 17:37:26'</span>,<span class=\"string\">'男'</span>,<span class=\"string\">'西安'</span>),(48,<span class=\"string\">'孙八'</span>,<span class=\"string\">'2018-03-08 11:44:00'</span>,<span class=\"string\">'女'</span>,<span class=\"string\">'杭州'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">DROP TABLE IF EXISTS `account`;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `account` (</span><br><span class=\"line\">  `ID` int(11) NOT NULL COMMENT <span class=\"string\">'编号'</span>,</span><br><span class=\"line\">  `UID` int(11) default NULL COMMENT <span class=\"string\">'用户编号'</span>,</span><br><span class=\"line\">  `MONEY` double default NULL COMMENT <span class=\"string\">'金额'</span>,</span><br><span class=\"line\">  PRIMARY KEY  (`ID`),</span><br><span class=\"line\">  KEY `FK_Reference_8` (`UID`),</span><br><span class=\"line\">  CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `account`(`ID`,`UID`,`MONEY`) values (1,1,1000),(2,3,1000),(3,5,2000);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"建实体类\"><a href=\"#建实体类\" class=\"headerlink\" title=\"建实体类\"></a>建实体类</h5><p>用户实体类和账户实体类：让用户和账户的实体类能体现出一对多的关系<br>由于我们之前新建过用户的实体类，所以我们在这里只新建一个账户实体类即可，和用户实体类一样放在com.loonycoder.domain包下<br>此处在从表实体类中引用主表的对象。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Account implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private Integer uid;</span><br><span class=\"line\">    private Double money;</span><br><span class=\"line\"></span><br><span class=\"line\">    //从表实体应该包含一个主表实体的对象引用</span><br><span class=\"line\">    private User user;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User <span class=\"function\"><span class=\"title\">getUser</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUser(User user) &#123;</span><br><span class=\"line\">        this.user = user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(Integer id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getUid</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> uid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUid(Integer uid) &#123;</span><br><span class=\"line\">        this.uid = uid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Double <span class=\"function\"><span class=\"title\">getMoney</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setMoney(Double money) &#123;</span><br><span class=\"line\">        this.money = money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"Account&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"id=\"</span> + id +</span><br><span class=\"line\">                <span class=\"string\">\", uid=\"</span> + uid +</span><br><span class=\"line\">                <span class=\"string\">\", money=\"</span> + money +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来我们新建一个Account的Mapper接口类，并提供查询所有账户的方法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.Account;</span><br><span class=\"line\">import com.loonycoder.domain.AccountUser;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IAccountMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 查询所有账户</span><br><span class=\"line\">     * @<span class=\"built_in\">return</span></span><br><span class=\"line\">     */</span><br><span class=\"line\">    List&lt;Account&gt; selectAll();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 查询所有账户，并且包含账户对应的用户下的姓名和地址信息</span><br><span class=\"line\">     * @<span class=\"built_in\">return</span></span><br><span class=\"line\">     */</span><br><span class=\"line\">    List&lt;AccountUser&gt; selectAccountUser();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h5><p>用户的配置文件和账户的配置文件<br>用户的配置文件用之前的就可以了，我们在此只新建账户的配置文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IAccountMapper\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--定义封装account和user的resultMap--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"accountUserMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"account\"</span>&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"aid\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"uid\"</span> column=<span class=\"string\">\"uid\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"money\"</span> column=<span class=\"string\">\"money\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;!--一对一的关系映射，配置封装user的内容--&gt;</span><br><span class=\"line\">        &lt;association property=<span class=\"string\">\"user\"</span> column=<span class=\"string\">\"uid\"</span> javaType=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">            &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;/association&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectAll\"</span> resultMap=<span class=\"string\">\"accountUserMap\"</span>&gt;</span><br><span class=\"line\">        select u.*,a.id as aid,a.uid,a.money from account a,user u <span class=\"built_in\">where</span> u.id = a.uid;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<p>当然我们还需要修改一下SqlMapConfig.xml中的别名和mapper映射配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Config 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--mybatis的主配置文件--&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">    &lt;!--引用外部配置文件配置数据源信息，下面的取值部分需要用<span class=\"variable\">$&#123;&#125;</span>方式取值--&gt;</span><br><span class=\"line\">    &lt;properties resource=<span class=\"string\">\"jdbcConfig.properties\"</span>&gt;</span><br><span class=\"line\">    &lt;/properties&gt;</span><br><span class=\"line\">    &lt;!--配置别名 <span class=\"built_in\">type</span>属性指定实体类，<span class=\"built_in\">alias</span>指定别名--&gt;</span><br><span class=\"line\">    &lt;typeAliases &gt;</span><br><span class=\"line\">        &lt;!--package标签可以指定具体到某个包下所有类都使用别名，默认别名是类的名字，不区分大小写--&gt;</span><br><span class=\"line\">        &lt;package name=<span class=\"string\">\"com.loonycoder.domain\"</span>&gt;&lt;/package&gt;</span><br><span class=\"line\">        &lt;!--&lt;typeAlias <span class=\"built_in\">type</span>=<span class=\"string\">\"com.loonycoder.domain.User\"</span> <span class=\"built_in\">alias</span>=<span class=\"string\">\"user\"</span>&gt;&lt;/typeAlias&gt;--&gt;</span><br><span class=\"line\">    &lt;/typeAliases&gt;</span><br><span class=\"line\">    &lt;!--配置环境--&gt;</span><br><span class=\"line\">    &lt;environments default=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">        &lt;environment id=<span class=\"string\">\"mysql\"</span>&gt;</span><br><span class=\"line\">            &lt;!--配置事务--&gt;</span><br><span class=\"line\">            &lt;transactionManager <span class=\"built_in\">type</span>=<span class=\"string\">\"JDBC\"</span>&gt;&lt;/transactionManager&gt;</span><br><span class=\"line\">            &lt;!--配置数据源（连接池）--&gt;</span><br><span class=\"line\">            &lt;dataSource <span class=\"built_in\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"driver\"</span> value=<span class=\"string\">\"<span class=\"variable\">$&#123;jdbc.driver&#125;</span>\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"url\"</span> value=<span class=\"string\">\"<span class=\"variable\">$&#123;jdbc.url&#125;</span>\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"username\"</span> value=<span class=\"string\">\"<span class=\"variable\">$&#123;jdbc.username&#125;</span>\"</span> /&gt;</span><br><span class=\"line\">                &lt;property name=<span class=\"string\">\"password\"</span> value=<span class=\"string\">\"<span class=\"variable\">$&#123;jdbc.password&#125;</span>\"</span> /&gt;</span><br><span class=\"line\">            &lt;/dataSource&gt;</span><br><span class=\"line\">        &lt;/environment&gt;</span><br><span class=\"line\">    &lt;/environments&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IUserMapper.xml\"</span> /&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IAccountMapper.xml\"</span> /&gt;</span><br><span class=\"line\">        &lt;!--&lt;mapper class=<span class=\"string\">\"com.loonycoder.dao.IUserMapper\"</span> /&gt;--&gt;</span><br><span class=\"line\">    &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建测试类执行\"><a href=\"#新建测试类执行\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">selectAllAccount</span></span>()&#123;</span><br><span class=\"line\">    List&lt;Account&gt; accts = accountMapper.selectAll();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Account acct : accts) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"每个账户下的用户信息\"</span>);</span><br><span class=\"line\">        System.out.println(acct);</span><br><span class=\"line\">        System.out.println(acct.getUser());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h5><p><img src=\"/images/mybatis1.png\" alt=\"result\"></p>\n<hr>\n<h3 id=\"场景-多对一\"><a href=\"#场景-多对一\" class=\"headerlink\" title=\"场景(多对一)\"></a>场景(多对一)</h3><p>需要实现：</p>\n<ul>\n<li>查询用户时，可以同时查询出用户下的所有账户信息</li>\n</ul>\n<h5 id=\"修改实体类\"><a href=\"#修改实体类\" class=\"headerlink\" title=\"修改实体类\"></a>修改实体类</h5><p>我们修改User实体类，让主表包含从表的集合引用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class User implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private String userName;</span><br><span class=\"line\">    private Date birthday;</span><br><span class=\"line\">    private String sex;</span><br><span class=\"line\">    private String address;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;Account&gt; accounts;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Account&gt; <span class=\"function\"><span class=\"title\">getAccounts</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> accounts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class=\"line\">        this.accounts = accounts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(Integer id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getUserName</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUserName(String userName) &#123;</span><br><span class=\"line\">        this.userName = userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date <span class=\"function\"><span class=\"title\">getBirthday</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setBirthday(Date birthday) &#123;</span><br><span class=\"line\">        this.birthday = birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getSex</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setSex(String sex) &#123;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getAddress</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddress(String address) &#123;</span><br><span class=\"line\">        this.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"id=\"</span> + id +</span><br><span class=\"line\">                <span class=\"string\">\", userName='\"</span> + userName + <span class=\"string\">'\\'</span><span class=\"string\">' +</span></span><br><span class=\"line\"><span class=\"string\">                \", birthday=\" + birthday +</span></span><br><span class=\"line\"><span class=\"string\">                \", sex='</span><span class=\"string\">\" + sex + '\\'' +</span></span><br><span class=\"line\"><span class=\"string\">                \"</span>, address=<span class=\"string\">'\" + address + '</span>\\<span class=\"string\">''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h5><p>User接口类我们不做修改，直接用原来的查询所有用户的方法即可，我们只需要改动映射配置文件。<br>修改IUserMapper.xml内容如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IUserMapper\"</span>&gt;</span><br><span class=\"line\">    &lt;!--配置列名和实体类属性对应关系 <span class=\"built_in\">type</span>属性不区分大小写--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"userMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        &lt;!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名--&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\">    &lt;!--定义User的resultMap--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"userAccountMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;!--配置user对象中accounts集合的映射--&gt;</span><br><span class=\"line\">        &lt;!--ofType指的是集合的泛型--&gt;</span><br><span class=\"line\">        &lt;collection property=<span class=\"string\">\"accounts\"</span> ofType=<span class=\"string\">\"account\"</span>&gt;</span><br><span class=\"line\">            &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"aid\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"uid\"</span> column=<span class=\"string\">\"uid\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"money\"</span> column=<span class=\"string\">\"money\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;/collection&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class=\"line\">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class=\"line\">    &lt;!--此处使用左外连接查询--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectAll\"</span> resultMap=<span class=\"string\">\"userAccountMap\"</span>&gt;</span><br><span class=\"line\">        select * from user u left outer join account a on u.id = a.uid;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;insert id=<span class=\"string\">\"saveUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        insert into user (username,sex,birthday,address) values (<span class=\"comment\">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class=\"line\">    &lt;/insert&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;delete id=<span class=\"string\">\"deleteUser\"</span> parameterType=<span class=\"string\">\"java.lang.Integer\"</span>&gt;</span><br><span class=\"line\">        delete from user <span class=\"built_in\">where</span> id = <span class=\"comment\">#&#123;uid&#125;;</span></span><br><span class=\"line\">    &lt;/delete&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;update id=<span class=\"string\">\"updateUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        update user <span class=\"built_in\">set</span> username = <span class=\"comment\">#&#123;userName&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class=\"line\">    &lt;/update&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectUserByCondition\"</span> resultMap=<span class=\"string\">\"userMap\"</span> parameterType=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">          select * from user</span><br><span class=\"line\">          &lt;<span class=\"built_in\">where</span>&gt;</span><br><span class=\"line\">            &lt;<span class=\"keyword\">if</span> <span class=\"built_in\">test</span>=<span class=\"string\">\"sex != null and sex != '' \"</span>&gt;</span><br><span class=\"line\">                and sex = <span class=\"comment\">#&#123;sex&#125;</span></span><br><span class=\"line\">            &lt;/<span class=\"keyword\">if</span>&gt;</span><br><span class=\"line\">          &lt;/<span class=\"built_in\">where</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建测试类执行-1\"><a href=\"#新建测试类执行-1\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void selectTest() throws Exception&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //5.使用代理对象执行方法</span><br><span class=\"line\">    List&lt;User&gt; users= userDao.selectAll();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (User user: users) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"每个用户下账户的信息：\"</span>);</span><br><span class=\"line\">        System.out.println(user);</span><br><span class=\"line\">        System.out.println(user.getAccounts());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"执行结果-1\"><a href=\"#执行结果-1\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h5><p><img src=\"/images/mybatis2.png\" alt=\"result\"></p>\n<hr>\n<h3 id=\"场景-多对多\"><a href=\"#场景-多对多\" class=\"headerlink\" title=\"场景(多对多)\"></a>场景(多对多)</h3><p>用户和角色<br>一个用户有多个角色<br>一个角色有多个用户<br>需要实现：</p>\n<ul>\n<li>当我们查询用户时，可以同时得到用户的角色信息</li>\n<li>当我们查询角色时，可以同时得到角色所属的用户信息</li>\n</ul>\n<h5 id=\"新建角色表和中间表\"><a href=\"#新建角色表和中间表\" class=\"headerlink\" title=\"新建角色表和中间表\"></a>新建角色表和中间表</h5><p>建表语句：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP TABLE IF EXISTS `role`;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `role` (</span><br><span class=\"line\">  `ID` int(11) NOT NULL COMMENT <span class=\"string\">'编号'</span>,</span><br><span class=\"line\">  `ROLE_NAME` varchar(30) default NULL COMMENT <span class=\"string\">'角色名称'</span>,</span><br><span class=\"line\">  `ROLE_DESC` varchar(60) default NULL COMMENT <span class=\"string\">'角色描述'</span>,</span><br><span class=\"line\">  PRIMARY KEY  (`ID`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,<span class=\"string\">'董事长'</span>,<span class=\"string\">'管理整个公司'</span>),(2,<span class=\"string\">'总裁'</span>,<span class=\"string\">'管理整个公司'</span>),(3,<span class=\"string\">'部门经理'</span>,<span class=\"string\">'管理某个部门'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">DROP TABLE IF EXISTS `user_role`;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `user_role` (</span><br><span class=\"line\">  `UID` int(11) NOT NULL COMMENT <span class=\"string\">'用户编号'</span>,</span><br><span class=\"line\">  `RID` int(11) NOT NULL COMMENT <span class=\"string\">'角色编号'</span>,</span><br><span class=\"line\">  PRIMARY KEY  (`UID`,`RID`),</span><br><span class=\"line\">  KEY `FK_Reference_10` (`RID`),</span><br><span class=\"line\">  CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`),</span><br><span class=\"line\">  CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `user_role`(`UID`,`RID`) values (1,1),(3,1),(3,2);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建角色实体类\"><a href=\"#新建角色实体类\" class=\"headerlink\" title=\"新建角色实体类\"></a>新建角色实体类</h5><p>此处注意也要让用户和角色体现出多对多关系：需要各自包含对方的一个集合引用。</p>\n<p>新建角色实体类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Role implements Serializable &#123;</span><br><span class=\"line\">    private Integer roleId;</span><br><span class=\"line\">    private String roleName;</span><br><span class=\"line\">    private String roleDesc;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getRoleId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> roleId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setRoleId(Integer roleId) &#123;</span><br><span class=\"line\">        this.roleId = roleId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getRoleName</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> roleName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setRoleName(String roleName) &#123;</span><br><span class=\"line\">        this.roleName = roleName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getRoleDesc</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> roleDesc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setRoleDesc(String roleDesc) &#123;</span><br><span class=\"line\">        this.roleDesc = roleDesc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"Role&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"roleId=\"</span> + roleId +</span><br><span class=\"line\">                <span class=\"string\">\", roleName='\"</span> + roleName + <span class=\"string\">'\\'</span><span class=\"string\">' +</span></span><br><span class=\"line\"><span class=\"string\">                \", roleDesc='</span><span class=\"string\">\" + roleDesc + '\\'' +</span></span><br><span class=\"line\"><span class=\"string\">                '&#125;';</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建实体类接口\"><a href=\"#新建实体类接口\" class=\"headerlink\" title=\"新建实体类接口\"></a>新建实体类接口</h5><p>新建RoleMapper接口类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.loonycoder.domain.Role;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface IRoleMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 查询所有角色信息</span><br><span class=\"line\">     * @<span class=\"built_in\">return</span></span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;Role&gt; selectAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建角色实体配置文件\"><a href=\"#新建角色实体配置文件\" class=\"headerlink\" title=\"新建角色实体配置文件\"></a>新建角色实体配置文件</h5><p>一、新建IRoleMapper.xml</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IRoleMapper\"</span>&gt;</span><br><span class=\"line\">    &lt;!--定义role表的resultMap--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"roleMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"role\"</span>&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"roleId\"</span> column=<span class=\"string\">\"rid\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"roleName\"</span> column=<span class=\"string\">\"role_name\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"roleDesc\"</span> column=<span class=\"string\">\"role_desc\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;collection property=<span class=\"string\">\"users\"</span> ofType=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">            &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;/collection&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--查询所有角色信息--&gt;</span><br><span class=\"line\">    &lt;!--使用两次左外连接查询--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectAll\"</span> resultMap=<span class=\"string\">\"roleMap\"</span>&gt;</span><br><span class=\"line\">        select u.*,r.id as rid,r.role_name,r.role_desc from role r</span><br><span class=\"line\">        left outer join user_role ur on r.id = ur.rid</span><br><span class=\"line\">        left outer join user u on u.id = ur.uid</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<p>二、在SqlMapConfig.xml中添加映射配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class=\"line\">    &lt;mappers&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IUserMapper.xml\"</span> /&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IAccountMapper.xml\"</span> /&gt;</span><br><span class=\"line\">        &lt;mapper resource=<span class=\"string\">\"com/loonycoder/dao/IRoleMapper.xml\"</span> /&gt;</span><br><span class=\"line\">        &lt;!--&lt;mapper class=<span class=\"string\">\"com.loonycoder.dao.IUserMapper\"</span> /&gt;--&gt;</span><br><span class=\"line\">    &lt;/mappers&gt;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"新建测试类执行-2\"><a href=\"#新建测试类执行-2\" class=\"headerlink\" title=\"新建测试类执行\"></a>新建测试类执行</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">selectRoleAll</span></span>()&#123;</span><br><span class=\"line\">    List&lt;Role&gt; roles = roleMapper.selectAll();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Role role:roles) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"每个角色的用户信息：\"</span>);</span><br><span class=\"line\">        System.out.println(role);</span><br><span class=\"line\">        System.out.println(role.getUsers());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"执行结果-2\"><a href=\"#执行结果-2\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h5><p><img src=\"/images/mybatis3.png\" alt=\"result\"></p>\n<hr>\n<h5 id=\"根据用户查询角色\"><a href=\"#根据用户查询角色\" class=\"headerlink\" title=\"根据用户查询角色\"></a>根据用户查询角色</h5><p>同理，我们修改用户实体类，添加多对多的关系映射：一个用户具备多个角色</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.loonycoder.domain;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class User implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private String userName;</span><br><span class=\"line\">    private Date birthday;</span><br><span class=\"line\">    private String sex;</span><br><span class=\"line\">    private String address;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//    多对多关系映射：一个用户具备多个角色</span><br><span class=\"line\">    private List&lt;Role&gt; roles;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Role&gt; <span class=\"function\"><span class=\"title\">getRoles</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setRoles(List&lt;Role&gt; roles) &#123;</span><br><span class=\"line\">        this.roles = roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;Account&gt; accounts;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Account&gt; <span class=\"function\"><span class=\"title\">getAccounts</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> accounts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class=\"line\">        this.accounts = accounts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer <span class=\"function\"><span class=\"title\">getId</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setId(Integer id) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getUserName</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUserName(String userName) &#123;</span><br><span class=\"line\">        this.userName = userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date <span class=\"function\"><span class=\"title\">getBirthday</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setBirthday(Date birthday) &#123;</span><br><span class=\"line\">        this.birthday = birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getSex</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setSex(String sex) &#123;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getAddress</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddress(String address) &#123;</span><br><span class=\"line\">        this.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">toString</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"id=\"</span> + id +</span><br><span class=\"line\">                <span class=\"string\">\", userName='\"</span> + userName + <span class=\"string\">'\\'</span><span class=\"string\">' +</span></span><br><span class=\"line\"><span class=\"string\">                \", birthday=\" + birthday +</span></span><br><span class=\"line\"><span class=\"string\">                \", sex='</span><span class=\"string\">\" + sex + '\\'' +</span></span><br><span class=\"line\"><span class=\"string\">                \"</span>, address=<span class=\"string\">'\" + address + '</span>\\<span class=\"string\">''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次，修改用户实体映射配置文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">        PUBLIC <span class=\"string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\">        <span class=\"string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class=\"line\">&lt;mapper namespace=<span class=\"string\">\"com.loonycoder.dao.IUserMapper\"</span>&gt;</span><br><span class=\"line\">    &lt;!--配置列名和实体类属性对应关系 <span class=\"built_in\">type</span>属性不区分大小写--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"userMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        &lt;!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名--&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\">    &lt;!--定义User的resultMap--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"userAccountMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;!--配置user对象中accounts集合的映射--&gt;</span><br><span class=\"line\">        &lt;!--ofType指的是集合的泛型--&gt;</span><br><span class=\"line\">        &lt;collection property=<span class=\"string\">\"accounts\"</span> ofType=<span class=\"string\">\"account\"</span>&gt;</span><br><span class=\"line\">            &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"aid\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"uid\"</span> column=<span class=\"string\">\"uid\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"money\"</span> column=<span class=\"string\">\"money\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;/collection&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;!--配置user的userRoleMap--&gt;</span><br><span class=\"line\">    &lt;resultMap id=<span class=\"string\">\"userRoleMap\"</span> <span class=\"built_in\">type</span>=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">        &lt;id property=<span class=\"string\">\"id\"</span> column=<span class=\"string\">\"id\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"userName\"</span> column=<span class=\"string\">\"username\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"sex\"</span> column=<span class=\"string\">\"sex\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"address\"</span> column=<span class=\"string\">\"address\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;result property=<span class=\"string\">\"birthday\"</span> column=<span class=\"string\">\"birthday\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;collection property=<span class=\"string\">\"roles\"</span> ofType=<span class=\"string\">\"role\"</span>&gt;</span><br><span class=\"line\">            &lt;id property=<span class=\"string\">\"roleId\"</span> column=<span class=\"string\">\"rid\"</span>&gt;&lt;/id&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"roleName\"</span> column=<span class=\"string\">\"role_name\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">            &lt;result property=<span class=\"string\">\"roleDesc\"</span> column=<span class=\"string\">\"role_desc\"</span>&gt;&lt;/result&gt;</span><br><span class=\"line\">        &lt;/collection&gt;</span><br><span class=\"line\">    &lt;/resultMap&gt;</span><br><span class=\"line\">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class=\"line\">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class=\"line\">    &lt;!--此处使用左外连接查询--&gt;</span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectAll\"</span> resultMap=<span class=\"string\">\"userAccountMap\"</span>&gt;</span><br><span class=\"line\">        select * from user u left outer join account a on u.id = a.uid;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectUserRoleAll\"</span> resultMap=<span class=\"string\">\"userRoleMap\"</span>&gt;</span><br><span class=\"line\">        select u.*,r.id as rid,r.role_name,r.role_desc from user u</span><br><span class=\"line\">        left outer join user_role ur on u.id = ur.uid</span><br><span class=\"line\">        left outer join role r on r.id = ur.rid</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;insert id=<span class=\"string\">\"saveUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        insert into user (username,sex,birthday,address) values (<span class=\"comment\">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class=\"line\">    &lt;/insert&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;delete id=<span class=\"string\">\"deleteUser\"</span> parameterType=<span class=\"string\">\"java.lang.Integer\"</span>&gt;</span><br><span class=\"line\">        delete from user <span class=\"built_in\">where</span> id = <span class=\"comment\">#&#123;uid&#125;;</span></span><br><span class=\"line\">    &lt;/delete&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;update id=<span class=\"string\">\"updateUser\"</span> parameterType=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">        update user <span class=\"built_in\">set</span> username = <span class=\"comment\">#&#123;userName&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class=\"line\">    &lt;/update&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;select id=<span class=\"string\">\"selectUserByCondition\"</span> resultMap=<span class=\"string\">\"userMap\"</span> parameterType=<span class=\"string\">\"user\"</span>&gt;</span><br><span class=\"line\">          select * from user</span><br><span class=\"line\">          &lt;<span class=\"built_in\">where</span>&gt;</span><br><span class=\"line\">            &lt;<span class=\"keyword\">if</span> <span class=\"built_in\">test</span>=<span class=\"string\">\"sex != null and sex != '' \"</span>&gt;</span><br><span class=\"line\">                and sex = <span class=\"comment\">#&#123;sex&#125;</span></span><br><span class=\"line\">            &lt;/<span class=\"keyword\">if</span>&gt;</span><br><span class=\"line\">          &lt;/<span class=\"built_in\">where</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在UserMapper接口中添加查询方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 查询用户及用户下所有的角色信息</span><br><span class=\"line\">     * @<span class=\"built_in\">return</span></span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;User&gt; selectUserRoleAll();</span><br></pre></td></tr></table></figure>\n\n<p>新建测试方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">selectUserRoleAll</span></span>()&#123;</span><br><span class=\"line\">    List&lt;User&gt; users = userDao.selectUserRoleAll();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (User user:users) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"每个用户的角色信息：\"</span>);</span><br><span class=\"line\">        System.out.println(user);</span><br><span class=\"line\">        System.out.println(user.getRoles());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：<br><img src=\"/images/mybatis4.png\" alt=\"result\"></p>\n"},{"title":"Spring框架——Spring框架概述及工作原理","date":"2018-10-21T16:00:00.000Z","_content":"\n![Spring](/images/spring_logo.jpg)\n\n### 一、简介\nSpring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过Pojo为基础的编程模型促进良好的编程习惯。\n\n---\n\n### 二、工作原理\n<font style=\"color: red\"><b>1、 IoC(Inversion of Control): 控制反转<b></font>\n概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系 \n \n核心：bean工厂。在Spring中，bean工厂创建的各个实例称作bean。  \n\n作用：IoC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。\n\n优点：IoC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IoC容器支持加载服务时的饿汉式初始化和懒加载。\n\n动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，根据xml里面的Spring的配置文件来动态的创建对象，和调用对象里的方法的。 \n\nDI：(全称：Dependency Injection)依赖注入，IoC的另一种表现方式，组件以一种预先定义好的方式来接受容器注入的资源。\n\n<font style=\"color: red\"><b>2、AOP(Aspect-Oriented Programming): 面向方面编程<b></font> \n\n\t可以为某一类对象进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的模块）从而达到对一个模块扩充的功能。这些都是通过配置类达到的。 \n\n优点：AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码；利用AOP可以对业务逻辑的各个部分进行隔离，使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n经典应用：事务管理、性能监视、安全检查、缓存 、日志等。\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/aop \n                           http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <!-- 1 创建目标类 -->\n    <bean id=\"userServiceId\" class=\"com.loonycoder.service.UserServiceImpl\"></bean>\n    <!-- 2 创建切面类（通知） -->\n    <bean id=\"myAspectId\" class=\"com.loonycoder.service.MyAspect\"></bean>\n    <!-- 3 aop编程 \n        3.1 导入命名空间\n        3.2 使用 <aop:config>进行配置\n                proxy-target-class=\"true\" 声明时使用cglib代理\n            <aop:pointcut> 切入点 ，从目标对象获得具体方法\n            <aop:advisor> 特殊的切面，只有一个通知 和 一个切入点\n                advice-ref 通知引用\n                pointcut-ref 切入点引用\n        3.3 切入点表达式\n            execution(* com.loonycoder.service.*.*(..))\n            选择方法         返回值任意   包             类名任意   方法名任意   参数任意\n \n    -->\n    <aop:config proxy-target-class=\"true\">\n        <aop:pointcut expression=\"execution(* com.loonycoder.service.*.*(..))\" id=\"myPointCut\"/>\n        <aop:advisor advice-ref=\"myAspectId\" pointcut-ref=\"myPointCut\"/>\n    </aop:config>\n</beans>\n```\n\n代理的两种方式——静态代理和动态代理静态代理：  \n- 针对每个具体类分别编写代理类；  \n- 针对一个接口编写一个代理类；  \n动态代理：  \n针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类\n\n3、三种注入方式\n1. setter属性注入，通过构建实体类属性的setting方法注入\n```bash\n<!-- 相当于User user = new User(); -->\n        <bean id=\"user\" class=\"com.loonycoder.domain.User\">\n            <property name=\"name\" value=\"张三\"></property>\n            <property name=\"age\" value=\"18\"></property>\n            <property name=\"sex\" value=\"男\"></property>\n        </bean>\n```\n\n2. constructor构造方法注入，通过构建实体类相应构造方法\n```bash\n<!-- 相当于User user = new User();-->\n<!-- index属性指的是参数索引，从0开始 -->\n<bean id=\"user\" class=\"com.loonycoder.domain.User\">\n    <constructor-arg type=\"java.lang.String\" index=\"0\" value=\"张三\"></constructor-arg>\n    <constructor-arg type=\"java.lang.Integer\" index=\"1\" value=\"18\"></constructor-arg>\n    <constructor-arg type=\"java.lang.String\" index=\"2\" value=\"男\"></constructor-arg>\n</bean>\n```\n另外还有一种是Interface接口注入，因为此种方式使用的极少，所以在此就不进行介绍了。\n\n4、单例和多例\n1)当scope=\"singleton\"时，容器一加载就创建实体类\n\n**注意：只有在单例的时候，这个配置才有效**\n- lazy-init=\"true\" 延迟加载，在使用对象时创建实体对象 \n- lazy-init=\"false\" 不延迟加载，容器启动立即创建\n\n2)当scope=\"prototype\"时，获取使用对象时创建对象\n\n5、Spring目的\n<font style=\"color: red\"><b>就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象）</b></font>  \nSpring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。  \nSpring里用的最经典的一个设计模式就是：模板方法模式。Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了也就基本上掌握了Spring。\n\n### 三、组成体系\n![spring](/images/spring-framework.gif)\n\n图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。\n**1. Data Access/Integration（数据访问／集成）**\n\n数据访问/集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。\n- JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了在开发过程中对数据库操作的编码。\n- ORM 模块：对流行的对象关系映射 API，包括 JPA、JDO、Hibernate 和 iBatis 提供了的集成层。\n- OXM 模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。\n- JMS 模块：指 Java 消息服务，包含的功能为生产和消费的信息。\n- Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。\n\n**2. Web 模块**\n\nSpring 的 Web 层包括 Web、Servlet、Struts 和 Portlet 组件，具体介绍如下。\n- Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。\n- Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web 应用程序。\n- Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。\n- Portlet 模块：提供了在 Portlet 环境中使用 MV C实现，类似 Web-Servlet 模块的功能。\n\n**3. Core Container（核心容器）**\n\nSpring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成，具体介绍如下。\n- Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。\n- Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。\n- Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。\n- Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。\n\n**4. 其他模块**\n\nSpring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下。\n- AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。\n- Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。\n- Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。\n- Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。\n\n\n","source":"_posts/Spring-1.md","raw":"---\ntitle: Spring框架——Spring框架概述及工作原理\ncategories:\n    - Java框架\n    \ndate: 2018-10-22\ntags:\n\t- 框架\n    - Spring\n---\n\n![Spring](/images/spring_logo.jpg)\n\n### 一、简介\nSpring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过Pojo为基础的编程模型促进良好的编程习惯。\n\n---\n\n### 二、工作原理\n<font style=\"color: red\"><b>1、 IoC(Inversion of Control): 控制反转<b></font>\n概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系 \n \n核心：bean工厂。在Spring中，bean工厂创建的各个实例称作bean。  \n\n作用：IoC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。\n\n优点：IoC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IoC容器支持加载服务时的饿汉式初始化和懒加载。\n\n动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，根据xml里面的Spring的配置文件来动态的创建对象，和调用对象里的方法的。 \n\nDI：(全称：Dependency Injection)依赖注入，IoC的另一种表现方式，组件以一种预先定义好的方式来接受容器注入的资源。\n\n<font style=\"color: red\"><b>2、AOP(Aspect-Oriented Programming): 面向方面编程<b></font> \n\n\t可以为某一类对象进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的模块）从而达到对一个模块扩充的功能。这些都是通过配置类达到的。 \n\n优点：AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码；利用AOP可以对业务逻辑的各个部分进行隔离，使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n经典应用：事务管理、性能监视、安全检查、缓存 、日志等。\n\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/aop \n                           http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <!-- 1 创建目标类 -->\n    <bean id=\"userServiceId\" class=\"com.loonycoder.service.UserServiceImpl\"></bean>\n    <!-- 2 创建切面类（通知） -->\n    <bean id=\"myAspectId\" class=\"com.loonycoder.service.MyAspect\"></bean>\n    <!-- 3 aop编程 \n        3.1 导入命名空间\n        3.2 使用 <aop:config>进行配置\n                proxy-target-class=\"true\" 声明时使用cglib代理\n            <aop:pointcut> 切入点 ，从目标对象获得具体方法\n            <aop:advisor> 特殊的切面，只有一个通知 和 一个切入点\n                advice-ref 通知引用\n                pointcut-ref 切入点引用\n        3.3 切入点表达式\n            execution(* com.loonycoder.service.*.*(..))\n            选择方法         返回值任意   包             类名任意   方法名任意   参数任意\n \n    -->\n    <aop:config proxy-target-class=\"true\">\n        <aop:pointcut expression=\"execution(* com.loonycoder.service.*.*(..))\" id=\"myPointCut\"/>\n        <aop:advisor advice-ref=\"myAspectId\" pointcut-ref=\"myPointCut\"/>\n    </aop:config>\n</beans>\n```\n\n代理的两种方式——静态代理和动态代理静态代理：  \n- 针对每个具体类分别编写代理类；  \n- 针对一个接口编写一个代理类；  \n动态代理：  \n针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类\n\n3、三种注入方式\n1. setter属性注入，通过构建实体类属性的setting方法注入\n```bash\n<!-- 相当于User user = new User(); -->\n        <bean id=\"user\" class=\"com.loonycoder.domain.User\">\n            <property name=\"name\" value=\"张三\"></property>\n            <property name=\"age\" value=\"18\"></property>\n            <property name=\"sex\" value=\"男\"></property>\n        </bean>\n```\n\n2. constructor构造方法注入，通过构建实体类相应构造方法\n```bash\n<!-- 相当于User user = new User();-->\n<!-- index属性指的是参数索引，从0开始 -->\n<bean id=\"user\" class=\"com.loonycoder.domain.User\">\n    <constructor-arg type=\"java.lang.String\" index=\"0\" value=\"张三\"></constructor-arg>\n    <constructor-arg type=\"java.lang.Integer\" index=\"1\" value=\"18\"></constructor-arg>\n    <constructor-arg type=\"java.lang.String\" index=\"2\" value=\"男\"></constructor-arg>\n</bean>\n```\n另外还有一种是Interface接口注入，因为此种方式使用的极少，所以在此就不进行介绍了。\n\n4、单例和多例\n1)当scope=\"singleton\"时，容器一加载就创建实体类\n\n**注意：只有在单例的时候，这个配置才有效**\n- lazy-init=\"true\" 延迟加载，在使用对象时创建实体对象 \n- lazy-init=\"false\" 不延迟加载，容器启动立即创建\n\n2)当scope=\"prototype\"时，获取使用对象时创建对象\n\n5、Spring目的\n<font style=\"color: red\"><b>就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象）</b></font>  \nSpring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。  \nSpring里用的最经典的一个设计模式就是：模板方法模式。Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了也就基本上掌握了Spring。\n\n### 三、组成体系\n![spring](/images/spring-framework.gif)\n\n图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。\n**1. Data Access/Integration（数据访问／集成）**\n\n数据访问/集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。\n- JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了在开发过程中对数据库操作的编码。\n- ORM 模块：对流行的对象关系映射 API，包括 JPA、JDO、Hibernate 和 iBatis 提供了的集成层。\n- OXM 模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。\n- JMS 模块：指 Java 消息服务，包含的功能为生产和消费的信息。\n- Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。\n\n**2. Web 模块**\n\nSpring 的 Web 层包括 Web、Servlet、Struts 和 Portlet 组件，具体介绍如下。\n- Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。\n- Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web 应用程序。\n- Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。\n- Portlet 模块：提供了在 Portlet 环境中使用 MV C实现，类似 Web-Servlet 模块的功能。\n\n**3. Core Container（核心容器）**\n\nSpring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成，具体介绍如下。\n- Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。\n- Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。\n- Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。\n- Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。\n\n**4. 其他模块**\n\nSpring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下。\n- AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。\n- Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。\n- Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。\n- Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。\n\n\n","slug":"Spring-1","published":1,"updated":"2020-02-21T15:31:31.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyu000iv9s68ajp3que","content":"<p><img src=\"/images/spring_logo.jpg\" alt=\"Spring\"></p>\n<h3 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h3><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过Pojo为基础的编程模型促进良好的编程习惯。</p>\n<hr>\n<h3 id=\"二、工作原理\"><a href=\"#二、工作原理\" class=\"headerlink\" title=\"二、工作原理\"></a>二、工作原理</h3><p><font style=\"color: red\"><b>1、 IoC(Inversion of Control): 控制反转<b></font><br>概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系 </p>\n<p>核心：bean工厂。在Spring中，bean工厂创建的各个实例称作bean。  </p>\n<p>作用：IoC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>\n<p>优点：IoC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IoC容器支持加载服务时的饿汉式初始化和懒加载。</p>\n<p>动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，根据xml里面的Spring的配置文件来动态的创建对象，和调用对象里的方法的。 </p>\n<p>DI：(全称：Dependency Injection)依赖注入，IoC的另一种表现方式，组件以一种预先定义好的方式来接受容器注入的资源。</p>\n<p><font style=\"color: red\"><b>2、AOP(Aspect-Oriented Programming): 面向方面编程<b></font> </p>\n<pre><code>可以为某一类对象进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的模块）从而达到对一个模块扩充的功能。这些都是通过配置类达到的。 </code></pre><p>优点：AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码；利用AOP可以对业务逻辑的各个部分进行隔离，使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>\n<p>经典应用：事务管理、性能监视、安全检查、缓存 、日志等。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;beans xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">       xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">       xmlns:aop=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span></span><br><span class=\"line\">       xsi:schemaLocation=<span class=\"string\">\"http://www.springframework.org/schema/beans </span></span><br><span class=\"line\"><span class=\"string\">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class=\"line\"><span class=\"string\">                           http://www.springframework.org/schema/aop </span></span><br><span class=\"line\"><span class=\"string\">                           http://www.springframework.org/schema/aop/spring-aop.xsd\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- 1 创建目标类 --&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">\"userServiceId\"</span> class=<span class=\"string\">\"com.loonycoder.service.UserServiceImpl\"</span>&gt;&lt;/bean&gt;</span><br><span class=\"line\">    &lt;!-- 2 创建切面类（通知） --&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">\"myAspectId\"</span> class=<span class=\"string\">\"com.loonycoder.service.MyAspect\"</span>&gt;&lt;/bean&gt;</span><br><span class=\"line\">    &lt;!-- 3 aop编程 </span><br><span class=\"line\">        3.1 导入命名空间</span><br><span class=\"line\">        3.2 使用 &lt;aop:config&gt;进行配置</span><br><span class=\"line\">                proxy-target-class=<span class=\"string\">\"true\"</span> 声明时使用cglib代理</span><br><span class=\"line\">            &lt;aop:pointcut&gt; 切入点 ，从目标对象获得具体方法</span><br><span class=\"line\">            &lt;aop:advisor&gt; 特殊的切面，只有一个通知 和 一个切入点</span><br><span class=\"line\">                advice-ref 通知引用</span><br><span class=\"line\">                pointcut-ref 切入点引用</span><br><span class=\"line\">        3.3 切入点表达式</span><br><span class=\"line\">            execution(* com.loonycoder.service.*.*(..))</span><br><span class=\"line\">            选择方法         返回值任意   包             类名任意   方法名任意   参数任意</span><br><span class=\"line\"> </span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">    &lt;aop:config proxy-target-class=<span class=\"string\">\"true\"</span>&gt;</span><br><span class=\"line\">        &lt;aop:pointcut expression=<span class=\"string\">\"execution(* com.loonycoder.service.*.*(..))\"</span> id=<span class=\"string\">\"myPointCut\"</span>/&gt;</span><br><span class=\"line\">        &lt;aop:advisor advice-ref=<span class=\"string\">\"myAspectId\"</span> pointcut-ref=<span class=\"string\">\"myPointCut\"</span>/&gt;</span><br><span class=\"line\">    &lt;/aop:config&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n<p>代理的两种方式——静态代理和动态代理静态代理：  </p>\n<ul>\n<li>针对每个具体类分别编写代理类；  </li>\n<li>针对一个接口编写一个代理类；<br>动态代理：<br>针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类</li>\n</ul>\n<p>3、三种注入方式</p>\n<ol>\n<li><p>setter属性注入，通过构建实体类属性的setting方法注入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 相当于User user = new User(); --&gt;</span><br><span class=\"line\">        &lt;bean id=<span class=\"string\">\"user\"</span> class=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">            &lt;property name=<span class=\"string\">\"name\"</span> value=<span class=\"string\">\"张三\"</span>&gt;&lt;/property&gt;</span><br><span class=\"line\">            &lt;property name=<span class=\"string\">\"age\"</span> value=<span class=\"string\">\"18\"</span>&gt;&lt;/property&gt;</span><br><span class=\"line\">            &lt;property name=<span class=\"string\">\"sex\"</span> value=<span class=\"string\">\"男\"</span>&gt;&lt;/property&gt;</span><br><span class=\"line\">        &lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>constructor构造方法注入，通过构建实体类相应构造方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 相当于User user = new User();--&gt;</span><br><span class=\"line\">&lt;!-- index属性指的是参数索引，从0开始 --&gt;</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"user\"</span> class=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">    &lt;constructor-arg <span class=\"built_in\">type</span>=<span class=\"string\">\"java.lang.String\"</span> index=<span class=\"string\">\"0\"</span> value=<span class=\"string\">\"张三\"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class=\"line\">    &lt;constructor-arg <span class=\"built_in\">type</span>=<span class=\"string\">\"java.lang.Integer\"</span> index=<span class=\"string\">\"1\"</span> value=<span class=\"string\">\"18\"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class=\"line\">    &lt;constructor-arg <span class=\"built_in\">type</span>=<span class=\"string\">\"java.lang.String\"</span> index=<span class=\"string\">\"2\"</span> value=<span class=\"string\">\"男\"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>另外还有一种是Interface接口注入，因为此种方式使用的极少，所以在此就不进行介绍了。</p>\n</li>\n</ol>\n<p>4、单例和多例<br>1)当scope=”singleton”时，容器一加载就创建实体类</p>\n<p><strong>注意：只有在单例的时候，这个配置才有效</strong></p>\n<ul>\n<li>lazy-init=”true” 延迟加载，在使用对象时创建实体对象 </li>\n<li>lazy-init=”false” 不延迟加载，容器启动立即创建</li>\n</ul>\n<p>2)当scope=”prototype”时，获取使用对象时创建对象</p>\n<p>5、Spring目的<br><font style=\"color: red\"><b>就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象）</b></font><br>Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。<br>Spring里用的最经典的一个设计模式就是：模板方法模式。Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了也就基本上掌握了Spring。</p>\n<h3 id=\"三、组成体系\"><a href=\"#三、组成体系\" class=\"headerlink\" title=\"三、组成体系\"></a>三、组成体系</h3><p><img src=\"/images/spring-framework.gif\" alt=\"spring\"></p>\n<p>图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。<br><strong>1. Data Access/Integration（数据访问／集成）</strong></p>\n<p>数据访问/集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。</p>\n<ul>\n<li>JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了在开发过程中对数据库操作的编码。</li>\n<li>ORM 模块：对流行的对象关系映射 API，包括 JPA、JDO、Hibernate 和 iBatis 提供了的集成层。</li>\n<li>OXM 模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。</li>\n<li>JMS 模块：指 Java 消息服务，包含的功能为生产和消费的信息。</li>\n<li>Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。</li>\n</ul>\n<p><strong>2. Web 模块</strong></p>\n<p>Spring 的 Web 层包括 Web、Servlet、Struts 和 Portlet 组件，具体介绍如下。</p>\n<ul>\n<li>Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。</li>\n<li>Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web 应用程序。</li>\n<li>Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。</li>\n<li>Portlet 模块：提供了在 Portlet 环境中使用 MV C实现，类似 Web-Servlet 模块的功能。</li>\n</ul>\n<p><strong>3. Core Container（核心容器）</strong></p>\n<p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成，具体介绍如下。</p>\n<ul>\n<li>Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。</li>\n<li>Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。</li>\n<li>Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。</li>\n<li>Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。</li>\n</ul>\n<p><strong>4. 其他模块</strong></p>\n<p>Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下。</p>\n<ul>\n<li>AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。</li>\n<li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li>\n<li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li>\n<li>Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/spring_logo.jpg\" alt=\"Spring\"></p>\n<h3 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h3><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过Pojo为基础的编程模型促进良好的编程习惯。</p>\n<hr>\n<h3 id=\"二、工作原理\"><a href=\"#二、工作原理\" class=\"headerlink\" title=\"二、工作原理\"></a>二、工作原理</h3><p><font style=\"color: red\"><b>1、 IoC(Inversion of Control): 控制反转<b></font><br>概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系 </p>\n<p>核心：bean工厂。在Spring中，bean工厂创建的各个实例称作bean。  </p>\n<p>作用：IoC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>\n<p>优点：IoC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IoC容器支持加载服务时的饿汉式初始化和懒加载。</p>\n<p>动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，根据xml里面的Spring的配置文件来动态的创建对象，和调用对象里的方法的。 </p>\n<p>DI：(全称：Dependency Injection)依赖注入，IoC的另一种表现方式，组件以一种预先定义好的方式来接受容器注入的资源。</p>\n<p><font style=\"color: red\"><b>2、AOP(Aspect-Oriented Programming): 面向方面编程<b></font> </p>\n<pre><code>可以为某一类对象进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的模块）从而达到对一个模块扩充的功能。这些都是通过配置类达到的。 </code></pre><p>优点：AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码；利用AOP可以对业务逻辑的各个部分进行隔离，使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>\n<p>经典应用：事务管理、性能监视、安全检查、缓存 、日志等。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;beans xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">       xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">       xmlns:aop=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span></span><br><span class=\"line\">       xsi:schemaLocation=<span class=\"string\">\"http://www.springframework.org/schema/beans </span></span><br><span class=\"line\"><span class=\"string\">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class=\"line\"><span class=\"string\">                           http://www.springframework.org/schema/aop </span></span><br><span class=\"line\"><span class=\"string\">                           http://www.springframework.org/schema/aop/spring-aop.xsd\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- 1 创建目标类 --&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">\"userServiceId\"</span> class=<span class=\"string\">\"com.loonycoder.service.UserServiceImpl\"</span>&gt;&lt;/bean&gt;</span><br><span class=\"line\">    &lt;!-- 2 创建切面类（通知） --&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">\"myAspectId\"</span> class=<span class=\"string\">\"com.loonycoder.service.MyAspect\"</span>&gt;&lt;/bean&gt;</span><br><span class=\"line\">    &lt;!-- 3 aop编程 </span><br><span class=\"line\">        3.1 导入命名空间</span><br><span class=\"line\">        3.2 使用 &lt;aop:config&gt;进行配置</span><br><span class=\"line\">                proxy-target-class=<span class=\"string\">\"true\"</span> 声明时使用cglib代理</span><br><span class=\"line\">            &lt;aop:pointcut&gt; 切入点 ，从目标对象获得具体方法</span><br><span class=\"line\">            &lt;aop:advisor&gt; 特殊的切面，只有一个通知 和 一个切入点</span><br><span class=\"line\">                advice-ref 通知引用</span><br><span class=\"line\">                pointcut-ref 切入点引用</span><br><span class=\"line\">        3.3 切入点表达式</span><br><span class=\"line\">            execution(* com.loonycoder.service.*.*(..))</span><br><span class=\"line\">            选择方法         返回值任意   包             类名任意   方法名任意   参数任意</span><br><span class=\"line\"> </span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">    &lt;aop:config proxy-target-class=<span class=\"string\">\"true\"</span>&gt;</span><br><span class=\"line\">        &lt;aop:pointcut expression=<span class=\"string\">\"execution(* com.loonycoder.service.*.*(..))\"</span> id=<span class=\"string\">\"myPointCut\"</span>/&gt;</span><br><span class=\"line\">        &lt;aop:advisor advice-ref=<span class=\"string\">\"myAspectId\"</span> pointcut-ref=<span class=\"string\">\"myPointCut\"</span>/&gt;</span><br><span class=\"line\">    &lt;/aop:config&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n<p>代理的两种方式——静态代理和动态代理静态代理：  </p>\n<ul>\n<li>针对每个具体类分别编写代理类；  </li>\n<li>针对一个接口编写一个代理类；<br>动态代理：<br>针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类</li>\n</ul>\n<p>3、三种注入方式</p>\n<ol>\n<li><p>setter属性注入，通过构建实体类属性的setting方法注入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 相当于User user = new User(); --&gt;</span><br><span class=\"line\">        &lt;bean id=<span class=\"string\">\"user\"</span> class=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">            &lt;property name=<span class=\"string\">\"name\"</span> value=<span class=\"string\">\"张三\"</span>&gt;&lt;/property&gt;</span><br><span class=\"line\">            &lt;property name=<span class=\"string\">\"age\"</span> value=<span class=\"string\">\"18\"</span>&gt;&lt;/property&gt;</span><br><span class=\"line\">            &lt;property name=<span class=\"string\">\"sex\"</span> value=<span class=\"string\">\"男\"</span>&gt;&lt;/property&gt;</span><br><span class=\"line\">        &lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>constructor构造方法注入，通过构建实体类相应构造方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 相当于User user = new User();--&gt;</span><br><span class=\"line\">&lt;!-- index属性指的是参数索引，从0开始 --&gt;</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"user\"</span> class=<span class=\"string\">\"com.loonycoder.domain.User\"</span>&gt;</span><br><span class=\"line\">    &lt;constructor-arg <span class=\"built_in\">type</span>=<span class=\"string\">\"java.lang.String\"</span> index=<span class=\"string\">\"0\"</span> value=<span class=\"string\">\"张三\"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class=\"line\">    &lt;constructor-arg <span class=\"built_in\">type</span>=<span class=\"string\">\"java.lang.Integer\"</span> index=<span class=\"string\">\"1\"</span> value=<span class=\"string\">\"18\"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class=\"line\">    &lt;constructor-arg <span class=\"built_in\">type</span>=<span class=\"string\">\"java.lang.String\"</span> index=<span class=\"string\">\"2\"</span> value=<span class=\"string\">\"男\"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>另外还有一种是Interface接口注入，因为此种方式使用的极少，所以在此就不进行介绍了。</p>\n</li>\n</ol>\n<p>4、单例和多例<br>1)当scope=”singleton”时，容器一加载就创建实体类</p>\n<p><strong>注意：只有在单例的时候，这个配置才有效</strong></p>\n<ul>\n<li>lazy-init=”true” 延迟加载，在使用对象时创建实体对象 </li>\n<li>lazy-init=”false” 不延迟加载，容器启动立即创建</li>\n</ul>\n<p>2)当scope=”prototype”时，获取使用对象时创建对象</p>\n<p>5、Spring目的<br><font style=\"color: red\"><b>就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象）</b></font><br>Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。<br>Spring里用的最经典的一个设计模式就是：模板方法模式。Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了也就基本上掌握了Spring。</p>\n<h3 id=\"三、组成体系\"><a href=\"#三、组成体系\" class=\"headerlink\" title=\"三、组成体系\"></a>三、组成体系</h3><p><img src=\"/images/spring-framework.gif\" alt=\"spring\"></p>\n<p>图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。<br><strong>1. Data Access/Integration（数据访问／集成）</strong></p>\n<p>数据访问/集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。</p>\n<ul>\n<li>JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了在开发过程中对数据库操作的编码。</li>\n<li>ORM 模块：对流行的对象关系映射 API，包括 JPA、JDO、Hibernate 和 iBatis 提供了的集成层。</li>\n<li>OXM 模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。</li>\n<li>JMS 模块：指 Java 消息服务，包含的功能为生产和消费的信息。</li>\n<li>Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。</li>\n</ul>\n<p><strong>2. Web 模块</strong></p>\n<p>Spring 的 Web 层包括 Web、Servlet、Struts 和 Portlet 组件，具体介绍如下。</p>\n<ul>\n<li>Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。</li>\n<li>Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web 应用程序。</li>\n<li>Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。</li>\n<li>Portlet 模块：提供了在 Portlet 环境中使用 MV C实现，类似 Web-Servlet 模块的功能。</li>\n</ul>\n<p><strong>3. Core Container（核心容器）</strong></p>\n<p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成，具体介绍如下。</p>\n<ul>\n<li>Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。</li>\n<li>Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。</li>\n<li>Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。</li>\n<li>Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。</li>\n</ul>\n<p><strong>4. 其他模块</strong></p>\n<p>Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下。</p>\n<ul>\n<li>AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。</li>\n<li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li>\n<li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li>\n<li>Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。</li>\n</ul>\n"},{"title":"Vue过滤器和Vue-resource","date":"2018-08-29T16:00:00.000Z","_content":"\n### 过滤器\n\n\n之前我们学习了Vue的 **vue基本指令** 进阶学习，我们需要了解Vue的过滤器：Vue.js允许你自定义过滤器，可被用作一些常见元素的格式化。过滤器可以用在两个地方：mustache插值和v-bind表达式。\n用法：\n```bash\n{{ 过滤器名称 | function }}\n```\n**定义：**\nVue提供了两种方式创建过滤器：\n- 1、全局过滤器\n```bash\nVue.filter('过滤器名称', function(){})\n```\n- 2、私有过滤器\n```bash\nnew Vue()({\n    el: '',\n    data: {},\n    methods: {},\n    filters: {\n        过滤器名称: function(){}\n    }\n})\n```\n\n#### 全局过滤器\n```bash\n<h3>{{ msg | myFilters('时光') }}</h3>\n\nVue.filter('myFilters', function(data, pattern){\n    if(pattern == '时光'){\n        var old = data.substring(0,4);\n        return old + ',时光路口。';\n    }\n});\n```\n\n**解释：**\n如上：Vue提供的全局过滤器，直接使用Vue调用，而不是定义在Vue实例中\n- Vue.filter()中第一个参数是过滤器名称，第二个参数是function(){}\n- function(){}中还有两个参数，第一个参数是原始的值，第二个参数是你想给过滤器方法传递的值。\n\n#### 私有过滤器\n```bash\n<h3>{{ msg | myFilters('望月') }}</h3>\n\nvar vm2 = new Vue({\n    el: '#app2',\n    data: {\n        msg: 'loonycoder！'\n    },\n    methods: {},\n    filters: {\n\n        myFilters: function(data, pattern) {\n            if(pattern == '望月'){\n                var old = data.substring(0,4);\n                return old + ',loonycoder';\n            }\n        }\n})\n```\n私有过滤器和全局过滤器用法基本相同，仅仅是作用于不同而已。\n\n### 自定义指令\n\n#### 按键修饰符\n在我们搜索商品时，在一些网站中我们直接回车后立即进行搜索，而不是点击搜索按钮才会搜索，那么这个功能怎么实现呢？\n那么我们就需要了解Vue中提供的**按键修饰符**\n用法： @keyup.按键别名 = \"要调用的方法名\"\n\n**按键别名**\n> .enter\n> .tab\n> .esc\n> .delete\n> …\n\n**示例**\n```bash\n<input type=\"text\" @keyup.enter=\"open\">\n\nmethods: {\n    open(){\n        alert(\"弹出\");\n    }\n}\n```\n\n**自定义按键修饰符**\n如果Vue提供的按键修饰符不能满足你的需求，你也可以使用Vue提供的自定义按键修饰符来实现，因为每个键盘的按键都对应了一个键盘码值，比如F2对应的键盘码值是：113：\n用法：\n```bash\n<input type=\"text\" @keyup.f2=\"open\">\n\nVue.config.keyCodes.f2 = 113;   \n\nmethods: {\n    open(){\n        alert(\"弹出\");\n    }\n}\n```\n\n#### 获取文本焦点\n获取文本焦点使用了focus属性，那么我们需要定义一个v-focus指令\n```bash\nVue.directive('focus', {\n    bind: function(el) {},\n    inserted: function(el) {},\n    updated: function(el) {}\n});\n```\n\n如上，使用Vue.directive()实现定义全局指令，需要注意以下几点：\n- 1、在directive()方法中包含两个参数：\n > 参数1：指令的名称，注意，在定义的时候指令名称不需要加v-前缀，但是在使用的时候需要加v-前缀。\n > 参数2：是一个对象，这个对象包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作。\n\n**示例：**\n```bash\nVue.directive('focus', {\n\n});\n\n// 使用的时候使用： v-focus\n```\n\n- 2、在directive()函数的第二个参数中（对象）中又包含了三个实例方法：\n> bind: 当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次；但是需要知道元素绑定了这个指令，若涉及对DOM操作的，并不会立即执行，因为元素不会立即插入到DOM中。所以涉及对元素进行DOM相关操作的，不要定义到这个方法中。\n> inserted: 当元素插入到DOM的时候，会立即执行，并只触发一次。\n> updated: 当VNode更新的时候，会指定updated，可能触发多次。\n\n**示例：**\n```bash\nue.directive('focus', {\n    bind: function(el) {\n        el.focus()\n    }\n});\n\n// 调用\n<input type=\"text\" v-focus />\n```\n\n如上，其中bind函数的第一个参数永远是el，它表示绑定的那个元素，是一个原生的JS对象；这里我们调用了JS的focus方法\n\n##### 钩子函数\n指令定义函数提供了几个钩子函数（可选）：\n>bind\n>inserted\n>update\n>componentUpdated: 所在组件的VNode及其孩子的VNode全部更新的时候调用\n>unbind: 只调用一次，指令与元素解除绑定时调用\n\n**钩子函数参数**\n在上面使用directive()函数的时候我们已经介绍了一些常用的钩子函数，那么既然是函数，就可能需要进行传参，那么为了实现钩子函数传参，Vue提供了几个参数属性来实现对钩子函数参数的一些操作：\n- el: 指令所绑定的元素，可以用来直接操作DOM。\n- binding: 一个对象，包含以下属性：\n    - name: 指令名，不包含v-前缀\n    - value: 指令的绑定值，如v-focus=\"1 + 1\"，那么value=2。\n    - expression: 绑定值的字符串形式，如v-focus=\"1+1\"，那么experssion的值是1+1。\n    - …\n- …\n\n**示例：**\n实现在文本框中输入的数据颜色要为蓝色\n```bash\n<input type=\"text\" v-color=\"'blue'\">\n\n// 自定义设置颜色的指令\nVue.directive('color', {\n    bind: function(el, binding){\n        el.style.color = binding.value\n    }\n});\n```\n\n其中因为设计要获取值的操作，所以使用binding这个对象钩子函数参数来使用接收，那么：\n1、这个el就表示当前这个input文本框对象\n2、这个binding就表示v-color=\"'blue'\"指令传递的参数blue（因为使用''单引号即不是字符串）\n3、binding-value就是获取到v-color指令绑定的参数值是：blue，通过el.style.color表示设置这个文本框样式中的颜色属性\n\n##### 定义私有指令\n使用**私有指令**和**全局指令**的用法基本相同，我们参考上面讲过的**私有过滤器**和**全局过滤器**就能猜想到**私有指令**的用法：\n**示例：**\n```bash\n<p v-fontsize=\"'50px'\">私有指令</p>\n\nvar vm = new Vue({\n    el: '',\n    data: {},\n    methods: {},\n    filters: {},\n    directives: {\n        'fontsize': {\n            bind: function(el, binding){\n                el.style.fontSize = binding.value\n            }\n        }\n    }\n});\n```\n\n**自定义指令的简写形式**\n对于仅仅使用bind和update钩子函数的操作，可以进行下列的简写形式：\n```bash\n<p v-fontsize=\"'50px'\">私有指令</p>\n\nvar vm = new Vue({\n    el: '',\n    data: {},\n    methods: {},\n    filters: {},\n    directives: {\n        'fontsize': function(el, binding){\n            el.style.fontSize = binding.value\n        }\n    }\n});\n```\n\n#### 综合案例\n实现将列表数据渲染到表格中，并实现添加功能案例（包含上面讲到的所有技术的**实例**）：\n```bash\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style type=\"text/css\">\n    table {\n        min-height: 25px;\n        line-height: 25px;\n        text-align: center;\n        border-collapse: collapse;\n    }\n\n    table,\n    table tr th,\n    table tr td {\n        border: 1px solid #0094ff;\n        padding: 11px;\n    }\n    </style>\n</head>\n\n<body>\n    <div id=\"app\">\n        id:\n        <input type=\"text\" v-model=\"id\" v-focus v-color=\"'blue'\"> username:\n        <input type=\"text\" v-model=\"username\" @keyup.enter=\"add\">\n        <input type=\"button\" value=\"添加\" @click=\"add\">\n        <br/>\n        <br/>\n        <table>\n            <thead>\n                <tr>\n                    <th>id</th>\n                    <th>name</th>\n                    <th>date</th>\n                    <th>fun</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr v-for=\"user in list\" :key=\"user.id\">\n                    <td>{{user.id}}</td>\n                    <td>{{user.username}}</td>\n                    <td>{{user.time | dataFormat('') }}</td>\n                    <td><a href=\"#\" @click=\"del(user.id)\">删除</a></td>\n                </tr>\n            </tbody>\n        </table>\n        <p>未使用过滤器：{{ new Date() }}</p>\n        <p>使用全局过滤器：{{ new Date() | dataFormat('') }}</p>\n    </div>\n    <div id=\"app2\">\n        使用私有过滤器：{{ dt | dataFormat('')}}\n        <p v-fontsize=\"'50px'\">私有指令</p>\n    </div>\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n    // 自定义文本框获取焦点指令\n    // Vue.directive()定义全局指令，包含两个参数：\n    // 参数1：指令的名称，注意，在定义的时候指令的名称不需要加v-前缀，但是在使用的时候需要加v-focus\n    // 参数2：是一个对象，这个对象中包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作\n    Vue.directive('focus', {\n        // 注意，在下面的函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数是一个原生JS对象\n        bind: function(el) { //每当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次\n            // 注意：在元素绑定了指令时，还没有插入到DOM中去，这时候调用focus方法是没有作用的，因为一个元素，只有插入到DOM之后，才能获取焦点\n            // el.focus()\n        },\n        inserted: function(el) { // inserted表示元素插入到DOM中的时候，会执行,触发一次\n            el.focus()\n        },\n        updated: function(el) { // 当VNode更新的是否，会执行updated，可触发多次\n        }\n    });\n\n    // 自定义设置颜色的指令\n    Vue.directive('color', {\n        bind: function(el, binding) {\n            el.style.color = binding.value\n        }\n    });\n\n    // 自定义按键\n    Vue.config.keyCodes.f2 = 113;\n\n    // 演示私有过滤器\n    var vm2 = new Vue({\n        el: '#app2',\n        data: {\n            dt: new Date(),\n        },\n        methods: {\n            open() {\n                alert(\"弹出\");\n            }\n        },\n        filters: {\n            dataFormat: function(data, pattern) {\n                // 获取当前日期\n                var dt = new Date(data);\n\n                // 获取年月日\n                var y = dt.getFullYear();\n                var m = dt.getMonth() + 1;\n                var d = dt.getDate();\n\n                if (pattern.toLowerCase() == 'yyyy-mm-dd') {\n                    return `${y}-${m}-${d}`;\n                } else {\n                    var hh = dt.getHours();\n                    var mm = dt.getMinutes();\n                    var ss = dt.getSeconds();\n\n                    // es6中提供的 yyyy-mm-dd hh:mm:ss 的简写形式\n                    return `${y}-${m}-${d} ${hh}:${mm}:${ss}` + '-->私有';\n                }\n            }\n        },\n        // 自定义私有指令（简写形式）\n        directives: {\n            'fontsize': function(el, binding) {\n                el.style.fontSize = binding.value\n            }\n        }\n    });\n\n    // 全局过滤器\n    Vue.filter('dataFormat', function(data, pattern) {\n        // 获取当前日期\n        var dt = new Date(data);\n\n        // 获取年月日\n        var y = dt.getFullYear();\n        var m = dt.getMonth() + 1;\n        var d = dt.getDate();\n\n        if (pattern.toLowerCase() == 'yyyy-mm-dd') {\n            return `${y}-${m}-${d}`;\n        } else {\n            var hh = dt.getHours();\n            var mm = dt.getMinutes();\n            var ss = dt.getSeconds();\n\n            return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n        }\n    });\n\n    // 创建Vue实例\n    var vm = new Vue({\n        el: '#app',\n        data: {\n            id: '',\n            username: '',\n            list: [\n                { id: 1, username: '望月', time: new Date() },\n                { id: 2, username: 'loonycoder', time: new Date() }\n            ]\n        },\n        methods: {\n            add() {\n                var user = { id: this.id, username: this.username, time: new Date() };\n                this.list.push(user);\n            },\n            del(id) {\n                // some()是操作数组的方法，作用是循环数组，并当return true是就终止循环\n                // 其中的user理解为循环list元素的别名，i表示索引\n                this.list.some((user, i) => {\n                    if (user.id == id) {\n                        this.list.splice(i, 1);\n                        return true;\n                    }\n                })\n            }\n        }\n    });\n    </script>\n</body>\n</html>\n```\n\n#### Vue实例的生命周期\n- 什么是声明周期：从Vue实例创建、运行、到销毁期间，伴随着发生的事件的过程成为生命周期。\n- 生命周期钩子：就是声明周期事件的别名。\n- 主要的声明周期函数分类\n\n> 创建期间的声明周期函数：\n> * beforeCreate: 实例刚在内存中被创建，此时，还没有初始化好data和methods属性。\n> * created: 实例已经在内存中创建好，此时data和methods已经创建好，但还没有编译模板。\n> * beforeMount: 此时已经完成了模板的编译，但是还没有挂载到页面上。\n> * mounted: 此时，已经将编译好的模板，挂载到了页面指定的容器中。\n> 运行期间的声明周期函数:\n> * beforeUpdate: 状态更新之前执行此函数，此时的data数据是最新的，但是此时还没有开始渲染DOM节点\n> * updated: 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据都是最新的，界面已经被重新渲染好了。\n销毁期间的生命周期函数\n> * beforeDestory: 实例销毁之前调用，在这一步，实例仍然可以使用。\n> * destroyed: Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器都会被移除，所所有的子实例也会被销毁。\n\n##### beforeCreate\n此函数执行的时候，data和methods中的数据还没有初始化。\n![beforeCreate](/images/vue7.png)\n![beforeCreate](/images/vue8.png)\n\n##### created\n此函数中，data和methods都已经初始化好了，如果需要调用methods中的方法或操作data中的值最早就在created函数中操作。\n![created](/images/vue9.png)\n![created](/images/vue10.png)\n\n##### beforeMount\n此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去。\n![beforeMount](/images/vue11.png)\n![beforeMount](/images/vue12.png)\n\n##### mounted\n只要执行完了mounted，表示整个Vue实例已经初始化完毕了，此时组件已经进入了运行阶段。\n![mounted](/images/vue13.png)\n\n##### 图示\n![图示](/images/vue14.png)\n\n---\n\n### vue-resource实现请求提交\n作为一个后端开发者，我们需要的数据都应该是从数据库中取出来的，目前JSP页面越来越不常用，而更常用HTML页面，那么就体现出来类似Vue这种框架的好处了。\n下面我们就了解一下怎样使用Vue实现发送AJAX的请求：\n\n##### 配置\n首先使用Vue实现发送AJAX请求，我们需要导入一个包：\n```bash\nvue-resource.js\n```\n**Methods**\n```bash\nthis.$http.get('url', [options]).then(successCallback, errorCallback);\n\nthis.$http.post('url', [body], [options]).then(successCallback, errorCallback);\n```\n\n解释：\n- this表示的是当前Vue实例对象，而vue-resource.js提供了$http属性用来调用其内置的请求方法，并且vue-resource.js是基于vue.js的。\noptions是指可选的请求参数，就是你发送请求想要传递的参数。\n- then可以实现发送完请求后，通过其获取请求成功响应的数据\n- then中包含两个参数successCallback和errorCallback，这两个都是对象，我们可以通过其进行对相应数据的操作。\n\n##### 实例\n```bash\n<button @click=\"getInfo\">点击我</button>\n\nvar vm = new Vue({\n    el: '#app',\n    data: {},\n    methods: {\n        getInfo(){\n            this.$http.get('url').then(result => {\n                console.log(result.body);\n            })\n        }\n    }\n});\n```\n\n**解释：**\n当我们请求成功后，可以通过then来获取请求成功响应的数据，而可以通过.data或.body来获取响应data，而我们通常使用result.body来获取具体响应的参数。注意其中的result => {}是ES6中的写法。\n\n##### post请求\n**注意：** post请求常用于类似提交表单的功能，而对于提交表单，存在一个表单提交格式，默认是：application/x-wwww-form-urlencoded ；而通过Vue发起的post请求，默认没有表单格式，所以，有的服务器就处理不了。\n那么我们可以通过post方法的第三个参数：{ emulateJSON: true }来设置提交内容类型为普通表单数据格式。\n\n**示例：**\n```bash\nthis.$http.post('url', {}, { emulateJSON: true }).then(result => {\n    console.log(result.body)\n})\n```\n\n其他请求方法与上面的雷同，具体方法请参考官方文档。\n\n#### 请求接口根域名配置\n\n由于我们个人的项目可能是部署到本地的Tomcat服务器上的，可能不会涉及请求接口的域名配置，那么我们先看一个案例：\n发送post请求到服务器接口\n\n```bash\n...\n\nmethods: {\n    add(){\n        this.$http.post('http://tycoding.cn/api/add', {}, {emulateJSON: true}).then(result => {\n            \n        });\n    }\n}\n```\n\n如上，当我们发送请求的时候，URL路径需要写上域名地址<http://www.loonycoder.com>，然后才是请求路径/api/add，那么我们每次发送ajax请求都会需要写这个域名地址，就会显得比较麻烦，所以Vue-resource给我们提供了一种设置默认请求**根域名**的配置：\n```bash\nVue.http.options.root = 'http://www.loonycoder.com';\n```\n\n如上，就是一个全局的请求根域名配置。\n\n**注意**\n仅了解了上面的配置可能请求还会404，那么我们需要知道：\n> 如果我们通过了全局配置请求接口的根域名，那么每次发送HTTP请求时，请求的URL路径应该以相对域名开头，即前面不能带/： * 如果this.$http.post('/xxx')请求URL带了/，那么Vue就不会启用上面的全局请求根域名配置，就会404.\n* 如果前面不带/即：this.$http.post('xxx')，那么就会启用上面的全局请求根域名配置进行URL的拼接。\n\n##### 全局配置表单提交格式选项\n上面讲到了如果使用post请求提交表单，那么你应该指定{emulateJSON: true}参数，那么每次进行post请求都指定又会显得很麻烦，那么vue-resource也给我们提供了一个全局配置的方式：\n```bash\nVue.http.options.emulateJSON = true;\n```\n这样我们就不需要再post请求中再配置第三个参数了：\n```bash\nmethods: {\n    add(){\n        this.$http.post('http://tycoding.cn/api/add', {}).then(result => {\n            \n        });\n    }\n}\n```\n\n##### 实例\n请求后台并即时渲染表格数据的案例：\n```bash\n<!-- html段 -->\n<input type=\"text\" v-model=\"username\">\n<input type=\"button\" value=\"添加\" @click=\"add\">\n\n<table>\n    <tr>\n        <th>编号</th>\n        <th>用户名</th>\n        <th>操作</th>\n    </tr>\n    <tbody>\n        <tr v-for=\"user in list\" :key=\"user.id\">\n            <td>{{user.id}}</td>\n            <td>{{user.username}}</td>\n            <td>\n                <a href=\"#\" @click.pervent=\"del(user.id)\">删除</a>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<!-- javascript段 -->\n<script type=\"text/javascript\">\n// 设置全局根域名\nVue.http.options.root = 'http://tycoding.cn/';\n\n//设置全局表单提交格式\nVue.http.options.emulateJSON = true;\n\n// 实例化Vue\nnew Vue({\n    el: '',\n    data: {\n        username: '',\n        list: []\n    },\n    created: {\n        // 因为进入列表页面就需要在列表中显示出数据，那么就需要实现加载页面时自动加载findAll方法\n        // 而之前我们已经知道了，Vue的声明周期中，最早可以操作methods和data中的数据的阶段是：created生命周期函数阶段。\n        // 那么在这里调用findAll方法即可\n        this.findAll();\n    },\n    methods: {\n        // 查询所有列表数据\n        findAll(){\n            this.$http.get('api/findAll').then(result => {\n                this.list = result.body;\n            }),\n        },\n\n        // 添加功能\n        add(){\n            this.$http.post('api/add', {username: this.username}).then(result => {\n                if(result.body.status == 0){\n                    // 如果状态码为0就表示请求成功，这个状态码的值根据实际定\n                    // 请求成功，即添加了一条新的数据，那么需要重新刷新列表（不然新数据不能及时的更新到页面上）\n                    this.findAll()\n                }else{\n                    alert('添加失败');\n                }\n            })\n        },\n\n        //删除功能\n        del(id){\n            this.$http.get('api/del' + id).then(result => {\n                if(result.body.status == 0){\n                    //请求成功\n                    //刷新列表\n                    this.findAll();\n                }else{\n                    alert('删除失败');\n                }\n            })\n        }\n    }\n});\n</script>\n```\n\n如上我们已经完成了常见的几个功能，后面我们将会介绍基于SpringMVC框架，实现与Vue整合并重写增删改查功能。\n\n**注意：**\n- 1、首先我们需要配置根域名，且具体的AJAX请求URL不能添加'/'；如果是基于本地的Tomcat服务器的项目，可能不需要配置根域名，具体视情况而定\n- 2、实现查询所有列表数据功能，思路是：1、发送AJAX请求数据；2、将响应的数据赋值给data中的list集合this.list = result.body。注意响应数据是存放到body中的，具体请F12查看浏览器请求头信息和响应头信息。\n- 3、上面获取了数据库中的列表数据，我们需要渲染到页面上，那么点击进入列表页面，列表页面中应该立即显示数据库中的所有数据，即findAll方法应该在初始化页面的同时自动去调用，并将数据赋值给list列表。而我们之前讲过操作methods和data中参数的最早时机是created声明周期函数阶段，那么我们直接在created函数中调用findAll方法即可实现自动加载。\n- 4、添加功能的思路：\n    + 1、在data中先声明需要添加的参数；\n    + 2、在表单中用v-model绑定需要添加的参数；\n    + 3、点击添加功能按钮，绑定@click事件，在methods中写对应的方法；\n    + 4、发送AJAX请求，并在URL中拼接需要添加的数据（通过this.username）获取绑定的参数；\n    + 5、如果是post请求，还需要设置表单提交格式{emulateJSON: true}，而我们使用了全局配置就不需要再在post参数中指定了；\n    + 6、如果添加成功，就调用findAll方法重新刷新列表\n- 5、删除功能需要在绑定@click事件的时候将id传入。并且我们需要使用@click&middot;pervent来阻止&lt;a&gt;标签的默认跳转。\n- 6、上面仅是提供演示，具体操作由实际情况而定。\n\n\n","source":"_posts/Vue2.md","raw":"---\ntitle: Vue过滤器和Vue-resource\ncategories:\n    - Web前端\ndate: 2018-08-30\ntags:\n\t- 前端框架\n\t\n---\n\n### 过滤器\n\n\n之前我们学习了Vue的 **vue基本指令** 进阶学习，我们需要了解Vue的过滤器：Vue.js允许你自定义过滤器，可被用作一些常见元素的格式化。过滤器可以用在两个地方：mustache插值和v-bind表达式。\n用法：\n```bash\n{{ 过滤器名称 | function }}\n```\n**定义：**\nVue提供了两种方式创建过滤器：\n- 1、全局过滤器\n```bash\nVue.filter('过滤器名称', function(){})\n```\n- 2、私有过滤器\n```bash\nnew Vue()({\n    el: '',\n    data: {},\n    methods: {},\n    filters: {\n        过滤器名称: function(){}\n    }\n})\n```\n\n#### 全局过滤器\n```bash\n<h3>{{ msg | myFilters('时光') }}</h3>\n\nVue.filter('myFilters', function(data, pattern){\n    if(pattern == '时光'){\n        var old = data.substring(0,4);\n        return old + ',时光路口。';\n    }\n});\n```\n\n**解释：**\n如上：Vue提供的全局过滤器，直接使用Vue调用，而不是定义在Vue实例中\n- Vue.filter()中第一个参数是过滤器名称，第二个参数是function(){}\n- function(){}中还有两个参数，第一个参数是原始的值，第二个参数是你想给过滤器方法传递的值。\n\n#### 私有过滤器\n```bash\n<h3>{{ msg | myFilters('望月') }}</h3>\n\nvar vm2 = new Vue({\n    el: '#app2',\n    data: {\n        msg: 'loonycoder！'\n    },\n    methods: {},\n    filters: {\n\n        myFilters: function(data, pattern) {\n            if(pattern == '望月'){\n                var old = data.substring(0,4);\n                return old + ',loonycoder';\n            }\n        }\n})\n```\n私有过滤器和全局过滤器用法基本相同，仅仅是作用于不同而已。\n\n### 自定义指令\n\n#### 按键修饰符\n在我们搜索商品时，在一些网站中我们直接回车后立即进行搜索，而不是点击搜索按钮才会搜索，那么这个功能怎么实现呢？\n那么我们就需要了解Vue中提供的**按键修饰符**\n用法： @keyup.按键别名 = \"要调用的方法名\"\n\n**按键别名**\n> .enter\n> .tab\n> .esc\n> .delete\n> …\n\n**示例**\n```bash\n<input type=\"text\" @keyup.enter=\"open\">\n\nmethods: {\n    open(){\n        alert(\"弹出\");\n    }\n}\n```\n\n**自定义按键修饰符**\n如果Vue提供的按键修饰符不能满足你的需求，你也可以使用Vue提供的自定义按键修饰符来实现，因为每个键盘的按键都对应了一个键盘码值，比如F2对应的键盘码值是：113：\n用法：\n```bash\n<input type=\"text\" @keyup.f2=\"open\">\n\nVue.config.keyCodes.f2 = 113;   \n\nmethods: {\n    open(){\n        alert(\"弹出\");\n    }\n}\n```\n\n#### 获取文本焦点\n获取文本焦点使用了focus属性，那么我们需要定义一个v-focus指令\n```bash\nVue.directive('focus', {\n    bind: function(el) {},\n    inserted: function(el) {},\n    updated: function(el) {}\n});\n```\n\n如上，使用Vue.directive()实现定义全局指令，需要注意以下几点：\n- 1、在directive()方法中包含两个参数：\n > 参数1：指令的名称，注意，在定义的时候指令名称不需要加v-前缀，但是在使用的时候需要加v-前缀。\n > 参数2：是一个对象，这个对象包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作。\n\n**示例：**\n```bash\nVue.directive('focus', {\n\n});\n\n// 使用的时候使用： v-focus\n```\n\n- 2、在directive()函数的第二个参数中（对象）中又包含了三个实例方法：\n> bind: 当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次；但是需要知道元素绑定了这个指令，若涉及对DOM操作的，并不会立即执行，因为元素不会立即插入到DOM中。所以涉及对元素进行DOM相关操作的，不要定义到这个方法中。\n> inserted: 当元素插入到DOM的时候，会立即执行，并只触发一次。\n> updated: 当VNode更新的时候，会指定updated，可能触发多次。\n\n**示例：**\n```bash\nue.directive('focus', {\n    bind: function(el) {\n        el.focus()\n    }\n});\n\n// 调用\n<input type=\"text\" v-focus />\n```\n\n如上，其中bind函数的第一个参数永远是el，它表示绑定的那个元素，是一个原生的JS对象；这里我们调用了JS的focus方法\n\n##### 钩子函数\n指令定义函数提供了几个钩子函数（可选）：\n>bind\n>inserted\n>update\n>componentUpdated: 所在组件的VNode及其孩子的VNode全部更新的时候调用\n>unbind: 只调用一次，指令与元素解除绑定时调用\n\n**钩子函数参数**\n在上面使用directive()函数的时候我们已经介绍了一些常用的钩子函数，那么既然是函数，就可能需要进行传参，那么为了实现钩子函数传参，Vue提供了几个参数属性来实现对钩子函数参数的一些操作：\n- el: 指令所绑定的元素，可以用来直接操作DOM。\n- binding: 一个对象，包含以下属性：\n    - name: 指令名，不包含v-前缀\n    - value: 指令的绑定值，如v-focus=\"1 + 1\"，那么value=2。\n    - expression: 绑定值的字符串形式，如v-focus=\"1+1\"，那么experssion的值是1+1。\n    - …\n- …\n\n**示例：**\n实现在文本框中输入的数据颜色要为蓝色\n```bash\n<input type=\"text\" v-color=\"'blue'\">\n\n// 自定义设置颜色的指令\nVue.directive('color', {\n    bind: function(el, binding){\n        el.style.color = binding.value\n    }\n});\n```\n\n其中因为设计要获取值的操作，所以使用binding这个对象钩子函数参数来使用接收，那么：\n1、这个el就表示当前这个input文本框对象\n2、这个binding就表示v-color=\"'blue'\"指令传递的参数blue（因为使用''单引号即不是字符串）\n3、binding-value就是获取到v-color指令绑定的参数值是：blue，通过el.style.color表示设置这个文本框样式中的颜色属性\n\n##### 定义私有指令\n使用**私有指令**和**全局指令**的用法基本相同，我们参考上面讲过的**私有过滤器**和**全局过滤器**就能猜想到**私有指令**的用法：\n**示例：**\n```bash\n<p v-fontsize=\"'50px'\">私有指令</p>\n\nvar vm = new Vue({\n    el: '',\n    data: {},\n    methods: {},\n    filters: {},\n    directives: {\n        'fontsize': {\n            bind: function(el, binding){\n                el.style.fontSize = binding.value\n            }\n        }\n    }\n});\n```\n\n**自定义指令的简写形式**\n对于仅仅使用bind和update钩子函数的操作，可以进行下列的简写形式：\n```bash\n<p v-fontsize=\"'50px'\">私有指令</p>\n\nvar vm = new Vue({\n    el: '',\n    data: {},\n    methods: {},\n    filters: {},\n    directives: {\n        'fontsize': function(el, binding){\n            el.style.fontSize = binding.value\n        }\n    }\n});\n```\n\n#### 综合案例\n实现将列表数据渲染到表格中，并实现添加功能案例（包含上面讲到的所有技术的**实例**）：\n```bash\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style type=\"text/css\">\n    table {\n        min-height: 25px;\n        line-height: 25px;\n        text-align: center;\n        border-collapse: collapse;\n    }\n\n    table,\n    table tr th,\n    table tr td {\n        border: 1px solid #0094ff;\n        padding: 11px;\n    }\n    </style>\n</head>\n\n<body>\n    <div id=\"app\">\n        id:\n        <input type=\"text\" v-model=\"id\" v-focus v-color=\"'blue'\"> username:\n        <input type=\"text\" v-model=\"username\" @keyup.enter=\"add\">\n        <input type=\"button\" value=\"添加\" @click=\"add\">\n        <br/>\n        <br/>\n        <table>\n            <thead>\n                <tr>\n                    <th>id</th>\n                    <th>name</th>\n                    <th>date</th>\n                    <th>fun</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr v-for=\"user in list\" :key=\"user.id\">\n                    <td>{{user.id}}</td>\n                    <td>{{user.username}}</td>\n                    <td>{{user.time | dataFormat('') }}</td>\n                    <td><a href=\"#\" @click=\"del(user.id)\">删除</a></td>\n                </tr>\n            </tbody>\n        </table>\n        <p>未使用过滤器：{{ new Date() }}</p>\n        <p>使用全局过滤器：{{ new Date() | dataFormat('') }}</p>\n    </div>\n    <div id=\"app2\">\n        使用私有过滤器：{{ dt | dataFormat('')}}\n        <p v-fontsize=\"'50px'\">私有指令</p>\n    </div>\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n    // 自定义文本框获取焦点指令\n    // Vue.directive()定义全局指令，包含两个参数：\n    // 参数1：指令的名称，注意，在定义的时候指令的名称不需要加v-前缀，但是在使用的时候需要加v-focus\n    // 参数2：是一个对象，这个对象中包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作\n    Vue.directive('focus', {\n        // 注意，在下面的函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数是一个原生JS对象\n        bind: function(el) { //每当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次\n            // 注意：在元素绑定了指令时，还没有插入到DOM中去，这时候调用focus方法是没有作用的，因为一个元素，只有插入到DOM之后，才能获取焦点\n            // el.focus()\n        },\n        inserted: function(el) { // inserted表示元素插入到DOM中的时候，会执行,触发一次\n            el.focus()\n        },\n        updated: function(el) { // 当VNode更新的是否，会执行updated，可触发多次\n        }\n    });\n\n    // 自定义设置颜色的指令\n    Vue.directive('color', {\n        bind: function(el, binding) {\n            el.style.color = binding.value\n        }\n    });\n\n    // 自定义按键\n    Vue.config.keyCodes.f2 = 113;\n\n    // 演示私有过滤器\n    var vm2 = new Vue({\n        el: '#app2',\n        data: {\n            dt: new Date(),\n        },\n        methods: {\n            open() {\n                alert(\"弹出\");\n            }\n        },\n        filters: {\n            dataFormat: function(data, pattern) {\n                // 获取当前日期\n                var dt = new Date(data);\n\n                // 获取年月日\n                var y = dt.getFullYear();\n                var m = dt.getMonth() + 1;\n                var d = dt.getDate();\n\n                if (pattern.toLowerCase() == 'yyyy-mm-dd') {\n                    return `${y}-${m}-${d}`;\n                } else {\n                    var hh = dt.getHours();\n                    var mm = dt.getMinutes();\n                    var ss = dt.getSeconds();\n\n                    // es6中提供的 yyyy-mm-dd hh:mm:ss 的简写形式\n                    return `${y}-${m}-${d} ${hh}:${mm}:${ss}` + '-->私有';\n                }\n            }\n        },\n        // 自定义私有指令（简写形式）\n        directives: {\n            'fontsize': function(el, binding) {\n                el.style.fontSize = binding.value\n            }\n        }\n    });\n\n    // 全局过滤器\n    Vue.filter('dataFormat', function(data, pattern) {\n        // 获取当前日期\n        var dt = new Date(data);\n\n        // 获取年月日\n        var y = dt.getFullYear();\n        var m = dt.getMonth() + 1;\n        var d = dt.getDate();\n\n        if (pattern.toLowerCase() == 'yyyy-mm-dd') {\n            return `${y}-${m}-${d}`;\n        } else {\n            var hh = dt.getHours();\n            var mm = dt.getMinutes();\n            var ss = dt.getSeconds();\n\n            return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n        }\n    });\n\n    // 创建Vue实例\n    var vm = new Vue({\n        el: '#app',\n        data: {\n            id: '',\n            username: '',\n            list: [\n                { id: 1, username: '望月', time: new Date() },\n                { id: 2, username: 'loonycoder', time: new Date() }\n            ]\n        },\n        methods: {\n            add() {\n                var user = { id: this.id, username: this.username, time: new Date() };\n                this.list.push(user);\n            },\n            del(id) {\n                // some()是操作数组的方法，作用是循环数组，并当return true是就终止循环\n                // 其中的user理解为循环list元素的别名，i表示索引\n                this.list.some((user, i) => {\n                    if (user.id == id) {\n                        this.list.splice(i, 1);\n                        return true;\n                    }\n                })\n            }\n        }\n    });\n    </script>\n</body>\n</html>\n```\n\n#### Vue实例的生命周期\n- 什么是声明周期：从Vue实例创建、运行、到销毁期间，伴随着发生的事件的过程成为生命周期。\n- 生命周期钩子：就是声明周期事件的别名。\n- 主要的声明周期函数分类\n\n> 创建期间的声明周期函数：\n> * beforeCreate: 实例刚在内存中被创建，此时，还没有初始化好data和methods属性。\n> * created: 实例已经在内存中创建好，此时data和methods已经创建好，但还没有编译模板。\n> * beforeMount: 此时已经完成了模板的编译，但是还没有挂载到页面上。\n> * mounted: 此时，已经将编译好的模板，挂载到了页面指定的容器中。\n> 运行期间的声明周期函数:\n> * beforeUpdate: 状态更新之前执行此函数，此时的data数据是最新的，但是此时还没有开始渲染DOM节点\n> * updated: 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据都是最新的，界面已经被重新渲染好了。\n销毁期间的生命周期函数\n> * beforeDestory: 实例销毁之前调用，在这一步，实例仍然可以使用。\n> * destroyed: Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器都会被移除，所所有的子实例也会被销毁。\n\n##### beforeCreate\n此函数执行的时候，data和methods中的数据还没有初始化。\n![beforeCreate](/images/vue7.png)\n![beforeCreate](/images/vue8.png)\n\n##### created\n此函数中，data和methods都已经初始化好了，如果需要调用methods中的方法或操作data中的值最早就在created函数中操作。\n![created](/images/vue9.png)\n![created](/images/vue10.png)\n\n##### beforeMount\n此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去。\n![beforeMount](/images/vue11.png)\n![beforeMount](/images/vue12.png)\n\n##### mounted\n只要执行完了mounted，表示整个Vue实例已经初始化完毕了，此时组件已经进入了运行阶段。\n![mounted](/images/vue13.png)\n\n##### 图示\n![图示](/images/vue14.png)\n\n---\n\n### vue-resource实现请求提交\n作为一个后端开发者，我们需要的数据都应该是从数据库中取出来的，目前JSP页面越来越不常用，而更常用HTML页面，那么就体现出来类似Vue这种框架的好处了。\n下面我们就了解一下怎样使用Vue实现发送AJAX的请求：\n\n##### 配置\n首先使用Vue实现发送AJAX请求，我们需要导入一个包：\n```bash\nvue-resource.js\n```\n**Methods**\n```bash\nthis.$http.get('url', [options]).then(successCallback, errorCallback);\n\nthis.$http.post('url', [body], [options]).then(successCallback, errorCallback);\n```\n\n解释：\n- this表示的是当前Vue实例对象，而vue-resource.js提供了$http属性用来调用其内置的请求方法，并且vue-resource.js是基于vue.js的。\noptions是指可选的请求参数，就是你发送请求想要传递的参数。\n- then可以实现发送完请求后，通过其获取请求成功响应的数据\n- then中包含两个参数successCallback和errorCallback，这两个都是对象，我们可以通过其进行对相应数据的操作。\n\n##### 实例\n```bash\n<button @click=\"getInfo\">点击我</button>\n\nvar vm = new Vue({\n    el: '#app',\n    data: {},\n    methods: {\n        getInfo(){\n            this.$http.get('url').then(result => {\n                console.log(result.body);\n            })\n        }\n    }\n});\n```\n\n**解释：**\n当我们请求成功后，可以通过then来获取请求成功响应的数据，而可以通过.data或.body来获取响应data，而我们通常使用result.body来获取具体响应的参数。注意其中的result => {}是ES6中的写法。\n\n##### post请求\n**注意：** post请求常用于类似提交表单的功能，而对于提交表单，存在一个表单提交格式，默认是：application/x-wwww-form-urlencoded ；而通过Vue发起的post请求，默认没有表单格式，所以，有的服务器就处理不了。\n那么我们可以通过post方法的第三个参数：{ emulateJSON: true }来设置提交内容类型为普通表单数据格式。\n\n**示例：**\n```bash\nthis.$http.post('url', {}, { emulateJSON: true }).then(result => {\n    console.log(result.body)\n})\n```\n\n其他请求方法与上面的雷同，具体方法请参考官方文档。\n\n#### 请求接口根域名配置\n\n由于我们个人的项目可能是部署到本地的Tomcat服务器上的，可能不会涉及请求接口的域名配置，那么我们先看一个案例：\n发送post请求到服务器接口\n\n```bash\n...\n\nmethods: {\n    add(){\n        this.$http.post('http://tycoding.cn/api/add', {}, {emulateJSON: true}).then(result => {\n            \n        });\n    }\n}\n```\n\n如上，当我们发送请求的时候，URL路径需要写上域名地址<http://www.loonycoder.com>，然后才是请求路径/api/add，那么我们每次发送ajax请求都会需要写这个域名地址，就会显得比较麻烦，所以Vue-resource给我们提供了一种设置默认请求**根域名**的配置：\n```bash\nVue.http.options.root = 'http://www.loonycoder.com';\n```\n\n如上，就是一个全局的请求根域名配置。\n\n**注意**\n仅了解了上面的配置可能请求还会404，那么我们需要知道：\n> 如果我们通过了全局配置请求接口的根域名，那么每次发送HTTP请求时，请求的URL路径应该以相对域名开头，即前面不能带/： * 如果this.$http.post('/xxx')请求URL带了/，那么Vue就不会启用上面的全局请求根域名配置，就会404.\n* 如果前面不带/即：this.$http.post('xxx')，那么就会启用上面的全局请求根域名配置进行URL的拼接。\n\n##### 全局配置表单提交格式选项\n上面讲到了如果使用post请求提交表单，那么你应该指定{emulateJSON: true}参数，那么每次进行post请求都指定又会显得很麻烦，那么vue-resource也给我们提供了一个全局配置的方式：\n```bash\nVue.http.options.emulateJSON = true;\n```\n这样我们就不需要再post请求中再配置第三个参数了：\n```bash\nmethods: {\n    add(){\n        this.$http.post('http://tycoding.cn/api/add', {}).then(result => {\n            \n        });\n    }\n}\n```\n\n##### 实例\n请求后台并即时渲染表格数据的案例：\n```bash\n<!-- html段 -->\n<input type=\"text\" v-model=\"username\">\n<input type=\"button\" value=\"添加\" @click=\"add\">\n\n<table>\n    <tr>\n        <th>编号</th>\n        <th>用户名</th>\n        <th>操作</th>\n    </tr>\n    <tbody>\n        <tr v-for=\"user in list\" :key=\"user.id\">\n            <td>{{user.id}}</td>\n            <td>{{user.username}}</td>\n            <td>\n                <a href=\"#\" @click.pervent=\"del(user.id)\">删除</a>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<!-- javascript段 -->\n<script type=\"text/javascript\">\n// 设置全局根域名\nVue.http.options.root = 'http://tycoding.cn/';\n\n//设置全局表单提交格式\nVue.http.options.emulateJSON = true;\n\n// 实例化Vue\nnew Vue({\n    el: '',\n    data: {\n        username: '',\n        list: []\n    },\n    created: {\n        // 因为进入列表页面就需要在列表中显示出数据，那么就需要实现加载页面时自动加载findAll方法\n        // 而之前我们已经知道了，Vue的声明周期中，最早可以操作methods和data中的数据的阶段是：created生命周期函数阶段。\n        // 那么在这里调用findAll方法即可\n        this.findAll();\n    },\n    methods: {\n        // 查询所有列表数据\n        findAll(){\n            this.$http.get('api/findAll').then(result => {\n                this.list = result.body;\n            }),\n        },\n\n        // 添加功能\n        add(){\n            this.$http.post('api/add', {username: this.username}).then(result => {\n                if(result.body.status == 0){\n                    // 如果状态码为0就表示请求成功，这个状态码的值根据实际定\n                    // 请求成功，即添加了一条新的数据，那么需要重新刷新列表（不然新数据不能及时的更新到页面上）\n                    this.findAll()\n                }else{\n                    alert('添加失败');\n                }\n            })\n        },\n\n        //删除功能\n        del(id){\n            this.$http.get('api/del' + id).then(result => {\n                if(result.body.status == 0){\n                    //请求成功\n                    //刷新列表\n                    this.findAll();\n                }else{\n                    alert('删除失败');\n                }\n            })\n        }\n    }\n});\n</script>\n```\n\n如上我们已经完成了常见的几个功能，后面我们将会介绍基于SpringMVC框架，实现与Vue整合并重写增删改查功能。\n\n**注意：**\n- 1、首先我们需要配置根域名，且具体的AJAX请求URL不能添加'/'；如果是基于本地的Tomcat服务器的项目，可能不需要配置根域名，具体视情况而定\n- 2、实现查询所有列表数据功能，思路是：1、发送AJAX请求数据；2、将响应的数据赋值给data中的list集合this.list = result.body。注意响应数据是存放到body中的，具体请F12查看浏览器请求头信息和响应头信息。\n- 3、上面获取了数据库中的列表数据，我们需要渲染到页面上，那么点击进入列表页面，列表页面中应该立即显示数据库中的所有数据，即findAll方法应该在初始化页面的同时自动去调用，并将数据赋值给list列表。而我们之前讲过操作methods和data中参数的最早时机是created声明周期函数阶段，那么我们直接在created函数中调用findAll方法即可实现自动加载。\n- 4、添加功能的思路：\n    + 1、在data中先声明需要添加的参数；\n    + 2、在表单中用v-model绑定需要添加的参数；\n    + 3、点击添加功能按钮，绑定@click事件，在methods中写对应的方法；\n    + 4、发送AJAX请求，并在URL中拼接需要添加的数据（通过this.username）获取绑定的参数；\n    + 5、如果是post请求，还需要设置表单提交格式{emulateJSON: true}，而我们使用了全局配置就不需要再在post参数中指定了；\n    + 6、如果添加成功，就调用findAll方法重新刷新列表\n- 5、删除功能需要在绑定@click事件的时候将id传入。并且我们需要使用@click&middot;pervent来阻止&lt;a&gt;标签的默认跳转。\n- 6、上面仅是提供演示，具体操作由实际情况而定。\n\n\n","slug":"Vue2","published":1,"updated":"2020-02-21T15:28:45.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyv000jv9s63r16dxrr","content":"<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>之前我们学习了Vue的 <strong>vue基本指令</strong> 进阶学习，我们需要了解Vue的过滤器：Vue.js允许你自定义过滤器，可被用作一些常见元素的格式化。过滤器可以用在两个地方：mustache插值和v-bind表达式。<br>用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; 过滤器名称 | <span class=\"keyword\">function</span> &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>定义：</strong><br>Vue提供了两种方式创建过滤器：</p>\n<ul>\n<li>1、全局过滤器<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.filter(<span class=\"string\">'过滤器名称'</span>, <span class=\"function\"><span class=\"title\">function</span></span>()&#123;&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>2、私有过滤器<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue()(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">''</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    filters: &#123;</span><br><span class=\"line\">        过滤器名称: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"全局过滤器\"><a href=\"#全局过滤器\" class=\"headerlink\" title=\"全局过滤器\"></a>全局过滤器</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h3&gt;&#123;&#123; msg | myFilters(<span class=\"string\">'时光'</span>) &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.filter(<span class=\"string\">'myFilters'</span>, <span class=\"keyword\">function</span>(data, pattern)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pattern == <span class=\"string\">'时光'</span>)&#123;</span><br><span class=\"line\">        var old = data.substring(0,4);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> old + <span class=\"string\">',时光路口。'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong><br>如上：Vue提供的全局过滤器，直接使用Vue调用，而不是定义在Vue实例中</p>\n<ul>\n<li>Vue.filter()中第一个参数是过滤器名称，第二个参数是function(){}</li>\n<li>function(){}中还有两个参数，第一个参数是原始的值，第二个参数是你想给过滤器方法传递的值。</li>\n</ul>\n<h4 id=\"私有过滤器\"><a href=\"#私有过滤器\" class=\"headerlink\" title=\"私有过滤器\"></a>私有过滤器</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h3&gt;&#123;&#123; msg | myFilters(<span class=\"string\">'望月'</span>) &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm2 = new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app2'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        msg: <span class=\"string\">'loonycoder！'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    filters: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        myFilters: <span class=\"keyword\">function</span>(data, pattern) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pattern == <span class=\"string\">'望月'</span>)&#123;</span><br><span class=\"line\">                var old = data.substring(0,4);</span><br><span class=\"line\">                <span class=\"built_in\">return</span> old + <span class=\"string\">',loonycoder'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>私有过滤器和全局过滤器用法基本相同，仅仅是作用于不同而已。</p>\n<h3 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h3><h4 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h4><p>在我们搜索商品时，在一些网站中我们直接回车后立即进行搜索，而不是点击搜索按钮才会搜索，那么这个功能怎么实现呢？<br>那么我们就需要了解Vue中提供的<strong>按键修饰符</strong><br>用法： @keyup.按键别名 = “要调用的方法名”</p>\n<p><strong>按键别名</strong></p>\n<blockquote>\n<p>.enter<br>.tab<br>.esc<br>.delete<br>…</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> @keyup.enter=<span class=\"string\">\"open\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">open</span></span>()&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">\"弹出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>自定义按键修饰符</strong><br>如果Vue提供的按键修饰符不能满足你的需求，你也可以使用Vue提供的自定义按键修饰符来实现，因为每个键盘的按键都对应了一个键盘码值，比如F2对应的键盘码值是：113：<br>用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> @keyup.f2=<span class=\"string\">\"open\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.keyCodes.f2 = 113;   </span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">open</span></span>()&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">\"弹出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"获取文本焦点\"><a href=\"#获取文本焦点\" class=\"headerlink\" title=\"获取文本焦点\"></a>获取文本焦点</h4><p>获取文本焦点使用了focus属性，那么我们需要定义一个v-focus指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'focus'</span>, &#123;</span><br><span class=\"line\">    <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el) &#123;&#125;,</span><br><span class=\"line\">    inserted: <span class=\"keyword\">function</span>(el) &#123;&#125;,</span><br><span class=\"line\">    updated: <span class=\"keyword\">function</span>(el) &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如上，使用Vue.directive()实现定义全局指令，需要注意以下几点：</p>\n<ul>\n<li>1、在directive()方法中包含两个参数：<blockquote>\n<p>参数1：指令的名称，注意，在定义的时候指令名称不需要加v-前缀，但是在使用的时候需要加v-前缀。<br>参数2：是一个对象，这个对象包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'focus'</span>, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用的时候使用： v-focus</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2、在directive()函数的第二个参数中（对象）中又包含了三个实例方法：<blockquote>\n<p>bind: 当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次；但是需要知道元素绑定了这个指令，若涉及对DOM操作的，并不会立即执行，因为元素不会立即插入到DOM中。所以涉及对元素进行DOM相关操作的，不要定义到这个方法中。<br>inserted: 当元素插入到DOM的时候，会立即执行，并只触发一次。<br>updated: 当VNode更新的时候，会指定updated，可能触发多次。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ue.directive(<span class=\"string\">'focus'</span>, &#123;</span><br><span class=\"line\">    <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el) &#123;</span><br><span class=\"line\">        el.focus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-focus /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，其中bind函数的第一个参数永远是el，它表示绑定的那个元素，是一个原生的JS对象；这里我们调用了JS的focus方法</p>\n<h5 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h5><p>指令定义函数提供了几个钩子函数（可选）：</p>\n<blockquote>\n<p>bind<br>inserted<br>update<br>componentUpdated: 所在组件的VNode及其孩子的VNode全部更新的时候调用<br>unbind: 只调用一次，指令与元素解除绑定时调用</p>\n</blockquote>\n<p><strong>钩子函数参数</strong><br>在上面使用directive()函数的时候我们已经介绍了一些常用的钩子函数，那么既然是函数，就可能需要进行传参，那么为了实现钩子函数传参，Vue提供了几个参数属性来实现对钩子函数参数的一些操作：</p>\n<ul>\n<li>el: 指令所绑定的元素，可以用来直接操作DOM。</li>\n<li>binding: 一个对象，包含以下属性：<ul>\n<li>name: 指令名，不包含v-前缀</li>\n<li>value: 指令的绑定值，如v-focus=”1 + 1”，那么value=2。</li>\n<li>expression: 绑定值的字符串形式，如v-focus=”1+1”，那么experssion的值是1+1。</li>\n<li>…</li>\n</ul>\n</li>\n<li>…</li>\n</ul>\n<p><strong>示例：</strong><br>实现在文本框中输入的数据颜色要为蓝色</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-color=<span class=\"string\">\"'blue'\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 自定义设置颜色的指令</span><br><span class=\"line\">Vue.directive(<span class=\"string\">'color'</span>, &#123;</span><br><span class=\"line\">    <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el, binding)&#123;</span><br><span class=\"line\">        el.style.color = binding.value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其中因为设计要获取值的操作，所以使用binding这个对象钩子函数参数来使用接收，那么：<br>1、这个el就表示当前这个input文本框对象<br>2、这个binding就表示v-color=”‘blue’”指令传递的参数blue（因为使用’’单引号即不是字符串）<br>3、binding-value就是获取到v-color指令绑定的参数值是：blue，通过el.style.color表示设置这个文本框样式中的颜色属性</p>\n<h5 id=\"定义私有指令\"><a href=\"#定义私有指令\" class=\"headerlink\" title=\"定义私有指令\"></a>定义私有指令</h5><p>使用<strong>私有指令</strong>和<strong>全局指令</strong>的用法基本相同，我们参考上面讲过的<strong>私有过滤器</strong>和<strong>全局过滤器</strong>就能猜想到<strong>私有指令</strong>的用法：<br><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-fontsize=<span class=\"string\">\"'50px'\"</span>&gt;私有指令&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">''</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    filters: &#123;&#125;,</span><br><span class=\"line\">    directives: &#123;</span><br><span class=\"line\">        <span class=\"string\">'fontsize'</span>: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el, binding)&#123;</span><br><span class=\"line\">                el.style.fontSize = binding.value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>自定义指令的简写形式</strong><br>对于仅仅使用bind和update钩子函数的操作，可以进行下列的简写形式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-fontsize=<span class=\"string\">\"'50px'\"</span>&gt;私有指令&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">''</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    filters: &#123;&#125;,</span><br><span class=\"line\">    directives: &#123;</span><br><span class=\"line\">        <span class=\"string\">'fontsize'</span>: <span class=\"keyword\">function</span>(el, binding)&#123;</span><br><span class=\"line\">            el.style.fontSize = binding.value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"综合案例\"><a href=\"#综合案例\" class=\"headerlink\" title=\"综合案例\"></a>综合案例</h4><p>实现将列表数据渲染到表格中，并实现添加功能案例（包含上面讲到的所有技术的<strong>实例</strong>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">    &lt;style <span class=\"built_in\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><br><span class=\"line\">    table &#123;</span><br><span class=\"line\">        min-height: 25px;</span><br><span class=\"line\">        line-height: 25px;</span><br><span class=\"line\">        text-align: center;</span><br><span class=\"line\">        border-collapse: collapse;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    table,</span><br><span class=\"line\">    table tr th,</span><br><span class=\"line\">    table tr td &#123;</span><br><span class=\"line\">        border: 1px solid <span class=\"comment\">#0094ff;</span></span><br><span class=\"line\">        padding: 11px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">        id:</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"id\"</span> v-focus v-color=<span class=\"string\">\"'blue'\"</span>&gt; username:</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"username\"</span> @keyup.enter=<span class=\"string\">\"add\"</span>&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"添加\"</span> @click=<span class=\"string\">\"add\"</span>&gt;</span><br><span class=\"line\">        &lt;br/&gt;</span><br><span class=\"line\">        &lt;br/&gt;</span><br><span class=\"line\">        &lt;table&gt;</span><br><span class=\"line\">            &lt;thead&gt;</span><br><span class=\"line\">                &lt;tr&gt;</span><br><span class=\"line\">                    &lt;th&gt;id&lt;/th&gt;</span><br><span class=\"line\">                    &lt;th&gt;name&lt;/th&gt;</span><br><span class=\"line\">                    &lt;th&gt;date&lt;/th&gt;</span><br><span class=\"line\">                    &lt;th&gt;fun&lt;/th&gt;</span><br><span class=\"line\">                &lt;/tr&gt;</span><br><span class=\"line\">            &lt;/thead&gt;</span><br><span class=\"line\">            &lt;tbody&gt;</span><br><span class=\"line\">                &lt;tr v-for=<span class=\"string\">\"user in list\"</span> :key=<span class=\"string\">\"user.id\"</span>&gt;</span><br><span class=\"line\">                    &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">                    &lt;td&gt;&#123;&#123;user.username&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">                    &lt;td&gt;&#123;&#123;user.time | dataFormat(<span class=\"string\">''</span>) &#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">                    &lt;td&gt;&lt;a href=<span class=\"string\">\"#\"</span> @click=<span class=\"string\">\"del(user.id)\"</span>&gt;删除&lt;/a&gt;&lt;/td&gt;</span><br><span class=\"line\">                &lt;/tr&gt;</span><br><span class=\"line\">            &lt;/tbody&gt;</span><br><span class=\"line\">        &lt;/table&gt;</span><br><span class=\"line\">        &lt;p&gt;未使用过滤器：&#123;&#123; new Date() &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;使用全局过滤器：&#123;&#123; new Date() | dataFormat(<span class=\"string\">''</span>) &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app2\"</span>&gt;</span><br><span class=\"line\">        使用私有过滤器：&#123;&#123; dt | dataFormat(<span class=\"string\">''</span>)&#125;&#125;</span><br><span class=\"line\">        &lt;p v-fontsize=<span class=\"string\">\"'50px'\"</span>&gt;私有指令&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    // 自定义文本框获取焦点指令</span><br><span class=\"line\">    // Vue.directive()定义全局指令，包含两个参数：</span><br><span class=\"line\">    // 参数1：指令的名称，注意，在定义的时候指令的名称不需要加v-前缀，但是在使用的时候需要加v-focus</span><br><span class=\"line\">    // 参数2：是一个对象，这个对象中包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作</span><br><span class=\"line\">    Vue.directive(<span class=\"string\">'focus'</span>, &#123;</span><br><span class=\"line\">        // 注意，在下面的函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数是一个原生JS对象</span><br><span class=\"line\">        <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el) &#123; //每当指令绑定到元素上的时候，会立即执行这个<span class=\"built_in\">bind</span>函数，只执行一次</span><br><span class=\"line\">            // 注意：在元素绑定了指令时，还没有插入到DOM中去，这时候调用focus方法是没有作用的，因为一个元素，只有插入到DOM之后，才能获取焦点</span><br><span class=\"line\">            // el.focus()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        inserted: <span class=\"keyword\">function</span>(el) &#123; // inserted表示元素插入到DOM中的时候，会执行,触发一次</span><br><span class=\"line\">            el.focus()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        updated: <span class=\"keyword\">function</span>(el) &#123; // 当VNode更新的是否，会执行updated，可触发多次</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义设置颜色的指令</span><br><span class=\"line\">    Vue.directive(<span class=\"string\">'color'</span>, &#123;</span><br><span class=\"line\">        <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el, binding) &#123;</span><br><span class=\"line\">            el.style.color = binding.value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义按键</span><br><span class=\"line\">    Vue.config.keyCodes.f2 = 113;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 演示私有过滤器</span><br><span class=\"line\">    var vm2 = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app2'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            dt: new Date(),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">open</span></span>() &#123;</span><br><span class=\"line\">                alert(<span class=\"string\">\"弹出\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        filters: &#123;</span><br><span class=\"line\">            dataFormat: <span class=\"keyword\">function</span>(data, pattern) &#123;</span><br><span class=\"line\">                // 获取当前日期</span><br><span class=\"line\">                var dt = new Date(data);</span><br><span class=\"line\"></span><br><span class=\"line\">                // 获取年月日</span><br><span class=\"line\">                var y = dt.getFullYear();</span><br><span class=\"line\">                var m = dt.getMonth() + 1;</span><br><span class=\"line\">                var d = dt.getDate();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pattern.toLowerCase() == <span class=\"string\">'yyyy-mm-dd'</span>) &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">return</span> `<span class=\"variable\">$&#123;y&#125;</span>-<span class=\"variable\">$&#123;m&#125;</span>-<span class=\"variable\">$&#123;d&#125;</span>`;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    var hh = dt.getHours();</span><br><span class=\"line\">                    var mm = dt.getMinutes();</span><br><span class=\"line\">                    var ss = dt.getSeconds();</span><br><span class=\"line\"></span><br><span class=\"line\">                    // es6中提供的 yyyy-mm-dd hh:mm:ss 的简写形式</span><br><span class=\"line\">                    <span class=\"built_in\">return</span> `<span class=\"variable\">$&#123;y&#125;</span>-<span class=\"variable\">$&#123;m&#125;</span>-<span class=\"variable\">$&#123;d&#125;</span> <span class=\"variable\">$&#123;hh&#125;</span>:<span class=\"variable\">$&#123;mm&#125;</span>:<span class=\"variable\">$&#123;ss&#125;</span>` + <span class=\"string\">'--&gt;私有'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 自定义私有指令（简写形式）</span><br><span class=\"line\">        directives: &#123;</span><br><span class=\"line\">            <span class=\"string\">'fontsize'</span>: <span class=\"keyword\">function</span>(el, binding) &#123;</span><br><span class=\"line\">                el.style.fontSize = binding.value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 全局过滤器</span><br><span class=\"line\">    Vue.filter(<span class=\"string\">'dataFormat'</span>, <span class=\"keyword\">function</span>(data, pattern) &#123;</span><br><span class=\"line\">        // 获取当前日期</span><br><span class=\"line\">        var dt = new Date(data);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取年月日</span><br><span class=\"line\">        var y = dt.getFullYear();</span><br><span class=\"line\">        var m = dt.getMonth() + 1;</span><br><span class=\"line\">        var d = dt.getDate();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pattern.toLowerCase() == <span class=\"string\">'yyyy-mm-dd'</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> `<span class=\"variable\">$&#123;y&#125;</span>-<span class=\"variable\">$&#123;m&#125;</span>-<span class=\"variable\">$&#123;d&#125;</span>`;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            var hh = dt.getHours();</span><br><span class=\"line\">            var mm = dt.getMinutes();</span><br><span class=\"line\">            var ss = dt.getSeconds();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">return</span> `<span class=\"variable\">$&#123;y&#125;</span>-<span class=\"variable\">$&#123;m&#125;</span>-<span class=\"variable\">$&#123;d&#125;</span> <span class=\"variable\">$&#123;hh&#125;</span>:<span class=\"variable\">$&#123;mm&#125;</span>:<span class=\"variable\">$&#123;ss&#125;</span>`;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建Vue实例</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            id: <span class=\"string\">''</span>,</span><br><span class=\"line\">            username: <span class=\"string\">''</span>,</span><br><span class=\"line\">            list: [</span><br><span class=\"line\">                &#123; id: 1, username: <span class=\"string\">'望月'</span>, time: new Date() &#125;,</span><br><span class=\"line\">                &#123; id: 2, username: <span class=\"string\">'loonycoder'</span>, time: new Date() &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">add</span></span>() &#123;</span><br><span class=\"line\">                var user = &#123; id: this.id, username: this.username, time: new Date() &#125;;</span><br><span class=\"line\">                this.list.push(user);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            del(id) &#123;</span><br><span class=\"line\">                // some()是操作数组的方法，作用是循环数组，并当<span class=\"built_in\">return</span> <span class=\"literal\">true</span>是就终止循环</span><br><span class=\"line\">                // 其中的user理解为循环list元素的别名，i表示索引</span><br><span class=\"line\">                this.list.some((user, i) =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (user.id == id) &#123;</span><br><span class=\"line\">                        this.list.splice(i, 1);</span><br><span class=\"line\">                        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Vue实例的生命周期\"><a href=\"#Vue实例的生命周期\" class=\"headerlink\" title=\"Vue实例的生命周期\"></a>Vue实例的生命周期</h4><ul>\n<li>什么是声明周期：从Vue实例创建、运行、到销毁期间，伴随着发生的事件的过程成为生命周期。</li>\n<li>生命周期钩子：就是声明周期事件的别名。</li>\n<li>主要的声明周期函数分类</li>\n</ul>\n<blockquote>\n<p>创建期间的声明周期函数：</p>\n<ul>\n<li>beforeCreate: 实例刚在内存中被创建，此时，还没有初始化好data和methods属性。</li>\n<li>created: 实例已经在内存中创建好，此时data和methods已经创建好，但还没有编译模板。</li>\n<li>beforeMount: 此时已经完成了模板的编译，但是还没有挂载到页面上。</li>\n<li>mounted: 此时，已经将编译好的模板，挂载到了页面指定的容器中。<br>运行期间的声明周期函数:</li>\n<li>beforeUpdate: 状态更新之前执行此函数，此时的data数据是最新的，但是此时还没有开始渲染DOM节点</li>\n<li>updated: 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据都是最新的，界面已经被重新渲染好了。<br>销毁期间的生命周期函数</li>\n<li>beforeDestory: 实例销毁之前调用，在这一步，实例仍然可以使用。</li>\n<li>destroyed: Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器都会被移除，所所有的子实例也会被销毁。</li>\n</ul>\n</blockquote>\n<h5 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h5><p>此函数执行的时候，data和methods中的数据还没有初始化。<br><img src=\"/images/vue7.png\" alt=\"beforeCreate\"><br><img src=\"/images/vue8.png\" alt=\"beforeCreate\"></p>\n<h5 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h5><p>此函数中，data和methods都已经初始化好了，如果需要调用methods中的方法或操作data中的值最早就在created函数中操作。<br><img src=\"/images/vue9.png\" alt=\"created\"><br><img src=\"/images/vue10.png\" alt=\"created\"></p>\n<h5 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h5><p>此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去。<br><img src=\"/images/vue11.png\" alt=\"beforeMount\"><br><img src=\"/images/vue12.png\" alt=\"beforeMount\"></p>\n<h5 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h5><p>只要执行完了mounted，表示整个Vue实例已经初始化完毕了，此时组件已经进入了运行阶段。<br><img src=\"/images/vue13.png\" alt=\"mounted\"></p>\n<h5 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h5><p><img src=\"/images/vue14.png\" alt=\"图示\"></p>\n<hr>\n<h3 id=\"vue-resource实现请求提交\"><a href=\"#vue-resource实现请求提交\" class=\"headerlink\" title=\"vue-resource实现请求提交\"></a>vue-resource实现请求提交</h3><p>作为一个后端开发者，我们需要的数据都应该是从数据库中取出来的，目前JSP页面越来越不常用，而更常用HTML页面，那么就体现出来类似Vue这种框架的好处了。<br>下面我们就了解一下怎样使用Vue实现发送AJAX的请求：</p>\n<h5 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h5><p>首先使用Vue实现发送AJAX请求，我们需要导入一个包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue-resource.js</span><br></pre></td></tr></table></figure>\n<p><strong>Methods</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$http</span>.get(<span class=\"string\">'url'</span>, [options]).<span class=\"keyword\">then</span>(successCallback, errorCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">this.<span class=\"variable\">$http</span>.post(<span class=\"string\">'url'</span>, [body], [options]).<span class=\"keyword\">then</span>(successCallback, errorCallback);</span><br></pre></td></tr></table></figure>\n\n<p>解释：</p>\n<ul>\n<li>this表示的是当前Vue实例对象，而vue-resource.js提供了$http属性用来调用其内置的请求方法，并且vue-resource.js是基于vue.js的。<br>options是指可选的请求参数，就是你发送请求想要传递的参数。</li>\n<li>then可以实现发送完请求后，通过其获取请求成功响应的数据</li>\n<li>then中包含两个参数successCallback和errorCallback，这两个都是对象，我们可以通过其进行对相应数据的操作。</li>\n</ul>\n<h5 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button @click=<span class=\"string\">\"getInfo\"</span>&gt;点击我&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">getInfo</span></span>()&#123;</span><br><span class=\"line\">            this.<span class=\"variable\">$http</span>.get(<span class=\"string\">'url'</span>).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">                console.log(result.body);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong><br>当我们请求成功后，可以通过then来获取请求成功响应的数据，而可以通过.data或.body来获取响应data，而我们通常使用result.body来获取具体响应的参数。注意其中的result =&gt; {}是ES6中的写法。</p>\n<h5 id=\"post请求\"><a href=\"#post请求\" class=\"headerlink\" title=\"post请求\"></a>post请求</h5><p><strong>注意：</strong> post请求常用于类似提交表单的功能，而对于提交表单，存在一个表单提交格式，默认是：application/x-wwww-form-urlencoded ；而通过Vue发起的post请求，默认没有表单格式，所以，有的服务器就处理不了。<br>那么我们可以通过post方法的第三个参数：{ emulateJSON: true }来设置提交内容类型为普通表单数据格式。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$http</span>.post(<span class=\"string\">'url'</span>, &#123;&#125;, &#123; emulateJSON: <span class=\"literal\">true</span> &#125;).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">    console.log(result.body)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其他请求方法与上面的雷同，具体方法请参考官方文档。</p>\n<h4 id=\"请求接口根域名配置\"><a href=\"#请求接口根域名配置\" class=\"headerlink\" title=\"请求接口根域名配置\"></a>请求接口根域名配置</h4><p>由于我们个人的项目可能是部署到本地的Tomcat服务器上的，可能不会涉及请求接口的域名配置，那么我们先看一个案例：<br>发送post请求到服务器接口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">add</span></span>()&#123;</span><br><span class=\"line\">        this.<span class=\"variable\">$http</span>.post(<span class=\"string\">'http://tycoding.cn/api/add'</span>, &#123;&#125;, &#123;emulateJSON: <span class=\"literal\">true</span>&#125;).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上，当我们发送请求的时候，URL路径需要写上域名地址<a href=\"http://www.loonycoder.com\" target=\"_blank\" rel=\"noopener\">http://www.loonycoder.com</a>，然后才是请求路径/api/add，那么我们每次发送ajax请求都会需要写这个域名地址，就会显得比较麻烦，所以Vue-resource给我们提供了一种设置默认请求<strong>根域名</strong>的配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.http.options.root = <span class=\"string\">'http://www.loonycoder.com'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如上，就是一个全局的请求根域名配置。</p>\n<p><strong>注意</strong><br>仅了解了上面的配置可能请求还会404，那么我们需要知道：</p>\n<blockquote>\n<p>如果我们通过了全局配置请求接口的根域名，那么每次发送HTTP请求时，请求的URL路径应该以相对域名开头，即前面不能带/： * 如果this.$http.post(‘/xxx’)请求URL带了/，那么Vue就不会启用上面的全局请求根域名配置，就会404.</p>\n</blockquote>\n<ul>\n<li>如果前面不带/即：this.$http.post(‘xxx’)，那么就会启用上面的全局请求根域名配置进行URL的拼接。</li>\n</ul>\n<h5 id=\"全局配置表单提交格式选项\"><a href=\"#全局配置表单提交格式选项\" class=\"headerlink\" title=\"全局配置表单提交格式选项\"></a>全局配置表单提交格式选项</h5><p>上面讲到了如果使用post请求提交表单，那么你应该指定{emulateJSON: true}参数，那么每次进行post请求都指定又会显得很麻烦，那么vue-resource也给我们提供了一个全局配置的方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.http.options.emulateJSON = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>这样我们就不需要再post请求中再配置第三个参数了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">add</span></span>()&#123;</span><br><span class=\"line\">        this.<span class=\"variable\">$http</span>.post(<span class=\"string\">'http://tycoding.cn/api/add'</span>, &#123;&#125;).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h5><p>请求后台并即时渲染表格数据的案例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- html段 --&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"username\"</span>&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"添加\"</span> @click=<span class=\"string\">\"add\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">    &lt;tr&gt;</span><br><span class=\"line\">        &lt;th&gt;编号&lt;/th&gt;</span><br><span class=\"line\">        &lt;th&gt;用户名&lt;/th&gt;</span><br><span class=\"line\">        &lt;th&gt;操作&lt;/th&gt;</span><br><span class=\"line\">    &lt;/tr&gt;</span><br><span class=\"line\">    &lt;tbody&gt;</span><br><span class=\"line\">        &lt;tr v-for=<span class=\"string\">\"user in list\"</span> :key=<span class=\"string\">\"user.id\"</span>&gt;</span><br><span class=\"line\">            &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;&#123;&#123;user.username&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;</span><br><span class=\"line\">                &lt;a href=<span class=\"string\">\"#\"</span> @click.pervent=<span class=\"string\">\"del(user.id)\"</span>&gt;删除&lt;/a&gt;</span><br><span class=\"line\">            &lt;/td&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">    &lt;/tbody&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- javascript段 --&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">// 设置全局根域名</span><br><span class=\"line\">Vue.http.options.root = <span class=\"string\">'http://tycoding.cn/'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">//设置全局表单提交格式</span><br><span class=\"line\">Vue.http.options.emulateJSON = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">// 实例化Vue</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">''</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        username: <span class=\"string\">''</span>,</span><br><span class=\"line\">        list: []</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    created: &#123;</span><br><span class=\"line\">        // 因为进入列表页面就需要在列表中显示出数据，那么就需要实现加载页面时自动加载findAll方法</span><br><span class=\"line\">        // 而之前我们已经知道了，Vue的声明周期中，最早可以操作methods和data中的数据的阶段是：created生命周期函数阶段。</span><br><span class=\"line\">        // 那么在这里调用findAll方法即可</span><br><span class=\"line\">        this.findAll();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        // 查询所有列表数据</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">findAll</span></span>()&#123;</span><br><span class=\"line\">            this.<span class=\"variable\">$http</span>.get(<span class=\"string\">'api/findAll'</span>).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">                this.list = result.body;</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 添加功能</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">add</span></span>()&#123;</span><br><span class=\"line\">            this.<span class=\"variable\">$http</span>.post(<span class=\"string\">'api/add'</span>, &#123;username: this.username&#125;).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.body.status == 0)&#123;</span><br><span class=\"line\">                    // 如果状态码为0就表示请求成功，这个状态码的值根据实际定</span><br><span class=\"line\">                    // 请求成功，即添加了一条新的数据，那么需要重新刷新列表（不然新数据不能及时的更新到页面上）</span><br><span class=\"line\">                    this.findAll()</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    alert(<span class=\"string\">'添加失败'</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        //删除功能</span><br><span class=\"line\">        del(id)&#123;</span><br><span class=\"line\">            this.<span class=\"variable\">$http</span>.get(<span class=\"string\">'api/del'</span> + id).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.body.status == 0)&#123;</span><br><span class=\"line\">                    //请求成功</span><br><span class=\"line\">                    //刷新列表</span><br><span class=\"line\">                    this.findAll();</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    alert(<span class=\"string\">'删除失败'</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上我们已经完成了常见的几个功能，后面我们将会介绍基于SpringMVC框架，实现与Vue整合并重写增删改查功能。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>1、首先我们需要配置根域名，且具体的AJAX请求URL不能添加’/‘；如果是基于本地的Tomcat服务器的项目，可能不需要配置根域名，具体视情况而定</li>\n<li>2、实现查询所有列表数据功能，思路是：1、发送AJAX请求数据；2、将响应的数据赋值给data中的list集合this.list = result.body。注意响应数据是存放到body中的，具体请F12查看浏览器请求头信息和响应头信息。</li>\n<li>3、上面获取了数据库中的列表数据，我们需要渲染到页面上，那么点击进入列表页面，列表页面中应该立即显示数据库中的所有数据，即findAll方法应该在初始化页面的同时自动去调用，并将数据赋值给list列表。而我们之前讲过操作methods和data中参数的最早时机是created声明周期函数阶段，那么我们直接在created函数中调用findAll方法即可实现自动加载。</li>\n<li>4、添加功能的思路：<ul>\n<li>1、在data中先声明需要添加的参数；</li>\n<li>2、在表单中用v-model绑定需要添加的参数；</li>\n<li>3、点击添加功能按钮，绑定@click事件，在methods中写对应的方法；</li>\n<li>4、发送AJAX请求，并在URL中拼接需要添加的数据（通过this.username）获取绑定的参数；</li>\n<li>5、如果是post请求，还需要设置表单提交格式{emulateJSON: true}，而我们使用了全局配置就不需要再在post参数中指定了；</li>\n<li>6、如果添加成功，就调用findAll方法重新刷新列表</li>\n</ul>\n</li>\n<li>5、删除功能需要在绑定@click事件的时候将id传入。并且我们需要使用@click&middot;pervent来阻止&lt;a&gt;标签的默认跳转。</li>\n<li>6、上面仅是提供演示，具体操作由实际情况而定。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>之前我们学习了Vue的 <strong>vue基本指令</strong> 进阶学习，我们需要了解Vue的过滤器：Vue.js允许你自定义过滤器，可被用作一些常见元素的格式化。过滤器可以用在两个地方：mustache插值和v-bind表达式。<br>用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; 过滤器名称 | <span class=\"keyword\">function</span> &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>定义：</strong><br>Vue提供了两种方式创建过滤器：</p>\n<ul>\n<li>1、全局过滤器<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.filter(<span class=\"string\">'过滤器名称'</span>, <span class=\"function\"><span class=\"title\">function</span></span>()&#123;&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>2、私有过滤器<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue()(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">''</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    filters: &#123;</span><br><span class=\"line\">        过滤器名称: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"全局过滤器\"><a href=\"#全局过滤器\" class=\"headerlink\" title=\"全局过滤器\"></a>全局过滤器</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h3&gt;&#123;&#123; msg | myFilters(<span class=\"string\">'时光'</span>) &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.filter(<span class=\"string\">'myFilters'</span>, <span class=\"keyword\">function</span>(data, pattern)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pattern == <span class=\"string\">'时光'</span>)&#123;</span><br><span class=\"line\">        var old = data.substring(0,4);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> old + <span class=\"string\">',时光路口。'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong><br>如上：Vue提供的全局过滤器，直接使用Vue调用，而不是定义在Vue实例中</p>\n<ul>\n<li>Vue.filter()中第一个参数是过滤器名称，第二个参数是function(){}</li>\n<li>function(){}中还有两个参数，第一个参数是原始的值，第二个参数是你想给过滤器方法传递的值。</li>\n</ul>\n<h4 id=\"私有过滤器\"><a href=\"#私有过滤器\" class=\"headerlink\" title=\"私有过滤器\"></a>私有过滤器</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h3&gt;&#123;&#123; msg | myFilters(<span class=\"string\">'望月'</span>) &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm2 = new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app2'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        msg: <span class=\"string\">'loonycoder！'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    filters: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        myFilters: <span class=\"keyword\">function</span>(data, pattern) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pattern == <span class=\"string\">'望月'</span>)&#123;</span><br><span class=\"line\">                var old = data.substring(0,4);</span><br><span class=\"line\">                <span class=\"built_in\">return</span> old + <span class=\"string\">',loonycoder'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>私有过滤器和全局过滤器用法基本相同，仅仅是作用于不同而已。</p>\n<h3 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h3><h4 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h4><p>在我们搜索商品时，在一些网站中我们直接回车后立即进行搜索，而不是点击搜索按钮才会搜索，那么这个功能怎么实现呢？<br>那么我们就需要了解Vue中提供的<strong>按键修饰符</strong><br>用法： @keyup.按键别名 = “要调用的方法名”</p>\n<p><strong>按键别名</strong></p>\n<blockquote>\n<p>.enter<br>.tab<br>.esc<br>.delete<br>…</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> @keyup.enter=<span class=\"string\">\"open\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">open</span></span>()&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">\"弹出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>自定义按键修饰符</strong><br>如果Vue提供的按键修饰符不能满足你的需求，你也可以使用Vue提供的自定义按键修饰符来实现，因为每个键盘的按键都对应了一个键盘码值，比如F2对应的键盘码值是：113：<br>用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> @keyup.f2=<span class=\"string\">\"open\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.keyCodes.f2 = 113;   </span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">open</span></span>()&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">\"弹出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"获取文本焦点\"><a href=\"#获取文本焦点\" class=\"headerlink\" title=\"获取文本焦点\"></a>获取文本焦点</h4><p>获取文本焦点使用了focus属性，那么我们需要定义一个v-focus指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'focus'</span>, &#123;</span><br><span class=\"line\">    <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el) &#123;&#125;,</span><br><span class=\"line\">    inserted: <span class=\"keyword\">function</span>(el) &#123;&#125;,</span><br><span class=\"line\">    updated: <span class=\"keyword\">function</span>(el) &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如上，使用Vue.directive()实现定义全局指令，需要注意以下几点：</p>\n<ul>\n<li>1、在directive()方法中包含两个参数：<blockquote>\n<p>参数1：指令的名称，注意，在定义的时候指令名称不需要加v-前缀，但是在使用的时候需要加v-前缀。<br>参数2：是一个对象，这个对象包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'focus'</span>, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用的时候使用： v-focus</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2、在directive()函数的第二个参数中（对象）中又包含了三个实例方法：<blockquote>\n<p>bind: 当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次；但是需要知道元素绑定了这个指令，若涉及对DOM操作的，并不会立即执行，因为元素不会立即插入到DOM中。所以涉及对元素进行DOM相关操作的，不要定义到这个方法中。<br>inserted: 当元素插入到DOM的时候，会立即执行，并只触发一次。<br>updated: 当VNode更新的时候，会指定updated，可能触发多次。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ue.directive(<span class=\"string\">'focus'</span>, &#123;</span><br><span class=\"line\">    <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el) &#123;</span><br><span class=\"line\">        el.focus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-focus /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，其中bind函数的第一个参数永远是el，它表示绑定的那个元素，是一个原生的JS对象；这里我们调用了JS的focus方法</p>\n<h5 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h5><p>指令定义函数提供了几个钩子函数（可选）：</p>\n<blockquote>\n<p>bind<br>inserted<br>update<br>componentUpdated: 所在组件的VNode及其孩子的VNode全部更新的时候调用<br>unbind: 只调用一次，指令与元素解除绑定时调用</p>\n</blockquote>\n<p><strong>钩子函数参数</strong><br>在上面使用directive()函数的时候我们已经介绍了一些常用的钩子函数，那么既然是函数，就可能需要进行传参，那么为了实现钩子函数传参，Vue提供了几个参数属性来实现对钩子函数参数的一些操作：</p>\n<ul>\n<li>el: 指令所绑定的元素，可以用来直接操作DOM。</li>\n<li>binding: 一个对象，包含以下属性：<ul>\n<li>name: 指令名，不包含v-前缀</li>\n<li>value: 指令的绑定值，如v-focus=”1 + 1”，那么value=2。</li>\n<li>expression: 绑定值的字符串形式，如v-focus=”1+1”，那么experssion的值是1+1。</li>\n<li>…</li>\n</ul>\n</li>\n<li>…</li>\n</ul>\n<p><strong>示例：</strong><br>实现在文本框中输入的数据颜色要为蓝色</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-color=<span class=\"string\">\"'blue'\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 自定义设置颜色的指令</span><br><span class=\"line\">Vue.directive(<span class=\"string\">'color'</span>, &#123;</span><br><span class=\"line\">    <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el, binding)&#123;</span><br><span class=\"line\">        el.style.color = binding.value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其中因为设计要获取值的操作，所以使用binding这个对象钩子函数参数来使用接收，那么：<br>1、这个el就表示当前这个input文本框对象<br>2、这个binding就表示v-color=”‘blue’”指令传递的参数blue（因为使用’’单引号即不是字符串）<br>3、binding-value就是获取到v-color指令绑定的参数值是：blue，通过el.style.color表示设置这个文本框样式中的颜色属性</p>\n<h5 id=\"定义私有指令\"><a href=\"#定义私有指令\" class=\"headerlink\" title=\"定义私有指令\"></a>定义私有指令</h5><p>使用<strong>私有指令</strong>和<strong>全局指令</strong>的用法基本相同，我们参考上面讲过的<strong>私有过滤器</strong>和<strong>全局过滤器</strong>就能猜想到<strong>私有指令</strong>的用法：<br><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-fontsize=<span class=\"string\">\"'50px'\"</span>&gt;私有指令&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">''</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    filters: &#123;&#125;,</span><br><span class=\"line\">    directives: &#123;</span><br><span class=\"line\">        <span class=\"string\">'fontsize'</span>: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el, binding)&#123;</span><br><span class=\"line\">                el.style.fontSize = binding.value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>自定义指令的简写形式</strong><br>对于仅仅使用bind和update钩子函数的操作，可以进行下列的简写形式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-fontsize=<span class=\"string\">\"'50px'\"</span>&gt;私有指令&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">''</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    filters: &#123;&#125;,</span><br><span class=\"line\">    directives: &#123;</span><br><span class=\"line\">        <span class=\"string\">'fontsize'</span>: <span class=\"keyword\">function</span>(el, binding)&#123;</span><br><span class=\"line\">            el.style.fontSize = binding.value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"综合案例\"><a href=\"#综合案例\" class=\"headerlink\" title=\"综合案例\"></a>综合案例</h4><p>实现将列表数据渲染到表格中，并实现添加功能案例（包含上面讲到的所有技术的<strong>实例</strong>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">    &lt;style <span class=\"built_in\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><br><span class=\"line\">    table &#123;</span><br><span class=\"line\">        min-height: 25px;</span><br><span class=\"line\">        line-height: 25px;</span><br><span class=\"line\">        text-align: center;</span><br><span class=\"line\">        border-collapse: collapse;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    table,</span><br><span class=\"line\">    table tr th,</span><br><span class=\"line\">    table tr td &#123;</span><br><span class=\"line\">        border: 1px solid <span class=\"comment\">#0094ff;</span></span><br><span class=\"line\">        padding: 11px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">        id:</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"id\"</span> v-focus v-color=<span class=\"string\">\"'blue'\"</span>&gt; username:</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"username\"</span> @keyup.enter=<span class=\"string\">\"add\"</span>&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"添加\"</span> @click=<span class=\"string\">\"add\"</span>&gt;</span><br><span class=\"line\">        &lt;br/&gt;</span><br><span class=\"line\">        &lt;br/&gt;</span><br><span class=\"line\">        &lt;table&gt;</span><br><span class=\"line\">            &lt;thead&gt;</span><br><span class=\"line\">                &lt;tr&gt;</span><br><span class=\"line\">                    &lt;th&gt;id&lt;/th&gt;</span><br><span class=\"line\">                    &lt;th&gt;name&lt;/th&gt;</span><br><span class=\"line\">                    &lt;th&gt;date&lt;/th&gt;</span><br><span class=\"line\">                    &lt;th&gt;fun&lt;/th&gt;</span><br><span class=\"line\">                &lt;/tr&gt;</span><br><span class=\"line\">            &lt;/thead&gt;</span><br><span class=\"line\">            &lt;tbody&gt;</span><br><span class=\"line\">                &lt;tr v-for=<span class=\"string\">\"user in list\"</span> :key=<span class=\"string\">\"user.id\"</span>&gt;</span><br><span class=\"line\">                    &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">                    &lt;td&gt;&#123;&#123;user.username&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">                    &lt;td&gt;&#123;&#123;user.time | dataFormat(<span class=\"string\">''</span>) &#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">                    &lt;td&gt;&lt;a href=<span class=\"string\">\"#\"</span> @click=<span class=\"string\">\"del(user.id)\"</span>&gt;删除&lt;/a&gt;&lt;/td&gt;</span><br><span class=\"line\">                &lt;/tr&gt;</span><br><span class=\"line\">            &lt;/tbody&gt;</span><br><span class=\"line\">        &lt;/table&gt;</span><br><span class=\"line\">        &lt;p&gt;未使用过滤器：&#123;&#123; new Date() &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;使用全局过滤器：&#123;&#123; new Date() | dataFormat(<span class=\"string\">''</span>) &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app2\"</span>&gt;</span><br><span class=\"line\">        使用私有过滤器：&#123;&#123; dt | dataFormat(<span class=\"string\">''</span>)&#125;&#125;</span><br><span class=\"line\">        &lt;p v-fontsize=<span class=\"string\">\"'50px'\"</span>&gt;私有指令&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    // 自定义文本框获取焦点指令</span><br><span class=\"line\">    // Vue.directive()定义全局指令，包含两个参数：</span><br><span class=\"line\">    // 参数1：指令的名称，注意，在定义的时候指令的名称不需要加v-前缀，但是在使用的时候需要加v-focus</span><br><span class=\"line\">    // 参数2：是一个对象，这个对象中包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作</span><br><span class=\"line\">    Vue.directive(<span class=\"string\">'focus'</span>, &#123;</span><br><span class=\"line\">        // 注意，在下面的函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数是一个原生JS对象</span><br><span class=\"line\">        <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el) &#123; //每当指令绑定到元素上的时候，会立即执行这个<span class=\"built_in\">bind</span>函数，只执行一次</span><br><span class=\"line\">            // 注意：在元素绑定了指令时，还没有插入到DOM中去，这时候调用focus方法是没有作用的，因为一个元素，只有插入到DOM之后，才能获取焦点</span><br><span class=\"line\">            // el.focus()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        inserted: <span class=\"keyword\">function</span>(el) &#123; // inserted表示元素插入到DOM中的时候，会执行,触发一次</span><br><span class=\"line\">            el.focus()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        updated: <span class=\"keyword\">function</span>(el) &#123; // 当VNode更新的是否，会执行updated，可触发多次</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义设置颜色的指令</span><br><span class=\"line\">    Vue.directive(<span class=\"string\">'color'</span>, &#123;</span><br><span class=\"line\">        <span class=\"built_in\">bind</span>: <span class=\"keyword\">function</span>(el, binding) &#123;</span><br><span class=\"line\">            el.style.color = binding.value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 自定义按键</span><br><span class=\"line\">    Vue.config.keyCodes.f2 = 113;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 演示私有过滤器</span><br><span class=\"line\">    var vm2 = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app2'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            dt: new Date(),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">open</span></span>() &#123;</span><br><span class=\"line\">                alert(<span class=\"string\">\"弹出\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        filters: &#123;</span><br><span class=\"line\">            dataFormat: <span class=\"keyword\">function</span>(data, pattern) &#123;</span><br><span class=\"line\">                // 获取当前日期</span><br><span class=\"line\">                var dt = new Date(data);</span><br><span class=\"line\"></span><br><span class=\"line\">                // 获取年月日</span><br><span class=\"line\">                var y = dt.getFullYear();</span><br><span class=\"line\">                var m = dt.getMonth() + 1;</span><br><span class=\"line\">                var d = dt.getDate();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pattern.toLowerCase() == <span class=\"string\">'yyyy-mm-dd'</span>) &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">return</span> `<span class=\"variable\">$&#123;y&#125;</span>-<span class=\"variable\">$&#123;m&#125;</span>-<span class=\"variable\">$&#123;d&#125;</span>`;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    var hh = dt.getHours();</span><br><span class=\"line\">                    var mm = dt.getMinutes();</span><br><span class=\"line\">                    var ss = dt.getSeconds();</span><br><span class=\"line\"></span><br><span class=\"line\">                    // es6中提供的 yyyy-mm-dd hh:mm:ss 的简写形式</span><br><span class=\"line\">                    <span class=\"built_in\">return</span> `<span class=\"variable\">$&#123;y&#125;</span>-<span class=\"variable\">$&#123;m&#125;</span>-<span class=\"variable\">$&#123;d&#125;</span> <span class=\"variable\">$&#123;hh&#125;</span>:<span class=\"variable\">$&#123;mm&#125;</span>:<span class=\"variable\">$&#123;ss&#125;</span>` + <span class=\"string\">'--&gt;私有'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 自定义私有指令（简写形式）</span><br><span class=\"line\">        directives: &#123;</span><br><span class=\"line\">            <span class=\"string\">'fontsize'</span>: <span class=\"keyword\">function</span>(el, binding) &#123;</span><br><span class=\"line\">                el.style.fontSize = binding.value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 全局过滤器</span><br><span class=\"line\">    Vue.filter(<span class=\"string\">'dataFormat'</span>, <span class=\"keyword\">function</span>(data, pattern) &#123;</span><br><span class=\"line\">        // 获取当前日期</span><br><span class=\"line\">        var dt = new Date(data);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取年月日</span><br><span class=\"line\">        var y = dt.getFullYear();</span><br><span class=\"line\">        var m = dt.getMonth() + 1;</span><br><span class=\"line\">        var d = dt.getDate();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pattern.toLowerCase() == <span class=\"string\">'yyyy-mm-dd'</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> `<span class=\"variable\">$&#123;y&#125;</span>-<span class=\"variable\">$&#123;m&#125;</span>-<span class=\"variable\">$&#123;d&#125;</span>`;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            var hh = dt.getHours();</span><br><span class=\"line\">            var mm = dt.getMinutes();</span><br><span class=\"line\">            var ss = dt.getSeconds();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">return</span> `<span class=\"variable\">$&#123;y&#125;</span>-<span class=\"variable\">$&#123;m&#125;</span>-<span class=\"variable\">$&#123;d&#125;</span> <span class=\"variable\">$&#123;hh&#125;</span>:<span class=\"variable\">$&#123;mm&#125;</span>:<span class=\"variable\">$&#123;ss&#125;</span>`;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建Vue实例</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            id: <span class=\"string\">''</span>,</span><br><span class=\"line\">            username: <span class=\"string\">''</span>,</span><br><span class=\"line\">            list: [</span><br><span class=\"line\">                &#123; id: 1, username: <span class=\"string\">'望月'</span>, time: new Date() &#125;,</span><br><span class=\"line\">                &#123; id: 2, username: <span class=\"string\">'loonycoder'</span>, time: new Date() &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">add</span></span>() &#123;</span><br><span class=\"line\">                var user = &#123; id: this.id, username: this.username, time: new Date() &#125;;</span><br><span class=\"line\">                this.list.push(user);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            del(id) &#123;</span><br><span class=\"line\">                // some()是操作数组的方法，作用是循环数组，并当<span class=\"built_in\">return</span> <span class=\"literal\">true</span>是就终止循环</span><br><span class=\"line\">                // 其中的user理解为循环list元素的别名，i表示索引</span><br><span class=\"line\">                this.list.some((user, i) =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (user.id == id) &#123;</span><br><span class=\"line\">                        this.list.splice(i, 1);</span><br><span class=\"line\">                        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Vue实例的生命周期\"><a href=\"#Vue实例的生命周期\" class=\"headerlink\" title=\"Vue实例的生命周期\"></a>Vue实例的生命周期</h4><ul>\n<li>什么是声明周期：从Vue实例创建、运行、到销毁期间，伴随着发生的事件的过程成为生命周期。</li>\n<li>生命周期钩子：就是声明周期事件的别名。</li>\n<li>主要的声明周期函数分类</li>\n</ul>\n<blockquote>\n<p>创建期间的声明周期函数：</p>\n<ul>\n<li>beforeCreate: 实例刚在内存中被创建，此时，还没有初始化好data和methods属性。</li>\n<li>created: 实例已经在内存中创建好，此时data和methods已经创建好，但还没有编译模板。</li>\n<li>beforeMount: 此时已经完成了模板的编译，但是还没有挂载到页面上。</li>\n<li>mounted: 此时，已经将编译好的模板，挂载到了页面指定的容器中。<br>运行期间的声明周期函数:</li>\n<li>beforeUpdate: 状态更新之前执行此函数，此时的data数据是最新的，但是此时还没有开始渲染DOM节点</li>\n<li>updated: 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据都是最新的，界面已经被重新渲染好了。<br>销毁期间的生命周期函数</li>\n<li>beforeDestory: 实例销毁之前调用，在这一步，实例仍然可以使用。</li>\n<li>destroyed: Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器都会被移除，所所有的子实例也会被销毁。</li>\n</ul>\n</blockquote>\n<h5 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h5><p>此函数执行的时候，data和methods中的数据还没有初始化。<br><img src=\"/images/vue7.png\" alt=\"beforeCreate\"><br><img src=\"/images/vue8.png\" alt=\"beforeCreate\"></p>\n<h5 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h5><p>此函数中，data和methods都已经初始化好了，如果需要调用methods中的方法或操作data中的值最早就在created函数中操作。<br><img src=\"/images/vue9.png\" alt=\"created\"><br><img src=\"/images/vue10.png\" alt=\"created\"></p>\n<h5 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h5><p>此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去。<br><img src=\"/images/vue11.png\" alt=\"beforeMount\"><br><img src=\"/images/vue12.png\" alt=\"beforeMount\"></p>\n<h5 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h5><p>只要执行完了mounted，表示整个Vue实例已经初始化完毕了，此时组件已经进入了运行阶段。<br><img src=\"/images/vue13.png\" alt=\"mounted\"></p>\n<h5 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h5><p><img src=\"/images/vue14.png\" alt=\"图示\"></p>\n<hr>\n<h3 id=\"vue-resource实现请求提交\"><a href=\"#vue-resource实现请求提交\" class=\"headerlink\" title=\"vue-resource实现请求提交\"></a>vue-resource实现请求提交</h3><p>作为一个后端开发者，我们需要的数据都应该是从数据库中取出来的，目前JSP页面越来越不常用，而更常用HTML页面，那么就体现出来类似Vue这种框架的好处了。<br>下面我们就了解一下怎样使用Vue实现发送AJAX的请求：</p>\n<h5 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h5><p>首先使用Vue实现发送AJAX请求，我们需要导入一个包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue-resource.js</span><br></pre></td></tr></table></figure>\n<p><strong>Methods</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$http</span>.get(<span class=\"string\">'url'</span>, [options]).<span class=\"keyword\">then</span>(successCallback, errorCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">this.<span class=\"variable\">$http</span>.post(<span class=\"string\">'url'</span>, [body], [options]).<span class=\"keyword\">then</span>(successCallback, errorCallback);</span><br></pre></td></tr></table></figure>\n\n<p>解释：</p>\n<ul>\n<li>this表示的是当前Vue实例对象，而vue-resource.js提供了$http属性用来调用其内置的请求方法，并且vue-resource.js是基于vue.js的。<br>options是指可选的请求参数，就是你发送请求想要传递的参数。</li>\n<li>then可以实现发送完请求后，通过其获取请求成功响应的数据</li>\n<li>then中包含两个参数successCallback和errorCallback，这两个都是对象，我们可以通过其进行对相应数据的操作。</li>\n</ul>\n<h5 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button @click=<span class=\"string\">\"getInfo\"</span>&gt;点击我&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">getInfo</span></span>()&#123;</span><br><span class=\"line\">            this.<span class=\"variable\">$http</span>.get(<span class=\"string\">'url'</span>).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">                console.log(result.body);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong><br>当我们请求成功后，可以通过then来获取请求成功响应的数据，而可以通过.data或.body来获取响应data，而我们通常使用result.body来获取具体响应的参数。注意其中的result =&gt; {}是ES6中的写法。</p>\n<h5 id=\"post请求\"><a href=\"#post请求\" class=\"headerlink\" title=\"post请求\"></a>post请求</h5><p><strong>注意：</strong> post请求常用于类似提交表单的功能，而对于提交表单，存在一个表单提交格式，默认是：application/x-wwww-form-urlencoded ；而通过Vue发起的post请求，默认没有表单格式，所以，有的服务器就处理不了。<br>那么我们可以通过post方法的第三个参数：{ emulateJSON: true }来设置提交内容类型为普通表单数据格式。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$http</span>.post(<span class=\"string\">'url'</span>, &#123;&#125;, &#123; emulateJSON: <span class=\"literal\">true</span> &#125;).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">    console.log(result.body)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其他请求方法与上面的雷同，具体方法请参考官方文档。</p>\n<h4 id=\"请求接口根域名配置\"><a href=\"#请求接口根域名配置\" class=\"headerlink\" title=\"请求接口根域名配置\"></a>请求接口根域名配置</h4><p>由于我们个人的项目可能是部署到本地的Tomcat服务器上的，可能不会涉及请求接口的域名配置，那么我们先看一个案例：<br>发送post请求到服务器接口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">add</span></span>()&#123;</span><br><span class=\"line\">        this.<span class=\"variable\">$http</span>.post(<span class=\"string\">'http://tycoding.cn/api/add'</span>, &#123;&#125;, &#123;emulateJSON: <span class=\"literal\">true</span>&#125;).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上，当我们发送请求的时候，URL路径需要写上域名地址<a href=\"http://www.loonycoder.com\" target=\"_blank\" rel=\"noopener\">http://www.loonycoder.com</a>，然后才是请求路径/api/add，那么我们每次发送ajax请求都会需要写这个域名地址，就会显得比较麻烦，所以Vue-resource给我们提供了一种设置默认请求<strong>根域名</strong>的配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.http.options.root = <span class=\"string\">'http://www.loonycoder.com'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如上，就是一个全局的请求根域名配置。</p>\n<p><strong>注意</strong><br>仅了解了上面的配置可能请求还会404，那么我们需要知道：</p>\n<blockquote>\n<p>如果我们通过了全局配置请求接口的根域名，那么每次发送HTTP请求时，请求的URL路径应该以相对域名开头，即前面不能带/： * 如果this.$http.post(‘/xxx’)请求URL带了/，那么Vue就不会启用上面的全局请求根域名配置，就会404.</p>\n</blockquote>\n<ul>\n<li>如果前面不带/即：this.$http.post(‘xxx’)，那么就会启用上面的全局请求根域名配置进行URL的拼接。</li>\n</ul>\n<h5 id=\"全局配置表单提交格式选项\"><a href=\"#全局配置表单提交格式选项\" class=\"headerlink\" title=\"全局配置表单提交格式选项\"></a>全局配置表单提交格式选项</h5><p>上面讲到了如果使用post请求提交表单，那么你应该指定{emulateJSON: true}参数，那么每次进行post请求都指定又会显得很麻烦，那么vue-resource也给我们提供了一个全局配置的方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.http.options.emulateJSON = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>这样我们就不需要再post请求中再配置第三个参数了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">add</span></span>()&#123;</span><br><span class=\"line\">        this.<span class=\"variable\">$http</span>.post(<span class=\"string\">'http://tycoding.cn/api/add'</span>, &#123;&#125;).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h5><p>请求后台并即时渲染表格数据的案例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- html段 --&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"username\"</span>&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"添加\"</span> @click=<span class=\"string\">\"add\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">    &lt;tr&gt;</span><br><span class=\"line\">        &lt;th&gt;编号&lt;/th&gt;</span><br><span class=\"line\">        &lt;th&gt;用户名&lt;/th&gt;</span><br><span class=\"line\">        &lt;th&gt;操作&lt;/th&gt;</span><br><span class=\"line\">    &lt;/tr&gt;</span><br><span class=\"line\">    &lt;tbody&gt;</span><br><span class=\"line\">        &lt;tr v-for=<span class=\"string\">\"user in list\"</span> :key=<span class=\"string\">\"user.id\"</span>&gt;</span><br><span class=\"line\">            &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;&#123;&#123;user.username&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;</span><br><span class=\"line\">                &lt;a href=<span class=\"string\">\"#\"</span> @click.pervent=<span class=\"string\">\"del(user.id)\"</span>&gt;删除&lt;/a&gt;</span><br><span class=\"line\">            &lt;/td&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">    &lt;/tbody&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- javascript段 --&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">// 设置全局根域名</span><br><span class=\"line\">Vue.http.options.root = <span class=\"string\">'http://tycoding.cn/'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">//设置全局表单提交格式</span><br><span class=\"line\">Vue.http.options.emulateJSON = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">// 实例化Vue</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">''</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        username: <span class=\"string\">''</span>,</span><br><span class=\"line\">        list: []</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    created: &#123;</span><br><span class=\"line\">        // 因为进入列表页面就需要在列表中显示出数据，那么就需要实现加载页面时自动加载findAll方法</span><br><span class=\"line\">        // 而之前我们已经知道了，Vue的声明周期中，最早可以操作methods和data中的数据的阶段是：created生命周期函数阶段。</span><br><span class=\"line\">        // 那么在这里调用findAll方法即可</span><br><span class=\"line\">        this.findAll();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        // 查询所有列表数据</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">findAll</span></span>()&#123;</span><br><span class=\"line\">            this.<span class=\"variable\">$http</span>.get(<span class=\"string\">'api/findAll'</span>).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">                this.list = result.body;</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 添加功能</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">add</span></span>()&#123;</span><br><span class=\"line\">            this.<span class=\"variable\">$http</span>.post(<span class=\"string\">'api/add'</span>, &#123;username: this.username&#125;).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.body.status == 0)&#123;</span><br><span class=\"line\">                    // 如果状态码为0就表示请求成功，这个状态码的值根据实际定</span><br><span class=\"line\">                    // 请求成功，即添加了一条新的数据，那么需要重新刷新列表（不然新数据不能及时的更新到页面上）</span><br><span class=\"line\">                    this.findAll()</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    alert(<span class=\"string\">'添加失败'</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        //删除功能</span><br><span class=\"line\">        del(id)&#123;</span><br><span class=\"line\">            this.<span class=\"variable\">$http</span>.get(<span class=\"string\">'api/del'</span> + id).<span class=\"keyword\">then</span>(result =&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.body.status == 0)&#123;</span><br><span class=\"line\">                    //请求成功</span><br><span class=\"line\">                    //刷新列表</span><br><span class=\"line\">                    this.findAll();</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    alert(<span class=\"string\">'删除失败'</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上我们已经完成了常见的几个功能，后面我们将会介绍基于SpringMVC框架，实现与Vue整合并重写增删改查功能。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>1、首先我们需要配置根域名，且具体的AJAX请求URL不能添加’/‘；如果是基于本地的Tomcat服务器的项目，可能不需要配置根域名，具体视情况而定</li>\n<li>2、实现查询所有列表数据功能，思路是：1、发送AJAX请求数据；2、将响应的数据赋值给data中的list集合this.list = result.body。注意响应数据是存放到body中的，具体请F12查看浏览器请求头信息和响应头信息。</li>\n<li>3、上面获取了数据库中的列表数据，我们需要渲染到页面上，那么点击进入列表页面，列表页面中应该立即显示数据库中的所有数据，即findAll方法应该在初始化页面的同时自动去调用，并将数据赋值给list列表。而我们之前讲过操作methods和data中参数的最早时机是created声明周期函数阶段，那么我们直接在created函数中调用findAll方法即可实现自动加载。</li>\n<li>4、添加功能的思路：<ul>\n<li>1、在data中先声明需要添加的参数；</li>\n<li>2、在表单中用v-model绑定需要添加的参数；</li>\n<li>3、点击添加功能按钮，绑定@click事件，在methods中写对应的方法；</li>\n<li>4、发送AJAX请求，并在URL中拼接需要添加的数据（通过this.username）获取绑定的参数；</li>\n<li>5、如果是post请求，还需要设置表单提交格式{emulateJSON: true}，而我们使用了全局配置就不需要再在post参数中指定了；</li>\n<li>6、如果添加成功，就调用findAll方法重新刷新列表</li>\n</ul>\n</li>\n<li>5、删除功能需要在绑定@click事件的时候将id传入。并且我们需要使用@click&middot;pervent来阻止&lt;a&gt;标签的默认跳转。</li>\n<li>6、上面仅是提供演示，具体操作由实际情况而定。</li>\n</ul>\n"},{"title":"Spring框架——深入理解AOP实现原理","date":"2018-11-06T16:00:00.000Z","_content":"> 阅读这篇文章前，最好有代理模式的基础，以及了解关于Spring扩展点例如BeanPostProcessor和如何使用自定义标签集成Spring，这些文章在我的博客里都能找到。当然，也最好有使用AOP的经验，这篇文章不会讲解如何使用AOP。\n\n![Spring](/images/spring_logo.jpg)\n\n### AOP简介\n说到AOP，其实这是一个**面向方面的编程思想** ，它解决了OOP的一些弊端，例如我们需要为**多个不具有继承关系的类引入一个公共行为**， 比如说日志、权限验证、事务管理等等，我们需要将这些代码**重复的添加**到一系列的类中，将**产生大量的重复代码**，如果需要修改，将在每个类中去进行修改，**不便于维护**，代码的**侵入性极高**。所以就有了AOP这样面向方面编程的编程思想，其功能可以为每个需要的类**加入共同的行为**，如果需要修改，只需要修改切面中的代码，改一处等于改多处，并且便于编程，写一个切面类即可达到在每个类中加入重复代码的目的。\n\n阅读此篇文章，你将了解Spring是**如何实现AOP**（前置通知、后置通知、环绕通知），由于Spring中的事务管理是基于AOP的功能来做的，所以你将更好的能理解Spring是如何将事务统一管理起来的。\n\n---\n\n### 自定义标签开启AOP\n\n只要用过AOP都知道，如果需要使用AOP，需要在配置文件中写这样一段配置：\n```bash\n<aop:aspectj-autoproxy />\n```\n只有写了这段配置才可以开启AOP功能，那么这个自定义标签又做了什么呢？在上一篇讲解自定义标签的文章中详细讲到了，此时我们需要关注其标签头aop去寻找对应的命名空间：\n```bash\nxmlns:aop=\"http://www.springframework.org/schema/aop\"\n```\n全局搜索命名空间<code>&lt;http\\\\://www.springframework.org/schema/aop&gt;</code>，注意http后加一个“\\” ，可以找到**spring.handlers**文件中对应的handler类：\n```bash\nhttp\\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler\n```\n这样就找到了命名空间对应的handler：\n```bash\npublic class AopNamespaceHandler extends NamespaceHandlerSupport {\n\n  /**\n   * Register the {@link BeanDefinitionParser BeanDefinitionParsers} for the\n   * '{@code config}', '{@code spring-configured}', '{@code aspectj-autoproxy}'\n   * and '{@code scoped-proxy}' tags.\n   */\n  @Override\n  public void init() {\n    // In 2.0 XSD as well as in 2.1 XSD.\n    registerBeanDefinitionParser(\"config\", new ConfigBeanDefinitionParser());\n    registerBeanDefinitionParser(\"aspectj-autoproxy\", new AspectJAutoProxyBeanDefinitionParser());\n    registerBeanDefinitionDecorator(\"scoped-proxy\", new ScopedProxyBeanDefinitionDecorator());\n\n    // Only in 2.0 XSD: moved to context namespace as of 2.1\n    registerBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser());\n  }\n}\n```\n回到开头配置自定义标签，我们使用了<code>aspectj-autoproxy</code>这个Parser。在init方法中，我们找到<code>aspectj-autoproxy</code>对应的Parser是<code>AspectJAutoProxyBeanDefinitionParser</code>这个类：\n```bash\n@Override\n@Nullable\n//我们只关注解析的主方法，parse方法\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    //注册一个类到IOC容器中\n    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);\n    extendBeanDefinition(element, parserContext);\n    return null;\n}\n```\n\n---\n\n### 注册AnnotationAwareAspectJAutoProxyCreator\n<code>AnnotationAwareAspectJAutoProxyCreator</code>是实现AOP功能的主要类，我们先来看看这个类的结构：\n![spring](/images/spring-aop1.png)\n此类实现了<code>BeanPostProcessor</code>，稍后将关注其后置处理Bean的方法**postProcessAfterInitialization**，并且实现了<code>BeanFactorAware</code>接口，此类将取得并存有一个<code>BeanFactory</code>实例对象。\n回到主线，关注注册此类的方法：\n```bash\npublic static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(\n    ParserContext parserContext, Element sourceElement) {\n//将一个类作为Bean注册到IOC容器中\n    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(\n        parserContext.getRegistry(), parserContext.extractSource(sourceElement));\n    //处理proxy-target-class与expose-proxy属性\n    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);\n    //注册组件并通知\n    registerComponentIfNecessary(beanDefinition, parserContext);\n}\n```\n其中，在注册这个类的过程中主要完成了3件事：\n1. 注册<code>AnnotationAwareAspectJAutoProxyCreator：</code>\n```bash\n@Nullable\npublic static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry,\n                                                                                  @Nullable Object source) {\n//将AnnotationAwareAspectJAutoProxyCreator这个类注册到IOC容器中\n    return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);\n}\n```\n```bash\n@Nullable\nprivate static BeanDefinition registerOrEscalateApcAsRequired(Class<?> cls, BeanDefinitionRegistry registry,\n                                                              @Nullable Object source) {\n\n    Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\n    //如果IOC容器中已经存在了此类型的Bean，则需要判断优先级\n    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\n        //获取此类的BeanDefinition信息\n        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\n        //如果此Bean的ClassName与AnnotationAwareAspectJAutoProxyCreator类的\n        //ClassName不同的话，判断优先级\n        if (!cls.getName().equals(apcDefinition.getBeanClassName())) {\n            int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());\n            int requiredPriority = findPriorityForClass(cls);\n            //如果已存在Bean优先级小于Creator的优先级\n            if (currentPriority < requiredPriority) {\n                //将ClassName替换成Creator\n                apcDefinition.setBeanClassName(cls.getName());\n            }\n        }\n        //不进行注册，因为已经注册了\n        return null;\n    }\n\n    //如果到这里，说明IOC容器中没有配置对应Creator\n    //使用Crearir的Class构造一个BeanDefinition\n    RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);\n    beanDefinition.setSource(source);\n    //配置依赖属性order，将其设置为最高优先级\n    beanDefinition.getPropertyValues().add(\"order\", Ordered.HIGHEST_PRECEDENCE);\n    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    //将设置好属性的BeanDefinition注册进IOC容器中\n    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);\n    return beanDefinition;\n}\n```\n2. 处理**proxy-target-class**与**expose-proxy**属性\n```bash\nprivate static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, @Nullable Element sourceElement) {\n    if (sourceElement != null) {\n        boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));\n        //处理proxy-target-class属性\n        if (proxyTargetClass) {\n            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);\n        }\n        boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));\n        //处理expose-proxy属性\n        if (exposeProxy) {\n            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);\n        }\n    }\n}\n```\n其中设置属性的过程：\n```bash\npublic static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) {\n    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\n        //根据之前注册的BeanName取出Creator\n        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\n        //将Creator的BeanDefinition的属性proxyTargetClass设置为true\n        definition.getPropertyValues().add(\"proxyTargetClass\", Boolean.TRUE);\n    }\n}\n\npublic static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) {\n    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\n        //根据之前注册的BeanName取出Creator\n        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\n        //将Creator的BeanDefinition的属性exposeProxy设置为true\n        definition.getPropertyValues().add(\"exposeProxy\", Boolean.TRUE);\n    }\n}\n```\n\n- **proxy-target-class**：在Spring的AOP中，默认的如果目标类实现了至少一个接口，将使用**JDK动态代理**实现AOP，否则使用**CGLib动态代理**实现AOP，如果希望AOP都使用CGLib实现，你就可以设置proxy-target-class属性为**true**，但要注意几个问题：\n\n1)**无法对final的方法进行动态代理**，原因很简单，CGLib使用继承实现，final方法无法重写，所以final的方法不能应用AOP。\n2)需要配置CGLib的JAR包\n- **expose-proxy**：在讲解事务的那篇文章中有提到，如果一个类中的事务A方法调用了同一个类中的事务B方法，**B方法将没有事务**，这个道理在AOP中也是这样的，相同类下的不同方法互相调用，内部方法将无法被应用通知（无法进行AOP），此时你需要将**expose-proxy属性设置为true**，暴露一个代理类（此属性的原理在下面会有详细讲解），然后在A方法中需要调用B方法的话需要这样写：\n```bash\npublic class Service{\n    public void A(){\n        ((Service)AopContext.currentProxy()).B();\n    }\n\n    public void B(){\n    //do something...\n    }\n}\n```\n这样，B方法就算再A方法内也可以被AOP。其中<code>AopContext</code>是存放线程变量的类，形象的称之为**AOP的上下文**。\n\n---\n\n### 实现AOP代理\n#### 创建AOP代理\n上面，自定义标签的配置完成了对**Creator类的自动注册**，我们可以知道，此类实现了<code>BeanPostProcessor</code>接口，将会在IOC容器初始化每个Bean时都调用此类的**postProcessAfterInitialization**方法，此方法即为AOP代理的入口，此方法在抽象父类<code>AbstractAutoProxyCreator</code>实现：\n```bash\n@Override\npublic Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException {\n    if (bean != null) {\n        //先从缓存中获取Key，由要代理的Bean的Class与benaName组成\n        Object cacheKey = getCacheKey(bean.getClass(), beanName);\n        //判断是否是过早暴露的Bean，此概念在讲IOC解决循环依赖中有提到\n        //如果是过早暴露的Bean，则此时连依赖注入都没有完成，则不对其进行代理\n        //待其真正初始化之后再尝试代理\n        if (!this.earlyProxyReferences.contains(cacheKey)) {\n            //如果符合条件进行AOP代理\n            return wrapIfNecessary(bean, beanName, cacheKey);\n        }\n    }\n    return bean;\n}\n```\n```bash\nprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n    //如果先前已经处理过的，不进行处理\n    if (StringUtils.hasLength(beanName) && this.targetSourcedBeans.contains(beanName)) {\n        return bean;\n    }\n    //如果此Bean已经被标记为无法代理，不进行处理\n    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n        return bean;\n    }\n    //如果Bean为AOP类的类型，或是需要跳过的类型，不进行处理\n    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n        //标记为不代理\n        this.advisedBeans.put(cacheKey, Boolean.FALSE);\n        return bean;\n    }\n\n    // Create proxy if we have advice.\n    //寻找符合此Bean的增强方法（通知方法）\n    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n    //如果寻找到的增强方法列表不为空，也就是不为DO_NOT_PROXY\n    if (specificInterceptors != DO_NOT_PROXY) {\n        //标记为已代理\n        this.advisedBeans.put(cacheKey, Boolean.TRUE);\n        //根据找到的增强方法，对此Bean进行动态代理\n        Object proxy = createProxy(\n            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n        this.proxyTypes.put(cacheKey, proxy.getClass());\n        //将代理对象作为Bean返回给IOC容器\n        return proxy;\n    }\n  //如果走到这里，说明代理失败，标记为代理失败\n    this.advisedBeans.put(cacheKey, Boolean.FALSE);\n    return bean;\n}\n```\n文章到了这里，就已经基本完成AOP的实现了，剩下我们需要关注的就是两件事：\n- 如何寻找符合Bean的增强器\n- 如何对Bean创建动态代理\n\n#### 寻找所有的增强器\n\n```bash\n@Override\n@Nullable\nprotected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) {\n    //寻找适合的Advisor\n    List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);\n    if (advisors.isEmpty()) {\n        return DO_NOT_PROXY;\n    }\n    return advisors.toArray();\n}\n```\n这里有一个<code>Advisor</code>的概念，其中Advisor**封装了切点信息与advise通知方法等等信息。**\n```bash\nprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n    //寻找所有适用的Advisor\n    List<Advisor> candidateAdvisors = findCandidateAdvisors();\n    //从所有Advisor中选出适合被当前Bean使用的Advisor\n    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n```\n\n##### 寻找已存在的Advisor\n首先，执行下面的方法寻找合适的<code>Advisor</code>（此方法在子类<code>Creator</code>中得到实现）：\n```bash\n@Override\nprotected List<Advisor> findCandidateAdvisors() {\n    // Add all the Spring advisors found according to superclass rules.\n    //首先调用父类findCandidateAdvisors的方法寻找在IOC容器中的Advisor类型的Bean\n    List<Advisor> advisors = super.findCandidateAdvisors();\n    // Build Advisors for all AspectJ aspects in the bean factory.\n    if (this.aspectJAdvisorsBuilder != null) {\n        //寻找注解的Advisor\n        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());\n    }\n    return advisors;\n}\n```\n先调用父类的**findCandidateAdvisors**方法寻找所有的<code>Advisor</code>：\n```bash\nprotected List<Advisor> findCandidateAdvisors() {\n    Assert.state(this.advisorRetrievalHelper != null, \"No BeanFactoryAdvisorRetrievalHelper available\");\n    //委派Helper类去寻找\n    return this.advisorRetrievalHelper.findAdvisorBeans();\n}\n```\n```bash\npublic List<Advisor> findAdvisorBeans() {\n    // Determine list of advisor bean names, if not cached already.\n    String[] advisorNames = null;\n    synchronized (this) {\n        //先从缓存中取\n        advisorNames = this.cachedAdvisorBeanNames;\n        //缓存中若没有再去IOC容器中取\n        if (advisorNames == null) {\n            // Do not initialize FactoryBeans here: We need to leave all regular beans\n            // uninitialized to let the auto-proxy creator apply to them!\n            //从IOC容器中寻找所有Advisor类型的BeanName\n            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n                this.beanFactory, Advisor.class, true, false);\n            //放入缓存\n            this.cachedAdvisorBeanNames = advisorNames;\n        }\n    }\n    //没有找到，返回空\n    if (advisorNames.length == 0) {\n        return new LinkedList<>();\n    }\n\n    List<Advisor> advisors = new LinkedList<>();\n    //遍历上面得到的所有BeanName\n    for (String name : advisorNames) {\n        if (isEligibleBean(name)) {\n            if (this.beanFactory.isCurrentlyInCreation(name)) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Skipping currently created advisor '\" + name + \"'\");\n                }\n            }\n            else {\n                try {\n                    //根据BeanName从IOC获取Bean实例并存入List中\n                    advisors.add(this.beanFactory.getBean(name, Advisor.class));\n                }\n                //catch方法 略...\n            }\n        }\n    }\n    return advisors;\n}\n```\n注意此时仅仅是**只获取IOC容器中那些Advisor类型的Bean作为Advisor**，而在我们注解配置AOP的方式中并不是配置Advisor类的，下面会说到如何获取所有打了注解的切面，这里只是尝试去IOC容器中找是否存在这样的类，有的话也不会漏掉。\n\n##### 寻找所有注解的Advisor\n现在我们拿到了部分的Advisor，回到我们主类<code>AnnotationAwareAspectJAutoProxyCreatorS</code>的**findCandidateAdvisors** 方法，此时将委派<code>BeanFactoryAspectJAdvisorsBuilder</code>类去执行**buildAspectJAdvisors**方法，将继续获取被注解了的Advisor：\n```bash\n@Override\nprotected List<Advisor> findCandidateAdvisors() {\n    // Add all the Spring advisors found according to superclass rules.\n    List<Advisor> advisors = super.findCandidateAdvisors();\n    // Build Advisors for all AspectJ aspects in the bean factory.\n    if (this.aspectJAdvisorsBuilder != null) {\n        //委派BeanFactoryAspectJAdvisorsBuilder去寻找注解Advisor\n        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());\n    }\n    return advisors;\n}\n```\n```bash\npublic List<Advisor> buildAspectJAdvisors() {\n    List<String> aspectNames = this.aspectBeanNames;\n\n    if (aspectNames == null) {\n        synchronized (this) {\n            aspectNames = this.aspectBeanNames;\n            //双重加锁保证在并发情况下不会寻找两次\n            if (aspectNames == null) {\n                List<Advisor> advisors = new LinkedList<>();\n                aspectNames = new LinkedList<>();\n                //从IOC容器中获取所有的BeanName\n                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n                    this.beanFactory, Object.class, true, false);\n                //遍历所有的BeanName\n                for (String beanName : beanNames) {\n                    if (!isEligibleBean(beanName)) {\n                        continue;\n                    }\n                    // We must be careful not to instantiate beans eagerly as in this case they\n                    // would be cached by the Spring container but would not have been weaved.\n                    Class<?> beanType = this.beanFactory.getType(beanName);\n                    if (beanType == null) {\n                        continue;\n                    }\n                    //判断此时的Bean的类上是否打了@Aspect注解\n                    if (this.advisorFactory.isAspect(beanType)) {\n                        //如果是，判断此类将是一个Advisor\n                        aspectNames.add(beanName);\n                        AspectMetadata amd = new AspectMetadata(beanType, beanName);\n                        //如果是单例，说明可以缓存下来\n                        if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {\n                            //封装成一个对象\n                            MetadataAwareAspectInstanceFactory factory =\n                                new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);\n                            //委派advisorFactory工厂针对以上封装信息创建Advisor\n                            List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(factory);\n                            //如果是单例，缓存\n                            if (this.beanFactory.isSingleton(beanName)) {\n                                this.advisorsCache.put(beanName, classAdvisors);\n                            }\n                            //如果不是，只缓存factory，待下一次进入取出缓存的factory\n                            //然后再用advisorFactory创建一次Advisor，省去寻找Bean与创建factory的麻烦\n                            else {\n                                this.aspectFactoryCache.put(beanName, factory);\n                            }\n                            advisors.addAll(classAdvisors);\n                        }\n                        else {\n                            // Per target or per this.\n                            if (this.beanFactory.isSingleton(beanName)) {\n                                throw new IllegalArgumentException(\"Bean with name '\" + beanName +\n                                                                   \"' is a singleton, but aspect instantiation model is not singleton\");\n                            }\n                            MetadataAwareAspectInstanceFactory factory =\n                                new PrototypeAspectInstanceFactory(this.beanFactory, beanName);\n                            this.aspectFactoryCache.put(beanName, factory);\n                            advisors.addAll(this.advisorFactory.getAdvisors(factory));\n                        }\n                    }\n                }\n                this.aspectBeanNames = aspectNames;\n                return advisors;\n            }\n        }\n    }\n\n    //如果走到这里，说明已经找过一遍了，这里从缓存获取信息\n    if (aspectNames.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<Advisor> advisors = new LinkedList<>();\n    //遍历所有缓存的切面名\n    for (String aspectName : aspectNames) {\n        //根据切面名从缓存拿Advisor\n        List<Advisor> cachedAdvisors = this.advisorsCache.get(aspectName);\n        //如果可以拿到，直接获取\n        if (cachedAdvisors != null) {\n            advisors.addAll(cachedAdvisors);\n        }\n        //如果拿不到，说明此时缓存的是factory\n        //根据factory使用advisorFactory创建Advisor\n        else {\n            MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);\n            advisors.addAll(this.advisorFactory.getAdvisors(factory));\n        }\n    }\n    return advisors;\n}\n```\n到这里，我们已经**完成了对所有Advisor的获取**，这里值得关注的是工厂（**advisorFactory**）是**如何创建Advisor**的呢？进入<code>ReflectiveAspectJAdvisorFactory</code>类的**getAdvisors**方法：\n```bash\n@Override\npublic List<Advisor> getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {\n    //获取切面类类型\n    Class<?> aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();\n    //获取切面Name\n    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();\n    //验证\n    validate(aspectClass);\n\n    // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator\n    // so that it will only instantiate once.\n    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =\n        new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);\n\n    List<Advisor> advisors = new LinkedList<>();\n    //遍历所有除了被打上@Pointcut注解的方法\n    for (Method method : getAdvisorMethods(aspectClass)) {\n        //在其每个方法中获取Advisor\n        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);\n        if (advisor != null) {\n            advisors.add(advisor);\n        }\n    }\n\n    // If it's a per target aspect, emit the dummy instantiating aspect.\n    if (!advisors.isEmpty() && lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {\n        Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);\n        advisors.add(0, instantiationAdvisor);\n    }\n\n    // Find introduction fields.\n    //获取DeclareParents注解的filed\n    for (Field field : aspectClass.getDeclaredFields()) {\n        Advisor advisor = getDeclareParentsAdvisor(field);\n        if (advisor != null) {\n            advisors.add(advisor);\n        }\n    }\n\n    return advisors;\n}\n```\n我们需要关注两点：\n1. **getAdvisorMethods**：此方法获取类上所有的<code>AdvisorMethods</code>，那么是如何进行的：\n```bash\nprivate List<Method> getAdvisorMethods(Class<?> aspectClass) {\n    final List<Method> methods = new LinkedList<>();\n    ReflectionUtils.doWithMethods(aspectClass, method -> {\n        // Exclude pointcuts\n        //获取方法上的注解，如果是Pointcut注解不处理\n        if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {\n            methods.add(method);\n        }\n    });\n    Collections.sort(methods, METHOD_COMPARATOR);\n    return methods;\n}\n```\n我们可以知道，其将**不是Pointcut的注解的方法加入到方法集合中作为AdvisorMethod**。\n2. **getAdvisor**：从上面获得的方法中，提取出<code>Advisor</code>：\n```bash\n@Override\n@Nullable\npublic Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,\n                          int declarationOrderInAspect, String aspectName) {\n\n    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());\n\n    //切点信息的获取\n    AspectJExpressionPointcut expressionPointcut = getPointcut(\n        candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());\n    if (expressionPointcut == null) {\n        return null;\n    }\n\n    //根据获得的切点信息封装增强器\n    return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,\n                                                          this, aspectInstanceFactory, declarationOrderInAspect, aspectName);\n}\n```\n我们依然需要关注两个点：\n\n- getPointcut：**切点信息的获取**\n- InstantiationModelAwarePointcutAdvisorImpl：**根据切点信息封装成增强器**\n\n##### 获取切点信息\n\n依然是在创建Advisor的工厂中的方法**getPointcut**：\n```bash\n@Nullable\nprivate AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class<?> candidateAspectClass) {\n    //获取该方法的注解\n    AspectJAnnotation<?> aspectJAnnotation =\n        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);\n    if (aspectJAnnotation == null) {\n        return null;\n    }\n\n    //封装信息\n    AspectJExpressionPointcut ajexp =\n        new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class<?>[0]);\n    //设置切点表达式\n    //例如：@Before（\"test()\"）上的test()\n    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());\n    if (this.beanFactory != null) {\n        ajexp.setBeanFactory(this.beanFactory);\n    }\n    return ajexp;\n}\n```\n需要关注的是获取方法的注解**findAspectJAnnotationOnMethod**：\n```bash\n@SuppressWarnings(\"unchecked\")\n@Nullable\nprotected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {\n    //需要关注的类型\n    Class<?>[] classesToLookFor = new Class<?>[] {\n        Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class};\n    for (Class<?> c : classesToLookFor) {\n        //将每个需要关注的类型都与方法进行匹配\n        AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c);\n        //如果找到，返回\n        if (foundAnnotation != null) {\n            return foundAnnotation;\n        }\n    }\n    return null;\n}\n```\n**findAnnotation ：**\n```bash\n@Nullable\nprivate static <A extends Annotation> AspectJAnnotation<A> findAnnotation(Method method, Class<A> toLookFor) {\n    //根据指定的类型寻找方法上的注解\n    A result = AnnotationUtils.findAnnotation(method, toLookFor);\n    if (result != null) {\n        //如果找到了，将其封装为AspectJAnnotation对象返回\n        return new AspectJAnnotation<>(result);\n    }\n    else {\n        return null;\n    }\n}\n```\n注意，在寻找注解的时候**仅仅是获取**了例如@Before(\"test()\")中的**test()这样的切点方法名信息**，这个过程在封装AspectJAnnotation对象时在**构造函数**完成：\n```bash\npublic AspectJAnnotation(A annotation) {\n    this.annotation = annotation;\n    this.annotationType = determineAnnotationType(annotation);\n    // We know these methods exist with the same name on each object,\n    // but need to invoke them reflectively as there isn't a common interface.\n    try {\n        //处理注解上的pointcut信息\n        this.pointcutExpression = resolveExpression(annotation);\n        this.argumentNames = (String) annotation.getClass().getMethod(\"argNames\").invoke(annotation);\n    }\n    catch (Exception ex) {\n        throw new IllegalArgumentException(annotation + \" cannot be an AspectJ annotation\", ex);\n    }\n}\n```\n```bash\nprivate String resolveExpression(A annotation) throws Exception {\n    //遍历获取注解中的两个方法名：value和pointcut\n    for (String methodName : EXPRESSION_PROPERTIES) {\n        Method method;\n        try {\n            //获取method对象\n            method = annotation.getClass().getDeclaredMethod(methodName);\n        }\n        catch (NoSuchMethodException ex) {\n            method = null;\n        }\n        if (method != null) {\n            //获取切点方法名，也就是注解上设置的，例如@Before(\"test()\")\n            //此时获取\"test()\"这样的字符串\n            String candidate = (String) method.invoke(annotation);\n            if (StringUtils.hasText(candidate)) {\n                return candidate;\n            }\n        }\n    }\n    throw new IllegalStateException(\"Failed to resolve expression: \" + annotation);\n}\n```\n\n##### 根据切点信息，封装成Advisor\n根据切点信息生成增强器，所有的增强都由<code>InstantiationModelAwarePointcutAdvisorImpl</code>这个类来封装，当然，这个类是一个<code>Advisor</code>。进入此类的构造函数：\n```bash\npublic InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,\n                                                  Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,\n                                                  MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {\n\n    //将获得的信息都封装到这个对象的属性上\n    this.declaredPointcut = declaredPointcut;\n    this.declaringClass = aspectJAdviceMethod.getDeclaringClass();\n    this.methodName = aspectJAdviceMethod.getName();\n    this.parameterTypes = aspectJAdviceMethod.getParameterTypes();\n    this.aspectJAdviceMethod = aspectJAdviceMethod;\n    this.aspectJAdvisorFactory = aspectJAdvisorFactory;\n    this.aspectInstanceFactory = aspectInstanceFactory;\n    this.declarationOrder = declarationOrder;\n    this.aspectName = aspectName;\n\n    if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {\n        // Static part of the pointcut is a lazy type.\n        Pointcut preInstantiationPointcut = Pointcuts.union(\n            aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);\n\n        // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.\n        // If it’s not a dynamic pointcut, it may be optimized out\n        // by the Spring AOP infrastructure after the first evaluation.\n        this.pointcut = new PerTargetInstantiationModelPointcut(\n            this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);\n        this.lazy = true;\n    }\n    else {\n        // A singleton aspect.\n        this.pointcut = this.declaredPointcut;\n        this.lazy = false;\n        //解析当前切点适用的Advice，并保存到instantiatedAdvice属性上\n        this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);\n    }\n}\n```\n\n在封装的过程中只是**简单的将信息放入类的属性中**，而值得关注的是最后一行的**instantiateAdvice**方法，此方法将**根据注解类型选择不同的Advise**，例如@Before、@After等等都是不同的Advice，它们需要前置或是后置通知，所体现的**增强的逻辑是不同的**，所以就需要不同的Advice来完成：\n```bash\nprivate Advice instantiateAdvice(AspectJExpressionPointcut pointcut) {\n    //委派别的类去获取Advice\n    Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut,\n                                                         this.aspectInstanceFactory, this.declarationOrder, this.aspectName);\n    return (advice != null ? advice : EMPTY_ADVICE);\n}\n```\n此类又委派了<code>aspectJAdvisorFactory</code>去获取Advice：\n```bash\n@Override\n@Nullable\npublic Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,\n                        MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {\n\n    //根据之前的信息获取切面类类型\n    Class<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();\n    validate(candidateAspectClass);\n\n    //寻找方法上的注解\n    AspectJAnnotation<?> aspectJAnnotation =\n        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);\n    if (aspectJAnnotation == null) {\n        return null;\n    }\n\n    // If we get here, we know we have an AspectJ method.\n    // Check that it’s an AspectJ-annotated class\n    if (!isAspect(candidateAspectClass)) {\n        throw new AopConfigException(\"Advice must be declared inside an aspect type: \" +\n                                     \"Offending method '\" + candidateAdviceMethod + \"' in class [\" +\n                                     candidateAspectClass.getName() + \"]\");\n    }\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Found AspectJ method: \" + candidateAdviceMethod);\n    }\n\n    AbstractAspectJAdvice springAdvice;\n\n    //根据刚刚从方法上获得的注解，解析成枚举的类型进行swich\n    switch (aspectJAnnotation.getAnnotationType()) {\n            //@Before注解将会走这里\n        case AtBefore:\n            springAdvice = new AspectJMethodBeforeAdvice(\n                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            break;\n            //@After注解\n        case AtAfter:\n            springAdvice = new AspectJAfterAdvice(\n                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            break;\n            //@AfterReturning\n        case AtAfterReturning:\n            springAdvice = new AspectJAfterReturningAdvice(\n                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();\n            if (StringUtils.hasText(afterReturningAnnotation.returning())) {\n                springAdvice.setReturningName(afterReturningAnnotation.returning());\n            }\n            break;\n            //@AfterThrowing\n        case AtAfterThrowing:\n            springAdvice = new AspectJAfterThrowingAdvice(\n                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();\n            if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {\n                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());\n            }\n            break;\n            //@Around\n        case AtAround:\n            springAdvice = new AspectJAroundAdvice(\n                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            break;\n            //@Pointcut\n        case AtPointcut:\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Processing pointcut '\" + candidateAdviceMethod.getName() + \"'\");\n            }\n            return null;\n        default:\n            throw new UnsupportedOperationException(\n                \"Unsupported advice type on method: \" + candidateAdviceMethod);\n    }\n\n    // Now to configure the advice...\n    //配置得到的Advice\n    springAdvice.setAspectName(aspectName);\n    springAdvice.setDeclarationOrder(declarationOrder);\n    String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);\n    if (argNames != null) {\n        springAdvice.setArgumentNamesFromStringArray(argNames);\n    }\n    springAdvice.calculateArgumentBindings();\n    return springAdvice;\n}\n```\n从上面我们可以知道，不同的通知对应不同的Advice，那么这些不同的advice的执行逻辑有哪些不同呢？这个疑问留着后面的执行过程会进行解答，这里只需要知道**我们获取的Advisor封装了advice与其切点信息**。\n\n#### 寻找适用的增强器\n我们的思路回到主线，此时我们已经**寻找到所有的增强器**了，现在开始从中**筛选**出适用的增强器：\n```bash\nprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n    //寻找所有适用的Advisor\n    //这一步在4.2中进行\n    List<Advisor> candidateAdvisors = findCandidateAdvisors();\n    //从所有Advisor中选出适合被当前Bean使用的Advisor\n    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n```\n此时执行**findAdvisorsThatCanApply**方法寻找适用的增强器：\n```bash\nprotected List<Advisor> findAdvisorsThatCanApply(\n    List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {\n\n    ProxyCreationContext.setCurrentProxiedBeanName(beanName);\n    try {\n        //委派AopUtils去做\n        return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);\n    }\n    finally {\n        ProxyCreationContext.setCurrentProxiedBeanName(null);\n    }\n}\n```\n这里委派了<code>AopUtils</code>去做事情：\n```bash\npublic static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {\n    if (candidateAdvisors.isEmpty()) {\n        return candidateAdvisors;\n    }\n    List<Advisor> eligibleAdvisors = new LinkedList<>();\n    //遍历之前找到的所有的Advisor\n    for (Advisor candidate : candidateAdvisors) {\n        //在这里会优先处理引介增强，并且判断Advisor是否适合此Bean\n        if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {\n            //优先加入List中\n            eligibleAdvisors.add(candidate);\n        }\n    }\n    boolean hasIntroductions = !eligibleAdvisors.isEmpty();\n    for (Advisor candidate : candidateAdvisors) {\n        if (candidate instanceof IntroductionAdvisor) {\n            // already processed\n            //已经处理过引介增强\n            continue;\n        }\n        //剩下的Advisor再进行判断\n        if (canApply(candidate, clazz, hasIntroductions)) {\n            //加入List中\n            eligibleAdvisors.add(candidate);\n        }\n    }\n    //返回适合的Advisor List\n    return eligibleAdvisors;\n}\n```\n我们重点关注**canApply**方法，看看是如何判断是否适合的：\n```bash\npublic static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {\n    if (advisor instanceof IntroductionAdvisor) {\n        //调用引介增强器的ClassFilter去匹配当前Bean是否适合\n        return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);\n    }\n    else if (advisor instanceof PointcutAdvisor) {\n        //如果是普通的Advisor，转换成PointcutAdvisor\n        //PointcutAdvisor接口定义了获取切点的方法getPointcut\n        PointcutAdvisor pca = (PointcutAdvisor) advisor;\n        //根据切点信息，寻找是否适合\n        return canApply(pca.getPointcut(), targetClass, hasIntroductions);\n    }\n    else {\n        // It doesn't have a pointcut so we assume it applies.\n        //如果没有切点，就假设它适合\n        return true;\n    }\n}\n```\n这里我们先忽略引介增强器，关注普通的Advisor。这里进入**canApply**方法，根据切点信息去判断是否合适：\n```bash\npublic static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\n    Assert.notNull(pc, \"Pointcut must not be null\");\n    //获取切点类过滤器，如果不符合直接返回false\n    //如果符合进入下一步判断\n    if (!pc.getClassFilter().matches(targetClass)) {\n        return false;\n    }\n\n    //获取切点的方法匹配器\n    MethodMatcher methodMatcher = pc.getMethodMatcher();\n    //如果此时methodMatcher是一个MethodMatcher.TRUE，说明匹配任何方法，直接返回true\n    if (methodMatcher == MethodMatcher.TRUE) {\n        // No need to iterate the methods if we’re matching any method anyway...\n        return true;\n    }\n\n    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n    if (methodMatcher instanceof IntroductionAwareMethodMatcher) {\n        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;\n    }\n\n    //拿到目标类的所有父类（包括接口）\n    Set<Class<?>> classes = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n    //包括本类\n    classes.add(targetClass);\n    //遍历父类与本类\n    for (Class<?> clazz : classes) {\n        //获取本class的方法对象\n        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n        //遍历方法\n        for (Method method : methods) {\n            //两个验证器只要其中一个匹配，就返回true\n            if ((introductionAwareMethodMatcher != null &&\n                 introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||\n                methodMatcher.matches(method, targetClass)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```\n到这里，就**完成了适用的增强器的查找**，从上面我们可以知道，当一个Bean中的任何一个方法（方法**包括在父类**中的方法）**匹配Advisor中的切点信息**，就认为当前的Advisor是**匹配当前Bean**的，就将此时的**Advisor加入此类的Advisors列表**中，注意，一个Bean中是可以有多个Advisor的，如果不能理解为什么一个Bean对应多个Advisor，你应该还没有明白Advisor的概念，Advisor中包含advice与切点信息，也就是说，一个通知方法例如前置通知@Before是对应一个Advisor的，如果一个类中既有前置通知又有后置通知，那么这个类中的Advisor是会匹配两个的。\n\n#### 创建代理\n##### 获取代理类型（JDK或CGLIB）\n再次回到最开始的地方，还记得4.1的**wrapIfNecessary**方法吗？此时我们已经寻找完符合此Bean的增强器了（**getAdvicesAndAdvisorsForBean**方法），就像刚刚所说，如果有两个通知匹配的话，现在增强器列表应该会有两个Advisor，也就是说增强列表不为空，将进行下一步，创建代理的过程**createProxy**：\n```bash\nprotected Object createProxy(Class<?> beanClass, @Nullable String beanName,\n                             @Nullable Object[] specificInterceptors, TargetSource targetSource) {\n\n    if (this.beanFactory instanceof ConfigurableListableBeanFactory) {\n        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);\n    }\n\n    ProxyFactory proxyFactory = new ProxyFactory();\n    //复制当前Creator的一些属性例如proxyTargetClass或是exposeProxy等\n    proxyFactory.copyFrom(this);\n\n    //如果proxyTargetClass是false才会进入判断\n    //如果proxyTargetClass是true就直接用CGLib代理了，不需要判断\n    if (!proxyFactory.isProxyTargetClass()) {\n        //判断是否需要代理本类\n        if (shouldProxyTargetClass(beanClass, beanName)) {\n            //也就是说，如果需要代理本类，将使用CGLib方式代理\n            proxyFactory.setProxyTargetClass(true);\n        }\n        //如果不需要，则获取所有该类的接口，设置到proxyFactory对象中\n        else {\n            evaluateProxyInterfaces(beanClass, proxyFactory);\n        }\n    }\n\n    //处理所有得到的适用的拦截器转换成Advisor\n    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);\n    //将Advisors加入proxyFactory对象中\n    proxyFactory.addAdvisors(advisors);\n    //将原本的Bean对象（原生未代理）加入proxyFactory对象中\n    proxyFactory.setTargetSource(targetSource);\n    //定制代理\n    customizeProxyFactory(proxyFactory);\n\n    proxyFactory.setFrozen(this.freezeProxy);\n    if (advisorsPreFiltered()) {\n        proxyFactory.setPreFiltered(true);\n    }\n\n    //设置好属性之后，就调用proxyFactory对象生成代理对象\n    return proxyFactory.getProxy(getProxyClassLoader());\n}\n```\n以上过程都在给<code>proxyFactory</code>这个对象设置属性，然后调用<code>proxyFactory</code>根据设置的一些属性生成代理对象，最后执行关键的创建代理方法**getProxy**：\n```bash\npublic Object getProxy(@Nullable ClassLoader classLoader) {\n    return createAopProxy().getProxy(classLoader);\n}\n```\n```bash\nprotected final synchronized AopProxy createAopProxy() {\n    if (!this.active) {\n        activate();\n    }\n    //使用aopProxyFactory根据本类信息创建\n    return getAopProxyFactory().createAopProxy(this);\n}\n```\n其中<code>aopProxyFactory</code>是在其父类的构造函数中赋值的：\n```bash\npublic ProxyCreatorSupport() {\n    this.aopProxyFactory = new DefaultAopProxyFactory();\n}\n```\n进入其创建方法**createAopProxy**：\n```bash\n@Override\npublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n    //判断ProxyTargetClass属性和是否有代理接口等等判断使用何种方式做代理\n    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {\n        Class<?> targetClass = config.getTargetClass();\n        if (targetClass == null) {\n            throw new AopConfigException(\"TargetSource cannot determine target class: \" +\n                                         \"Either an interface or a target is required for proxy creation.\");\n        }\n        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\n            return new JdkDynamicAopProxy(config);\n        }\n        return new ObjenesisCglibAopProxy(config);\n    }\n    else {\n        return new JdkDynamicAopProxy(config);\n    }\n}\n```\n> 注意此时config对象是我们之前设置了各种信息的proxyFactory对象，在代理的构造函数中存放了这个属性，也就是说代理对象持有一个Advisor列表。\n\n这段代码清晰明了，主要就是在**判断使用何种方式做代理**：\n\n- optimize：这个属性适用于CGLib，对JDK动态代理无效。主要是控制CGLib创建的代理是否使用激进的优化策略。\n- proxyTargetClass：文章开头也有提到，如果属性为true，将会使用CGLib进行代理。\n- hasNoUserSuppliedProxyInterfaces：是否存在代理接口。\n\n总结一下JDK于CGLIB如何选择：\n- 如果目标对象实现了接口，默认情况下会采用JDK代理\n- 如果目标对象实现了接口，但可以使用proxyTargetClass属性来强制使用CGLIB代理\n- 如果对象没用实现接口，必须使用CGLIB代理\n\n##### 获取代理\n\n思路回到开头获取代理的方法中：\n```bash\npublic Object getProxy(@Nullable ClassLoader classLoader) {\n    return createAopProxy().getProxy(classLoader);\n}\n```\n此时我们完成了**createAopProxy**，拿到了JDK代理对象（我们这里假设用JDK做代理）接着调用其**getProxy**方法：\n```bash\n@Override\npublic Object getProxy(@Nullable ClassLoader classLoader) {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Creating JDK dynamic proxy: target source is \" + this.advised.getTargetSource());\n    }\n    //拿到被代理类的接口\n    Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);\n    //检查上面得到的接口是否定义了equals、hashCode方法\n    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);\n    //创建代理对象\n    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n}\n```\n注意此时的<code>advised</code>就是我们上面所说的<code>config</code>对象也就是封装半天信息的<code>proxyFactory</code>对象，里面存有一系列信息例如**Advisor、切点之类**。\n\n这里不对动态代理进行解释，如果熟悉动态代理的看到这里应该已经懂了，其将当前对象作为实现代理的主要对象。毫无疑问，当前对象一定实现了<code>InvocationHandler</code>接口，我们需要关注的即为它的**invoke**方法：\n```bash\n@Override\n@Nullable\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    MethodInvocation invocation;\n    Object oldProxy = null;\n    boolean setProxyContext = false;\n\n    //原生对象\n    TargetSource targetSource = this.advised.targetSource;\n    Object target = null;\n\n    try {\n        //eqauls()方法，如果目标对象未实现此方法\n        if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {\n            // The target does not implement the equals(Object) method itself.\n            return equals(args[0]);\n        }\n        //hashCode()方法，如果目标对象未实现此方法\n        else if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {\n            // The target does not implement the hashCode() method itself.\n            return hashCode();\n        }\n        else if (method.getDeclaringClass() == DecoratingProxy.class) {\n            // There is only getDecoratedClass() declared -> dispatch to proxy config.\n            return AopProxyUtils.ultimateTargetClass(this.advised);\n        }\n        //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知\n        else if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&\n                 method.getDeclaringClass().isAssignableFrom(Advised.class)) {\n            // Service invocations on ProxyConfig with the proxy config...\n            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);\n        }\n\n        Object retVal;\n\n        //这里就是先前提到的如果exposeProxy属性为true，将会暴露一个proxy代理对象\n        //给AOP上下文对象，存在线程变量中\n        if (this.advised.exposeProxy) {\n            // Make invocation available if necessary.\n            oldProxy = AopContext.setCurrentProxy(proxy);\n            setProxyContext = true;\n        }\n\n        // Get as late as possible to minimize the time we \"own\" the target,\n        // in case it comes from a pool.\n        //获得目标对象的类\n        target = targetSource.getTarget();\n        Class<?> targetClass = (target != null ? target.getClass() : null);\n\n        // Get the interception chain for this method.\n        //获取可以应用到此方法上的Interceptor列表\n        List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\n        // Check whether we have any advice. If we don’t, we can fallback on direct\n        // reflective invocation of the target, and avoid creating a MethodInvocation.\n        //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)\n        if (chain.isEmpty()) {\n            // We can skip creating a MethodInvocation: just invoke the target directly\n            // Note that the final invoker must be an InvokerInterceptor so we know it does\n            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.\n            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n        }\n        else {\n            // We need to create a method invocation...\n            //走到这里，说明该方法符合被通知的条件，创建MethodInvocation\n            //执行其proceed方法\n            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n            // Proceed to the joinpoint through the interceptor chain.\n            retVal = invocation.proceed();\n        }\n\n        // Massage return value if necessary.\n        Class<?> returnType = method.getReturnType();\n        if (retVal != null && retVal == target &&\n            returnType != Object.class && returnType.isInstance(proxy) &&\n            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {\n            // Special case: it returned \"this\" and the return type of the method\n            // is type-compatible. Note that we can't help if the target sets\n            // a reference to itself in another returned object.\n            retVal = proxy;\n        }\n        else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {\n            throw new AopInvocationException(\n                \"Null return value from advice does not match primitive return type for: \" + method);\n        }\n        return retVal;\n    }\n    finally {\n        if (target != null && !targetSource.isStatic()) {\n            // Must have come from TargetSource.\n            targetSource.releaseTarget(target);\n        }\n        if (setProxyContext) {\n            // Restore old proxy.\n            AopContext.setCurrentProxy(oldProxy);\n        }\n    }\n}\n```\n也就是说，每次调用代理对象的方法，将执行以下步骤：\n1. **判断是否是equals或hashCode或Advised的方法**：如果是执行对应判断。\n2. **判断是否需要暴露代理对象**（将代理对象存入AopContext）：在文章开头就有提到这个属性，还是之前的例子，在A方法中调用B方法，此时B方法其实是原生对象的B方法，但如果B方法需要被AOP，需要执行的是代理对象的B方法，而不是原生对象的B方法，原生对象的B方法是没有被代理AOP的。所以这里需要暴露出代理对象，从AopContext上下文中取出代理对象，将其强转成对应类，执行B方法，此时的B方法即可是被AOP的方法了。值得一提的是AopContext暴露出来的代理对象是线程变量。\n3. **获取当前方法对应的拦截器链**：主要是使用<code>advised</code>去对当前方法进行判断**是否符合切点**如果符合取出对应需要执行的链。如果此时**链为空**，代表执行的该方法是**不需要被AOP**的，正常反射执行即可，如果**链不为空**，将链封装成<code>ReflectiveMethodInvocation</code>对象执行其**proceed**方法，该对象的该方法是执行AOP的核心，下面详细讲解。\n\n#### 执行AOP通知\n到此我们创建好了代理对象，并**返回出去作为一个Bean存放在IOC容器中**，当我们取出此Bean并执行方法时，如果碰到了需要被AOP的方法时，会找到一个**拦截器链**，然后将其传入<code>ReflectiveMethodInvocation</code>对象封装，接着不会执行原方法而是执行其**proceed**方法，所以该方法是执行AOP通知的核心方法：\n```bash\n//此属性默认为-1\nprivate int currentInterceptorIndex = -1;\n\n//存放interceptors的列表\nprotected final List<?> interceptorsAndDynamicMethodMatchers;\n\n@Override\n@Nullable\npublic Object proceed() throws Throwable {\n    //  We start with an index of -1 and increment early.\n    //如果Interceptor执行完了，则执行joinPoint\n    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n        return invokeJoinpoint();\n    }\n\n    //根据游标获取对应的Advice\n    Object interceptorOrInterceptionAdvice =\n        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n    //如果要动态匹配joinPoint\n    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n        // Evaluate dynamic method matcher here: static part will already have\n        // been evaluated and found to match.\n        InterceptorAndDynamicMethodMatcher dm =\n            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n        //动态匹配：运行时参数是否满足匹配条件\n        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n            return dm.interceptor.invoke(this);\n        }\n        else {\n            // Dynamic matching failed.\n            // Skip this interceptor and invoke the next in the chain.\n            //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor\n            return proceed();\n        }\n    }\n    else {\n        // It’s an interceptor, so we just invoke it: The pointcut will have\n        // been evaluated statically before this object was constructed.\n        //执行当前IntercetporAdvice\n        //注意此时传了this对象，是为了执行链的保持\n        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n    }\n}\n```\n\n到这里，需要解释几点：\n1. **如何判断执行结束？在开头我们说到currentInterceptorIndex**属性是为-1的，**interceptorsAndDynamicMethodMatchers**的size是执行链的数量，刚进来的时候执行链一定大于等于1，所以其减1也不会等于-1，不会执行**invokeJoinpoint**方法，走到下面执行这样一行代码\n```bash\nObject interceptorOrInterceptionAdvice =\n        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n```\n注意此时**currentInterceptorIndex**游标变成了0，也就是取执行链的第一个执行器取执行，同时游标变成0。下面会执行Advice的**invoke**方法，这里举例Before类型的Advice的**invoke**方法：\n```bash\n@Override\npublic Object invoke(MethodInvocation mi) throws Throwable {\n    this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );\n    return mi.proceed();\n}\n```\n注意此时<code>mi对象</code>就是上面传进来的<code>this</code>，也就是<code>ReflectiveMethodInvocation</code>对象，他在通知方法执行完成之后，又执行了<code>ReflectiveMethodInvocation</code>的**proceed**方法，然后第二次进入**proceed**时，游标已经变成了0，我们假设此时拦截器数量为一个，那么此时**currentInterceptorIndex=0,interceptorsAndDynamicMethodMatchers.size() - 1 = 0：**\n```bash\nif (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n    return invokeJoinpoint();\n}\n```\n将中止执行下面的内容，直接执行**invokeJoinpoint**方法：\n```bash\n@Nullable\nprotected Object invokeJoinpoint() throws Throwable {\n    return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);\n}\n```\n这里底层就是**通过反射执行原方法**，到此结束，也就是说其**利用游标索引与循环调用proceed方法来判断当前执行链的结束**，真是个聪明的方法。\n\n2. **为什么@Before的Advice的invoke可以实现前置通知效果，同样的@After如何实现后置通知效果？在这里我们将补上上面没有详细讲解的一些Advice类 。**\n1) <code>MethodBeforeAdviceInterceptor</code>前置通知：\n```bash\npublic class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {\n\n    private MethodBeforeAdvice advice;\n\n    /**\n   * Create a new MethodBeforeAdviceInterceptor for the given advice.\n   * @param advice the MethodBeforeAdvice to wrap\n   */\n    //构造器初始化保存了advice对象\n    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {\n        Assert.notNull(advice, \"Advice must not be null\");\n        this.advice = advice;\n    }\n\n    @Override\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );\n        return mi.proceed();\n    }\n}\n```\n2)<code>AfterReturningAdviceInterceptor</code>后置通知：\n```bash\npublic class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable {\n\n    private final AfterReturningAdvice advice;\n\n\n    /**\n   * Create a new AfterReturningAdviceInterceptor for the given advice.\n   * @param advice the AfterReturningAdvice to wrap\n   */\n    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) {\n        Assert.notNull(advice, \"Advice must not be null\");\n        this.advice = advice;\n    }\n\n    @Override\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        Object retVal = mi.proceed();\n        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());\n        return retVal;\n    }\n\n}\n```\n从上面两个不同的<code>Advice</code>可以看出，其**invoke**方法的逻辑只是**顺序不同**而已，但为什么可以达到前置后置通知的呢？其实前置通知很好理解，在invoke的逻辑中只要**先执行我们指定的前置通知逻辑**，然后**继续往下执行proceed**即可实现在执行原方法前加一段逻辑的功能，我们主要分析后置通知是如何实现的。还是进行一个假设，此时该方法**只有一个执行链后置通知@After**，那么刚开始进入proceed方法时，获取这个Advice执行invoke方法，然后**又去执行proceed方法**了，由上面的分析此时的游标显示执行链已经执行完毕，所以此时会**直接反射执行原方法**，然后**proceed方法执行完毕**，最后将会执行后置通知Advice的invoke方法的下一步，**advice.afterReturning**，也就是用户**自定义的后置方法逻辑**，实现了在方法最后插入一段代码逻辑的功能，如果是多个通知例如前置后置都有的话，留给读者思考，相信懂得以上逻辑之后推敲起来并不是很难。\n\n---\n\n### 总结\n到这里为止，我们分析了AOP是从**自定义标签开始**，自定义标签注册了一个<code>Creator</code>类，而此<code>Creator</code>类是一个<code>BeanPostProcessor</code>，也就是说每个Bean都将调用Creator实现的方法。\n\n来到了**如何实现AOP代理的分析**中，在此方法中判断Bean是否需要被代理，然后进一步判断此Bean是否可以获得增强器，在这个过程中会去拿所有的Advisor，然后在所有的Advisor列表中筛选出适用的增强器，如果适用的增强器Advisor为空证明此Bean不用被代理，如果不为空则会进入创建代理的流程。\n\n所以我们开始分析**创建代理是怎样的过程** ，在什么情况下会进行JDK动态代理，在什么情况下会进行CGLIB动态代理，然后创建代理结束之后。\n\n必不可少的也需要分析是**如何执行AOP通知**的，其核心类是<code>ReflectiveMethodInvocation</code>的**proceed**方法，轮询执行拦截器，并且不同的Advice根据其特有的逻辑执行调用顺序，来完成AOP通知的功能。\n","source":"_posts/Spring-3.md","raw":"---\ntitle: Spring框架——深入理解AOP实现原理\ncategories:\n    - Java框架\n    \ndate: 2018-11-07\ntags:\n\t- 框架\n    - Spring\n---\n> 阅读这篇文章前，最好有代理模式的基础，以及了解关于Spring扩展点例如BeanPostProcessor和如何使用自定义标签集成Spring，这些文章在我的博客里都能找到。当然，也最好有使用AOP的经验，这篇文章不会讲解如何使用AOP。\n\n![Spring](/images/spring_logo.jpg)\n\n### AOP简介\n说到AOP，其实这是一个**面向方面的编程思想** ，它解决了OOP的一些弊端，例如我们需要为**多个不具有继承关系的类引入一个公共行为**， 比如说日志、权限验证、事务管理等等，我们需要将这些代码**重复的添加**到一系列的类中，将**产生大量的重复代码**，如果需要修改，将在每个类中去进行修改，**不便于维护**，代码的**侵入性极高**。所以就有了AOP这样面向方面编程的编程思想，其功能可以为每个需要的类**加入共同的行为**，如果需要修改，只需要修改切面中的代码，改一处等于改多处，并且便于编程，写一个切面类即可达到在每个类中加入重复代码的目的。\n\n阅读此篇文章，你将了解Spring是**如何实现AOP**（前置通知、后置通知、环绕通知），由于Spring中的事务管理是基于AOP的功能来做的，所以你将更好的能理解Spring是如何将事务统一管理起来的。\n\n---\n\n### 自定义标签开启AOP\n\n只要用过AOP都知道，如果需要使用AOP，需要在配置文件中写这样一段配置：\n```bash\n<aop:aspectj-autoproxy />\n```\n只有写了这段配置才可以开启AOP功能，那么这个自定义标签又做了什么呢？在上一篇讲解自定义标签的文章中详细讲到了，此时我们需要关注其标签头aop去寻找对应的命名空间：\n```bash\nxmlns:aop=\"http://www.springframework.org/schema/aop\"\n```\n全局搜索命名空间<code>&lt;http\\\\://www.springframework.org/schema/aop&gt;</code>，注意http后加一个“\\” ，可以找到**spring.handlers**文件中对应的handler类：\n```bash\nhttp\\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler\n```\n这样就找到了命名空间对应的handler：\n```bash\npublic class AopNamespaceHandler extends NamespaceHandlerSupport {\n\n  /**\n   * Register the {@link BeanDefinitionParser BeanDefinitionParsers} for the\n   * '{@code config}', '{@code spring-configured}', '{@code aspectj-autoproxy}'\n   * and '{@code scoped-proxy}' tags.\n   */\n  @Override\n  public void init() {\n    // In 2.0 XSD as well as in 2.1 XSD.\n    registerBeanDefinitionParser(\"config\", new ConfigBeanDefinitionParser());\n    registerBeanDefinitionParser(\"aspectj-autoproxy\", new AspectJAutoProxyBeanDefinitionParser());\n    registerBeanDefinitionDecorator(\"scoped-proxy\", new ScopedProxyBeanDefinitionDecorator());\n\n    // Only in 2.0 XSD: moved to context namespace as of 2.1\n    registerBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser());\n  }\n}\n```\n回到开头配置自定义标签，我们使用了<code>aspectj-autoproxy</code>这个Parser。在init方法中，我们找到<code>aspectj-autoproxy</code>对应的Parser是<code>AspectJAutoProxyBeanDefinitionParser</code>这个类：\n```bash\n@Override\n@Nullable\n//我们只关注解析的主方法，parse方法\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    //注册一个类到IOC容器中\n    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);\n    extendBeanDefinition(element, parserContext);\n    return null;\n}\n```\n\n---\n\n### 注册AnnotationAwareAspectJAutoProxyCreator\n<code>AnnotationAwareAspectJAutoProxyCreator</code>是实现AOP功能的主要类，我们先来看看这个类的结构：\n![spring](/images/spring-aop1.png)\n此类实现了<code>BeanPostProcessor</code>，稍后将关注其后置处理Bean的方法**postProcessAfterInitialization**，并且实现了<code>BeanFactorAware</code>接口，此类将取得并存有一个<code>BeanFactory</code>实例对象。\n回到主线，关注注册此类的方法：\n```bash\npublic static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(\n    ParserContext parserContext, Element sourceElement) {\n//将一个类作为Bean注册到IOC容器中\n    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(\n        parserContext.getRegistry(), parserContext.extractSource(sourceElement));\n    //处理proxy-target-class与expose-proxy属性\n    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);\n    //注册组件并通知\n    registerComponentIfNecessary(beanDefinition, parserContext);\n}\n```\n其中，在注册这个类的过程中主要完成了3件事：\n1. 注册<code>AnnotationAwareAspectJAutoProxyCreator：</code>\n```bash\n@Nullable\npublic static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry,\n                                                                                  @Nullable Object source) {\n//将AnnotationAwareAspectJAutoProxyCreator这个类注册到IOC容器中\n    return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);\n}\n```\n```bash\n@Nullable\nprivate static BeanDefinition registerOrEscalateApcAsRequired(Class<?> cls, BeanDefinitionRegistry registry,\n                                                              @Nullable Object source) {\n\n    Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\n    //如果IOC容器中已经存在了此类型的Bean，则需要判断优先级\n    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\n        //获取此类的BeanDefinition信息\n        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\n        //如果此Bean的ClassName与AnnotationAwareAspectJAutoProxyCreator类的\n        //ClassName不同的话，判断优先级\n        if (!cls.getName().equals(apcDefinition.getBeanClassName())) {\n            int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());\n            int requiredPriority = findPriorityForClass(cls);\n            //如果已存在Bean优先级小于Creator的优先级\n            if (currentPriority < requiredPriority) {\n                //将ClassName替换成Creator\n                apcDefinition.setBeanClassName(cls.getName());\n            }\n        }\n        //不进行注册，因为已经注册了\n        return null;\n    }\n\n    //如果到这里，说明IOC容器中没有配置对应Creator\n    //使用Crearir的Class构造一个BeanDefinition\n    RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);\n    beanDefinition.setSource(source);\n    //配置依赖属性order，将其设置为最高优先级\n    beanDefinition.getPropertyValues().add(\"order\", Ordered.HIGHEST_PRECEDENCE);\n    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    //将设置好属性的BeanDefinition注册进IOC容器中\n    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);\n    return beanDefinition;\n}\n```\n2. 处理**proxy-target-class**与**expose-proxy**属性\n```bash\nprivate static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, @Nullable Element sourceElement) {\n    if (sourceElement != null) {\n        boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));\n        //处理proxy-target-class属性\n        if (proxyTargetClass) {\n            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);\n        }\n        boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));\n        //处理expose-proxy属性\n        if (exposeProxy) {\n            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);\n        }\n    }\n}\n```\n其中设置属性的过程：\n```bash\npublic static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) {\n    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\n        //根据之前注册的BeanName取出Creator\n        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\n        //将Creator的BeanDefinition的属性proxyTargetClass设置为true\n        definition.getPropertyValues().add(\"proxyTargetClass\", Boolean.TRUE);\n    }\n}\n\npublic static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) {\n    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\n        //根据之前注册的BeanName取出Creator\n        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\n        //将Creator的BeanDefinition的属性exposeProxy设置为true\n        definition.getPropertyValues().add(\"exposeProxy\", Boolean.TRUE);\n    }\n}\n```\n\n- **proxy-target-class**：在Spring的AOP中，默认的如果目标类实现了至少一个接口，将使用**JDK动态代理**实现AOP，否则使用**CGLib动态代理**实现AOP，如果希望AOP都使用CGLib实现，你就可以设置proxy-target-class属性为**true**，但要注意几个问题：\n\n1)**无法对final的方法进行动态代理**，原因很简单，CGLib使用继承实现，final方法无法重写，所以final的方法不能应用AOP。\n2)需要配置CGLib的JAR包\n- **expose-proxy**：在讲解事务的那篇文章中有提到，如果一个类中的事务A方法调用了同一个类中的事务B方法，**B方法将没有事务**，这个道理在AOP中也是这样的，相同类下的不同方法互相调用，内部方法将无法被应用通知（无法进行AOP），此时你需要将**expose-proxy属性设置为true**，暴露一个代理类（此属性的原理在下面会有详细讲解），然后在A方法中需要调用B方法的话需要这样写：\n```bash\npublic class Service{\n    public void A(){\n        ((Service)AopContext.currentProxy()).B();\n    }\n\n    public void B(){\n    //do something...\n    }\n}\n```\n这样，B方法就算再A方法内也可以被AOP。其中<code>AopContext</code>是存放线程变量的类，形象的称之为**AOP的上下文**。\n\n---\n\n### 实现AOP代理\n#### 创建AOP代理\n上面，自定义标签的配置完成了对**Creator类的自动注册**，我们可以知道，此类实现了<code>BeanPostProcessor</code>接口，将会在IOC容器初始化每个Bean时都调用此类的**postProcessAfterInitialization**方法，此方法即为AOP代理的入口，此方法在抽象父类<code>AbstractAutoProxyCreator</code>实现：\n```bash\n@Override\npublic Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException {\n    if (bean != null) {\n        //先从缓存中获取Key，由要代理的Bean的Class与benaName组成\n        Object cacheKey = getCacheKey(bean.getClass(), beanName);\n        //判断是否是过早暴露的Bean，此概念在讲IOC解决循环依赖中有提到\n        //如果是过早暴露的Bean，则此时连依赖注入都没有完成，则不对其进行代理\n        //待其真正初始化之后再尝试代理\n        if (!this.earlyProxyReferences.contains(cacheKey)) {\n            //如果符合条件进行AOP代理\n            return wrapIfNecessary(bean, beanName, cacheKey);\n        }\n    }\n    return bean;\n}\n```\n```bash\nprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n    //如果先前已经处理过的，不进行处理\n    if (StringUtils.hasLength(beanName) && this.targetSourcedBeans.contains(beanName)) {\n        return bean;\n    }\n    //如果此Bean已经被标记为无法代理，不进行处理\n    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n        return bean;\n    }\n    //如果Bean为AOP类的类型，或是需要跳过的类型，不进行处理\n    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n        //标记为不代理\n        this.advisedBeans.put(cacheKey, Boolean.FALSE);\n        return bean;\n    }\n\n    // Create proxy if we have advice.\n    //寻找符合此Bean的增强方法（通知方法）\n    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n    //如果寻找到的增强方法列表不为空，也就是不为DO_NOT_PROXY\n    if (specificInterceptors != DO_NOT_PROXY) {\n        //标记为已代理\n        this.advisedBeans.put(cacheKey, Boolean.TRUE);\n        //根据找到的增强方法，对此Bean进行动态代理\n        Object proxy = createProxy(\n            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n        this.proxyTypes.put(cacheKey, proxy.getClass());\n        //将代理对象作为Bean返回给IOC容器\n        return proxy;\n    }\n  //如果走到这里，说明代理失败，标记为代理失败\n    this.advisedBeans.put(cacheKey, Boolean.FALSE);\n    return bean;\n}\n```\n文章到了这里，就已经基本完成AOP的实现了，剩下我们需要关注的就是两件事：\n- 如何寻找符合Bean的增强器\n- 如何对Bean创建动态代理\n\n#### 寻找所有的增强器\n\n```bash\n@Override\n@Nullable\nprotected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) {\n    //寻找适合的Advisor\n    List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);\n    if (advisors.isEmpty()) {\n        return DO_NOT_PROXY;\n    }\n    return advisors.toArray();\n}\n```\n这里有一个<code>Advisor</code>的概念，其中Advisor**封装了切点信息与advise通知方法等等信息。**\n```bash\nprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n    //寻找所有适用的Advisor\n    List<Advisor> candidateAdvisors = findCandidateAdvisors();\n    //从所有Advisor中选出适合被当前Bean使用的Advisor\n    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n```\n\n##### 寻找已存在的Advisor\n首先，执行下面的方法寻找合适的<code>Advisor</code>（此方法在子类<code>Creator</code>中得到实现）：\n```bash\n@Override\nprotected List<Advisor> findCandidateAdvisors() {\n    // Add all the Spring advisors found according to superclass rules.\n    //首先调用父类findCandidateAdvisors的方法寻找在IOC容器中的Advisor类型的Bean\n    List<Advisor> advisors = super.findCandidateAdvisors();\n    // Build Advisors for all AspectJ aspects in the bean factory.\n    if (this.aspectJAdvisorsBuilder != null) {\n        //寻找注解的Advisor\n        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());\n    }\n    return advisors;\n}\n```\n先调用父类的**findCandidateAdvisors**方法寻找所有的<code>Advisor</code>：\n```bash\nprotected List<Advisor> findCandidateAdvisors() {\n    Assert.state(this.advisorRetrievalHelper != null, \"No BeanFactoryAdvisorRetrievalHelper available\");\n    //委派Helper类去寻找\n    return this.advisorRetrievalHelper.findAdvisorBeans();\n}\n```\n```bash\npublic List<Advisor> findAdvisorBeans() {\n    // Determine list of advisor bean names, if not cached already.\n    String[] advisorNames = null;\n    synchronized (this) {\n        //先从缓存中取\n        advisorNames = this.cachedAdvisorBeanNames;\n        //缓存中若没有再去IOC容器中取\n        if (advisorNames == null) {\n            // Do not initialize FactoryBeans here: We need to leave all regular beans\n            // uninitialized to let the auto-proxy creator apply to them!\n            //从IOC容器中寻找所有Advisor类型的BeanName\n            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n                this.beanFactory, Advisor.class, true, false);\n            //放入缓存\n            this.cachedAdvisorBeanNames = advisorNames;\n        }\n    }\n    //没有找到，返回空\n    if (advisorNames.length == 0) {\n        return new LinkedList<>();\n    }\n\n    List<Advisor> advisors = new LinkedList<>();\n    //遍历上面得到的所有BeanName\n    for (String name : advisorNames) {\n        if (isEligibleBean(name)) {\n            if (this.beanFactory.isCurrentlyInCreation(name)) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Skipping currently created advisor '\" + name + \"'\");\n                }\n            }\n            else {\n                try {\n                    //根据BeanName从IOC获取Bean实例并存入List中\n                    advisors.add(this.beanFactory.getBean(name, Advisor.class));\n                }\n                //catch方法 略...\n            }\n        }\n    }\n    return advisors;\n}\n```\n注意此时仅仅是**只获取IOC容器中那些Advisor类型的Bean作为Advisor**，而在我们注解配置AOP的方式中并不是配置Advisor类的，下面会说到如何获取所有打了注解的切面，这里只是尝试去IOC容器中找是否存在这样的类，有的话也不会漏掉。\n\n##### 寻找所有注解的Advisor\n现在我们拿到了部分的Advisor，回到我们主类<code>AnnotationAwareAspectJAutoProxyCreatorS</code>的**findCandidateAdvisors** 方法，此时将委派<code>BeanFactoryAspectJAdvisorsBuilder</code>类去执行**buildAspectJAdvisors**方法，将继续获取被注解了的Advisor：\n```bash\n@Override\nprotected List<Advisor> findCandidateAdvisors() {\n    // Add all the Spring advisors found according to superclass rules.\n    List<Advisor> advisors = super.findCandidateAdvisors();\n    // Build Advisors for all AspectJ aspects in the bean factory.\n    if (this.aspectJAdvisorsBuilder != null) {\n        //委派BeanFactoryAspectJAdvisorsBuilder去寻找注解Advisor\n        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());\n    }\n    return advisors;\n}\n```\n```bash\npublic List<Advisor> buildAspectJAdvisors() {\n    List<String> aspectNames = this.aspectBeanNames;\n\n    if (aspectNames == null) {\n        synchronized (this) {\n            aspectNames = this.aspectBeanNames;\n            //双重加锁保证在并发情况下不会寻找两次\n            if (aspectNames == null) {\n                List<Advisor> advisors = new LinkedList<>();\n                aspectNames = new LinkedList<>();\n                //从IOC容器中获取所有的BeanName\n                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n                    this.beanFactory, Object.class, true, false);\n                //遍历所有的BeanName\n                for (String beanName : beanNames) {\n                    if (!isEligibleBean(beanName)) {\n                        continue;\n                    }\n                    // We must be careful not to instantiate beans eagerly as in this case they\n                    // would be cached by the Spring container but would not have been weaved.\n                    Class<?> beanType = this.beanFactory.getType(beanName);\n                    if (beanType == null) {\n                        continue;\n                    }\n                    //判断此时的Bean的类上是否打了@Aspect注解\n                    if (this.advisorFactory.isAspect(beanType)) {\n                        //如果是，判断此类将是一个Advisor\n                        aspectNames.add(beanName);\n                        AspectMetadata amd = new AspectMetadata(beanType, beanName);\n                        //如果是单例，说明可以缓存下来\n                        if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {\n                            //封装成一个对象\n                            MetadataAwareAspectInstanceFactory factory =\n                                new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);\n                            //委派advisorFactory工厂针对以上封装信息创建Advisor\n                            List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(factory);\n                            //如果是单例，缓存\n                            if (this.beanFactory.isSingleton(beanName)) {\n                                this.advisorsCache.put(beanName, classAdvisors);\n                            }\n                            //如果不是，只缓存factory，待下一次进入取出缓存的factory\n                            //然后再用advisorFactory创建一次Advisor，省去寻找Bean与创建factory的麻烦\n                            else {\n                                this.aspectFactoryCache.put(beanName, factory);\n                            }\n                            advisors.addAll(classAdvisors);\n                        }\n                        else {\n                            // Per target or per this.\n                            if (this.beanFactory.isSingleton(beanName)) {\n                                throw new IllegalArgumentException(\"Bean with name '\" + beanName +\n                                                                   \"' is a singleton, but aspect instantiation model is not singleton\");\n                            }\n                            MetadataAwareAspectInstanceFactory factory =\n                                new PrototypeAspectInstanceFactory(this.beanFactory, beanName);\n                            this.aspectFactoryCache.put(beanName, factory);\n                            advisors.addAll(this.advisorFactory.getAdvisors(factory));\n                        }\n                    }\n                }\n                this.aspectBeanNames = aspectNames;\n                return advisors;\n            }\n        }\n    }\n\n    //如果走到这里，说明已经找过一遍了，这里从缓存获取信息\n    if (aspectNames.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<Advisor> advisors = new LinkedList<>();\n    //遍历所有缓存的切面名\n    for (String aspectName : aspectNames) {\n        //根据切面名从缓存拿Advisor\n        List<Advisor> cachedAdvisors = this.advisorsCache.get(aspectName);\n        //如果可以拿到，直接获取\n        if (cachedAdvisors != null) {\n            advisors.addAll(cachedAdvisors);\n        }\n        //如果拿不到，说明此时缓存的是factory\n        //根据factory使用advisorFactory创建Advisor\n        else {\n            MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);\n            advisors.addAll(this.advisorFactory.getAdvisors(factory));\n        }\n    }\n    return advisors;\n}\n```\n到这里，我们已经**完成了对所有Advisor的获取**，这里值得关注的是工厂（**advisorFactory**）是**如何创建Advisor**的呢？进入<code>ReflectiveAspectJAdvisorFactory</code>类的**getAdvisors**方法：\n```bash\n@Override\npublic List<Advisor> getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {\n    //获取切面类类型\n    Class<?> aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();\n    //获取切面Name\n    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();\n    //验证\n    validate(aspectClass);\n\n    // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator\n    // so that it will only instantiate once.\n    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =\n        new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);\n\n    List<Advisor> advisors = new LinkedList<>();\n    //遍历所有除了被打上@Pointcut注解的方法\n    for (Method method : getAdvisorMethods(aspectClass)) {\n        //在其每个方法中获取Advisor\n        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);\n        if (advisor != null) {\n            advisors.add(advisor);\n        }\n    }\n\n    // If it's a per target aspect, emit the dummy instantiating aspect.\n    if (!advisors.isEmpty() && lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {\n        Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);\n        advisors.add(0, instantiationAdvisor);\n    }\n\n    // Find introduction fields.\n    //获取DeclareParents注解的filed\n    for (Field field : aspectClass.getDeclaredFields()) {\n        Advisor advisor = getDeclareParentsAdvisor(field);\n        if (advisor != null) {\n            advisors.add(advisor);\n        }\n    }\n\n    return advisors;\n}\n```\n我们需要关注两点：\n1. **getAdvisorMethods**：此方法获取类上所有的<code>AdvisorMethods</code>，那么是如何进行的：\n```bash\nprivate List<Method> getAdvisorMethods(Class<?> aspectClass) {\n    final List<Method> methods = new LinkedList<>();\n    ReflectionUtils.doWithMethods(aspectClass, method -> {\n        // Exclude pointcuts\n        //获取方法上的注解，如果是Pointcut注解不处理\n        if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {\n            methods.add(method);\n        }\n    });\n    Collections.sort(methods, METHOD_COMPARATOR);\n    return methods;\n}\n```\n我们可以知道，其将**不是Pointcut的注解的方法加入到方法集合中作为AdvisorMethod**。\n2. **getAdvisor**：从上面获得的方法中，提取出<code>Advisor</code>：\n```bash\n@Override\n@Nullable\npublic Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,\n                          int declarationOrderInAspect, String aspectName) {\n\n    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());\n\n    //切点信息的获取\n    AspectJExpressionPointcut expressionPointcut = getPointcut(\n        candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());\n    if (expressionPointcut == null) {\n        return null;\n    }\n\n    //根据获得的切点信息封装增强器\n    return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,\n                                                          this, aspectInstanceFactory, declarationOrderInAspect, aspectName);\n}\n```\n我们依然需要关注两个点：\n\n- getPointcut：**切点信息的获取**\n- InstantiationModelAwarePointcutAdvisorImpl：**根据切点信息封装成增强器**\n\n##### 获取切点信息\n\n依然是在创建Advisor的工厂中的方法**getPointcut**：\n```bash\n@Nullable\nprivate AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class<?> candidateAspectClass) {\n    //获取该方法的注解\n    AspectJAnnotation<?> aspectJAnnotation =\n        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);\n    if (aspectJAnnotation == null) {\n        return null;\n    }\n\n    //封装信息\n    AspectJExpressionPointcut ajexp =\n        new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class<?>[0]);\n    //设置切点表达式\n    //例如：@Before（\"test()\"）上的test()\n    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());\n    if (this.beanFactory != null) {\n        ajexp.setBeanFactory(this.beanFactory);\n    }\n    return ajexp;\n}\n```\n需要关注的是获取方法的注解**findAspectJAnnotationOnMethod**：\n```bash\n@SuppressWarnings(\"unchecked\")\n@Nullable\nprotected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {\n    //需要关注的类型\n    Class<?>[] classesToLookFor = new Class<?>[] {\n        Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class};\n    for (Class<?> c : classesToLookFor) {\n        //将每个需要关注的类型都与方法进行匹配\n        AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c);\n        //如果找到，返回\n        if (foundAnnotation != null) {\n            return foundAnnotation;\n        }\n    }\n    return null;\n}\n```\n**findAnnotation ：**\n```bash\n@Nullable\nprivate static <A extends Annotation> AspectJAnnotation<A> findAnnotation(Method method, Class<A> toLookFor) {\n    //根据指定的类型寻找方法上的注解\n    A result = AnnotationUtils.findAnnotation(method, toLookFor);\n    if (result != null) {\n        //如果找到了，将其封装为AspectJAnnotation对象返回\n        return new AspectJAnnotation<>(result);\n    }\n    else {\n        return null;\n    }\n}\n```\n注意，在寻找注解的时候**仅仅是获取**了例如@Before(\"test()\")中的**test()这样的切点方法名信息**，这个过程在封装AspectJAnnotation对象时在**构造函数**完成：\n```bash\npublic AspectJAnnotation(A annotation) {\n    this.annotation = annotation;\n    this.annotationType = determineAnnotationType(annotation);\n    // We know these methods exist with the same name on each object,\n    // but need to invoke them reflectively as there isn't a common interface.\n    try {\n        //处理注解上的pointcut信息\n        this.pointcutExpression = resolveExpression(annotation);\n        this.argumentNames = (String) annotation.getClass().getMethod(\"argNames\").invoke(annotation);\n    }\n    catch (Exception ex) {\n        throw new IllegalArgumentException(annotation + \" cannot be an AspectJ annotation\", ex);\n    }\n}\n```\n```bash\nprivate String resolveExpression(A annotation) throws Exception {\n    //遍历获取注解中的两个方法名：value和pointcut\n    for (String methodName : EXPRESSION_PROPERTIES) {\n        Method method;\n        try {\n            //获取method对象\n            method = annotation.getClass().getDeclaredMethod(methodName);\n        }\n        catch (NoSuchMethodException ex) {\n            method = null;\n        }\n        if (method != null) {\n            //获取切点方法名，也就是注解上设置的，例如@Before(\"test()\")\n            //此时获取\"test()\"这样的字符串\n            String candidate = (String) method.invoke(annotation);\n            if (StringUtils.hasText(candidate)) {\n                return candidate;\n            }\n        }\n    }\n    throw new IllegalStateException(\"Failed to resolve expression: \" + annotation);\n}\n```\n\n##### 根据切点信息，封装成Advisor\n根据切点信息生成增强器，所有的增强都由<code>InstantiationModelAwarePointcutAdvisorImpl</code>这个类来封装，当然，这个类是一个<code>Advisor</code>。进入此类的构造函数：\n```bash\npublic InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,\n                                                  Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,\n                                                  MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {\n\n    //将获得的信息都封装到这个对象的属性上\n    this.declaredPointcut = declaredPointcut;\n    this.declaringClass = aspectJAdviceMethod.getDeclaringClass();\n    this.methodName = aspectJAdviceMethod.getName();\n    this.parameterTypes = aspectJAdviceMethod.getParameterTypes();\n    this.aspectJAdviceMethod = aspectJAdviceMethod;\n    this.aspectJAdvisorFactory = aspectJAdvisorFactory;\n    this.aspectInstanceFactory = aspectInstanceFactory;\n    this.declarationOrder = declarationOrder;\n    this.aspectName = aspectName;\n\n    if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {\n        // Static part of the pointcut is a lazy type.\n        Pointcut preInstantiationPointcut = Pointcuts.union(\n            aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);\n\n        // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.\n        // If it’s not a dynamic pointcut, it may be optimized out\n        // by the Spring AOP infrastructure after the first evaluation.\n        this.pointcut = new PerTargetInstantiationModelPointcut(\n            this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);\n        this.lazy = true;\n    }\n    else {\n        // A singleton aspect.\n        this.pointcut = this.declaredPointcut;\n        this.lazy = false;\n        //解析当前切点适用的Advice，并保存到instantiatedAdvice属性上\n        this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);\n    }\n}\n```\n\n在封装的过程中只是**简单的将信息放入类的属性中**，而值得关注的是最后一行的**instantiateAdvice**方法，此方法将**根据注解类型选择不同的Advise**，例如@Before、@After等等都是不同的Advice，它们需要前置或是后置通知，所体现的**增强的逻辑是不同的**，所以就需要不同的Advice来完成：\n```bash\nprivate Advice instantiateAdvice(AspectJExpressionPointcut pointcut) {\n    //委派别的类去获取Advice\n    Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut,\n                                                         this.aspectInstanceFactory, this.declarationOrder, this.aspectName);\n    return (advice != null ? advice : EMPTY_ADVICE);\n}\n```\n此类又委派了<code>aspectJAdvisorFactory</code>去获取Advice：\n```bash\n@Override\n@Nullable\npublic Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,\n                        MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {\n\n    //根据之前的信息获取切面类类型\n    Class<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();\n    validate(candidateAspectClass);\n\n    //寻找方法上的注解\n    AspectJAnnotation<?> aspectJAnnotation =\n        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);\n    if (aspectJAnnotation == null) {\n        return null;\n    }\n\n    // If we get here, we know we have an AspectJ method.\n    // Check that it’s an AspectJ-annotated class\n    if (!isAspect(candidateAspectClass)) {\n        throw new AopConfigException(\"Advice must be declared inside an aspect type: \" +\n                                     \"Offending method '\" + candidateAdviceMethod + \"' in class [\" +\n                                     candidateAspectClass.getName() + \"]\");\n    }\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Found AspectJ method: \" + candidateAdviceMethod);\n    }\n\n    AbstractAspectJAdvice springAdvice;\n\n    //根据刚刚从方法上获得的注解，解析成枚举的类型进行swich\n    switch (aspectJAnnotation.getAnnotationType()) {\n            //@Before注解将会走这里\n        case AtBefore:\n            springAdvice = new AspectJMethodBeforeAdvice(\n                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            break;\n            //@After注解\n        case AtAfter:\n            springAdvice = new AspectJAfterAdvice(\n                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            break;\n            //@AfterReturning\n        case AtAfterReturning:\n            springAdvice = new AspectJAfterReturningAdvice(\n                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();\n            if (StringUtils.hasText(afterReturningAnnotation.returning())) {\n                springAdvice.setReturningName(afterReturningAnnotation.returning());\n            }\n            break;\n            //@AfterThrowing\n        case AtAfterThrowing:\n            springAdvice = new AspectJAfterThrowingAdvice(\n                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();\n            if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {\n                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());\n            }\n            break;\n            //@Around\n        case AtAround:\n            springAdvice = new AspectJAroundAdvice(\n                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            break;\n            //@Pointcut\n        case AtPointcut:\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Processing pointcut '\" + candidateAdviceMethod.getName() + \"'\");\n            }\n            return null;\n        default:\n            throw new UnsupportedOperationException(\n                \"Unsupported advice type on method: \" + candidateAdviceMethod);\n    }\n\n    // Now to configure the advice...\n    //配置得到的Advice\n    springAdvice.setAspectName(aspectName);\n    springAdvice.setDeclarationOrder(declarationOrder);\n    String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);\n    if (argNames != null) {\n        springAdvice.setArgumentNamesFromStringArray(argNames);\n    }\n    springAdvice.calculateArgumentBindings();\n    return springAdvice;\n}\n```\n从上面我们可以知道，不同的通知对应不同的Advice，那么这些不同的advice的执行逻辑有哪些不同呢？这个疑问留着后面的执行过程会进行解答，这里只需要知道**我们获取的Advisor封装了advice与其切点信息**。\n\n#### 寻找适用的增强器\n我们的思路回到主线，此时我们已经**寻找到所有的增强器**了，现在开始从中**筛选**出适用的增强器：\n```bash\nprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n    //寻找所有适用的Advisor\n    //这一步在4.2中进行\n    List<Advisor> candidateAdvisors = findCandidateAdvisors();\n    //从所有Advisor中选出适合被当前Bean使用的Advisor\n    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n```\n此时执行**findAdvisorsThatCanApply**方法寻找适用的增强器：\n```bash\nprotected List<Advisor> findAdvisorsThatCanApply(\n    List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {\n\n    ProxyCreationContext.setCurrentProxiedBeanName(beanName);\n    try {\n        //委派AopUtils去做\n        return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);\n    }\n    finally {\n        ProxyCreationContext.setCurrentProxiedBeanName(null);\n    }\n}\n```\n这里委派了<code>AopUtils</code>去做事情：\n```bash\npublic static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {\n    if (candidateAdvisors.isEmpty()) {\n        return candidateAdvisors;\n    }\n    List<Advisor> eligibleAdvisors = new LinkedList<>();\n    //遍历之前找到的所有的Advisor\n    for (Advisor candidate : candidateAdvisors) {\n        //在这里会优先处理引介增强，并且判断Advisor是否适合此Bean\n        if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {\n            //优先加入List中\n            eligibleAdvisors.add(candidate);\n        }\n    }\n    boolean hasIntroductions = !eligibleAdvisors.isEmpty();\n    for (Advisor candidate : candidateAdvisors) {\n        if (candidate instanceof IntroductionAdvisor) {\n            // already processed\n            //已经处理过引介增强\n            continue;\n        }\n        //剩下的Advisor再进行判断\n        if (canApply(candidate, clazz, hasIntroductions)) {\n            //加入List中\n            eligibleAdvisors.add(candidate);\n        }\n    }\n    //返回适合的Advisor List\n    return eligibleAdvisors;\n}\n```\n我们重点关注**canApply**方法，看看是如何判断是否适合的：\n```bash\npublic static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {\n    if (advisor instanceof IntroductionAdvisor) {\n        //调用引介增强器的ClassFilter去匹配当前Bean是否适合\n        return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);\n    }\n    else if (advisor instanceof PointcutAdvisor) {\n        //如果是普通的Advisor，转换成PointcutAdvisor\n        //PointcutAdvisor接口定义了获取切点的方法getPointcut\n        PointcutAdvisor pca = (PointcutAdvisor) advisor;\n        //根据切点信息，寻找是否适合\n        return canApply(pca.getPointcut(), targetClass, hasIntroductions);\n    }\n    else {\n        // It doesn't have a pointcut so we assume it applies.\n        //如果没有切点，就假设它适合\n        return true;\n    }\n}\n```\n这里我们先忽略引介增强器，关注普通的Advisor。这里进入**canApply**方法，根据切点信息去判断是否合适：\n```bash\npublic static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\n    Assert.notNull(pc, \"Pointcut must not be null\");\n    //获取切点类过滤器，如果不符合直接返回false\n    //如果符合进入下一步判断\n    if (!pc.getClassFilter().matches(targetClass)) {\n        return false;\n    }\n\n    //获取切点的方法匹配器\n    MethodMatcher methodMatcher = pc.getMethodMatcher();\n    //如果此时methodMatcher是一个MethodMatcher.TRUE，说明匹配任何方法，直接返回true\n    if (methodMatcher == MethodMatcher.TRUE) {\n        // No need to iterate the methods if we’re matching any method anyway...\n        return true;\n    }\n\n    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n    if (methodMatcher instanceof IntroductionAwareMethodMatcher) {\n        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;\n    }\n\n    //拿到目标类的所有父类（包括接口）\n    Set<Class<?>> classes = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n    //包括本类\n    classes.add(targetClass);\n    //遍历父类与本类\n    for (Class<?> clazz : classes) {\n        //获取本class的方法对象\n        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n        //遍历方法\n        for (Method method : methods) {\n            //两个验证器只要其中一个匹配，就返回true\n            if ((introductionAwareMethodMatcher != null &&\n                 introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||\n                methodMatcher.matches(method, targetClass)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```\n到这里，就**完成了适用的增强器的查找**，从上面我们可以知道，当一个Bean中的任何一个方法（方法**包括在父类**中的方法）**匹配Advisor中的切点信息**，就认为当前的Advisor是**匹配当前Bean**的，就将此时的**Advisor加入此类的Advisors列表**中，注意，一个Bean中是可以有多个Advisor的，如果不能理解为什么一个Bean对应多个Advisor，你应该还没有明白Advisor的概念，Advisor中包含advice与切点信息，也就是说，一个通知方法例如前置通知@Before是对应一个Advisor的，如果一个类中既有前置通知又有后置通知，那么这个类中的Advisor是会匹配两个的。\n\n#### 创建代理\n##### 获取代理类型（JDK或CGLIB）\n再次回到最开始的地方，还记得4.1的**wrapIfNecessary**方法吗？此时我们已经寻找完符合此Bean的增强器了（**getAdvicesAndAdvisorsForBean**方法），就像刚刚所说，如果有两个通知匹配的话，现在增强器列表应该会有两个Advisor，也就是说增强列表不为空，将进行下一步，创建代理的过程**createProxy**：\n```bash\nprotected Object createProxy(Class<?> beanClass, @Nullable String beanName,\n                             @Nullable Object[] specificInterceptors, TargetSource targetSource) {\n\n    if (this.beanFactory instanceof ConfigurableListableBeanFactory) {\n        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);\n    }\n\n    ProxyFactory proxyFactory = new ProxyFactory();\n    //复制当前Creator的一些属性例如proxyTargetClass或是exposeProxy等\n    proxyFactory.copyFrom(this);\n\n    //如果proxyTargetClass是false才会进入判断\n    //如果proxyTargetClass是true就直接用CGLib代理了，不需要判断\n    if (!proxyFactory.isProxyTargetClass()) {\n        //判断是否需要代理本类\n        if (shouldProxyTargetClass(beanClass, beanName)) {\n            //也就是说，如果需要代理本类，将使用CGLib方式代理\n            proxyFactory.setProxyTargetClass(true);\n        }\n        //如果不需要，则获取所有该类的接口，设置到proxyFactory对象中\n        else {\n            evaluateProxyInterfaces(beanClass, proxyFactory);\n        }\n    }\n\n    //处理所有得到的适用的拦截器转换成Advisor\n    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);\n    //将Advisors加入proxyFactory对象中\n    proxyFactory.addAdvisors(advisors);\n    //将原本的Bean对象（原生未代理）加入proxyFactory对象中\n    proxyFactory.setTargetSource(targetSource);\n    //定制代理\n    customizeProxyFactory(proxyFactory);\n\n    proxyFactory.setFrozen(this.freezeProxy);\n    if (advisorsPreFiltered()) {\n        proxyFactory.setPreFiltered(true);\n    }\n\n    //设置好属性之后，就调用proxyFactory对象生成代理对象\n    return proxyFactory.getProxy(getProxyClassLoader());\n}\n```\n以上过程都在给<code>proxyFactory</code>这个对象设置属性，然后调用<code>proxyFactory</code>根据设置的一些属性生成代理对象，最后执行关键的创建代理方法**getProxy**：\n```bash\npublic Object getProxy(@Nullable ClassLoader classLoader) {\n    return createAopProxy().getProxy(classLoader);\n}\n```\n```bash\nprotected final synchronized AopProxy createAopProxy() {\n    if (!this.active) {\n        activate();\n    }\n    //使用aopProxyFactory根据本类信息创建\n    return getAopProxyFactory().createAopProxy(this);\n}\n```\n其中<code>aopProxyFactory</code>是在其父类的构造函数中赋值的：\n```bash\npublic ProxyCreatorSupport() {\n    this.aopProxyFactory = new DefaultAopProxyFactory();\n}\n```\n进入其创建方法**createAopProxy**：\n```bash\n@Override\npublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n    //判断ProxyTargetClass属性和是否有代理接口等等判断使用何种方式做代理\n    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {\n        Class<?> targetClass = config.getTargetClass();\n        if (targetClass == null) {\n            throw new AopConfigException(\"TargetSource cannot determine target class: \" +\n                                         \"Either an interface or a target is required for proxy creation.\");\n        }\n        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\n            return new JdkDynamicAopProxy(config);\n        }\n        return new ObjenesisCglibAopProxy(config);\n    }\n    else {\n        return new JdkDynamicAopProxy(config);\n    }\n}\n```\n> 注意此时config对象是我们之前设置了各种信息的proxyFactory对象，在代理的构造函数中存放了这个属性，也就是说代理对象持有一个Advisor列表。\n\n这段代码清晰明了，主要就是在**判断使用何种方式做代理**：\n\n- optimize：这个属性适用于CGLib，对JDK动态代理无效。主要是控制CGLib创建的代理是否使用激进的优化策略。\n- proxyTargetClass：文章开头也有提到，如果属性为true，将会使用CGLib进行代理。\n- hasNoUserSuppliedProxyInterfaces：是否存在代理接口。\n\n总结一下JDK于CGLIB如何选择：\n- 如果目标对象实现了接口，默认情况下会采用JDK代理\n- 如果目标对象实现了接口，但可以使用proxyTargetClass属性来强制使用CGLIB代理\n- 如果对象没用实现接口，必须使用CGLIB代理\n\n##### 获取代理\n\n思路回到开头获取代理的方法中：\n```bash\npublic Object getProxy(@Nullable ClassLoader classLoader) {\n    return createAopProxy().getProxy(classLoader);\n}\n```\n此时我们完成了**createAopProxy**，拿到了JDK代理对象（我们这里假设用JDK做代理）接着调用其**getProxy**方法：\n```bash\n@Override\npublic Object getProxy(@Nullable ClassLoader classLoader) {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Creating JDK dynamic proxy: target source is \" + this.advised.getTargetSource());\n    }\n    //拿到被代理类的接口\n    Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);\n    //检查上面得到的接口是否定义了equals、hashCode方法\n    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);\n    //创建代理对象\n    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n}\n```\n注意此时的<code>advised</code>就是我们上面所说的<code>config</code>对象也就是封装半天信息的<code>proxyFactory</code>对象，里面存有一系列信息例如**Advisor、切点之类**。\n\n这里不对动态代理进行解释，如果熟悉动态代理的看到这里应该已经懂了，其将当前对象作为实现代理的主要对象。毫无疑问，当前对象一定实现了<code>InvocationHandler</code>接口，我们需要关注的即为它的**invoke**方法：\n```bash\n@Override\n@Nullable\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    MethodInvocation invocation;\n    Object oldProxy = null;\n    boolean setProxyContext = false;\n\n    //原生对象\n    TargetSource targetSource = this.advised.targetSource;\n    Object target = null;\n\n    try {\n        //eqauls()方法，如果目标对象未实现此方法\n        if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {\n            // The target does not implement the equals(Object) method itself.\n            return equals(args[0]);\n        }\n        //hashCode()方法，如果目标对象未实现此方法\n        else if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {\n            // The target does not implement the hashCode() method itself.\n            return hashCode();\n        }\n        else if (method.getDeclaringClass() == DecoratingProxy.class) {\n            // There is only getDecoratedClass() declared -> dispatch to proxy config.\n            return AopProxyUtils.ultimateTargetClass(this.advised);\n        }\n        //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知\n        else if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&\n                 method.getDeclaringClass().isAssignableFrom(Advised.class)) {\n            // Service invocations on ProxyConfig with the proxy config...\n            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);\n        }\n\n        Object retVal;\n\n        //这里就是先前提到的如果exposeProxy属性为true，将会暴露一个proxy代理对象\n        //给AOP上下文对象，存在线程变量中\n        if (this.advised.exposeProxy) {\n            // Make invocation available if necessary.\n            oldProxy = AopContext.setCurrentProxy(proxy);\n            setProxyContext = true;\n        }\n\n        // Get as late as possible to minimize the time we \"own\" the target,\n        // in case it comes from a pool.\n        //获得目标对象的类\n        target = targetSource.getTarget();\n        Class<?> targetClass = (target != null ? target.getClass() : null);\n\n        // Get the interception chain for this method.\n        //获取可以应用到此方法上的Interceptor列表\n        List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\n        // Check whether we have any advice. If we don’t, we can fallback on direct\n        // reflective invocation of the target, and avoid creating a MethodInvocation.\n        //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)\n        if (chain.isEmpty()) {\n            // We can skip creating a MethodInvocation: just invoke the target directly\n            // Note that the final invoker must be an InvokerInterceptor so we know it does\n            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.\n            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n        }\n        else {\n            // We need to create a method invocation...\n            //走到这里，说明该方法符合被通知的条件，创建MethodInvocation\n            //执行其proceed方法\n            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n            // Proceed to the joinpoint through the interceptor chain.\n            retVal = invocation.proceed();\n        }\n\n        // Massage return value if necessary.\n        Class<?> returnType = method.getReturnType();\n        if (retVal != null && retVal == target &&\n            returnType != Object.class && returnType.isInstance(proxy) &&\n            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {\n            // Special case: it returned \"this\" and the return type of the method\n            // is type-compatible. Note that we can't help if the target sets\n            // a reference to itself in another returned object.\n            retVal = proxy;\n        }\n        else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {\n            throw new AopInvocationException(\n                \"Null return value from advice does not match primitive return type for: \" + method);\n        }\n        return retVal;\n    }\n    finally {\n        if (target != null && !targetSource.isStatic()) {\n            // Must have come from TargetSource.\n            targetSource.releaseTarget(target);\n        }\n        if (setProxyContext) {\n            // Restore old proxy.\n            AopContext.setCurrentProxy(oldProxy);\n        }\n    }\n}\n```\n也就是说，每次调用代理对象的方法，将执行以下步骤：\n1. **判断是否是equals或hashCode或Advised的方法**：如果是执行对应判断。\n2. **判断是否需要暴露代理对象**（将代理对象存入AopContext）：在文章开头就有提到这个属性，还是之前的例子，在A方法中调用B方法，此时B方法其实是原生对象的B方法，但如果B方法需要被AOP，需要执行的是代理对象的B方法，而不是原生对象的B方法，原生对象的B方法是没有被代理AOP的。所以这里需要暴露出代理对象，从AopContext上下文中取出代理对象，将其强转成对应类，执行B方法，此时的B方法即可是被AOP的方法了。值得一提的是AopContext暴露出来的代理对象是线程变量。\n3. **获取当前方法对应的拦截器链**：主要是使用<code>advised</code>去对当前方法进行判断**是否符合切点**如果符合取出对应需要执行的链。如果此时**链为空**，代表执行的该方法是**不需要被AOP**的，正常反射执行即可，如果**链不为空**，将链封装成<code>ReflectiveMethodInvocation</code>对象执行其**proceed**方法，该对象的该方法是执行AOP的核心，下面详细讲解。\n\n#### 执行AOP通知\n到此我们创建好了代理对象，并**返回出去作为一个Bean存放在IOC容器中**，当我们取出此Bean并执行方法时，如果碰到了需要被AOP的方法时，会找到一个**拦截器链**，然后将其传入<code>ReflectiveMethodInvocation</code>对象封装，接着不会执行原方法而是执行其**proceed**方法，所以该方法是执行AOP通知的核心方法：\n```bash\n//此属性默认为-1\nprivate int currentInterceptorIndex = -1;\n\n//存放interceptors的列表\nprotected final List<?> interceptorsAndDynamicMethodMatchers;\n\n@Override\n@Nullable\npublic Object proceed() throws Throwable {\n    //  We start with an index of -1 and increment early.\n    //如果Interceptor执行完了，则执行joinPoint\n    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n        return invokeJoinpoint();\n    }\n\n    //根据游标获取对应的Advice\n    Object interceptorOrInterceptionAdvice =\n        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n    //如果要动态匹配joinPoint\n    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n        // Evaluate dynamic method matcher here: static part will already have\n        // been evaluated and found to match.\n        InterceptorAndDynamicMethodMatcher dm =\n            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n        //动态匹配：运行时参数是否满足匹配条件\n        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n            return dm.interceptor.invoke(this);\n        }\n        else {\n            // Dynamic matching failed.\n            // Skip this interceptor and invoke the next in the chain.\n            //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor\n            return proceed();\n        }\n    }\n    else {\n        // It’s an interceptor, so we just invoke it: The pointcut will have\n        // been evaluated statically before this object was constructed.\n        //执行当前IntercetporAdvice\n        //注意此时传了this对象，是为了执行链的保持\n        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n    }\n}\n```\n\n到这里，需要解释几点：\n1. **如何判断执行结束？在开头我们说到currentInterceptorIndex**属性是为-1的，**interceptorsAndDynamicMethodMatchers**的size是执行链的数量，刚进来的时候执行链一定大于等于1，所以其减1也不会等于-1，不会执行**invokeJoinpoint**方法，走到下面执行这样一行代码\n```bash\nObject interceptorOrInterceptionAdvice =\n        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n```\n注意此时**currentInterceptorIndex**游标变成了0，也就是取执行链的第一个执行器取执行，同时游标变成0。下面会执行Advice的**invoke**方法，这里举例Before类型的Advice的**invoke**方法：\n```bash\n@Override\npublic Object invoke(MethodInvocation mi) throws Throwable {\n    this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );\n    return mi.proceed();\n}\n```\n注意此时<code>mi对象</code>就是上面传进来的<code>this</code>，也就是<code>ReflectiveMethodInvocation</code>对象，他在通知方法执行完成之后，又执行了<code>ReflectiveMethodInvocation</code>的**proceed**方法，然后第二次进入**proceed**时，游标已经变成了0，我们假设此时拦截器数量为一个，那么此时**currentInterceptorIndex=0,interceptorsAndDynamicMethodMatchers.size() - 1 = 0：**\n```bash\nif (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n    return invokeJoinpoint();\n}\n```\n将中止执行下面的内容，直接执行**invokeJoinpoint**方法：\n```bash\n@Nullable\nprotected Object invokeJoinpoint() throws Throwable {\n    return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);\n}\n```\n这里底层就是**通过反射执行原方法**，到此结束，也就是说其**利用游标索引与循环调用proceed方法来判断当前执行链的结束**，真是个聪明的方法。\n\n2. **为什么@Before的Advice的invoke可以实现前置通知效果，同样的@After如何实现后置通知效果？在这里我们将补上上面没有详细讲解的一些Advice类 。**\n1) <code>MethodBeforeAdviceInterceptor</code>前置通知：\n```bash\npublic class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {\n\n    private MethodBeforeAdvice advice;\n\n    /**\n   * Create a new MethodBeforeAdviceInterceptor for the given advice.\n   * @param advice the MethodBeforeAdvice to wrap\n   */\n    //构造器初始化保存了advice对象\n    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {\n        Assert.notNull(advice, \"Advice must not be null\");\n        this.advice = advice;\n    }\n\n    @Override\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );\n        return mi.proceed();\n    }\n}\n```\n2)<code>AfterReturningAdviceInterceptor</code>后置通知：\n```bash\npublic class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable {\n\n    private final AfterReturningAdvice advice;\n\n\n    /**\n   * Create a new AfterReturningAdviceInterceptor for the given advice.\n   * @param advice the AfterReturningAdvice to wrap\n   */\n    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) {\n        Assert.notNull(advice, \"Advice must not be null\");\n        this.advice = advice;\n    }\n\n    @Override\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        Object retVal = mi.proceed();\n        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());\n        return retVal;\n    }\n\n}\n```\n从上面两个不同的<code>Advice</code>可以看出，其**invoke**方法的逻辑只是**顺序不同**而已，但为什么可以达到前置后置通知的呢？其实前置通知很好理解，在invoke的逻辑中只要**先执行我们指定的前置通知逻辑**，然后**继续往下执行proceed**即可实现在执行原方法前加一段逻辑的功能，我们主要分析后置通知是如何实现的。还是进行一个假设，此时该方法**只有一个执行链后置通知@After**，那么刚开始进入proceed方法时，获取这个Advice执行invoke方法，然后**又去执行proceed方法**了，由上面的分析此时的游标显示执行链已经执行完毕，所以此时会**直接反射执行原方法**，然后**proceed方法执行完毕**，最后将会执行后置通知Advice的invoke方法的下一步，**advice.afterReturning**，也就是用户**自定义的后置方法逻辑**，实现了在方法最后插入一段代码逻辑的功能，如果是多个通知例如前置后置都有的话，留给读者思考，相信懂得以上逻辑之后推敲起来并不是很难。\n\n---\n\n### 总结\n到这里为止，我们分析了AOP是从**自定义标签开始**，自定义标签注册了一个<code>Creator</code>类，而此<code>Creator</code>类是一个<code>BeanPostProcessor</code>，也就是说每个Bean都将调用Creator实现的方法。\n\n来到了**如何实现AOP代理的分析**中，在此方法中判断Bean是否需要被代理，然后进一步判断此Bean是否可以获得增强器，在这个过程中会去拿所有的Advisor，然后在所有的Advisor列表中筛选出适用的增强器，如果适用的增强器Advisor为空证明此Bean不用被代理，如果不为空则会进入创建代理的流程。\n\n所以我们开始分析**创建代理是怎样的过程** ，在什么情况下会进行JDK动态代理，在什么情况下会进行CGLIB动态代理，然后创建代理结束之后。\n\n必不可少的也需要分析是**如何执行AOP通知**的，其核心类是<code>ReflectiveMethodInvocation</code>的**proceed**方法，轮询执行拦截器，并且不同的Advice根据其特有的逻辑执行调用顺序，来完成AOP通知的功能。\n","slug":"Spring-3","published":1,"updated":"2020-02-21T16:36:05.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyx000nv9s619sicn6s","content":"<blockquote>\n<p>阅读这篇文章前，最好有代理模式的基础，以及了解关于Spring扩展点例如BeanPostProcessor和如何使用自定义标签集成Spring，这些文章在我的博客里都能找到。当然，也最好有使用AOP的经验，这篇文章不会讲解如何使用AOP。</p>\n</blockquote>\n<p><img src=\"/images/spring_logo.jpg\" alt=\"Spring\"></p>\n<h3 id=\"AOP简介\"><a href=\"#AOP简介\" class=\"headerlink\" title=\"AOP简介\"></a>AOP简介</h3><p>说到AOP，其实这是一个<strong>面向方面的编程思想</strong> ，它解决了OOP的一些弊端，例如我们需要为<strong>多个不具有继承关系的类引入一个公共行为</strong>， 比如说日志、权限验证、事务管理等等，我们需要将这些代码<strong>重复的添加</strong>到一系列的类中，将<strong>产生大量的重复代码</strong>，如果需要修改，将在每个类中去进行修改，<strong>不便于维护</strong>，代码的<strong>侵入性极高</strong>。所以就有了AOP这样面向方面编程的编程思想，其功能可以为每个需要的类<strong>加入共同的行为</strong>，如果需要修改，只需要修改切面中的代码，改一处等于改多处，并且便于编程，写一个切面类即可达到在每个类中加入重复代码的目的。</p>\n<p>阅读此篇文章，你将了解Spring是<strong>如何实现AOP</strong>（前置通知、后置通知、环绕通知），由于Spring中的事务管理是基于AOP的功能来做的，所以你将更好的能理解Spring是如何将事务统一管理起来的。</p>\n<hr>\n<h3 id=\"自定义标签开启AOP\"><a href=\"#自定义标签开启AOP\" class=\"headerlink\" title=\"自定义标签开启AOP\"></a>自定义标签开启AOP</h3><p>只要用过AOP都知道，如果需要使用AOP，需要在配置文件中写这样一段配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:aspectj-autoproxy /&gt;</span><br></pre></td></tr></table></figure>\n<p>只有写了这段配置才可以开启AOP功能，那么这个自定义标签又做了什么呢？在上一篇讲解自定义标签的文章中详细讲到了，此时我们需要关注其标签头aop去寻找对应的命名空间：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlns:aop=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span></span><br></pre></td></tr></table></figure>\n<p>全局搜索命名空间<code>&lt;http\\://<a href=\"http://www.springframework.org/schema/aop\" target=\"_blank\" rel=\"noopener\">www.springframework.org/schema/aop</a>&gt;</code>，注意http后加一个“\\” ，可以找到<strong>spring.handlers</strong>文件中对应的handler类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http\\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure>\n<p>这样就找到了命名空间对应的handler：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AopNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Register the &#123;@link BeanDefinitionParser BeanDefinitionParsers&#125; <span class=\"keyword\">for</span> the</span><br><span class=\"line\">   * <span class=\"string\">'&#123;@code config&#125;'</span>, <span class=\"string\">'&#123;@code spring-configured&#125;'</span>, <span class=\"string\">'&#123;@code aspectj-autoproxy&#125;'</span></span><br><span class=\"line\">   * and <span class=\"string\">'&#123;@code scoped-proxy&#125;'</span> tags.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void <span class=\"function\"><span class=\"title\">init</span></span>() &#123;</span><br><span class=\"line\">    // In 2.0 XSD as well as <span class=\"keyword\">in</span> 2.1 XSD.</span><br><span class=\"line\">    registerBeanDefinitionParser(<span class=\"string\">\"config\"</span>, new ConfigBeanDefinitionParser());</span><br><span class=\"line\">    registerBeanDefinitionParser(<span class=\"string\">\"aspectj-autoproxy\"</span>, new AspectJAutoProxyBeanDefinitionParser());</span><br><span class=\"line\">    registerBeanDefinitionDecorator(<span class=\"string\">\"scoped-proxy\"</span>, new ScopedProxyBeanDefinitionDecorator());</span><br><span class=\"line\"></span><br><span class=\"line\">    // Only <span class=\"keyword\">in</span> 2.0 XSD: moved to context namespace as of 2.1</span><br><span class=\"line\">    registerBeanDefinitionParser(<span class=\"string\">\"spring-configured\"</span>, new SpringConfiguredBeanDefinitionParser());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回到开头配置自定义标签，我们使用了<code>aspectj-autoproxy</code>这个Parser。在init方法中，我们找到<code>aspectj-autoproxy</code>对应的Parser是<code>AspectJAutoProxyBeanDefinitionParser</code>这个类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">//我们只关注解析的主方法，parse方法</span><br><span class=\"line\">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class=\"line\">    //注册一个类到IOC容器中</span><br><span class=\"line\">    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class=\"line\">    extendBeanDefinition(element, parserContext);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"注册AnnotationAwareAspectJAutoProxyCreator\"><a href=\"#注册AnnotationAwareAspectJAutoProxyCreator\" class=\"headerlink\" title=\"注册AnnotationAwareAspectJAutoProxyCreator\"></a>注册AnnotationAwareAspectJAutoProxyCreator</h3><p><code>AnnotationAwareAspectJAutoProxyCreator</code>是实现AOP功能的主要类，我们先来看看这个类的结构：<br><img src=\"/images/spring-aop1.png\" alt=\"spring\"><br>此类实现了<code>BeanPostProcessor</code>，稍后将关注其后置处理Bean的方法<strong>postProcessAfterInitialization</strong>，并且实现了<code>BeanFactorAware</code>接口，此类将取得并存有一个<code>BeanFactory</code>实例对象。<br>回到主线，关注注册此类的方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class=\"line\">    ParserContext parserContext, Element sourceElement) &#123;</span><br><span class=\"line\">//将一个类作为Bean注册到IOC容器中</span><br><span class=\"line\">    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class=\"line\">        parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class=\"line\">    //处理proxy-target-class与expose-proxy属性</span><br><span class=\"line\">    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class=\"line\">    //注册组件并通知</span><br><span class=\"line\">    registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，在注册这个类的过程中主要完成了3件事：</p>\n<ol>\n<li>注册<code>AnnotationAwareAspectJAutoProxyCreator：</code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry,</span><br><span class=\"line\">                                                                                  @Nullable Object <span class=\"built_in\">source</span>) &#123;</span><br><span class=\"line\">//将AnnotationAwareAspectJAutoProxyCreator这个类注册到IOC容器中</span><br><span class=\"line\">    <span class=\"built_in\">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, <span class=\"built_in\">source</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry,</span><br><span class=\"line\">                                                              @Nullable Object <span class=\"built_in\">source</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Assert.notNull(registry, <span class=\"string\">\"BeanDefinitionRegistry must not be null\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果IOC容器中已经存在了此类型的Bean，则需要判断优先级</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">        //获取此类的BeanDefinition信息</span><br><span class=\"line\">        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class=\"line\">        //如果此Bean的ClassName与AnnotationAwareAspectJAutoProxyCreator类的</span><br><span class=\"line\">        //ClassName不同的话，判断优先级</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class=\"line\">            int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class=\"line\">            int requiredPriority = findPriorityForClass(cls);</span><br><span class=\"line\">            //如果已存在Bean优先级小于Creator的优先级</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class=\"line\">                //将ClassName替换成Creator</span><br><span class=\"line\">                apcDefinition.setBeanClassName(cls.getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //不进行注册，因为已经注册了</span><br><span class=\"line\">        <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果到这里，说明IOC容器中没有配置对应Creator</span><br><span class=\"line\">    //使用Crearir的Class构造一个BeanDefinition</span><br><span class=\"line\">    RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);</span><br><span class=\"line\">    beanDefinition.setSource(<span class=\"built_in\">source</span>);</span><br><span class=\"line\">    //配置依赖属性order，将其设置为最高优先级</span><br><span class=\"line\">    beanDefinition.getPropertyValues().add(<span class=\"string\">\"order\"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class=\"line\">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class=\"line\">    //将设置好属性的BeanDefinition注册进IOC容器中</span><br><span class=\"line\">    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> beanDefinition;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>处理<strong>proxy-target-class</strong>与<strong>expose-proxy</strong>属性<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, @Nullable Element sourceElement) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sourceElement != null) &#123;</span><br><span class=\"line\">        boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class=\"line\">        //处理proxy-target-class属性</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (proxyTargetClass) &#123;</span><br><span class=\"line\">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class=\"line\">        //处理expose-proxy属性</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exposeProxy) &#123;</span><br><span class=\"line\">            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n其中设置属性的过程：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">        //根据之前注册的BeanName取出Creator</span><br><span class=\"line\">        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class=\"line\">        //将Creator的BeanDefinition的属性proxyTargetClass设置为<span class=\"literal\">true</span></span><br><span class=\"line\">        definition.getPropertyValues().add(<span class=\"string\">\"proxyTargetClass\"</span>, Boolean.TRUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">        //根据之前注册的BeanName取出Creator</span><br><span class=\"line\">        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class=\"line\">        //将Creator的BeanDefinition的属性exposeProxy设置为<span class=\"literal\">true</span></span><br><span class=\"line\">        definition.getPropertyValues().add(<span class=\"string\">\"exposeProxy\"</span>, Boolean.TRUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><strong>proxy-target-class</strong>：在Spring的AOP中，默认的如果目标类实现了至少一个接口，将使用<strong>JDK动态代理</strong>实现AOP，否则使用<strong>CGLib动态代理</strong>实现AOP，如果希望AOP都使用CGLib实现，你就可以设置proxy-target-class属性为<strong>true</strong>，但要注意几个问题：</li>\n</ul>\n<p>1)<strong>无法对final的方法进行动态代理</strong>，原因很简单，CGLib使用继承实现，final方法无法重写，所以final的方法不能应用AOP。<br>2)需要配置CGLib的JAR包</p>\n<ul>\n<li><strong>expose-proxy</strong>：在讲解事务的那篇文章中有提到，如果一个类中的事务A方法调用了同一个类中的事务B方法，<strong>B方法将没有事务</strong>，这个道理在AOP中也是这样的，相同类下的不同方法互相调用，内部方法将无法被应用通知（无法进行AOP），此时你需要将<strong>expose-proxy属性设置为true</strong>，暴露一个代理类（此属性的原理在下面会有详细讲解），然后在A方法中需要调用B方法的话需要这样写：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Service&#123;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">        ((Service)AopContext.currentProxy()).B();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">B</span></span>()&#123;</span><br><span class=\"line\">    //<span class=\"keyword\">do</span> something...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n这样，B方法就算再A方法内也可以被AOP。其中<code>AopContext</code>是存放线程变量的类，形象的称之为<strong>AOP的上下文</strong>。</li>\n</ul>\n<hr>\n<h3 id=\"实现AOP代理\"><a href=\"#实现AOP代理\" class=\"headerlink\" title=\"实现AOP代理\"></a>实现AOP代理</h3><h4 id=\"创建AOP代理\"><a href=\"#创建AOP代理\" class=\"headerlink\" title=\"创建AOP代理\"></a>创建AOP代理</h4><p>上面，自定义标签的配置完成了对<strong>Creator类的自动注册</strong>，我们可以知道，此类实现了<code>BeanPostProcessor</code>接口，将会在IOC容器初始化每个Bean时都调用此类的<strong>postProcessAfterInitialization</strong>方法，此方法即为AOP代理的入口，此方法在抽象父类<code>AbstractAutoProxyCreator</code>实现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bean != null) &#123;</span><br><span class=\"line\">        //先从缓存中获取Key，由要代理的Bean的Class与benaName组成</span><br><span class=\"line\">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class=\"line\">        //判断是否是过早暴露的Bean，此概念在讲IOC解决循环依赖中有提到</span><br><span class=\"line\">        //如果是过早暴露的Bean，则此时连依赖注入都没有完成，则不对其进行代理</span><br><span class=\"line\">        //待其真正初始化之后再尝试代理</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!this.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class=\"line\">            //如果符合条件进行AOP代理</span><br><span class=\"line\">            <span class=\"built_in\">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> bean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class=\"line\">    //如果先前已经处理过的，不进行处理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //如果此Bean已经被标记为无法代理，不进行处理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //如果Bean为AOP类的类型，或是需要跳过的类型，不进行处理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class=\"line\">        //标记为不代理</span><br><span class=\"line\">        this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Create proxy <span class=\"keyword\">if</span> we have advice.</span><br><span class=\"line\">    //寻找符合此Bean的增强方法（通知方法）</span><br><span class=\"line\">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</span><br><span class=\"line\">    //如果寻找到的增强方法列表不为空，也就是不为DO_NOT_PROXY</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class=\"line\">        //标记为已代理</span><br><span class=\"line\">        this.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class=\"line\">        //根据找到的增强方法，对此Bean进行动态代理</span><br><span class=\"line\">        Object proxy = createProxy(</span><br><span class=\"line\">            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class=\"line\">        this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class=\"line\">        //将代理对象作为Bean返回给IOC容器</span><br><span class=\"line\">        <span class=\"built_in\">return</span> proxy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  //如果走到这里，说明代理失败，标记为代理失败</span><br><span class=\"line\">    this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> bean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>文章到了这里，就已经基本完成AOP的实现了，剩下我们需要关注的就是两件事：</p>\n<ul>\n<li>如何寻找符合Bean的增强器</li>\n<li>如何对Bean创建动态代理</li>\n</ul>\n<h4 id=\"寻找所有的增强器\"><a href=\"#寻找所有的增强器\" class=\"headerlink\" title=\"寻找所有的增强器\"></a>寻找所有的增强器</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) &#123;</span><br><span class=\"line\">    //寻找适合的Advisor</span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (advisors.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> DO_NOT_PROXY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> advisors.toArray();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有一个<code>Advisor</code>的概念，其中Advisor<strong>封装了切点信息与advise通知方法等等信息。</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class=\"line\">    //寻找所有适用的Advisor</span><br><span class=\"line\">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class=\"line\">    //从所有Advisor中选出适合被当前Bean使用的Advisor</span><br><span class=\"line\">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class=\"line\">    extendAdvisors(eligibleAdvisors);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class=\"line\">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> eligibleAdvisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"寻找已存在的Advisor\"><a href=\"#寻找已存在的Advisor\" class=\"headerlink\" title=\"寻找已存在的Advisor\"></a>寻找已存在的Advisor</h5><p>首先，执行下面的方法寻找合适的<code>Advisor</code>（此方法在子类<code>Creator</code>中得到实现）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected List&lt;Advisor&gt; <span class=\"function\"><span class=\"title\">findCandidateAdvisors</span></span>() &#123;</span><br><span class=\"line\">    // Add all the Spring advisors found according to superclass rules.</span><br><span class=\"line\">    //首先调用父类findCandidateAdvisors的方法寻找在IOC容器中的Advisor类型的Bean</span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();</span><br><span class=\"line\">    // Build Advisors <span class=\"keyword\">for</span> all AspectJ aspects <span class=\"keyword\">in</span> the bean factory.</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (this.aspectJAdvisorsBuilder != null) &#123;</span><br><span class=\"line\">        //寻找注解的Advisor</span><br><span class=\"line\">        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> advisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先调用父类的<strong>findCandidateAdvisors</strong>方法寻找所有的<code>Advisor</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected List&lt;Advisor&gt; <span class=\"function\"><span class=\"title\">findCandidateAdvisors</span></span>() &#123;</span><br><span class=\"line\">    Assert.state(this.advisorRetrievalHelper != null, <span class=\"string\">\"No BeanFactoryAdvisorRetrievalHelper available\"</span>);</span><br><span class=\"line\">    //委派Helper类去寻找</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;Advisor&gt; <span class=\"function\"><span class=\"title\">findAdvisorBeans</span></span>() &#123;</span><br><span class=\"line\">    // Determine list of advisor bean names, <span class=\"keyword\">if</span> not cached already.</span><br><span class=\"line\">    String[] advisorNames = null;</span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        //先从缓存中取</span><br><span class=\"line\">        advisorNames = this.cachedAdvisorBeanNames;</span><br><span class=\"line\">        //缓存中若没有再去IOC容器中取</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (advisorNames == null) &#123;</span><br><span class=\"line\">            // Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class=\"line\">            // uninitialized to <span class=\"built_in\">let</span> the auto-proxy creator apply to them!</span><br><span class=\"line\">            //从IOC容器中寻找所有Advisor类型的BeanName</span><br><span class=\"line\">            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class=\"line\">                this.beanFactory, Advisor.class, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            //放入缓存</span><br><span class=\"line\">            this.cachedAdvisorBeanNames = advisorNames;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //没有找到，返回空</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (advisorNames.length == 0) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new LinkedList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    //遍历上面得到的所有BeanName</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String name : advisorNames) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isEligibleBean(name)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (this.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                    logger.debug(<span class=\"string\">\"Skipping currently created advisor '\"</span> + name + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    //根据BeanName从IOC获取Bean实例并存入List中</span><br><span class=\"line\">                    advisors.add(this.beanFactory.getBean(name, Advisor.class));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                //catch方法 略...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> advisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意此时仅仅是<strong>只获取IOC容器中那些Advisor类型的Bean作为Advisor</strong>，而在我们注解配置AOP的方式中并不是配置Advisor类的，下面会说到如何获取所有打了注解的切面，这里只是尝试去IOC容器中找是否存在这样的类，有的话也不会漏掉。</p>\n<h5 id=\"寻找所有注解的Advisor\"><a href=\"#寻找所有注解的Advisor\" class=\"headerlink\" title=\"寻找所有注解的Advisor\"></a>寻找所有注解的Advisor</h5><p>现在我们拿到了部分的Advisor，回到我们主类<code>AnnotationAwareAspectJAutoProxyCreatorS</code>的<strong>findCandidateAdvisors</strong> 方法，此时将委派<code>BeanFactoryAspectJAdvisorsBuilder</code>类去执行<strong>buildAspectJAdvisors</strong>方法，将继续获取被注解了的Advisor：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected List&lt;Advisor&gt; <span class=\"function\"><span class=\"title\">findCandidateAdvisors</span></span>() &#123;</span><br><span class=\"line\">    // Add all the Spring advisors found according to superclass rules.</span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();</span><br><span class=\"line\">    // Build Advisors <span class=\"keyword\">for</span> all AspectJ aspects <span class=\"keyword\">in</span> the bean factory.</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (this.aspectJAdvisorsBuilder != null) &#123;</span><br><span class=\"line\">        //委派BeanFactoryAspectJAdvisorsBuilder去寻找注解Advisor</span><br><span class=\"line\">        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> advisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;Advisor&gt; <span class=\"function\"><span class=\"title\">buildAspectJAdvisors</span></span>() &#123;</span><br><span class=\"line\">    List&lt;String&gt; aspectNames = this.aspectBeanNames;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aspectNames == null) &#123;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            aspectNames = this.aspectBeanNames;</span><br><span class=\"line\">            //双重加锁保证在并发情况下不会寻找两次</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (aspectNames == null) &#123;</span><br><span class=\"line\">                List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class=\"line\">                aspectNames = new LinkedList&lt;&gt;();</span><br><span class=\"line\">                //从IOC容器中获取所有的BeanName</span><br><span class=\"line\">                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class=\"line\">                    this.beanFactory, Object.class, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                //遍历所有的BeanName</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String beanName : beanNames) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    // We must be careful not to instantiate beans eagerly as <span class=\"keyword\">in</span> this <span class=\"keyword\">case</span> they</span><br><span class=\"line\">                    // would be cached by the Spring container but would not have been weaved.</span><br><span class=\"line\">                    Class&lt;?&gt; beanType = this.beanFactory.getType(beanName);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (beanType == null) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    //判断此时的Bean的类上是否打了@Aspect注解</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (this.advisorFactory.isAspect(beanType)) &#123;</span><br><span class=\"line\">                        //如果是，判断此类将是一个Advisor</span><br><span class=\"line\">                        aspectNames.add(beanName);</span><br><span class=\"line\">                        AspectMetadata amd = new AspectMetadata(beanType, beanName);</span><br><span class=\"line\">                        //如果是单例，说明可以缓存下来</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class=\"line\">                            //封装成一个对象</span><br><span class=\"line\">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class=\"line\">                                new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);</span><br><span class=\"line\">                            //委派advisorFactory工厂针对以上封装信息创建Advisor</span><br><span class=\"line\">                            List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);</span><br><span class=\"line\">                            //如果是单例，缓存</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (this.beanFactory.isSingleton(beanName)) &#123;</span><br><span class=\"line\">                                this.advisorsCache.put(beanName, classAdvisors);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            //如果不是，只缓存factory，待下一次进入取出缓存的factory</span><br><span class=\"line\">                            //然后再用advisorFactory创建一次Advisor，省去寻找Bean与创建factory的麻烦</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                this.aspectFactoryCache.put(beanName, factory);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            advisors.addAll(classAdvisors);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            // Per target or per this.</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (this.beanFactory.isSingleton(beanName)) &#123;</span><br><span class=\"line\">                                throw new IllegalArgumentException(<span class=\"string\">\"Bean with name '\"</span> + beanName +</span><br><span class=\"line\">                                                                   <span class=\"string\">\"' is a singleton, but aspect instantiation model is not singleton\"</span>);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class=\"line\">                                new PrototypeAspectInstanceFactory(this.beanFactory, beanName);</span><br><span class=\"line\">                            this.aspectFactoryCache.put(beanName, factory);</span><br><span class=\"line\">                            advisors.addAll(this.advisorFactory.getAdvisors(factory));</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                this.aspectBeanNames = aspectNames;</span><br><span class=\"line\">                <span class=\"built_in\">return</span> advisors;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果走到这里，说明已经找过一遍了，这里从缓存获取信息</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Collections.emptyList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    //遍历所有缓存的切面名</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String aspectName : aspectNames) &#123;</span><br><span class=\"line\">        //根据切面名从缓存拿Advisor</span><br><span class=\"line\">        List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName);</span><br><span class=\"line\">        //如果可以拿到，直接获取</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cachedAdvisors != null) &#123;</span><br><span class=\"line\">            advisors.addAll(cachedAdvisors);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //如果拿不到，说明此时缓存的是factory</span><br><span class=\"line\">        //根据factory使用advisorFactory创建Advisor</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);</span><br><span class=\"line\">            advisors.addAll(this.advisorFactory.getAdvisors(factory));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> advisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经<strong>完成了对所有Advisor的获取</strong>，这里值得关注的是工厂（<strong>advisorFactory</strong>）是<strong>如何创建Advisor</strong>的呢？进入<code>ReflectiveAspectJAdvisorFactory</code>类的<strong>getAdvisors</strong>方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) &#123;</span><br><span class=\"line\">    //获取切面类类型</span><br><span class=\"line\">    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class=\"line\">    //获取切面Name</span><br><span class=\"line\">    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class=\"line\">    //验证</span><br><span class=\"line\">    validate(aspectClass);</span><br><span class=\"line\"></span><br><span class=\"line\">    // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span><br><span class=\"line\">    // so that it will only instantiate once.</span><br><span class=\"line\">    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class=\"line\">        new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    //遍历所有除了被打上@Pointcut注解的方法</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class=\"line\">        //在其每个方法中获取Advisor</span><br><span class=\"line\">        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (advisor != null) &#123;</span><br><span class=\"line\">            advisors.add(advisor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // If it<span class=\"string\">'s a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class=\"line\"><span class=\"string\">    if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span></span><br><span class=\"line\"><span class=\"string\">        advisors.add(0, instantiationAdvisor);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // Find introduction fields.</span></span><br><span class=\"line\"><span class=\"string\">    //获取DeclareParents注解的filed</span></span><br><span class=\"line\"><span class=\"string\">    for (Field field : aspectClass.getDeclaredFields()) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        Advisor advisor = getDeclareParentsAdvisor(field);</span></span><br><span class=\"line\"><span class=\"string\">        if (advisor != null) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            advisors.add(advisor);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    return advisors;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们需要关注两点：</p>\n<ol>\n<li><strong>getAdvisorMethods</strong>：此方法获取类上所有的<code>AdvisorMethods</code>，那么是如何进行的：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) &#123;</span><br><span class=\"line\">    final List&lt;Method&gt; methods = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;</span><br><span class=\"line\">        // Exclude pointcuts</span><br><span class=\"line\">        //获取方法上的注解，如果是Pointcut注解不处理</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) &#123;</span><br><span class=\"line\">            methods.add(method);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Collections.sort(methods, METHOD_COMPARATOR);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> methods;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n我们可以知道，其将<strong>不是Pointcut的注解的方法加入到方法集合中作为AdvisorMethod</strong>。</li>\n<li><strong>getAdvisor</strong>：从上面获得的方法中，提取出<code>Advisor</code>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span><br><span class=\"line\">                          int declarationOrderInAspect, String aspectName) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    //切点信息的获取</span><br><span class=\"line\">    AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class=\"line\">        candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (expressionPointcut == null) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //根据获得的切点信息封装增强器</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class=\"line\">                                                          this, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n我们依然需要关注两个点：</li>\n</ol>\n<ul>\n<li>getPointcut：<strong>切点信息的获取</strong></li>\n<li>InstantiationModelAwarePointcutAdvisorImpl：<strong>根据切点信息封装成增强器</strong></li>\n</ul>\n<h5 id=\"获取切点信息\"><a href=\"#获取切点信息\" class=\"headerlink\" title=\"获取切点信息\"></a>获取切点信息</h5><p>依然是在创建Advisor的工厂中的方法<strong>getPointcut</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) &#123;</span><br><span class=\"line\">    //获取该方法的注解</span><br><span class=\"line\">    AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class=\"line\">        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aspectJAnnotation == null) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //封装信息</span><br><span class=\"line\">    AspectJExpressionPointcut ajexp =</span><br><span class=\"line\">        new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]);</span><br><span class=\"line\">    //设置切点表达式</span><br><span class=\"line\">    //例如：@Before（<span class=\"string\">\"test()\"</span>）上的<span class=\"built_in\">test</span>()</span><br><span class=\"line\">    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (this.beanFactory != null) &#123;</span><br><span class=\"line\">        ajexp.setBeanFactory(this.beanFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> ajexp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要关注的是获取方法的注解<strong>findAspectJAnnotationOnMethod</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SuppressWarnings(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">protected static AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class=\"line\">    //需要关注的类型</span><br><span class=\"line\">    Class&lt;?&gt;[] classesToLookFor = new Class&lt;?&gt;[] &#123;</span><br><span class=\"line\">        Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class&lt;?&gt; c : classesToLookFor) &#123;</span><br><span class=\"line\">        //将每个需要关注的类型都与方法进行匹配</span><br><span class=\"line\">        AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);</span><br><span class=\"line\">        //如果找到，返回</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (foundAnnotation != null) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> foundAnnotation;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>findAnnotation ：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">private static &lt;A extends Annotation&gt; AspectJAnnotation&lt;A&gt; findAnnotation(Method method, Class&lt;A&gt; toLookFor) &#123;</span><br><span class=\"line\">    //根据指定的类型寻找方法上的注解</span><br><span class=\"line\">    A result = AnnotationUtils.findAnnotation(method, toLookFor);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != null) &#123;</span><br><span class=\"line\">        //如果找到了，将其封装为AspectJAnnotation对象返回</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new AspectJAnnotation&lt;&gt;(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，在寻找注解的时候<strong>仅仅是获取</strong>了例如@Before(“test()”)中的<strong>test()这样的切点方法名信息</strong>，这个过程在封装AspectJAnnotation对象时在<strong>构造函数</strong>完成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AspectJAnnotation(A annotation) &#123;</span><br><span class=\"line\">    this.annotation = annotation;</span><br><span class=\"line\">    this.annotationType = determineAnnotationType(annotation);</span><br><span class=\"line\">    // We know these methods exist with the same name on each object,</span><br><span class=\"line\">    // but need to invoke them reflectively as there isn<span class=\"string\">'t a common interface.</span></span><br><span class=\"line\"><span class=\"string\">    try &#123;</span></span><br><span class=\"line\"><span class=\"string\">        //处理注解上的pointcut信息</span></span><br><span class=\"line\"><span class=\"string\">        this.pointcutExpression = resolveExpression(annotation);</span></span><br><span class=\"line\"><span class=\"string\">        this.argumentNames = (String) annotation.getClass().getMethod(\"argNames\").invoke(annotation);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    catch (Exception ex) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        throw new IllegalArgumentException(annotation + \" cannot be an AspectJ annotation\", ex);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private String resolveExpression(A annotation) throws Exception &#123;</span><br><span class=\"line\">    //遍历获取注解中的两个方法名：value和pointcut</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String methodName : EXPRESSION_PROPERTIES) &#123;</span><br><span class=\"line\">        Method method;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //获取method对象</span><br><span class=\"line\">            method = annotation.getClass().getDeclaredMethod(methodName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch (NoSuchMethodException ex) &#123;</span><br><span class=\"line\">            method = null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method != null) &#123;</span><br><span class=\"line\">            //获取切点方法名，也就是注解上设置的，例如@Before(<span class=\"string\">\"test()\"</span>)</span><br><span class=\"line\">            //此时获取<span class=\"string\">\"test()\"</span>这样的字符串</span><br><span class=\"line\">            String candidate = (String) method.invoke(annotation);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (StringUtils.hasText(candidate)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">return</span> candidate;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    throw new IllegalStateException(<span class=\"string\">\"Failed to resolve expression: \"</span> + annotation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"根据切点信息，封装成Advisor\"><a href=\"#根据切点信息，封装成Advisor\" class=\"headerlink\" title=\"根据切点信息，封装成Advisor\"></a>根据切点信息，封装成Advisor</h5><p>根据切点信息生成增强器，所有的增强都由<code>InstantiationModelAwarePointcutAdvisorImpl</code>这个类来封装，当然，这个类是一个<code>Advisor</code>。进入此类的构造函数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,</span><br><span class=\"line\">                                                  Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span><br><span class=\"line\">                                                  MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //将获得的信息都封装到这个对象的属性上</span><br><span class=\"line\">    this.declaredPointcut = declaredPointcut;</span><br><span class=\"line\">    this.declaringClass = aspectJAdviceMethod.getDeclaringClass();</span><br><span class=\"line\">    this.methodName = aspectJAdviceMethod.getName();</span><br><span class=\"line\">    this.parameterTypes = aspectJAdviceMethod.getParameterTypes();</span><br><span class=\"line\">    this.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class=\"line\">    this.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class=\"line\">    this.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class=\"line\">    this.declarationOrder = declarationOrder;</span><br><span class=\"line\">    this.aspectName = aspectName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class=\"line\">        // Static part of the pointcut is a lazy <span class=\"built_in\">type</span>.</span><br><span class=\"line\">        Pointcut preInstantiationPointcut = Pointcuts.union(</span><br><span class=\"line\">            aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.</span><br><span class=\"line\">        // If it’s not a dynamic pointcut, it may be optimized out</span><br><span class=\"line\">        // by the Spring AOP infrastructure after the first evaluation.</span><br><span class=\"line\">        this.pointcut = new PerTargetInstantiationModelPointcut(</span><br><span class=\"line\">            this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class=\"line\">        this.lazy = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        // A singleton aspect.</span><br><span class=\"line\">        this.pointcut = this.declaredPointcut;</span><br><span class=\"line\">        this.lazy = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        //解析当前切点适用的Advice，并保存到instantiatedAdvice属性上</span><br><span class=\"line\">        this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在封装的过程中只是<strong>简单的将信息放入类的属性中</strong>，而值得关注的是最后一行的<strong>instantiateAdvice</strong>方法，此方法将<strong>根据注解类型选择不同的Advise</strong>，例如@Before、@After等等都是不同的Advice，它们需要前置或是后置通知，所体现的<strong>增强的逻辑是不同的</strong>，所以就需要不同的Advice来完成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) &#123;</span><br><span class=\"line\">    //委派别的类去获取Advice</span><br><span class=\"line\">    Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut,</span><br><span class=\"line\">                                                         this.aspectInstanceFactory, this.declarationOrder, this.aspectName);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> (advice != null ? advice : EMPTY_ADVICE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此类又委派了<code>aspectJAdvisorFactory</code>去获取Advice：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span><br><span class=\"line\">                        MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //根据之前的信息获取切面类类型</span><br><span class=\"line\">    Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class=\"line\">    validate(candidateAspectClass);</span><br><span class=\"line\"></span><br><span class=\"line\">    //寻找方法上的注解</span><br><span class=\"line\">    AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class=\"line\">        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aspectJAnnotation == null) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // If we get here, we know we have an AspectJ method.</span><br><span class=\"line\">    // Check that it’s an AspectJ-annotated class</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class=\"line\">        throw new AopConfigException(<span class=\"string\">\"Advice must be declared inside an aspect type: \"</span> +</span><br><span class=\"line\">                                     <span class=\"string\">\"Offending method '\"</span> + candidateAdviceMethod + <span class=\"string\">\"' in class [\"</span> +</span><br><span class=\"line\">                                     candidateAspectClass.getName() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(<span class=\"string\">\"Found AspectJ method: \"</span> + candidateAdviceMethod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AbstractAspectJAdvice springAdvice;</span><br><span class=\"line\"></span><br><span class=\"line\">    //根据刚刚从方法上获得的注解，解析成枚举的类型进行swich</span><br><span class=\"line\">    switch (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class=\"line\">            //@Before注解将会走这里</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtBefore:</span><br><span class=\"line\">            springAdvice = new AspectJMethodBeforeAdvice(</span><br><span class=\"line\">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            //@After注解</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtAfter:</span><br><span class=\"line\">            springAdvice = new AspectJAfterAdvice(</span><br><span class=\"line\">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            //@AfterReturning</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtAfterReturning:</span><br><span class=\"line\">            springAdvice = new AspectJAfterReturningAdvice(</span><br><span class=\"line\">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class=\"line\">            AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class=\"line\">                springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            //@AfterThrowing</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtAfterThrowing:</span><br><span class=\"line\">            springAdvice = new AspectJAfterThrowingAdvice(</span><br><span class=\"line\">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class=\"line\">            AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class=\"line\">                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            //@Around</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtAround:</span><br><span class=\"line\">            springAdvice = new AspectJAroundAdvice(</span><br><span class=\"line\">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            //@Pointcut</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtPointcut:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                logger.debug(<span class=\"string\">\"Processing pointcut '\"</span> + candidateAdviceMethod.getName() + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            throw new UnsupportedOperationException(</span><br><span class=\"line\">                <span class=\"string\">\"Unsupported advice type on method: \"</span> + candidateAdviceMethod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Now to configure the advice...</span><br><span class=\"line\">    //配置得到的Advice</span><br><span class=\"line\">    springAdvice.setAspectName(aspectName);</span><br><span class=\"line\">    springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class=\"line\">    String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argNames != null) &#123;</span><br><span class=\"line\">        springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    springAdvice.calculateArgumentBindings();</span><br><span class=\"line\">    <span class=\"built_in\">return</span> springAdvice;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面我们可以知道，不同的通知对应不同的Advice，那么这些不同的advice的执行逻辑有哪些不同呢？这个疑问留着后面的执行过程会进行解答，这里只需要知道<strong>我们获取的Advisor封装了advice与其切点信息</strong>。</p>\n<h4 id=\"寻找适用的增强器\"><a href=\"#寻找适用的增强器\" class=\"headerlink\" title=\"寻找适用的增强器\"></a>寻找适用的增强器</h4><p>我们的思路回到主线，此时我们已经<strong>寻找到所有的增强器</strong>了，现在开始从中<strong>筛选</strong>出适用的增强器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class=\"line\">    //寻找所有适用的Advisor</span><br><span class=\"line\">    //这一步在4.2中进行</span><br><span class=\"line\">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class=\"line\">    //从所有Advisor中选出适合被当前Bean使用的Advisor</span><br><span class=\"line\">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class=\"line\">    extendAdvisors(eligibleAdvisors);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class=\"line\">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> eligibleAdvisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时执行<strong>findAdvisorsThatCanApply</strong>方法寻找适用的增强器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected List&lt;Advisor&gt; findAdvisorsThatCanApply(</span><br><span class=\"line\">    List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        //委派AopUtils去做</span><br><span class=\"line\">        <span class=\"built_in\">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    finally &#123;</span><br><span class=\"line\">        ProxyCreationContext.setCurrentProxiedBeanName(null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里委派了<code>AopUtils</code>去做事情：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> candidateAdvisors;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    //遍历之前找到的所有的Advisor</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class=\"line\">        //在这里会优先处理引介增强，并且判断Advisor是否适合此Bean</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class=\"line\">            //优先加入List中</span><br><span class=\"line\">            eligibleAdvisors.add(candidate);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    boolean hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidate instanceof IntroductionAdvisor) &#123;</span><br><span class=\"line\">            // already processed</span><br><span class=\"line\">            //已经处理过引介增强</span><br><span class=\"line\">            <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //剩下的Advisor再进行判断</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class=\"line\">            //加入List中</span><br><span class=\"line\">            eligibleAdvisors.add(candidate);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //返回适合的Advisor List</span><br><span class=\"line\">    <span class=\"built_in\">return</span> eligibleAdvisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们重点关注<strong>canApply</strong>方法，看看是如何判断是否适合的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (advisor instanceof IntroductionAdvisor) &#123;</span><br><span class=\"line\">        //调用引介增强器的ClassFilter去匹配当前Bean是否适合</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (advisor instanceof PointcutAdvisor) &#123;</span><br><span class=\"line\">        //如果是普通的Advisor，转换成PointcutAdvisor</span><br><span class=\"line\">        //PointcutAdvisor接口定义了获取切点的方法getPointcut</span><br><span class=\"line\">        PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class=\"line\">        //根据切点信息，寻找是否适合</span><br><span class=\"line\">        <span class=\"built_in\">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        // It doesn<span class=\"string\">'t have a pointcut so we assume it applies.</span></span><br><span class=\"line\"><span class=\"string\">        //如果没有切点，就假设它适合</span></span><br><span class=\"line\"><span class=\"string\">        return true;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这里我们先忽略引介增强器，关注普通的Advisor。这里进入<strong>canApply</strong>方法，根据切点信息去判断是否合适：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123;</span><br><span class=\"line\">    Assert.notNull(pc, <span class=\"string\">\"Pointcut must not be null\"</span>);</span><br><span class=\"line\">    //获取切点类过滤器，如果不符合直接返回<span class=\"literal\">false</span></span><br><span class=\"line\">    //如果符合进入下一步判断</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //获取切点的方法匹配器</span><br><span class=\"line\">    MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class=\"line\">    //如果此时methodMatcher是一个MethodMatcher.TRUE，说明匹配任何方法，直接返回<span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class=\"line\">        // No need to iterate the methods <span class=\"keyword\">if</span> we’re matching any method anyway...</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (methodMatcher instanceof IntroductionAwareMethodMatcher) &#123;</span><br><span class=\"line\">        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //拿到目标类的所有父类（包括接口）</span><br><span class=\"line\">    Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class=\"line\">    //包括本类</span><br><span class=\"line\">    classes.add(targetClass);</span><br><span class=\"line\">    //遍历父类与本类</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class=\"line\">        //获取本class的方法对象</span><br><span class=\"line\">        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class=\"line\">        //遍历方法</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">            //两个验证器只要其中一个匹配，就返回<span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((introductionAwareMethodMatcher != null &amp;&amp;</span><br><span class=\"line\">                 introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||</span><br><span class=\"line\">                methodMatcher.matches(method, targetClass)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，就<strong>完成了适用的增强器的查找</strong>，从上面我们可以知道，当一个Bean中的任何一个方法（方法<strong>包括在父类</strong>中的方法）<strong>匹配Advisor中的切点信息</strong>，就认为当前的Advisor是<strong>匹配当前Bean</strong>的，就将此时的<strong>Advisor加入此类的Advisors列表</strong>中，注意，一个Bean中是可以有多个Advisor的，如果不能理解为什么一个Bean对应多个Advisor，你应该还没有明白Advisor的概念，Advisor中包含advice与切点信息，也就是说，一个通知方法例如前置通知@Before是对应一个Advisor的，如果一个类中既有前置通知又有后置通知，那么这个类中的Advisor是会匹配两个的。</p>\n<h4 id=\"创建代理\"><a href=\"#创建代理\" class=\"headerlink\" title=\"创建代理\"></a>创建代理</h4><h5 id=\"获取代理类型（JDK或CGLIB）\"><a href=\"#获取代理类型（JDK或CGLIB）\" class=\"headerlink\" title=\"获取代理类型（JDK或CGLIB）\"></a>获取代理类型（JDK或CGLIB）</h5><p>再次回到最开始的地方，还记得4.1的<strong>wrapIfNecessary</strong>方法吗？此时我们已经寻找完符合此Bean的增强器了（<strong>getAdvicesAndAdvisorsForBean</strong>方法），就像刚刚所说，如果有两个通知匹配的话，现在增强器列表应该会有两个Advisor，也就是说增强列表不为空，将进行下一步，创建代理的过程<strong>createProxy</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,</span><br><span class=\"line\">                             @Nullable Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class=\"line\">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class=\"line\">    //复制当前Creator的一些属性例如proxyTargetClass或是exposeProxy等</span><br><span class=\"line\">    proxyFactory.copyFrom(this);</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果proxyTargetClass是<span class=\"literal\">false</span>才会进入判断</span><br><span class=\"line\">    //如果proxyTargetClass是<span class=\"literal\">true</span>就直接用CGLib代理了，不需要判断</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class=\"line\">        //判断是否需要代理本类</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class=\"line\">            //也就是说，如果需要代理本类，将使用CGLib方式代理</span><br><span class=\"line\">            proxyFactory.setProxyTargetClass(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //如果不需要，则获取所有该类的接口，设置到proxyFactory对象中</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //处理所有得到的适用的拦截器转换成Advisor</span><br><span class=\"line\">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class=\"line\">    //将Advisors加入proxyFactory对象中</span><br><span class=\"line\">    proxyFactory.addAdvisors(advisors);</span><br><span class=\"line\">    //将原本的Bean对象（原生未代理）加入proxyFactory对象中</span><br><span class=\"line\">    proxyFactory.setTargetSource(targetSource);</span><br><span class=\"line\">    //定制代理</span><br><span class=\"line\">    customizeProxyFactory(proxyFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    proxyFactory.setFrozen(this.freezeProxy);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (advisorsPreFiltered()) &#123;</span><br><span class=\"line\">        proxyFactory.setPreFiltered(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //设置好属性之后，就调用proxyFactory对象生成代理对象</span><br><span class=\"line\">    <span class=\"built_in\">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上过程都在给<code>proxyFactory</code>这个对象设置属性，然后调用<code>proxyFactory</code>根据设置的一些属性生成代理对象，最后执行关键的创建代理方法<strong>getProxy</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> createAopProxy().getProxy(classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected final synchronized AopProxy <span class=\"function\"><span class=\"title\">createAopProxy</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!this.active) &#123;</span><br><span class=\"line\">        activate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //使用aopProxyFactory根据本类信息创建</span><br><span class=\"line\">    <span class=\"built_in\">return</span> getAopProxyFactory().createAopProxy(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>aopProxyFactory</code>是在其父类的构造函数中赋值的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"function\"><span class=\"title\">ProxyCreatorSupport</span></span>() &#123;</span><br><span class=\"line\">    this.aopProxyFactory = new DefaultAopProxyFactory();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进入其创建方法<strong>createAopProxy</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class=\"line\">    //判断ProxyTargetClass属性和是否有代理接口等等判断使用何种方式做代理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (targetClass == null) &#123;</span><br><span class=\"line\">            throw new AopConfigException(<span class=\"string\">\"TargetSource cannot determine target class: \"</span> +</span><br><span class=\"line\">                                         <span class=\"string\">\"Either an interface or a target is required for proxy creation.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> new JdkDynamicAopProxy(config);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new ObjenesisCglibAopProxy(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new JdkDynamicAopProxy(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意此时config对象是我们之前设置了各种信息的proxyFactory对象，在代理的构造函数中存放了这个属性，也就是说代理对象持有一个Advisor列表。</p>\n</blockquote>\n<p>这段代码清晰明了，主要就是在<strong>判断使用何种方式做代理</strong>：</p>\n<ul>\n<li>optimize：这个属性适用于CGLib，对JDK动态代理无效。主要是控制CGLib创建的代理是否使用激进的优化策略。</li>\n<li>proxyTargetClass：文章开头也有提到，如果属性为true，将会使用CGLib进行代理。</li>\n<li>hasNoUserSuppliedProxyInterfaces：是否存在代理接口。</li>\n</ul>\n<p>总结一下JDK于CGLIB如何选择：</p>\n<ul>\n<li>如果目标对象实现了接口，默认情况下会采用JDK代理</li>\n<li>如果目标对象实现了接口，但可以使用proxyTargetClass属性来强制使用CGLIB代理</li>\n<li>如果对象没用实现接口，必须使用CGLIB代理</li>\n</ul>\n<h5 id=\"获取代理\"><a href=\"#获取代理\" class=\"headerlink\" title=\"获取代理\"></a>获取代理</h5><p>思路回到开头获取代理的方法中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> createAopProxy().getProxy(classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时我们完成了<strong>createAopProxy</strong>，拿到了JDK代理对象（我们这里假设用JDK做代理）接着调用其<strong>getProxy</strong>方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(<span class=\"string\">\"Creating JDK dynamic proxy: target source is \"</span> + this.advised.getTargetSource());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //拿到被代理类的接口</span><br><span class=\"line\">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    //检查上面得到的接口是否定义了equals、hashCode方法</span><br><span class=\"line\">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class=\"line\">    //创建代理对象</span><br><span class=\"line\">    <span class=\"built_in\">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意此时的<code>advised</code>就是我们上面所说的<code>config</code>对象也就是封装半天信息的<code>proxyFactory</code>对象，里面存有一系列信息例如<strong>Advisor、切点之类</strong>。</p>\n<p>这里不对动态代理进行解释，如果熟悉动态代理的看到这里应该已经懂了，其将当前对象作为实现代理的主要对象。毫无疑问，当前对象一定实现了<code>InvocationHandler</code>接口，我们需要关注的即为它的<strong>invoke</strong>方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class=\"line\">    MethodInvocation invocation;</span><br><span class=\"line\">    Object oldProxy = null;</span><br><span class=\"line\">    boolean setProxyContext = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    //原生对象</span><br><span class=\"line\">    TargetSource targetSource = this.advised.targetSource;</span><br><span class=\"line\">    Object target = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        //eqauls()方法，如果目标对象未实现此方法</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class=\"line\">            // The target does not implement the equals(Object) method itself.</span><br><span class=\"line\">            <span class=\"built_in\">return</span> equals(args[0]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //hashCode()方法，如果目标对象未实现此方法</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class=\"line\">            // The target does not implement the hashCode() method itself.</span><br><span class=\"line\">            <span class=\"built_in\">return</span> hashCode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class=\"line\">            // There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span><br><span class=\"line\">            <span class=\"built_in\">return</span> AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class=\"line\">                 method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class=\"line\">            // Service invocations on ProxyConfig with the proxy config...</span><br><span class=\"line\">            <span class=\"built_in\">return</span> AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Object retVal;</span><br><span class=\"line\"></span><br><span class=\"line\">        //这里就是先前提到的如果exposeProxy属性为<span class=\"literal\">true</span>，将会暴露一个proxy代理对象</span><br><span class=\"line\">        //给AOP上下文对象，存在线程变量中</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (this.advised.exposeProxy) &#123;</span><br><span class=\"line\">            // Make invocation available <span class=\"keyword\">if</span> necessary.</span><br><span class=\"line\">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class=\"line\">            setProxyContext = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Get as late as possible to minimize the time we <span class=\"string\">\"own\"</span> the target,</span><br><span class=\"line\">        // <span class=\"keyword\">in</span> <span class=\"keyword\">case</span> it comes from a pool.</span><br><span class=\"line\">        //获得目标对象的类</span><br><span class=\"line\">        target = targetSource.getTarget();</span><br><span class=\"line\">        Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Get the interception chain <span class=\"keyword\">for</span> this method.</span><br><span class=\"line\">        //获取可以应用到此方法上的Interceptor列表</span><br><span class=\"line\">        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Check whether we have any advice. If we don’t, we can fallback on direct</span><br><span class=\"line\">        // reflective invocation of the target, and avoid creating a MethodInvocation.</span><br><span class=\"line\">        //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (chain.isEmpty()) &#123;</span><br><span class=\"line\">            // We can skip creating a MethodInvocation: just invoke the target directly</span><br><span class=\"line\">            // Note that the final invoker must be an InvokerInterceptor so we know it does</span><br><span class=\"line\">            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br><span class=\"line\">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class=\"line\">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // We need to create a method invocation...</span><br><span class=\"line\">            //走到这里，说明该方法符合被通知的条件，创建MethodInvocation</span><br><span class=\"line\">            //执行其proceed方法</span><br><span class=\"line\">            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class=\"line\">            // Proceed to the joinpoint through the interceptor chain.</span><br><span class=\"line\">            retVal = invocation.proceed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Massage <span class=\"built_in\">return</span> value <span class=\"keyword\">if</span> necessary.</span><br><span class=\"line\">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retVal != null &amp;&amp; retVal == target &amp;&amp;</span><br><span class=\"line\">            returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class=\"line\">            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class=\"line\">            // Special <span class=\"keyword\">case</span>: it returned <span class=\"string\">\"this\"</span> and the <span class=\"built_in\">return</span> <span class=\"built_in\">type</span> of the method</span><br><span class=\"line\">            // is <span class=\"built_in\">type</span>-compatible. Note that we can<span class=\"string\">'t help if the target sets</span></span><br><span class=\"line\"><span class=\"string\">            // a reference to itself in another returned object.</span></span><br><span class=\"line\"><span class=\"string\">            retVal = proxy;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            throw new AopInvocationException(</span></span><br><span class=\"line\"><span class=\"string\">                \"Null return value from advice does not match primitive return type for: \" + method);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        return retVal;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    finally &#123;</span></span><br><span class=\"line\"><span class=\"string\">        if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            // Must have come from TargetSource.</span></span><br><span class=\"line\"><span class=\"string\">            targetSource.releaseTarget(target);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        if (setProxyContext) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            // Restore old proxy.</span></span><br><span class=\"line\"><span class=\"string\">            AopContext.setCurrentProxy(oldProxy);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>也就是说，每次调用代理对象的方法，将执行以下步骤：</p>\n<ol>\n<li><strong>判断是否是equals或hashCode或Advised的方法</strong>：如果是执行对应判断。</li>\n<li><strong>判断是否需要暴露代理对象</strong>（将代理对象存入AopContext）：在文章开头就有提到这个属性，还是之前的例子，在A方法中调用B方法，此时B方法其实是原生对象的B方法，但如果B方法需要被AOP，需要执行的是代理对象的B方法，而不是原生对象的B方法，原生对象的B方法是没有被代理AOP的。所以这里需要暴露出代理对象，从AopContext上下文中取出代理对象，将其强转成对应类，执行B方法，此时的B方法即可是被AOP的方法了。值得一提的是AopContext暴露出来的代理对象是线程变量。</li>\n<li><strong>获取当前方法对应的拦截器链</strong>：主要是使用<code>advised</code>去对当前方法进行判断<strong>是否符合切点</strong>如果符合取出对应需要执行的链。如果此时<strong>链为空</strong>，代表执行的该方法是<strong>不需要被AOP</strong>的，正常反射执行即可，如果<strong>链不为空</strong>，将链封装成<code>ReflectiveMethodInvocation</code>对象执行其<strong>proceed</strong>方法，该对象的该方法是执行AOP的核心，下面详细讲解。</li>\n</ol>\n<h4 id=\"执行AOP通知\"><a href=\"#执行AOP通知\" class=\"headerlink\" title=\"执行AOP通知\"></a>执行AOP通知</h4><p>到此我们创建好了代理对象，并<strong>返回出去作为一个Bean存放在IOC容器中</strong>，当我们取出此Bean并执行方法时，如果碰到了需要被AOP的方法时，会找到一个<strong>拦截器链</strong>，然后将其传入<code>ReflectiveMethodInvocation</code>对象封装，接着不会执行原方法而是执行其<strong>proceed</strong>方法，所以该方法是执行AOP通知的核心方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//此属性默认为-1</span><br><span class=\"line\">private int currentInterceptorIndex = -1;</span><br><span class=\"line\"></span><br><span class=\"line\">//存放interceptors的列表</span><br><span class=\"line\">protected final List&lt;?&gt; interceptorsAndDynamicMethodMatchers;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">public Object proceed() throws Throwable &#123;</span><br><span class=\"line\">    //  We start with an index of -1 and increment early.</span><br><span class=\"line\">    //如果Interceptor执行完了，则执行joinPoint</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> invokeJoinpoint();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //根据游标获取对应的Advice</span><br><span class=\"line\">    Object interceptorOrInterceptionAdvice =</span><br><span class=\"line\">        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class=\"line\">    //如果要动态匹配joinPoint</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class=\"line\">        // Evaluate dynamic method matcher here: static part will already have</span><br><span class=\"line\">        // been evaluated and found to match.</span><br><span class=\"line\">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class=\"line\">            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class=\"line\">        //动态匹配：运行时参数是否满足匹配条件</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> dm.interceptor.invoke(this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // Dynamic matching failed.</span><br><span class=\"line\">            // Skip this interceptor and invoke the next <span class=\"keyword\">in</span> the chain.</span><br><span class=\"line\">            //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor</span><br><span class=\"line\">            <span class=\"built_in\">return</span> proceed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        // It’s an interceptor, so we just invoke it: The pointcut will have</span><br><span class=\"line\">        // been evaluated statically before this object was constructed.</span><br><span class=\"line\">        //执行当前IntercetporAdvice</span><br><span class=\"line\">        //注意此时传了this对象，是为了执行链的保持</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里，需要解释几点：</p>\n<ol>\n<li><p><strong>如何判断执行结束？在开头我们说到currentInterceptorIndex</strong>属性是为-1的，<strong>interceptorsAndDynamicMethodMatchers</strong>的size是执行链的数量，刚进来的时候执行链一定大于等于1，所以其减1也不会等于-1，不会执行<strong>invokeJoinpoint</strong>方法，走到下面执行这样一行代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object interceptorOrInterceptionAdvice =</span><br><span class=\"line\">        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br></pre></td></tr></table></figure>\n<p>注意此时<strong>currentInterceptorIndex</strong>游标变成了0，也就是取执行链的第一个执行器取执行，同时游标变成0。下面会执行Advice的<strong>invoke</strong>方法，这里举例Before类型的Advice的<strong>invoke</strong>方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class=\"line\">    this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</span><br><span class=\"line\">    <span class=\"built_in\">return</span> mi.proceed();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意此时<code>mi对象</code>就是上面传进来的<code>this</code>，也就是<code>ReflectiveMethodInvocation</code>对象，他在通知方法执行完成之后，又执行了<code>ReflectiveMethodInvocation</code>的<strong>proceed</strong>方法，然后第二次进入<strong>proceed</strong>时，游标已经变成了0，我们假设此时拦截器数量为一个，那么此时<strong>currentInterceptorIndex=0,interceptorsAndDynamicMethodMatchers.size() - 1 = 0：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> invokeJoinpoint();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将中止执行下面的内容，直接执行<strong>invokeJoinpoint</strong>方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">protected Object invokeJoinpoint() throws Throwable &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里底层就是<strong>通过反射执行原方法</strong>，到此结束，也就是说其<strong>利用游标索引与循环调用proceed方法来判断当前执行链的结束</strong>，真是个聪明的方法。</p>\n</li>\n<li><p><strong>为什么@Before的Advice的invoke可以实现前置通知效果，同样的@After如何实现后置通知效果？在这里我们将补上上面没有详细讲解的一些Advice类 。</strong><br>1) <code>MethodBeforeAdviceInterceptor</code>前置通知：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MethodBeforeAdvice advice;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">   * Create a new MethodBeforeAdviceInterceptor <span class=\"keyword\">for</span> the given advice.</span><br><span class=\"line\">   * @param advice the MethodBeforeAdvice to wrap</span><br><span class=\"line\">   */</span><br><span class=\"line\">    //构造器初始化保存了advice对象</span><br><span class=\"line\">    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123;</span><br><span class=\"line\">        Assert.notNull(advice, <span class=\"string\">\"Advice must not be null\"</span>);</span><br><span class=\"line\">        this.advice = advice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class=\"line\">        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</span><br><span class=\"line\">        <span class=\"built_in\">return</span> mi.proceed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2)<code>AfterReturningAdviceInterceptor</code>后置通知：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final AfterReturningAdvice advice;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">   * Create a new AfterReturningAdviceInterceptor <span class=\"keyword\">for</span> the given advice.</span><br><span class=\"line\">   * @param advice the AfterReturningAdvice to wrap</span><br><span class=\"line\">   */</span><br><span class=\"line\">    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) &#123;</span><br><span class=\"line\">        Assert.notNull(advice, <span class=\"string\">\"Advice must not be null\"</span>);</span><br><span class=\"line\">        this.advice = advice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class=\"line\">        Object retVal = mi.proceed();</span><br><span class=\"line\">        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class=\"line\">        <span class=\"built_in\">return</span> retVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面两个不同的<code>Advice</code>可以看出，其<strong>invoke</strong>方法的逻辑只是<strong>顺序不同</strong>而已，但为什么可以达到前置后置通知的呢？其实前置通知很好理解，在invoke的逻辑中只要<strong>先执行我们指定的前置通知逻辑</strong>，然后<strong>继续往下执行proceed</strong>即可实现在执行原方法前加一段逻辑的功能，我们主要分析后置通知是如何实现的。还是进行一个假设，此时该方法<strong>只有一个执行链后置通知@After</strong>，那么刚开始进入proceed方法时，获取这个Advice执行invoke方法，然后<strong>又去执行proceed方法</strong>了，由上面的分析此时的游标显示执行链已经执行完毕，所以此时会<strong>直接反射执行原方法</strong>，然后<strong>proceed方法执行完毕</strong>，最后将会执行后置通知Advice的invoke方法的下一步，<strong>advice.afterReturning</strong>，也就是用户<strong>自定义的后置方法逻辑</strong>，实现了在方法最后插入一段代码逻辑的功能，如果是多个通知例如前置后置都有的话，留给读者思考，相信懂得以上逻辑之后推敲起来并不是很难。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>到这里为止，我们分析了AOP是从<strong>自定义标签开始</strong>，自定义标签注册了一个<code>Creator</code>类，而此<code>Creator</code>类是一个<code>BeanPostProcessor</code>，也就是说每个Bean都将调用Creator实现的方法。</p>\n<p>来到了<strong>如何实现AOP代理的分析</strong>中，在此方法中判断Bean是否需要被代理，然后进一步判断此Bean是否可以获得增强器，在这个过程中会去拿所有的Advisor，然后在所有的Advisor列表中筛选出适用的增强器，如果适用的增强器Advisor为空证明此Bean不用被代理，如果不为空则会进入创建代理的流程。</p>\n<p>所以我们开始分析<strong>创建代理是怎样的过程</strong> ，在什么情况下会进行JDK动态代理，在什么情况下会进行CGLIB动态代理，然后创建代理结束之后。</p>\n<p>必不可少的也需要分析是<strong>如何执行AOP通知</strong>的，其核心类是<code>ReflectiveMethodInvocation</code>的<strong>proceed</strong>方法，轮询执行拦截器，并且不同的Advice根据其特有的逻辑执行调用顺序，来完成AOP通知的功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>阅读这篇文章前，最好有代理模式的基础，以及了解关于Spring扩展点例如BeanPostProcessor和如何使用自定义标签集成Spring，这些文章在我的博客里都能找到。当然，也最好有使用AOP的经验，这篇文章不会讲解如何使用AOP。</p>\n</blockquote>\n<p><img src=\"/images/spring_logo.jpg\" alt=\"Spring\"></p>\n<h3 id=\"AOP简介\"><a href=\"#AOP简介\" class=\"headerlink\" title=\"AOP简介\"></a>AOP简介</h3><p>说到AOP，其实这是一个<strong>面向方面的编程思想</strong> ，它解决了OOP的一些弊端，例如我们需要为<strong>多个不具有继承关系的类引入一个公共行为</strong>， 比如说日志、权限验证、事务管理等等，我们需要将这些代码<strong>重复的添加</strong>到一系列的类中，将<strong>产生大量的重复代码</strong>，如果需要修改，将在每个类中去进行修改，<strong>不便于维护</strong>，代码的<strong>侵入性极高</strong>。所以就有了AOP这样面向方面编程的编程思想，其功能可以为每个需要的类<strong>加入共同的行为</strong>，如果需要修改，只需要修改切面中的代码，改一处等于改多处，并且便于编程，写一个切面类即可达到在每个类中加入重复代码的目的。</p>\n<p>阅读此篇文章，你将了解Spring是<strong>如何实现AOP</strong>（前置通知、后置通知、环绕通知），由于Spring中的事务管理是基于AOP的功能来做的，所以你将更好的能理解Spring是如何将事务统一管理起来的。</p>\n<hr>\n<h3 id=\"自定义标签开启AOP\"><a href=\"#自定义标签开启AOP\" class=\"headerlink\" title=\"自定义标签开启AOP\"></a>自定义标签开启AOP</h3><p>只要用过AOP都知道，如果需要使用AOP，需要在配置文件中写这样一段配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:aspectj-autoproxy /&gt;</span><br></pre></td></tr></table></figure>\n<p>只有写了这段配置才可以开启AOP功能，那么这个自定义标签又做了什么呢？在上一篇讲解自定义标签的文章中详细讲到了，此时我们需要关注其标签头aop去寻找对应的命名空间：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlns:aop=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span></span><br></pre></td></tr></table></figure>\n<p>全局搜索命名空间<code>&lt;http\\://<a href=\"http://www.springframework.org/schema/aop\" target=\"_blank\" rel=\"noopener\">www.springframework.org/schema/aop</a>&gt;</code>，注意http后加一个“\\” ，可以找到<strong>spring.handlers</strong>文件中对应的handler类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http\\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure>\n<p>这样就找到了命名空间对应的handler：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AopNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Register the &#123;@link BeanDefinitionParser BeanDefinitionParsers&#125; <span class=\"keyword\">for</span> the</span><br><span class=\"line\">   * <span class=\"string\">'&#123;@code config&#125;'</span>, <span class=\"string\">'&#123;@code spring-configured&#125;'</span>, <span class=\"string\">'&#123;@code aspectj-autoproxy&#125;'</span></span><br><span class=\"line\">   * and <span class=\"string\">'&#123;@code scoped-proxy&#125;'</span> tags.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void <span class=\"function\"><span class=\"title\">init</span></span>() &#123;</span><br><span class=\"line\">    // In 2.0 XSD as well as <span class=\"keyword\">in</span> 2.1 XSD.</span><br><span class=\"line\">    registerBeanDefinitionParser(<span class=\"string\">\"config\"</span>, new ConfigBeanDefinitionParser());</span><br><span class=\"line\">    registerBeanDefinitionParser(<span class=\"string\">\"aspectj-autoproxy\"</span>, new AspectJAutoProxyBeanDefinitionParser());</span><br><span class=\"line\">    registerBeanDefinitionDecorator(<span class=\"string\">\"scoped-proxy\"</span>, new ScopedProxyBeanDefinitionDecorator());</span><br><span class=\"line\"></span><br><span class=\"line\">    // Only <span class=\"keyword\">in</span> 2.0 XSD: moved to context namespace as of 2.1</span><br><span class=\"line\">    registerBeanDefinitionParser(<span class=\"string\">\"spring-configured\"</span>, new SpringConfiguredBeanDefinitionParser());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回到开头配置自定义标签，我们使用了<code>aspectj-autoproxy</code>这个Parser。在init方法中，我们找到<code>aspectj-autoproxy</code>对应的Parser是<code>AspectJAutoProxyBeanDefinitionParser</code>这个类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">//我们只关注解析的主方法，parse方法</span><br><span class=\"line\">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class=\"line\">    //注册一个类到IOC容器中</span><br><span class=\"line\">    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class=\"line\">    extendBeanDefinition(element, parserContext);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"注册AnnotationAwareAspectJAutoProxyCreator\"><a href=\"#注册AnnotationAwareAspectJAutoProxyCreator\" class=\"headerlink\" title=\"注册AnnotationAwareAspectJAutoProxyCreator\"></a>注册AnnotationAwareAspectJAutoProxyCreator</h3><p><code>AnnotationAwareAspectJAutoProxyCreator</code>是实现AOP功能的主要类，我们先来看看这个类的结构：<br><img src=\"/images/spring-aop1.png\" alt=\"spring\"><br>此类实现了<code>BeanPostProcessor</code>，稍后将关注其后置处理Bean的方法<strong>postProcessAfterInitialization</strong>，并且实现了<code>BeanFactorAware</code>接口，此类将取得并存有一个<code>BeanFactory</code>实例对象。<br>回到主线，关注注册此类的方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class=\"line\">    ParserContext parserContext, Element sourceElement) &#123;</span><br><span class=\"line\">//将一个类作为Bean注册到IOC容器中</span><br><span class=\"line\">    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class=\"line\">        parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class=\"line\">    //处理proxy-target-class与expose-proxy属性</span><br><span class=\"line\">    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class=\"line\">    //注册组件并通知</span><br><span class=\"line\">    registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，在注册这个类的过程中主要完成了3件事：</p>\n<ol>\n<li>注册<code>AnnotationAwareAspectJAutoProxyCreator：</code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry,</span><br><span class=\"line\">                                                                                  @Nullable Object <span class=\"built_in\">source</span>) &#123;</span><br><span class=\"line\">//将AnnotationAwareAspectJAutoProxyCreator这个类注册到IOC容器中</span><br><span class=\"line\">    <span class=\"built_in\">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, <span class=\"built_in\">source</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry,</span><br><span class=\"line\">                                                              @Nullable Object <span class=\"built_in\">source</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Assert.notNull(registry, <span class=\"string\">\"BeanDefinitionRegistry must not be null\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果IOC容器中已经存在了此类型的Bean，则需要判断优先级</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">        //获取此类的BeanDefinition信息</span><br><span class=\"line\">        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class=\"line\">        //如果此Bean的ClassName与AnnotationAwareAspectJAutoProxyCreator类的</span><br><span class=\"line\">        //ClassName不同的话，判断优先级</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class=\"line\">            int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class=\"line\">            int requiredPriority = findPriorityForClass(cls);</span><br><span class=\"line\">            //如果已存在Bean优先级小于Creator的优先级</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class=\"line\">                //将ClassName替换成Creator</span><br><span class=\"line\">                apcDefinition.setBeanClassName(cls.getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //不进行注册，因为已经注册了</span><br><span class=\"line\">        <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果到这里，说明IOC容器中没有配置对应Creator</span><br><span class=\"line\">    //使用Crearir的Class构造一个BeanDefinition</span><br><span class=\"line\">    RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);</span><br><span class=\"line\">    beanDefinition.setSource(<span class=\"built_in\">source</span>);</span><br><span class=\"line\">    //配置依赖属性order，将其设置为最高优先级</span><br><span class=\"line\">    beanDefinition.getPropertyValues().add(<span class=\"string\">\"order\"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class=\"line\">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class=\"line\">    //将设置好属性的BeanDefinition注册进IOC容器中</span><br><span class=\"line\">    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> beanDefinition;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>处理<strong>proxy-target-class</strong>与<strong>expose-proxy</strong>属性<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, @Nullable Element sourceElement) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sourceElement != null) &#123;</span><br><span class=\"line\">        boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class=\"line\">        //处理proxy-target-class属性</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (proxyTargetClass) &#123;</span><br><span class=\"line\">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class=\"line\">        //处理expose-proxy属性</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exposeProxy) &#123;</span><br><span class=\"line\">            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n其中设置属性的过程：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">        //根据之前注册的BeanName取出Creator</span><br><span class=\"line\">        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class=\"line\">        //将Creator的BeanDefinition的属性proxyTargetClass设置为<span class=\"literal\">true</span></span><br><span class=\"line\">        definition.getPropertyValues().add(<span class=\"string\">\"proxyTargetClass\"</span>, Boolean.TRUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class=\"line\">        //根据之前注册的BeanName取出Creator</span><br><span class=\"line\">        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class=\"line\">        //将Creator的BeanDefinition的属性exposeProxy设置为<span class=\"literal\">true</span></span><br><span class=\"line\">        definition.getPropertyValues().add(<span class=\"string\">\"exposeProxy\"</span>, Boolean.TRUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><strong>proxy-target-class</strong>：在Spring的AOP中，默认的如果目标类实现了至少一个接口，将使用<strong>JDK动态代理</strong>实现AOP，否则使用<strong>CGLib动态代理</strong>实现AOP，如果希望AOP都使用CGLib实现，你就可以设置proxy-target-class属性为<strong>true</strong>，但要注意几个问题：</li>\n</ul>\n<p>1)<strong>无法对final的方法进行动态代理</strong>，原因很简单，CGLib使用继承实现，final方法无法重写，所以final的方法不能应用AOP。<br>2)需要配置CGLib的JAR包</p>\n<ul>\n<li><strong>expose-proxy</strong>：在讲解事务的那篇文章中有提到，如果一个类中的事务A方法调用了同一个类中的事务B方法，<strong>B方法将没有事务</strong>，这个道理在AOP中也是这样的，相同类下的不同方法互相调用，内部方法将无法被应用通知（无法进行AOP），此时你需要将<strong>expose-proxy属性设置为true</strong>，暴露一个代理类（此属性的原理在下面会有详细讲解），然后在A方法中需要调用B方法的话需要这样写：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Service&#123;</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">A</span></span>()&#123;</span><br><span class=\"line\">        ((Service)AopContext.currentProxy()).B();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">B</span></span>()&#123;</span><br><span class=\"line\">    //<span class=\"keyword\">do</span> something...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n这样，B方法就算再A方法内也可以被AOP。其中<code>AopContext</code>是存放线程变量的类，形象的称之为<strong>AOP的上下文</strong>。</li>\n</ul>\n<hr>\n<h3 id=\"实现AOP代理\"><a href=\"#实现AOP代理\" class=\"headerlink\" title=\"实现AOP代理\"></a>实现AOP代理</h3><h4 id=\"创建AOP代理\"><a href=\"#创建AOP代理\" class=\"headerlink\" title=\"创建AOP代理\"></a>创建AOP代理</h4><p>上面，自定义标签的配置完成了对<strong>Creator类的自动注册</strong>，我们可以知道，此类实现了<code>BeanPostProcessor</code>接口，将会在IOC容器初始化每个Bean时都调用此类的<strong>postProcessAfterInitialization</strong>方法，此方法即为AOP代理的入口，此方法在抽象父类<code>AbstractAutoProxyCreator</code>实现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bean != null) &#123;</span><br><span class=\"line\">        //先从缓存中获取Key，由要代理的Bean的Class与benaName组成</span><br><span class=\"line\">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class=\"line\">        //判断是否是过早暴露的Bean，此概念在讲IOC解决循环依赖中有提到</span><br><span class=\"line\">        //如果是过早暴露的Bean，则此时连依赖注入都没有完成，则不对其进行代理</span><br><span class=\"line\">        //待其真正初始化之后再尝试代理</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!this.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class=\"line\">            //如果符合条件进行AOP代理</span><br><span class=\"line\">            <span class=\"built_in\">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> bean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class=\"line\">    //如果先前已经处理过的，不进行处理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //如果此Bean已经被标记为无法代理，不进行处理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //如果Bean为AOP类的类型，或是需要跳过的类型，不进行处理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class=\"line\">        //标记为不代理</span><br><span class=\"line\">        this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Create proxy <span class=\"keyword\">if</span> we have advice.</span><br><span class=\"line\">    //寻找符合此Bean的增强方法（通知方法）</span><br><span class=\"line\">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</span><br><span class=\"line\">    //如果寻找到的增强方法列表不为空，也就是不为DO_NOT_PROXY</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class=\"line\">        //标记为已代理</span><br><span class=\"line\">        this.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class=\"line\">        //根据找到的增强方法，对此Bean进行动态代理</span><br><span class=\"line\">        Object proxy = createProxy(</span><br><span class=\"line\">            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class=\"line\">        this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class=\"line\">        //将代理对象作为Bean返回给IOC容器</span><br><span class=\"line\">        <span class=\"built_in\">return</span> proxy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  //如果走到这里，说明代理失败，标记为代理失败</span><br><span class=\"line\">    this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> bean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>文章到了这里，就已经基本完成AOP的实现了，剩下我们需要关注的就是两件事：</p>\n<ul>\n<li>如何寻找符合Bean的增强器</li>\n<li>如何对Bean创建动态代理</li>\n</ul>\n<h4 id=\"寻找所有的增强器\"><a href=\"#寻找所有的增强器\" class=\"headerlink\" title=\"寻找所有的增强器\"></a>寻找所有的增强器</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) &#123;</span><br><span class=\"line\">    //寻找适合的Advisor</span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (advisors.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> DO_NOT_PROXY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> advisors.toArray();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有一个<code>Advisor</code>的概念，其中Advisor<strong>封装了切点信息与advise通知方法等等信息。</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class=\"line\">    //寻找所有适用的Advisor</span><br><span class=\"line\">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class=\"line\">    //从所有Advisor中选出适合被当前Bean使用的Advisor</span><br><span class=\"line\">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class=\"line\">    extendAdvisors(eligibleAdvisors);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class=\"line\">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> eligibleAdvisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"寻找已存在的Advisor\"><a href=\"#寻找已存在的Advisor\" class=\"headerlink\" title=\"寻找已存在的Advisor\"></a>寻找已存在的Advisor</h5><p>首先，执行下面的方法寻找合适的<code>Advisor</code>（此方法在子类<code>Creator</code>中得到实现）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected List&lt;Advisor&gt; <span class=\"function\"><span class=\"title\">findCandidateAdvisors</span></span>() &#123;</span><br><span class=\"line\">    // Add all the Spring advisors found according to superclass rules.</span><br><span class=\"line\">    //首先调用父类findCandidateAdvisors的方法寻找在IOC容器中的Advisor类型的Bean</span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();</span><br><span class=\"line\">    // Build Advisors <span class=\"keyword\">for</span> all AspectJ aspects <span class=\"keyword\">in</span> the bean factory.</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (this.aspectJAdvisorsBuilder != null) &#123;</span><br><span class=\"line\">        //寻找注解的Advisor</span><br><span class=\"line\">        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> advisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先调用父类的<strong>findCandidateAdvisors</strong>方法寻找所有的<code>Advisor</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected List&lt;Advisor&gt; <span class=\"function\"><span class=\"title\">findCandidateAdvisors</span></span>() &#123;</span><br><span class=\"line\">    Assert.state(this.advisorRetrievalHelper != null, <span class=\"string\">\"No BeanFactoryAdvisorRetrievalHelper available\"</span>);</span><br><span class=\"line\">    //委派Helper类去寻找</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;Advisor&gt; <span class=\"function\"><span class=\"title\">findAdvisorBeans</span></span>() &#123;</span><br><span class=\"line\">    // Determine list of advisor bean names, <span class=\"keyword\">if</span> not cached already.</span><br><span class=\"line\">    String[] advisorNames = null;</span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        //先从缓存中取</span><br><span class=\"line\">        advisorNames = this.cachedAdvisorBeanNames;</span><br><span class=\"line\">        //缓存中若没有再去IOC容器中取</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (advisorNames == null) &#123;</span><br><span class=\"line\">            // Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class=\"line\">            // uninitialized to <span class=\"built_in\">let</span> the auto-proxy creator apply to them!</span><br><span class=\"line\">            //从IOC容器中寻找所有Advisor类型的BeanName</span><br><span class=\"line\">            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class=\"line\">                this.beanFactory, Advisor.class, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            //放入缓存</span><br><span class=\"line\">            this.cachedAdvisorBeanNames = advisorNames;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //没有找到，返回空</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (advisorNames.length == 0) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new LinkedList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    //遍历上面得到的所有BeanName</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String name : advisorNames) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isEligibleBean(name)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (this.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                    logger.debug(<span class=\"string\">\"Skipping currently created advisor '\"</span> + name + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    //根据BeanName从IOC获取Bean实例并存入List中</span><br><span class=\"line\">                    advisors.add(this.beanFactory.getBean(name, Advisor.class));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                //catch方法 略...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> advisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意此时仅仅是<strong>只获取IOC容器中那些Advisor类型的Bean作为Advisor</strong>，而在我们注解配置AOP的方式中并不是配置Advisor类的，下面会说到如何获取所有打了注解的切面，这里只是尝试去IOC容器中找是否存在这样的类，有的话也不会漏掉。</p>\n<h5 id=\"寻找所有注解的Advisor\"><a href=\"#寻找所有注解的Advisor\" class=\"headerlink\" title=\"寻找所有注解的Advisor\"></a>寻找所有注解的Advisor</h5><p>现在我们拿到了部分的Advisor，回到我们主类<code>AnnotationAwareAspectJAutoProxyCreatorS</code>的<strong>findCandidateAdvisors</strong> 方法，此时将委派<code>BeanFactoryAspectJAdvisorsBuilder</code>类去执行<strong>buildAspectJAdvisors</strong>方法，将继续获取被注解了的Advisor：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected List&lt;Advisor&gt; <span class=\"function\"><span class=\"title\">findCandidateAdvisors</span></span>() &#123;</span><br><span class=\"line\">    // Add all the Spring advisors found according to superclass rules.</span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();</span><br><span class=\"line\">    // Build Advisors <span class=\"keyword\">for</span> all AspectJ aspects <span class=\"keyword\">in</span> the bean factory.</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (this.aspectJAdvisorsBuilder != null) &#123;</span><br><span class=\"line\">        //委派BeanFactoryAspectJAdvisorsBuilder去寻找注解Advisor</span><br><span class=\"line\">        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> advisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;Advisor&gt; <span class=\"function\"><span class=\"title\">buildAspectJAdvisors</span></span>() &#123;</span><br><span class=\"line\">    List&lt;String&gt; aspectNames = this.aspectBeanNames;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aspectNames == null) &#123;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            aspectNames = this.aspectBeanNames;</span><br><span class=\"line\">            //双重加锁保证在并发情况下不会寻找两次</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (aspectNames == null) &#123;</span><br><span class=\"line\">                List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class=\"line\">                aspectNames = new LinkedList&lt;&gt;();</span><br><span class=\"line\">                //从IOC容器中获取所有的BeanName</span><br><span class=\"line\">                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class=\"line\">                    this.beanFactory, Object.class, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                //遍历所有的BeanName</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String beanName : beanNames) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    // We must be careful not to instantiate beans eagerly as <span class=\"keyword\">in</span> this <span class=\"keyword\">case</span> they</span><br><span class=\"line\">                    // would be cached by the Spring container but would not have been weaved.</span><br><span class=\"line\">                    Class&lt;?&gt; beanType = this.beanFactory.getType(beanName);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (beanType == null) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    //判断此时的Bean的类上是否打了@Aspect注解</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (this.advisorFactory.isAspect(beanType)) &#123;</span><br><span class=\"line\">                        //如果是，判断此类将是一个Advisor</span><br><span class=\"line\">                        aspectNames.add(beanName);</span><br><span class=\"line\">                        AspectMetadata amd = new AspectMetadata(beanType, beanName);</span><br><span class=\"line\">                        //如果是单例，说明可以缓存下来</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class=\"line\">                            //封装成一个对象</span><br><span class=\"line\">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class=\"line\">                                new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);</span><br><span class=\"line\">                            //委派advisorFactory工厂针对以上封装信息创建Advisor</span><br><span class=\"line\">                            List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);</span><br><span class=\"line\">                            //如果是单例，缓存</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (this.beanFactory.isSingleton(beanName)) &#123;</span><br><span class=\"line\">                                this.advisorsCache.put(beanName, classAdvisors);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            //如果不是，只缓存factory，待下一次进入取出缓存的factory</span><br><span class=\"line\">                            //然后再用advisorFactory创建一次Advisor，省去寻找Bean与创建factory的麻烦</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                this.aspectFactoryCache.put(beanName, factory);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            advisors.addAll(classAdvisors);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            // Per target or per this.</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (this.beanFactory.isSingleton(beanName)) &#123;</span><br><span class=\"line\">                                throw new IllegalArgumentException(<span class=\"string\">\"Bean with name '\"</span> + beanName +</span><br><span class=\"line\">                                                                   <span class=\"string\">\"' is a singleton, but aspect instantiation model is not singleton\"</span>);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class=\"line\">                                new PrototypeAspectInstanceFactory(this.beanFactory, beanName);</span><br><span class=\"line\">                            this.aspectFactoryCache.put(beanName, factory);</span><br><span class=\"line\">                            advisors.addAll(this.advisorFactory.getAdvisors(factory));</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                this.aspectBeanNames = aspectNames;</span><br><span class=\"line\">                <span class=\"built_in\">return</span> advisors;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果走到这里，说明已经找过一遍了，这里从缓存获取信息</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> Collections.emptyList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    //遍历所有缓存的切面名</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String aspectName : aspectNames) &#123;</span><br><span class=\"line\">        //根据切面名从缓存拿Advisor</span><br><span class=\"line\">        List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName);</span><br><span class=\"line\">        //如果可以拿到，直接获取</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cachedAdvisors != null) &#123;</span><br><span class=\"line\">            advisors.addAll(cachedAdvisors);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //如果拿不到，说明此时缓存的是factory</span><br><span class=\"line\">        //根据factory使用advisorFactory创建Advisor</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);</span><br><span class=\"line\">            advisors.addAll(this.advisorFactory.getAdvisors(factory));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> advisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经<strong>完成了对所有Advisor的获取</strong>，这里值得关注的是工厂（<strong>advisorFactory</strong>）是<strong>如何创建Advisor</strong>的呢？进入<code>ReflectiveAspectJAdvisorFactory</code>类的<strong>getAdvisors</strong>方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) &#123;</span><br><span class=\"line\">    //获取切面类类型</span><br><span class=\"line\">    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class=\"line\">    //获取切面Name</span><br><span class=\"line\">    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class=\"line\">    //验证</span><br><span class=\"line\">    validate(aspectClass);</span><br><span class=\"line\"></span><br><span class=\"line\">    // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span><br><span class=\"line\">    // so that it will only instantiate once.</span><br><span class=\"line\">    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class=\"line\">        new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    //遍历所有除了被打上@Pointcut注解的方法</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class=\"line\">        //在其每个方法中获取Advisor</span><br><span class=\"line\">        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (advisor != null) &#123;</span><br><span class=\"line\">            advisors.add(advisor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // If it<span class=\"string\">'s a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class=\"line\"><span class=\"string\">    if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span></span><br><span class=\"line\"><span class=\"string\">        advisors.add(0, instantiationAdvisor);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // Find introduction fields.</span></span><br><span class=\"line\"><span class=\"string\">    //获取DeclareParents注解的filed</span></span><br><span class=\"line\"><span class=\"string\">    for (Field field : aspectClass.getDeclaredFields()) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        Advisor advisor = getDeclareParentsAdvisor(field);</span></span><br><span class=\"line\"><span class=\"string\">        if (advisor != null) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            advisors.add(advisor);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    return advisors;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们需要关注两点：</p>\n<ol>\n<li><strong>getAdvisorMethods</strong>：此方法获取类上所有的<code>AdvisorMethods</code>，那么是如何进行的：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) &#123;</span><br><span class=\"line\">    final List&lt;Method&gt; methods = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;</span><br><span class=\"line\">        // Exclude pointcuts</span><br><span class=\"line\">        //获取方法上的注解，如果是Pointcut注解不处理</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) &#123;</span><br><span class=\"line\">            methods.add(method);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Collections.sort(methods, METHOD_COMPARATOR);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> methods;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n我们可以知道，其将<strong>不是Pointcut的注解的方法加入到方法集合中作为AdvisorMethod</strong>。</li>\n<li><strong>getAdvisor</strong>：从上面获得的方法中，提取出<code>Advisor</code>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span><br><span class=\"line\">                          int declarationOrderInAspect, String aspectName) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    //切点信息的获取</span><br><span class=\"line\">    AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class=\"line\">        candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (expressionPointcut == null) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //根据获得的切点信息封装增强器</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class=\"line\">                                                          this, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n我们依然需要关注两个点：</li>\n</ol>\n<ul>\n<li>getPointcut：<strong>切点信息的获取</strong></li>\n<li>InstantiationModelAwarePointcutAdvisorImpl：<strong>根据切点信息封装成增强器</strong></li>\n</ul>\n<h5 id=\"获取切点信息\"><a href=\"#获取切点信息\" class=\"headerlink\" title=\"获取切点信息\"></a>获取切点信息</h5><p>依然是在创建Advisor的工厂中的方法<strong>getPointcut</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) &#123;</span><br><span class=\"line\">    //获取该方法的注解</span><br><span class=\"line\">    AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class=\"line\">        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aspectJAnnotation == null) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //封装信息</span><br><span class=\"line\">    AspectJExpressionPointcut ajexp =</span><br><span class=\"line\">        new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]);</span><br><span class=\"line\">    //设置切点表达式</span><br><span class=\"line\">    //例如：@Before（<span class=\"string\">\"test()\"</span>）上的<span class=\"built_in\">test</span>()</span><br><span class=\"line\">    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (this.beanFactory != null) &#123;</span><br><span class=\"line\">        ajexp.setBeanFactory(this.beanFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> ajexp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要关注的是获取方法的注解<strong>findAspectJAnnotationOnMethod</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@SuppressWarnings(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">protected static AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class=\"line\">    //需要关注的类型</span><br><span class=\"line\">    Class&lt;?&gt;[] classesToLookFor = new Class&lt;?&gt;[] &#123;</span><br><span class=\"line\">        Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class&lt;?&gt; c : classesToLookFor) &#123;</span><br><span class=\"line\">        //将每个需要关注的类型都与方法进行匹配</span><br><span class=\"line\">        AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);</span><br><span class=\"line\">        //如果找到，返回</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (foundAnnotation != null) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> foundAnnotation;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>findAnnotation ：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">private static &lt;A extends Annotation&gt; AspectJAnnotation&lt;A&gt; findAnnotation(Method method, Class&lt;A&gt; toLookFor) &#123;</span><br><span class=\"line\">    //根据指定的类型寻找方法上的注解</span><br><span class=\"line\">    A result = AnnotationUtils.findAnnotation(method, toLookFor);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != null) &#123;</span><br><span class=\"line\">        //如果找到了，将其封装为AspectJAnnotation对象返回</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new AspectJAnnotation&lt;&gt;(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，在寻找注解的时候<strong>仅仅是获取</strong>了例如@Before(“test()”)中的<strong>test()这样的切点方法名信息</strong>，这个过程在封装AspectJAnnotation对象时在<strong>构造函数</strong>完成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AspectJAnnotation(A annotation) &#123;</span><br><span class=\"line\">    this.annotation = annotation;</span><br><span class=\"line\">    this.annotationType = determineAnnotationType(annotation);</span><br><span class=\"line\">    // We know these methods exist with the same name on each object,</span><br><span class=\"line\">    // but need to invoke them reflectively as there isn<span class=\"string\">'t a common interface.</span></span><br><span class=\"line\"><span class=\"string\">    try &#123;</span></span><br><span class=\"line\"><span class=\"string\">        //处理注解上的pointcut信息</span></span><br><span class=\"line\"><span class=\"string\">        this.pointcutExpression = resolveExpression(annotation);</span></span><br><span class=\"line\"><span class=\"string\">        this.argumentNames = (String) annotation.getClass().getMethod(\"argNames\").invoke(annotation);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    catch (Exception ex) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        throw new IllegalArgumentException(annotation + \" cannot be an AspectJ annotation\", ex);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private String resolveExpression(A annotation) throws Exception &#123;</span><br><span class=\"line\">    //遍历获取注解中的两个方法名：value和pointcut</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String methodName : EXPRESSION_PROPERTIES) &#123;</span><br><span class=\"line\">        Method method;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //获取method对象</span><br><span class=\"line\">            method = annotation.getClass().getDeclaredMethod(methodName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch (NoSuchMethodException ex) &#123;</span><br><span class=\"line\">            method = null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method != null) &#123;</span><br><span class=\"line\">            //获取切点方法名，也就是注解上设置的，例如@Before(<span class=\"string\">\"test()\"</span>)</span><br><span class=\"line\">            //此时获取<span class=\"string\">\"test()\"</span>这样的字符串</span><br><span class=\"line\">            String candidate = (String) method.invoke(annotation);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (StringUtils.hasText(candidate)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">return</span> candidate;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    throw new IllegalStateException(<span class=\"string\">\"Failed to resolve expression: \"</span> + annotation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"根据切点信息，封装成Advisor\"><a href=\"#根据切点信息，封装成Advisor\" class=\"headerlink\" title=\"根据切点信息，封装成Advisor\"></a>根据切点信息，封装成Advisor</h5><p>根据切点信息生成增强器，所有的增强都由<code>InstantiationModelAwarePointcutAdvisorImpl</code>这个类来封装，当然，这个类是一个<code>Advisor</code>。进入此类的构造函数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,</span><br><span class=\"line\">                                                  Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span><br><span class=\"line\">                                                  MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //将获得的信息都封装到这个对象的属性上</span><br><span class=\"line\">    this.declaredPointcut = declaredPointcut;</span><br><span class=\"line\">    this.declaringClass = aspectJAdviceMethod.getDeclaringClass();</span><br><span class=\"line\">    this.methodName = aspectJAdviceMethod.getName();</span><br><span class=\"line\">    this.parameterTypes = aspectJAdviceMethod.getParameterTypes();</span><br><span class=\"line\">    this.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class=\"line\">    this.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class=\"line\">    this.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class=\"line\">    this.declarationOrder = declarationOrder;</span><br><span class=\"line\">    this.aspectName = aspectName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class=\"line\">        // Static part of the pointcut is a lazy <span class=\"built_in\">type</span>.</span><br><span class=\"line\">        Pointcut preInstantiationPointcut = Pointcuts.union(</span><br><span class=\"line\">            aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.</span><br><span class=\"line\">        // If it’s not a dynamic pointcut, it may be optimized out</span><br><span class=\"line\">        // by the Spring AOP infrastructure after the first evaluation.</span><br><span class=\"line\">        this.pointcut = new PerTargetInstantiationModelPointcut(</span><br><span class=\"line\">            this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class=\"line\">        this.lazy = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        // A singleton aspect.</span><br><span class=\"line\">        this.pointcut = this.declaredPointcut;</span><br><span class=\"line\">        this.lazy = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        //解析当前切点适用的Advice，并保存到instantiatedAdvice属性上</span><br><span class=\"line\">        this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在封装的过程中只是<strong>简单的将信息放入类的属性中</strong>，而值得关注的是最后一行的<strong>instantiateAdvice</strong>方法，此方法将<strong>根据注解类型选择不同的Advise</strong>，例如@Before、@After等等都是不同的Advice，它们需要前置或是后置通知，所体现的<strong>增强的逻辑是不同的</strong>，所以就需要不同的Advice来完成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) &#123;</span><br><span class=\"line\">    //委派别的类去获取Advice</span><br><span class=\"line\">    Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut,</span><br><span class=\"line\">                                                         this.aspectInstanceFactory, this.declarationOrder, this.aspectName);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> (advice != null ? advice : EMPTY_ADVICE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此类又委派了<code>aspectJAdvisorFactory</code>去获取Advice：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span><br><span class=\"line\">                        MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //根据之前的信息获取切面类类型</span><br><span class=\"line\">    Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class=\"line\">    validate(candidateAspectClass);</span><br><span class=\"line\"></span><br><span class=\"line\">    //寻找方法上的注解</span><br><span class=\"line\">    AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class=\"line\">        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aspectJAnnotation == null) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // If we get here, we know we have an AspectJ method.</span><br><span class=\"line\">    // Check that it’s an AspectJ-annotated class</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class=\"line\">        throw new AopConfigException(<span class=\"string\">\"Advice must be declared inside an aspect type: \"</span> +</span><br><span class=\"line\">                                     <span class=\"string\">\"Offending method '\"</span> + candidateAdviceMethod + <span class=\"string\">\"' in class [\"</span> +</span><br><span class=\"line\">                                     candidateAspectClass.getName() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(<span class=\"string\">\"Found AspectJ method: \"</span> + candidateAdviceMethod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AbstractAspectJAdvice springAdvice;</span><br><span class=\"line\"></span><br><span class=\"line\">    //根据刚刚从方法上获得的注解，解析成枚举的类型进行swich</span><br><span class=\"line\">    switch (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class=\"line\">            //@Before注解将会走这里</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtBefore:</span><br><span class=\"line\">            springAdvice = new AspectJMethodBeforeAdvice(</span><br><span class=\"line\">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            //@After注解</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtAfter:</span><br><span class=\"line\">            springAdvice = new AspectJAfterAdvice(</span><br><span class=\"line\">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            //@AfterReturning</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtAfterReturning:</span><br><span class=\"line\">            springAdvice = new AspectJAfterReturningAdvice(</span><br><span class=\"line\">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class=\"line\">            AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class=\"line\">                springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            //@AfterThrowing</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtAfterThrowing:</span><br><span class=\"line\">            springAdvice = new AspectJAfterThrowingAdvice(</span><br><span class=\"line\">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class=\"line\">            AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class=\"line\">                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            //@Around</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtAround:</span><br><span class=\"line\">            springAdvice = new AspectJAroundAdvice(</span><br><span class=\"line\">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            //@Pointcut</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AtPointcut:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                logger.debug(<span class=\"string\">\"Processing pointcut '\"</span> + candidateAdviceMethod.getName() + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            throw new UnsupportedOperationException(</span><br><span class=\"line\">                <span class=\"string\">\"Unsupported advice type on method: \"</span> + candidateAdviceMethod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Now to configure the advice...</span><br><span class=\"line\">    //配置得到的Advice</span><br><span class=\"line\">    springAdvice.setAspectName(aspectName);</span><br><span class=\"line\">    springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class=\"line\">    String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argNames != null) &#123;</span><br><span class=\"line\">        springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    springAdvice.calculateArgumentBindings();</span><br><span class=\"line\">    <span class=\"built_in\">return</span> springAdvice;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面我们可以知道，不同的通知对应不同的Advice，那么这些不同的advice的执行逻辑有哪些不同呢？这个疑问留着后面的执行过程会进行解答，这里只需要知道<strong>我们获取的Advisor封装了advice与其切点信息</strong>。</p>\n<h4 id=\"寻找适用的增强器\"><a href=\"#寻找适用的增强器\" class=\"headerlink\" title=\"寻找适用的增强器\"></a>寻找适用的增强器</h4><p>我们的思路回到主线，此时我们已经<strong>寻找到所有的增强器</strong>了，现在开始从中<strong>筛选</strong>出适用的增强器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class=\"line\">    //寻找所有适用的Advisor</span><br><span class=\"line\">    //这一步在4.2中进行</span><br><span class=\"line\">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class=\"line\">    //从所有Advisor中选出适合被当前Bean使用的Advisor</span><br><span class=\"line\">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class=\"line\">    extendAdvisors(eligibleAdvisors);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class=\"line\">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> eligibleAdvisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时执行<strong>findAdvisorsThatCanApply</strong>方法寻找适用的增强器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected List&lt;Advisor&gt; findAdvisorsThatCanApply(</span><br><span class=\"line\">    List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        //委派AopUtils去做</span><br><span class=\"line\">        <span class=\"built_in\">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    finally &#123;</span><br><span class=\"line\">        ProxyCreationContext.setCurrentProxiedBeanName(null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里委派了<code>AopUtils</code>去做事情：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> candidateAdvisors;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    //遍历之前找到的所有的Advisor</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class=\"line\">        //在这里会优先处理引介增强，并且判断Advisor是否适合此Bean</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class=\"line\">            //优先加入List中</span><br><span class=\"line\">            eligibleAdvisors.add(candidate);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    boolean hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidate instanceof IntroductionAdvisor) &#123;</span><br><span class=\"line\">            // already processed</span><br><span class=\"line\">            //已经处理过引介增强</span><br><span class=\"line\">            <span class=\"built_in\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //剩下的Advisor再进行判断</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class=\"line\">            //加入List中</span><br><span class=\"line\">            eligibleAdvisors.add(candidate);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //返回适合的Advisor List</span><br><span class=\"line\">    <span class=\"built_in\">return</span> eligibleAdvisors;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们重点关注<strong>canApply</strong>方法，看看是如何判断是否适合的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (advisor instanceof IntroductionAdvisor) &#123;</span><br><span class=\"line\">        //调用引介增强器的ClassFilter去匹配当前Bean是否适合</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (advisor instanceof PointcutAdvisor) &#123;</span><br><span class=\"line\">        //如果是普通的Advisor，转换成PointcutAdvisor</span><br><span class=\"line\">        //PointcutAdvisor接口定义了获取切点的方法getPointcut</span><br><span class=\"line\">        PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class=\"line\">        //根据切点信息，寻找是否适合</span><br><span class=\"line\">        <span class=\"built_in\">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        // It doesn<span class=\"string\">'t have a pointcut so we assume it applies.</span></span><br><span class=\"line\"><span class=\"string\">        //如果没有切点，就假设它适合</span></span><br><span class=\"line\"><span class=\"string\">        return true;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这里我们先忽略引介增强器，关注普通的Advisor。这里进入<strong>canApply</strong>方法，根据切点信息去判断是否合适：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123;</span><br><span class=\"line\">    Assert.notNull(pc, <span class=\"string\">\"Pointcut must not be null\"</span>);</span><br><span class=\"line\">    //获取切点类过滤器，如果不符合直接返回<span class=\"literal\">false</span></span><br><span class=\"line\">    //如果符合进入下一步判断</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //获取切点的方法匹配器</span><br><span class=\"line\">    MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class=\"line\">    //如果此时methodMatcher是一个MethodMatcher.TRUE，说明匹配任何方法，直接返回<span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class=\"line\">        // No need to iterate the methods <span class=\"keyword\">if</span> we’re matching any method anyway...</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (methodMatcher instanceof IntroductionAwareMethodMatcher) &#123;</span><br><span class=\"line\">        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //拿到目标类的所有父类（包括接口）</span><br><span class=\"line\">    Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class=\"line\">    //包括本类</span><br><span class=\"line\">    classes.add(targetClass);</span><br><span class=\"line\">    //遍历父类与本类</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class=\"line\">        //获取本class的方法对象</span><br><span class=\"line\">        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class=\"line\">        //遍历方法</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">            //两个验证器只要其中一个匹配，就返回<span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((introductionAwareMethodMatcher != null &amp;&amp;</span><br><span class=\"line\">                 introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||</span><br><span class=\"line\">                methodMatcher.matches(method, targetClass)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，就<strong>完成了适用的增强器的查找</strong>，从上面我们可以知道，当一个Bean中的任何一个方法（方法<strong>包括在父类</strong>中的方法）<strong>匹配Advisor中的切点信息</strong>，就认为当前的Advisor是<strong>匹配当前Bean</strong>的，就将此时的<strong>Advisor加入此类的Advisors列表</strong>中，注意，一个Bean中是可以有多个Advisor的，如果不能理解为什么一个Bean对应多个Advisor，你应该还没有明白Advisor的概念，Advisor中包含advice与切点信息，也就是说，一个通知方法例如前置通知@Before是对应一个Advisor的，如果一个类中既有前置通知又有后置通知，那么这个类中的Advisor是会匹配两个的。</p>\n<h4 id=\"创建代理\"><a href=\"#创建代理\" class=\"headerlink\" title=\"创建代理\"></a>创建代理</h4><h5 id=\"获取代理类型（JDK或CGLIB）\"><a href=\"#获取代理类型（JDK或CGLIB）\" class=\"headerlink\" title=\"获取代理类型（JDK或CGLIB）\"></a>获取代理类型（JDK或CGLIB）</h5><p>再次回到最开始的地方，还记得4.1的<strong>wrapIfNecessary</strong>方法吗？此时我们已经寻找完符合此Bean的增强器了（<strong>getAdvicesAndAdvisorsForBean</strong>方法），就像刚刚所说，如果有两个通知匹配的话，现在增强器列表应该会有两个Advisor，也就是说增强列表不为空，将进行下一步，创建代理的过程<strong>createProxy</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,</span><br><span class=\"line\">                             @Nullable Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class=\"line\">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class=\"line\">    //复制当前Creator的一些属性例如proxyTargetClass或是exposeProxy等</span><br><span class=\"line\">    proxyFactory.copyFrom(this);</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果proxyTargetClass是<span class=\"literal\">false</span>才会进入判断</span><br><span class=\"line\">    //如果proxyTargetClass是<span class=\"literal\">true</span>就直接用CGLib代理了，不需要判断</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class=\"line\">        //判断是否需要代理本类</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class=\"line\">            //也就是说，如果需要代理本类，将使用CGLib方式代理</span><br><span class=\"line\">            proxyFactory.setProxyTargetClass(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //如果不需要，则获取所有该类的接口，设置到proxyFactory对象中</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //处理所有得到的适用的拦截器转换成Advisor</span><br><span class=\"line\">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class=\"line\">    //将Advisors加入proxyFactory对象中</span><br><span class=\"line\">    proxyFactory.addAdvisors(advisors);</span><br><span class=\"line\">    //将原本的Bean对象（原生未代理）加入proxyFactory对象中</span><br><span class=\"line\">    proxyFactory.setTargetSource(targetSource);</span><br><span class=\"line\">    //定制代理</span><br><span class=\"line\">    customizeProxyFactory(proxyFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    proxyFactory.setFrozen(this.freezeProxy);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (advisorsPreFiltered()) &#123;</span><br><span class=\"line\">        proxyFactory.setPreFiltered(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //设置好属性之后，就调用proxyFactory对象生成代理对象</span><br><span class=\"line\">    <span class=\"built_in\">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上过程都在给<code>proxyFactory</code>这个对象设置属性，然后调用<code>proxyFactory</code>根据设置的一些属性生成代理对象，最后执行关键的创建代理方法<strong>getProxy</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> createAopProxy().getProxy(classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected final synchronized AopProxy <span class=\"function\"><span class=\"title\">createAopProxy</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!this.active) &#123;</span><br><span class=\"line\">        activate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //使用aopProxyFactory根据本类信息创建</span><br><span class=\"line\">    <span class=\"built_in\">return</span> getAopProxyFactory().createAopProxy(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>aopProxyFactory</code>是在其父类的构造函数中赋值的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"function\"><span class=\"title\">ProxyCreatorSupport</span></span>() &#123;</span><br><span class=\"line\">    this.aopProxyFactory = new DefaultAopProxyFactory();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进入其创建方法<strong>createAopProxy</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class=\"line\">    //判断ProxyTargetClass属性和是否有代理接口等等判断使用何种方式做代理</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (targetClass == null) &#123;</span><br><span class=\"line\">            throw new AopConfigException(<span class=\"string\">\"TargetSource cannot determine target class: \"</span> +</span><br><span class=\"line\">                                         <span class=\"string\">\"Either an interface or a target is required for proxy creation.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> new JdkDynamicAopProxy(config);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new ObjenesisCglibAopProxy(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> new JdkDynamicAopProxy(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意此时config对象是我们之前设置了各种信息的proxyFactory对象，在代理的构造函数中存放了这个属性，也就是说代理对象持有一个Advisor列表。</p>\n</blockquote>\n<p>这段代码清晰明了，主要就是在<strong>判断使用何种方式做代理</strong>：</p>\n<ul>\n<li>optimize：这个属性适用于CGLib，对JDK动态代理无效。主要是控制CGLib创建的代理是否使用激进的优化策略。</li>\n<li>proxyTargetClass：文章开头也有提到，如果属性为true，将会使用CGLib进行代理。</li>\n<li>hasNoUserSuppliedProxyInterfaces：是否存在代理接口。</li>\n</ul>\n<p>总结一下JDK于CGLIB如何选择：</p>\n<ul>\n<li>如果目标对象实现了接口，默认情况下会采用JDK代理</li>\n<li>如果目标对象实现了接口，但可以使用proxyTargetClass属性来强制使用CGLIB代理</li>\n<li>如果对象没用实现接口，必须使用CGLIB代理</li>\n</ul>\n<h5 id=\"获取代理\"><a href=\"#获取代理\" class=\"headerlink\" title=\"获取代理\"></a>获取代理</h5><p>思路回到开头获取代理的方法中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> createAopProxy().getProxy(classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时我们完成了<strong>createAopProxy</strong>，拿到了JDK代理对象（我们这里假设用JDK做代理）接着调用其<strong>getProxy</strong>方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(<span class=\"string\">\"Creating JDK dynamic proxy: target source is \"</span> + this.advised.getTargetSource());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //拿到被代理类的接口</span><br><span class=\"line\">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    //检查上面得到的接口是否定义了equals、hashCode方法</span><br><span class=\"line\">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class=\"line\">    //创建代理对象</span><br><span class=\"line\">    <span class=\"built_in\">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意此时的<code>advised</code>就是我们上面所说的<code>config</code>对象也就是封装半天信息的<code>proxyFactory</code>对象，里面存有一系列信息例如<strong>Advisor、切点之类</strong>。</p>\n<p>这里不对动态代理进行解释，如果熟悉动态代理的看到这里应该已经懂了，其将当前对象作为实现代理的主要对象。毫无疑问，当前对象一定实现了<code>InvocationHandler</code>接口，我们需要关注的即为它的<strong>invoke</strong>方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class=\"line\">    MethodInvocation invocation;</span><br><span class=\"line\">    Object oldProxy = null;</span><br><span class=\"line\">    boolean setProxyContext = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    //原生对象</span><br><span class=\"line\">    TargetSource targetSource = this.advised.targetSource;</span><br><span class=\"line\">    Object target = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        //eqauls()方法，如果目标对象未实现此方法</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class=\"line\">            // The target does not implement the equals(Object) method itself.</span><br><span class=\"line\">            <span class=\"built_in\">return</span> equals(args[0]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //hashCode()方法，如果目标对象未实现此方法</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class=\"line\">            // The target does not implement the hashCode() method itself.</span><br><span class=\"line\">            <span class=\"built_in\">return</span> hashCode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class=\"line\">            // There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span><br><span class=\"line\">            <span class=\"built_in\">return</span> AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class=\"line\">                 method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class=\"line\">            // Service invocations on ProxyConfig with the proxy config...</span><br><span class=\"line\">            <span class=\"built_in\">return</span> AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Object retVal;</span><br><span class=\"line\"></span><br><span class=\"line\">        //这里就是先前提到的如果exposeProxy属性为<span class=\"literal\">true</span>，将会暴露一个proxy代理对象</span><br><span class=\"line\">        //给AOP上下文对象，存在线程变量中</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (this.advised.exposeProxy) &#123;</span><br><span class=\"line\">            // Make invocation available <span class=\"keyword\">if</span> necessary.</span><br><span class=\"line\">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class=\"line\">            setProxyContext = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Get as late as possible to minimize the time we <span class=\"string\">\"own\"</span> the target,</span><br><span class=\"line\">        // <span class=\"keyword\">in</span> <span class=\"keyword\">case</span> it comes from a pool.</span><br><span class=\"line\">        //获得目标对象的类</span><br><span class=\"line\">        target = targetSource.getTarget();</span><br><span class=\"line\">        Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Get the interception chain <span class=\"keyword\">for</span> this method.</span><br><span class=\"line\">        //获取可以应用到此方法上的Interceptor列表</span><br><span class=\"line\">        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Check whether we have any advice. If we don’t, we can fallback on direct</span><br><span class=\"line\">        // reflective invocation of the target, and avoid creating a MethodInvocation.</span><br><span class=\"line\">        //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (chain.isEmpty()) &#123;</span><br><span class=\"line\">            // We can skip creating a MethodInvocation: just invoke the target directly</span><br><span class=\"line\">            // Note that the final invoker must be an InvokerInterceptor so we know it does</span><br><span class=\"line\">            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br><span class=\"line\">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class=\"line\">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // We need to create a method invocation...</span><br><span class=\"line\">            //走到这里，说明该方法符合被通知的条件，创建MethodInvocation</span><br><span class=\"line\">            //执行其proceed方法</span><br><span class=\"line\">            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class=\"line\">            // Proceed to the joinpoint through the interceptor chain.</span><br><span class=\"line\">            retVal = invocation.proceed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Massage <span class=\"built_in\">return</span> value <span class=\"keyword\">if</span> necessary.</span><br><span class=\"line\">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retVal != null &amp;&amp; retVal == target &amp;&amp;</span><br><span class=\"line\">            returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class=\"line\">            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class=\"line\">            // Special <span class=\"keyword\">case</span>: it returned <span class=\"string\">\"this\"</span> and the <span class=\"built_in\">return</span> <span class=\"built_in\">type</span> of the method</span><br><span class=\"line\">            // is <span class=\"built_in\">type</span>-compatible. Note that we can<span class=\"string\">'t help if the target sets</span></span><br><span class=\"line\"><span class=\"string\">            // a reference to itself in another returned object.</span></span><br><span class=\"line\"><span class=\"string\">            retVal = proxy;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            throw new AopInvocationException(</span></span><br><span class=\"line\"><span class=\"string\">                \"Null return value from advice does not match primitive return type for: \" + method);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        return retVal;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    finally &#123;</span></span><br><span class=\"line\"><span class=\"string\">        if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            // Must have come from TargetSource.</span></span><br><span class=\"line\"><span class=\"string\">            targetSource.releaseTarget(target);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        if (setProxyContext) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            // Restore old proxy.</span></span><br><span class=\"line\"><span class=\"string\">            AopContext.setCurrentProxy(oldProxy);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>也就是说，每次调用代理对象的方法，将执行以下步骤：</p>\n<ol>\n<li><strong>判断是否是equals或hashCode或Advised的方法</strong>：如果是执行对应判断。</li>\n<li><strong>判断是否需要暴露代理对象</strong>（将代理对象存入AopContext）：在文章开头就有提到这个属性，还是之前的例子，在A方法中调用B方法，此时B方法其实是原生对象的B方法，但如果B方法需要被AOP，需要执行的是代理对象的B方法，而不是原生对象的B方法，原生对象的B方法是没有被代理AOP的。所以这里需要暴露出代理对象，从AopContext上下文中取出代理对象，将其强转成对应类，执行B方法，此时的B方法即可是被AOP的方法了。值得一提的是AopContext暴露出来的代理对象是线程变量。</li>\n<li><strong>获取当前方法对应的拦截器链</strong>：主要是使用<code>advised</code>去对当前方法进行判断<strong>是否符合切点</strong>如果符合取出对应需要执行的链。如果此时<strong>链为空</strong>，代表执行的该方法是<strong>不需要被AOP</strong>的，正常反射执行即可，如果<strong>链不为空</strong>，将链封装成<code>ReflectiveMethodInvocation</code>对象执行其<strong>proceed</strong>方法，该对象的该方法是执行AOP的核心，下面详细讲解。</li>\n</ol>\n<h4 id=\"执行AOP通知\"><a href=\"#执行AOP通知\" class=\"headerlink\" title=\"执行AOP通知\"></a>执行AOP通知</h4><p>到此我们创建好了代理对象，并<strong>返回出去作为一个Bean存放在IOC容器中</strong>，当我们取出此Bean并执行方法时，如果碰到了需要被AOP的方法时，会找到一个<strong>拦截器链</strong>，然后将其传入<code>ReflectiveMethodInvocation</code>对象封装，接着不会执行原方法而是执行其<strong>proceed</strong>方法，所以该方法是执行AOP通知的核心方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//此属性默认为-1</span><br><span class=\"line\">private int currentInterceptorIndex = -1;</span><br><span class=\"line\"></span><br><span class=\"line\">//存放interceptors的列表</span><br><span class=\"line\">protected final List&lt;?&gt; interceptorsAndDynamicMethodMatchers;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">@Nullable</span><br><span class=\"line\">public Object proceed() throws Throwable &#123;</span><br><span class=\"line\">    //  We start with an index of -1 and increment early.</span><br><span class=\"line\">    //如果Interceptor执行完了，则执行joinPoint</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> invokeJoinpoint();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //根据游标获取对应的Advice</span><br><span class=\"line\">    Object interceptorOrInterceptionAdvice =</span><br><span class=\"line\">        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class=\"line\">    //如果要动态匹配joinPoint</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class=\"line\">        // Evaluate dynamic method matcher here: static part will already have</span><br><span class=\"line\">        // been evaluated and found to match.</span><br><span class=\"line\">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class=\"line\">            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class=\"line\">        //动态匹配：运行时参数是否满足匹配条件</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> dm.interceptor.invoke(this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // Dynamic matching failed.</span><br><span class=\"line\">            // Skip this interceptor and invoke the next <span class=\"keyword\">in</span> the chain.</span><br><span class=\"line\">            //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor</span><br><span class=\"line\">            <span class=\"built_in\">return</span> proceed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        // It’s an interceptor, so we just invoke it: The pointcut will have</span><br><span class=\"line\">        // been evaluated statically before this object was constructed.</span><br><span class=\"line\">        //执行当前IntercetporAdvice</span><br><span class=\"line\">        //注意此时传了this对象，是为了执行链的保持</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里，需要解释几点：</p>\n<ol>\n<li><p><strong>如何判断执行结束？在开头我们说到currentInterceptorIndex</strong>属性是为-1的，<strong>interceptorsAndDynamicMethodMatchers</strong>的size是执行链的数量，刚进来的时候执行链一定大于等于1，所以其减1也不会等于-1，不会执行<strong>invokeJoinpoint</strong>方法，走到下面执行这样一行代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object interceptorOrInterceptionAdvice =</span><br><span class=\"line\">        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br></pre></td></tr></table></figure>\n<p>注意此时<strong>currentInterceptorIndex</strong>游标变成了0，也就是取执行链的第一个执行器取执行，同时游标变成0。下面会执行Advice的<strong>invoke</strong>方法，这里举例Before类型的Advice的<strong>invoke</strong>方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class=\"line\">    this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</span><br><span class=\"line\">    <span class=\"built_in\">return</span> mi.proceed();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意此时<code>mi对象</code>就是上面传进来的<code>this</code>，也就是<code>ReflectiveMethodInvocation</code>对象，他在通知方法执行完成之后，又执行了<code>ReflectiveMethodInvocation</code>的<strong>proceed</strong>方法，然后第二次进入<strong>proceed</strong>时，游标已经变成了0，我们假设此时拦截器数量为一个，那么此时<strong>currentInterceptorIndex=0,interceptorsAndDynamicMethodMatchers.size() - 1 = 0：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> invokeJoinpoint();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将中止执行下面的内容，直接执行<strong>invokeJoinpoint</strong>方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Nullable</span><br><span class=\"line\">protected Object invokeJoinpoint() throws Throwable &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里底层就是<strong>通过反射执行原方法</strong>，到此结束，也就是说其<strong>利用游标索引与循环调用proceed方法来判断当前执行链的结束</strong>，真是个聪明的方法。</p>\n</li>\n<li><p><strong>为什么@Before的Advice的invoke可以实现前置通知效果，同样的@After如何实现后置通知效果？在这里我们将补上上面没有详细讲解的一些Advice类 。</strong><br>1) <code>MethodBeforeAdviceInterceptor</code>前置通知：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MethodBeforeAdvice advice;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">   * Create a new MethodBeforeAdviceInterceptor <span class=\"keyword\">for</span> the given advice.</span><br><span class=\"line\">   * @param advice the MethodBeforeAdvice to wrap</span><br><span class=\"line\">   */</span><br><span class=\"line\">    //构造器初始化保存了advice对象</span><br><span class=\"line\">    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123;</span><br><span class=\"line\">        Assert.notNull(advice, <span class=\"string\">\"Advice must not be null\"</span>);</span><br><span class=\"line\">        this.advice = advice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class=\"line\">        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</span><br><span class=\"line\">        <span class=\"built_in\">return</span> mi.proceed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2)<code>AfterReturningAdviceInterceptor</code>后置通知：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final AfterReturningAdvice advice;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">   * Create a new AfterReturningAdviceInterceptor <span class=\"keyword\">for</span> the given advice.</span><br><span class=\"line\">   * @param advice the AfterReturningAdvice to wrap</span><br><span class=\"line\">   */</span><br><span class=\"line\">    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) &#123;</span><br><span class=\"line\">        Assert.notNull(advice, <span class=\"string\">\"Advice must not be null\"</span>);</span><br><span class=\"line\">        this.advice = advice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class=\"line\">        Object retVal = mi.proceed();</span><br><span class=\"line\">        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class=\"line\">        <span class=\"built_in\">return</span> retVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面两个不同的<code>Advice</code>可以看出，其<strong>invoke</strong>方法的逻辑只是<strong>顺序不同</strong>而已，但为什么可以达到前置后置通知的呢？其实前置通知很好理解，在invoke的逻辑中只要<strong>先执行我们指定的前置通知逻辑</strong>，然后<strong>继续往下执行proceed</strong>即可实现在执行原方法前加一段逻辑的功能，我们主要分析后置通知是如何实现的。还是进行一个假设，此时该方法<strong>只有一个执行链后置通知@After</strong>，那么刚开始进入proceed方法时，获取这个Advice执行invoke方法，然后<strong>又去执行proceed方法</strong>了，由上面的分析此时的游标显示执行链已经执行完毕，所以此时会<strong>直接反射执行原方法</strong>，然后<strong>proceed方法执行完毕</strong>，最后将会执行后置通知Advice的invoke方法的下一步，<strong>advice.afterReturning</strong>，也就是用户<strong>自定义的后置方法逻辑</strong>，实现了在方法最后插入一段代码逻辑的功能，如果是多个通知例如前置后置都有的话，留给读者思考，相信懂得以上逻辑之后推敲起来并不是很难。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>到这里为止，我们分析了AOP是从<strong>自定义标签开始</strong>，自定义标签注册了一个<code>Creator</code>类，而此<code>Creator</code>类是一个<code>BeanPostProcessor</code>，也就是说每个Bean都将调用Creator实现的方法。</p>\n<p>来到了<strong>如何实现AOP代理的分析</strong>中，在此方法中判断Bean是否需要被代理，然后进一步判断此Bean是否可以获得增强器，在这个过程中会去拿所有的Advisor，然后在所有的Advisor列表中筛选出适用的增强器，如果适用的增强器Advisor为空证明此Bean不用被代理，如果不为空则会进入创建代理的流程。</p>\n<p>所以我们开始分析<strong>创建代理是怎样的过程</strong> ，在什么情况下会进行JDK动态代理，在什么情况下会进行CGLIB动态代理，然后创建代理结束之后。</p>\n<p>必不可少的也需要分析是<strong>如何执行AOP通知</strong>的，其核心类是<code>ReflectiveMethodInvocation</code>的<strong>proceed</strong>方法，轮询执行拦截器，并且不同的Advice根据其特有的逻辑执行调用顺序，来完成AOP通知的功能。</p>\n"},{"title":"Vue组件","date":"2018-09-06T16:00:00.000Z","_content":"\n#### Vue创建组件\n\n##### 什么是组件\n什么是组件？组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样地方功能，就可以去调用对应的组件即可。\n组件化和模块化的区别：\n- 模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的只能单一；\n- 组件化：是从UI界面的角度进行划分的；前端的组件化，方便了UI组件的重用；\n\n##### 定义Vue组件\n\n**方式一**\n1、使用Vue.extend来创建全局的Vue组件\n2、通过template属性来指定组件要展示的HTML结构\n3、通过Vue.component()定义全局组件\n4、在HTML指定位置通过Tag标签的形式应用你的组件，组件的名称即是tag标签的名称\n```bash\n<div id=\"app\">\n\t<!-- 组件的名称即为对应tag标签的名称 -->\n\t<mycom1></mycom1>\n</div>\n\n<script>\n\t// 创建组件\n\tvar com1 = Vue.extend({\n\t\ttemplate: '<h3>这是使用Vue.extend 创建的组件</h3>'\n\t});\n\n\t// 使用Vue.component('组件的名称', 创建出来的组件模板对象)，定义全局组件\n\tVue.component('mycom1', com1);\n</script>\n```\n**注意：**\n- 用Vue.component()定义组件名称的时候有两种命名方式：1、驼峰命名：Xxx；2、xxx。注意，使用驼峰命名时，tag标签不能使用驼峰名称，应将相应的大写字母替换为-加小写字母，例如：Vue.component('myCom', com1)，那么tag标签应为： &lt;my-com&gt; &lt;/my-com&gt;\n\n**方式二**\n```bash\n<!-- 组件的名称即为对应tag标签的名称 -->\n<mycom1></mycom1>\n\n<script>\n\n\t// 使用Vue.component('组件的名称', 创建出来的组件模板对象)，定义全局组件\n\tVue.component('mycom1', Vue.extend({\n\t\ttemplate: '<h3>这是使用Vue.extend 创建的组件</h3>'\n\t}));\n</script>\n```\n\n方式二就像是方式一的简化版，但是注意：\n在template中定义的内容只能存在一个根节点元素，即上面例子中template中不能出现和 &lt;h3&gt;平级的标签。\n比如下面这种写法就是**错误的**\n```bash\nVue.component('mycom1', Vue.extend({\n\ttemplate: '<h3>这是使用Vue.extend 创建的组件</h3><span></span>'\n}));\n```\n解决办法就是，外层嵌套一个根标签就行了：\n```bash\nVue.component('mycom1', Vue.extend({\n\ttemplate: '<div><h3>这是使用Vue.extend 创建的组件</h3><span></span></div>'\n}));\n```\n**方式三**\n1、JavaScript中仍使用Vue.component来定义全局组件，和方式二相似，但是里面不再是template: 'HTML结构'了，而是引用一个外部标签的id值，即template:'id'。\n2、在被Vue实例控制的app外面，定义&lt;template id=\"id\"&gt;你的HTML结构&lt;/template&gt;\n这种方式的好处就是是就组件代码都是定义在HTML结构中的，有智能代码提示；而JavaScript中定义组件仅是写一个引用。\n实例：\n```bash\n<div id=\"app\">\n\t<!-- 页面引用 -->\n</div>\n\n\n<template id=\"tmp\">\n\t<!-- 比如仅存在一个根节点元素 -->\n\t<div>\n\t\t<h1></h1>>\n\t\t<h2></h2>\n\t</div>\n</template>\n\n//JavaScript部分\nVue.component('mycom', {\n\ttemplate: '#tmp'\n});\n```\n\n**定义私**有组件\n除了上面讲到的定义全局组件，我们也可以定义私有组件，使用components: {}函数。\n如：\n```bash\n<div id=\"app\">\n    <tem></tem>\n</div>\n<template id=\"tmp\">\n    <h3>这是私有组件</h3>\n</template>\n<script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n<script type=\"text/javascript\">\nnew Vue({\n    el: '#app',\n    data: {},\n    methods: {},\n    components: {\n        tem: {\n            template: '#tmp'\n        }\n    }\n\n});\n</script>\n```\n\n##### 组件元素\n**组件的**data\n在组件中，同样可以有自己的data数据，但是用法和Vue实例中的data用法有所不同：\n1、组件中的data必须是一个方法，即\n```bash\ndata: function(){ }\n```\n2、组件中的data方法必须返回一个Object对象\n```bash\ndata: function(){\n\treturn object\n}\n```\n\n实例：\n```bash\n<div id=\"app\">\n    <mycom1></mycom1>\n</div>\n<script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n<script type=\"text/javascript\">\nVue.component('mycom1', Vue.extend({\n\tdata: function(){\n\t\treturn {\n\t\t\tmsg: '这是组件的data'\n\t\t}\n\t},\n\ttemplate: '<h3>这是使用Vue.extend 创建的组件-- {{msg}}</h3>'\n}));\n\nnew Vue({\n    el: '#app',\n    data: {},\n    methods: {},\n    components: {\n    }\n});\n</script>\n```\n\n**组件的**切换\n在遇到登录注册表单时，通常我们需要对两个按钮进行切换实现显示不同的表单，那么Vue中的组件切换正符合了这个功能要求。\n\n**方式一**\n\n可以使用Vue提供的v-if和v-else来实现两个组件间的切换，但是，仅支持切换两个组件\n\n实例：\n```bash\n<div id=\"app\">\n    <a href=\"#\" @click.prevent=\"flag=true\">登录</a>\n    <a href=\"#\" @click.prevent=\"flag=false\">注册</a>\n\n    <login v-if=\"flag\"></login>\n    <register v-else=\"flag\"></register>\n</div>\n<template id=\"login\">\n    <h3>这是登录表单</h3>\n</template>\n<template id=\"register\">\n\t<h3>这是注册表单</h3>\n</template>\n<script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n<script type=\"text/javascript\">\n// 创建登录组件\nVue.component('login', {\n\ttemplate: '#login'\n});\n\n// 创建注册组件\nVue.component('register', {\n\ttemplate: '#register'\n})\n\nnew Vue({\n    el: '#app',\n    data: {\n    \tflag: true\n    },\n    methods: {}\n\n});\n</script>\n```\n定义flag参数，当flag=true就显示组件，当flar=false就隐藏组件\n\n**方式二**\n\nVue提供了component来展示对应名称的组件。其中component是一个占位符，:is属性，可以用来指定要展示的组件名称\n\n实例：\n```bash\n<div id=\"app\">\n    <a href=\"#\" @click.prevent=\"comName='login'\">登录</a>\n    <a href=\"#\" @click.prevent=\"comName='register'\">注册</a>\n\n    <component :is=\"comName\"></component>\n</div>\n<template id=\"login\">\n    <h3>这是登录表单</h3>\n</template>\n<template id=\"register\">\n\t<h3>这是注册表单</h3>\n</template>\n<script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n<script type=\"text/javascript\">\n// 创建登录组件\nVue.component('login', {\n\ttemplate: '#login'\n});\n\n// 创建注册组件\nVue.component('register', {\n\ttemplate: '#register'\n})\n\nnew Vue({\n    el: '#app',\n    data: {\n    \tcomName: 'login'\n    },\n    methods: {}\n});\n</script>\n```\n即使用Vue提供的component，它能够实现自动对组件进行展示和隐藏，通过:is='组件名称'。\n\n##### 父子组件间传值\n**父组件**给子组件传值\n\n父组件给子组件传值，即实现在子组件中调用父组件中的methods或是获取父组件中的data.\n\n**传参数**\n\n```bash\n<body>\n\t<!-- 父组件实例 -->\n    <div id=\"app\">\n\t\t\n        <!-- 子组件实例 -->\n        <com1></com1>\n    </div>\n\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n\n    new Vue({\n        el: '#app',\n        data: {\n        \tmsg: '这是父组件data值'\n        },\n        methods: {\n        \tshow(){\n        \t\tconsole.log(\"这是父组件的show方法\");\n        \t}\n        },\n\n        // 子组件\n        components: {\n        \tcom1: {\n        \t\ttemplate: '<h2>这是子组件</h2>'\n        \t}\n        }\n    });\n    </script>\n</body>\n```\n如上，当我们直接在子组件中引用父组件data中定义的msg数据，将上面的修改为：\n```bash\ncom1: {\n\ttemplate: '<h2>这是子组件--{{msg}}</h2>'\n}\n```\n那么就会报错。所以就证实了默认在子组件中不能访问父组件中的data或methods。\n为了解决子组件获取父组件数据，Vue提供了以下方式获取：\n- 1、父组件在引用子组件的时候，通过属性绑定的方式v-bind:，把需要传递给子组件的数据以属性绑定的形式传递到子组件内部，供子组件使用。\n- 2、在子组件中，通过props: []获取到父组件传递过来的数据；这样就完成了父组件向子组件传值\n\n**实例：**\n```bash\n<body>\n\t<!-- 父组件实例 -->\n    <div id=\"app\">\n\t\t\n        <!-- 子组件实例 -->\n        <com1 :fatoson=\"msg\"></com1>\n    </div>\n\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n\n    new Vue({\n        el: '#app',\n        data: {\n        \tmsg: '这是父组件data值'\n        },\n        methods: {},\n\n        // 子组件\n        components: {\n        \tcom1: {\n        \t\ttemplate: '<h2>这是子组件--{{fatoson}}</h2>',\n        \t\tprops: ['fatoson']\n        \t}\n        }\n    });\n    </script>\n</body>\n```\n\n如上，我们在子组件实例中使用了v-bind绑定了一个参数fatoson，其值是：msg即在父组件data中定义的值；那么就相当于父组件的一个data数据被Vue绑定到了子组件实例中，且父组件data值的别名是fatoson，那么在子组件中通过props: []属性就能获取到这个别名，然后就实现了父组件向子组件传值。需要注意以下：\n- 1、我们可以将为子组件绑定的参数名称是父组件值的别名。即此时msg相当于fatoson。\n- 2、注意命名中若是驼峰命名，在HTML中必须用-替换。\n- 3、注意props是Vue为父组将向子组件传值提供的一个参数，且他是唯一的数组类型的。\n- 4、注意子组件通过props获取到的父组件的值是只读的，即不能修改。\n\n**传方法**\n上面讲了父组件给子组件传递普通的参数，下面我们将了解到父组件怎样给子组件传递方法。\n```bash\n<body>\n\t<!-- 父组件实例 -->\n    <div id=\"app\">\n\t\t\n        <!-- 子组件实例 -->\n        <com1 @open=\"show\"></com1>\n    </div>\n    <template id=\"tmp\">\n    \t<div>\n    \t\t<h2>这是子组件</h2>\n    \t\t<input type=\"button\" @click=\"myclick\" value=\"子组件按钮，点击触发父组件方法\"/>\n    \t</div>\n    </template>\n\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n\n    new Vue({\n        el: '#app',\n        data: {\n        \tmsg: '这是父组件data值'\n        },\n        methods: {\n        \tshow(){\n        \t\tconsole.log(\"这是父组件的show方法\");\n        \t}\n        },\n\n        // 子组件\n        components: {\n        \tcom1: {\n        \t\ttemplate: '#tmp',\n        \t\tprops: ['fatoson'],\n        \t\tmethods: {\n        \t\t\tmyclick(){\n       \t\t \t\t\tthis.$emit('open');\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n    });\n    </script>\n</body>\n```\n\n**解释：**\n- 1、这里子组件的template数据引用外部的&lt;template&gt;&lt;/template&gt;中的HTML代码。\n- 2、与传值思路相同，传递方法也需要在子组件实例中使用v-on即@来绑定方法，方法别名@open，方法的值是show是在父组件中定义的方法名。\n- 3、与传值思路相同，传值使用了props来接受传递的参数，那么传方法提供了$emit()元素\n\n**综合**\n上面讲的父组件向子组件传递方法，那么既然是方法就肯定能传递方法参数。我们只需要在父组件方法中指定值名称即可\n```bash\n@子组件接收的方法别名=\"父组件中的方法(父组件中的参数值或data)\"\n```\n```bash\n<body>\n\t<!-- 父组件实例 -->\n    <div id=\"app\">\n\t\t\n        <!-- 子组件实例 -->\n        <com1 @open=\"show(fatosonval)\"></com1>\n    </div>\n    <template id=\"tmp\">\n    \t<div>\n    \t\t<h2>这是子组件</h2>\n    \t\t<input type=\"button\" @click=\"myclick\" value=\"子组件按钮，点击触发父组件方法\"/>\n    \t</div>\n    </template>\n\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n\n    new Vue({\n        el: '#app',\n        data: {\n        \tfatosonval: {\n        \t\tid: '1',\n        \t\tname: 'Loonycoder'\n        \t}\n        },\n        methods: {\n        \tshow(data){\n        \t\tconsole.log(data);\n        \t}\n        },\n\n        // 子组件\n        components: {\n        \tcom1: {\n        \t\ttemplate: '#tmp',\n        \t\tmethods: {\n        \t\t\tmyclick(){\n       \t\t \t\t\tthis.$emit('open');\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n    });\n    </script>\n</body>\n```\n\n**子组件**给父组件传值\n即实现在父组件中调用子组件中的方法\n```bash\n<body>\n\t<!-- 父组件实例 -->\n    <div id=\"app\">\n\t\t\n        <!-- 子组件实例 -->\n        <com1 @open=\"show\"></com1>\n    </div>\n    <template id=\"tmp\">\n    \t<div>\n    \t\t<h2>这是子组件</h2>\n    \t\t<input type=\"button\" @click=\"myclick\" value=\"子组件按钮，点击触发父组件方法\"/>\n    \t</div>\n    </template>\n\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n\n    new Vue({\n        el: '#app',\n        data: {\n        \tfatosonval: null\n        },\n        methods: {\n        \tshow(data){\n        \t\tconsole.log(data);\n        \t}\n        },\n\n        // 子组件\n        components: {\n        \tcom1: {\n        \t\ttemplate: '#tmp',\n        \t\tdata(){\n        \t\t\treturn {\n        \t\t\t\tsonval: { name: 'Loonycoder', age: 24 }\n        \t\t\t}\n        \t\t},\n        \t\tmethods: {\n        \t\t\tmyclick(){\n       \t\t \t\t\tthis.$emit('open', this.sonval);\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n    });\n    </script>\n</body>\n```\n之前我们实现父组件向子组件传值的时候，需要在@open()中指定父组件中的data，而子组件给父组件传值的时候就不需要再指定了，而是直接在调用子组件中的open（这是父组件方法的别名），将子组件的值写进$emit('方法别名', data参数)中即可。\n\n##### Vue获取DOM元素和组件\n首先我们需要明白的就是Vue并不提倡我们操作DOM元素，Vue的宗旨就是让我们只关心业务逻辑。\n那么通常我们需要获取一个如&lt;h2&gt;&lt;/h2&gt;中的值，采用原生JS通常需要先为tag标签定义一个id属性，然后通过JS代码document.getElementById('id').innterText来获取到&lt;h2&gt;中的文本数据，而Vue也实现了操作原生DOM的功能：\n- 在需要获取的HTML标签中指定`ref`属性，其值可自定义。\n- 在Vue实例中，使用`this.$refs.指定的值`来获取DOM对象，进行操作。\n```bash\n<h2 ref=\"h2\">这是h2的文本数据</h2>\n\nconsole.log(this.$refs.h2.innerText);\n```\n**通过$refs还能轻易获取子组件中的data和methods数据**\n首先需要为子组件引用实例定义ref=\"com1\"属性，然后在Vue实例中通过this.$refs.com1即可获取子组件中的所有对象，即还能获取到子组件中的data和methods\n实例：\n```bash\n<body>\n    <!-- 父组件实例 -->\n    <div id=\"app\">\n        <!-- 子组件实例 -->\n        <com1 ref=\"com1\"></com1>\n        <input type=\"button\" @click=\"show\" value=\"获取元素\">\n\n        <h2 ref=\"h2\">这是父组件</h2>\n    </div>\n    <template id=\"tmp\">\n        <div>\n            <h2>这是子组件</h2>\n        </div>\n    </template>\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n    new Vue({\n        el: '#app',\n        methods: {\n            show(){\n                // console.log(this.$refs.h2.innerText);\n                // console.log(this.$refs.com1); //获取子组件中的所有实例对象\n                // console.log(this.$refs.com1.sonval); //获取子组件中定义的data值\n                console.log(this.$refs.com1.sonshow()); //调用子组件中定义的方法\n\n            }\n        },\n\n        // 子组件\n        components: {\n            com1: {\n                template: '#tmp',\n                data() {\n                    return {\n                        sonval: { name: 'Loonycoder', age: 24 }\n                    }\n                },\n                methods: {\n                    sonshow() {\n                        console.log('子组件的方法');\n                    }\n                }\n            }\n        }\n    });\n    </script>\n</body>\n```\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Vue3.md","raw":"---\ntitle: Vue组件\ncategories:\n    - Web前端\ndate: 2018-09-07\ntags:\n\t- 前端框架\n\t\n---\n\n#### Vue创建组件\n\n##### 什么是组件\n什么是组件？组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样地方功能，就可以去调用对应的组件即可。\n组件化和模块化的区别：\n- 模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的只能单一；\n- 组件化：是从UI界面的角度进行划分的；前端的组件化，方便了UI组件的重用；\n\n##### 定义Vue组件\n\n**方式一**\n1、使用Vue.extend来创建全局的Vue组件\n2、通过template属性来指定组件要展示的HTML结构\n3、通过Vue.component()定义全局组件\n4、在HTML指定位置通过Tag标签的形式应用你的组件，组件的名称即是tag标签的名称\n```bash\n<div id=\"app\">\n\t<!-- 组件的名称即为对应tag标签的名称 -->\n\t<mycom1></mycom1>\n</div>\n\n<script>\n\t// 创建组件\n\tvar com1 = Vue.extend({\n\t\ttemplate: '<h3>这是使用Vue.extend 创建的组件</h3>'\n\t});\n\n\t// 使用Vue.component('组件的名称', 创建出来的组件模板对象)，定义全局组件\n\tVue.component('mycom1', com1);\n</script>\n```\n**注意：**\n- 用Vue.component()定义组件名称的时候有两种命名方式：1、驼峰命名：Xxx；2、xxx。注意，使用驼峰命名时，tag标签不能使用驼峰名称，应将相应的大写字母替换为-加小写字母，例如：Vue.component('myCom', com1)，那么tag标签应为： &lt;my-com&gt; &lt;/my-com&gt;\n\n**方式二**\n```bash\n<!-- 组件的名称即为对应tag标签的名称 -->\n<mycom1></mycom1>\n\n<script>\n\n\t// 使用Vue.component('组件的名称', 创建出来的组件模板对象)，定义全局组件\n\tVue.component('mycom1', Vue.extend({\n\t\ttemplate: '<h3>这是使用Vue.extend 创建的组件</h3>'\n\t}));\n</script>\n```\n\n方式二就像是方式一的简化版，但是注意：\n在template中定义的内容只能存在一个根节点元素，即上面例子中template中不能出现和 &lt;h3&gt;平级的标签。\n比如下面这种写法就是**错误的**\n```bash\nVue.component('mycom1', Vue.extend({\n\ttemplate: '<h3>这是使用Vue.extend 创建的组件</h3><span></span>'\n}));\n```\n解决办法就是，外层嵌套一个根标签就行了：\n```bash\nVue.component('mycom1', Vue.extend({\n\ttemplate: '<div><h3>这是使用Vue.extend 创建的组件</h3><span></span></div>'\n}));\n```\n**方式三**\n1、JavaScript中仍使用Vue.component来定义全局组件，和方式二相似，但是里面不再是template: 'HTML结构'了，而是引用一个外部标签的id值，即template:'id'。\n2、在被Vue实例控制的app外面，定义&lt;template id=\"id\"&gt;你的HTML结构&lt;/template&gt;\n这种方式的好处就是是就组件代码都是定义在HTML结构中的，有智能代码提示；而JavaScript中定义组件仅是写一个引用。\n实例：\n```bash\n<div id=\"app\">\n\t<!-- 页面引用 -->\n</div>\n\n\n<template id=\"tmp\">\n\t<!-- 比如仅存在一个根节点元素 -->\n\t<div>\n\t\t<h1></h1>>\n\t\t<h2></h2>\n\t</div>\n</template>\n\n//JavaScript部分\nVue.component('mycom', {\n\ttemplate: '#tmp'\n});\n```\n\n**定义私**有组件\n除了上面讲到的定义全局组件，我们也可以定义私有组件，使用components: {}函数。\n如：\n```bash\n<div id=\"app\">\n    <tem></tem>\n</div>\n<template id=\"tmp\">\n    <h3>这是私有组件</h3>\n</template>\n<script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n<script type=\"text/javascript\">\nnew Vue({\n    el: '#app',\n    data: {},\n    methods: {},\n    components: {\n        tem: {\n            template: '#tmp'\n        }\n    }\n\n});\n</script>\n```\n\n##### 组件元素\n**组件的**data\n在组件中，同样可以有自己的data数据，但是用法和Vue实例中的data用法有所不同：\n1、组件中的data必须是一个方法，即\n```bash\ndata: function(){ }\n```\n2、组件中的data方法必须返回一个Object对象\n```bash\ndata: function(){\n\treturn object\n}\n```\n\n实例：\n```bash\n<div id=\"app\">\n    <mycom1></mycom1>\n</div>\n<script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n<script type=\"text/javascript\">\nVue.component('mycom1', Vue.extend({\n\tdata: function(){\n\t\treturn {\n\t\t\tmsg: '这是组件的data'\n\t\t}\n\t},\n\ttemplate: '<h3>这是使用Vue.extend 创建的组件-- {{msg}}</h3>'\n}));\n\nnew Vue({\n    el: '#app',\n    data: {},\n    methods: {},\n    components: {\n    }\n});\n</script>\n```\n\n**组件的**切换\n在遇到登录注册表单时，通常我们需要对两个按钮进行切换实现显示不同的表单，那么Vue中的组件切换正符合了这个功能要求。\n\n**方式一**\n\n可以使用Vue提供的v-if和v-else来实现两个组件间的切换，但是，仅支持切换两个组件\n\n实例：\n```bash\n<div id=\"app\">\n    <a href=\"#\" @click.prevent=\"flag=true\">登录</a>\n    <a href=\"#\" @click.prevent=\"flag=false\">注册</a>\n\n    <login v-if=\"flag\"></login>\n    <register v-else=\"flag\"></register>\n</div>\n<template id=\"login\">\n    <h3>这是登录表单</h3>\n</template>\n<template id=\"register\">\n\t<h3>这是注册表单</h3>\n</template>\n<script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n<script type=\"text/javascript\">\n// 创建登录组件\nVue.component('login', {\n\ttemplate: '#login'\n});\n\n// 创建注册组件\nVue.component('register', {\n\ttemplate: '#register'\n})\n\nnew Vue({\n    el: '#app',\n    data: {\n    \tflag: true\n    },\n    methods: {}\n\n});\n</script>\n```\n定义flag参数，当flag=true就显示组件，当flar=false就隐藏组件\n\n**方式二**\n\nVue提供了component来展示对应名称的组件。其中component是一个占位符，:is属性，可以用来指定要展示的组件名称\n\n实例：\n```bash\n<div id=\"app\">\n    <a href=\"#\" @click.prevent=\"comName='login'\">登录</a>\n    <a href=\"#\" @click.prevent=\"comName='register'\">注册</a>\n\n    <component :is=\"comName\"></component>\n</div>\n<template id=\"login\">\n    <h3>这是登录表单</h3>\n</template>\n<template id=\"register\">\n\t<h3>这是注册表单</h3>\n</template>\n<script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n<script type=\"text/javascript\">\n// 创建登录组件\nVue.component('login', {\n\ttemplate: '#login'\n});\n\n// 创建注册组件\nVue.component('register', {\n\ttemplate: '#register'\n})\n\nnew Vue({\n    el: '#app',\n    data: {\n    \tcomName: 'login'\n    },\n    methods: {}\n});\n</script>\n```\n即使用Vue提供的component，它能够实现自动对组件进行展示和隐藏，通过:is='组件名称'。\n\n##### 父子组件间传值\n**父组件**给子组件传值\n\n父组件给子组件传值，即实现在子组件中调用父组件中的methods或是获取父组件中的data.\n\n**传参数**\n\n```bash\n<body>\n\t<!-- 父组件实例 -->\n    <div id=\"app\">\n\t\t\n        <!-- 子组件实例 -->\n        <com1></com1>\n    </div>\n\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n\n    new Vue({\n        el: '#app',\n        data: {\n        \tmsg: '这是父组件data值'\n        },\n        methods: {\n        \tshow(){\n        \t\tconsole.log(\"这是父组件的show方法\");\n        \t}\n        },\n\n        // 子组件\n        components: {\n        \tcom1: {\n        \t\ttemplate: '<h2>这是子组件</h2>'\n        \t}\n        }\n    });\n    </script>\n</body>\n```\n如上，当我们直接在子组件中引用父组件data中定义的msg数据，将上面的修改为：\n```bash\ncom1: {\n\ttemplate: '<h2>这是子组件--{{msg}}</h2>'\n}\n```\n那么就会报错。所以就证实了默认在子组件中不能访问父组件中的data或methods。\n为了解决子组件获取父组件数据，Vue提供了以下方式获取：\n- 1、父组件在引用子组件的时候，通过属性绑定的方式v-bind:，把需要传递给子组件的数据以属性绑定的形式传递到子组件内部，供子组件使用。\n- 2、在子组件中，通过props: []获取到父组件传递过来的数据；这样就完成了父组件向子组件传值\n\n**实例：**\n```bash\n<body>\n\t<!-- 父组件实例 -->\n    <div id=\"app\">\n\t\t\n        <!-- 子组件实例 -->\n        <com1 :fatoson=\"msg\"></com1>\n    </div>\n\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n\n    new Vue({\n        el: '#app',\n        data: {\n        \tmsg: '这是父组件data值'\n        },\n        methods: {},\n\n        // 子组件\n        components: {\n        \tcom1: {\n        \t\ttemplate: '<h2>这是子组件--{{fatoson}}</h2>',\n        \t\tprops: ['fatoson']\n        \t}\n        }\n    });\n    </script>\n</body>\n```\n\n如上，我们在子组件实例中使用了v-bind绑定了一个参数fatoson，其值是：msg即在父组件data中定义的值；那么就相当于父组件的一个data数据被Vue绑定到了子组件实例中，且父组件data值的别名是fatoson，那么在子组件中通过props: []属性就能获取到这个别名，然后就实现了父组件向子组件传值。需要注意以下：\n- 1、我们可以将为子组件绑定的参数名称是父组件值的别名。即此时msg相当于fatoson。\n- 2、注意命名中若是驼峰命名，在HTML中必须用-替换。\n- 3、注意props是Vue为父组将向子组件传值提供的一个参数，且他是唯一的数组类型的。\n- 4、注意子组件通过props获取到的父组件的值是只读的，即不能修改。\n\n**传方法**\n上面讲了父组件给子组件传递普通的参数，下面我们将了解到父组件怎样给子组件传递方法。\n```bash\n<body>\n\t<!-- 父组件实例 -->\n    <div id=\"app\">\n\t\t\n        <!-- 子组件实例 -->\n        <com1 @open=\"show\"></com1>\n    </div>\n    <template id=\"tmp\">\n    \t<div>\n    \t\t<h2>这是子组件</h2>\n    \t\t<input type=\"button\" @click=\"myclick\" value=\"子组件按钮，点击触发父组件方法\"/>\n    \t</div>\n    </template>\n\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n\n    new Vue({\n        el: '#app',\n        data: {\n        \tmsg: '这是父组件data值'\n        },\n        methods: {\n        \tshow(){\n        \t\tconsole.log(\"这是父组件的show方法\");\n        \t}\n        },\n\n        // 子组件\n        components: {\n        \tcom1: {\n        \t\ttemplate: '#tmp',\n        \t\tprops: ['fatoson'],\n        \t\tmethods: {\n        \t\t\tmyclick(){\n       \t\t \t\t\tthis.$emit('open');\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n    });\n    </script>\n</body>\n```\n\n**解释：**\n- 1、这里子组件的template数据引用外部的&lt;template&gt;&lt;/template&gt;中的HTML代码。\n- 2、与传值思路相同，传递方法也需要在子组件实例中使用v-on即@来绑定方法，方法别名@open，方法的值是show是在父组件中定义的方法名。\n- 3、与传值思路相同，传值使用了props来接受传递的参数，那么传方法提供了$emit()元素\n\n**综合**\n上面讲的父组件向子组件传递方法，那么既然是方法就肯定能传递方法参数。我们只需要在父组件方法中指定值名称即可\n```bash\n@子组件接收的方法别名=\"父组件中的方法(父组件中的参数值或data)\"\n```\n```bash\n<body>\n\t<!-- 父组件实例 -->\n    <div id=\"app\">\n\t\t\n        <!-- 子组件实例 -->\n        <com1 @open=\"show(fatosonval)\"></com1>\n    </div>\n    <template id=\"tmp\">\n    \t<div>\n    \t\t<h2>这是子组件</h2>\n    \t\t<input type=\"button\" @click=\"myclick\" value=\"子组件按钮，点击触发父组件方法\"/>\n    \t</div>\n    </template>\n\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n\n    new Vue({\n        el: '#app',\n        data: {\n        \tfatosonval: {\n        \t\tid: '1',\n        \t\tname: 'Loonycoder'\n        \t}\n        },\n        methods: {\n        \tshow(data){\n        \t\tconsole.log(data);\n        \t}\n        },\n\n        // 子组件\n        components: {\n        \tcom1: {\n        \t\ttemplate: '#tmp',\n        \t\tmethods: {\n        \t\t\tmyclick(){\n       \t\t \t\t\tthis.$emit('open');\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n    });\n    </script>\n</body>\n```\n\n**子组件**给父组件传值\n即实现在父组件中调用子组件中的方法\n```bash\n<body>\n\t<!-- 父组件实例 -->\n    <div id=\"app\">\n\t\t\n        <!-- 子组件实例 -->\n        <com1 @open=\"show\"></com1>\n    </div>\n    <template id=\"tmp\">\n    \t<div>\n    \t\t<h2>这是子组件</h2>\n    \t\t<input type=\"button\" @click=\"myclick\" value=\"子组件按钮，点击触发父组件方法\"/>\n    \t</div>\n    </template>\n\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n\n    new Vue({\n        el: '#app',\n        data: {\n        \tfatosonval: null\n        },\n        methods: {\n        \tshow(data){\n        \t\tconsole.log(data);\n        \t}\n        },\n\n        // 子组件\n        components: {\n        \tcom1: {\n        \t\ttemplate: '#tmp',\n        \t\tdata(){\n        \t\t\treturn {\n        \t\t\t\tsonval: { name: 'Loonycoder', age: 24 }\n        \t\t\t}\n        \t\t},\n        \t\tmethods: {\n        \t\t\tmyclick(){\n       \t\t \t\t\tthis.$emit('open', this.sonval);\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n    });\n    </script>\n</body>\n```\n之前我们实现父组件向子组件传值的时候，需要在@open()中指定父组件中的data，而子组件给父组件传值的时候就不需要再指定了，而是直接在调用子组件中的open（这是父组件方法的别名），将子组件的值写进$emit('方法别名', data参数)中即可。\n\n##### Vue获取DOM元素和组件\n首先我们需要明白的就是Vue并不提倡我们操作DOM元素，Vue的宗旨就是让我们只关心业务逻辑。\n那么通常我们需要获取一个如&lt;h2&gt;&lt;/h2&gt;中的值，采用原生JS通常需要先为tag标签定义一个id属性，然后通过JS代码document.getElementById('id').innterText来获取到&lt;h2&gt;中的文本数据，而Vue也实现了操作原生DOM的功能：\n- 在需要获取的HTML标签中指定`ref`属性，其值可自定义。\n- 在Vue实例中，使用`this.$refs.指定的值`来获取DOM对象，进行操作。\n```bash\n<h2 ref=\"h2\">这是h2的文本数据</h2>\n\nconsole.log(this.$refs.h2.innerText);\n```\n**通过$refs还能轻易获取子组件中的data和methods数据**\n首先需要为子组件引用实例定义ref=\"com1\"属性，然后在Vue实例中通过this.$refs.com1即可获取子组件中的所有对象，即还能获取到子组件中的data和methods\n实例：\n```bash\n<body>\n    <!-- 父组件实例 -->\n    <div id=\"app\">\n        <!-- 子组件实例 -->\n        <com1 ref=\"com1\"></com1>\n        <input type=\"button\" @click=\"show\" value=\"获取元素\">\n\n        <h2 ref=\"h2\">这是父组件</h2>\n    </div>\n    <template id=\"tmp\">\n        <div>\n            <h2>这是子组件</h2>\n        </div>\n    </template>\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\">\n    new Vue({\n        el: '#app',\n        methods: {\n            show(){\n                // console.log(this.$refs.h2.innerText);\n                // console.log(this.$refs.com1); //获取子组件中的所有实例对象\n                // console.log(this.$refs.com1.sonval); //获取子组件中定义的data值\n                console.log(this.$refs.com1.sonshow()); //调用子组件中定义的方法\n\n            }\n        },\n\n        // 子组件\n        components: {\n            com1: {\n                template: '#tmp',\n                data() {\n                    return {\n                        sonval: { name: 'Loonycoder', age: 24 }\n                    }\n                },\n                methods: {\n                    sonshow() {\n                        console.log('子组件的方法');\n                    }\n                }\n            }\n        }\n    });\n    </script>\n</body>\n```\n\n\n\n\n\n\n\n\n\n\n","slug":"Vue3","published":1,"updated":"2020-02-21T15:28:56.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiyy000pv9s6e1i0dzgn","content":"<h4 id=\"Vue创建组件\"><a href=\"#Vue创建组件\" class=\"headerlink\" title=\"Vue创建组件\"></a>Vue创建组件</h4><h5 id=\"什么是组件\"><a href=\"#什么是组件\" class=\"headerlink\" title=\"什么是组件\"></a>什么是组件</h5><p>什么是组件？组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样地方功能，就可以去调用对应的组件即可。<br>组件化和模块化的区别：</p>\n<ul>\n<li>模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的只能单一；</li>\n<li>组件化：是从UI界面的角度进行划分的；前端的组件化，方便了UI组件的重用；</li>\n</ul>\n<h5 id=\"定义Vue组件\"><a href=\"#定义Vue组件\" class=\"headerlink\" title=\"定义Vue组件\"></a>定义Vue组件</h5><p><strong>方式一</strong><br>1、使用Vue.extend来创建全局的Vue组件<br>2、通过template属性来指定组件要展示的HTML结构<br>3、通过Vue.component()定义全局组件<br>4、在HTML指定位置通过Tag标签的形式应用你的组件，组件的名称即是tag标签的名称</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t&lt;!-- 组件的名称即为对应tag标签的名称 --&gt;</span><br><span class=\"line\">\t&lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t// 创建组件</span><br><span class=\"line\">\tvar com1 = Vue.extend(&#123;</span><br><span class=\"line\">\t\ttemplate: <span class=\"string\">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 使用Vue.component(<span class=\"string\">'组件的名称'</span>, 创建出来的组件模板对象)，定义全局组件</span><br><span class=\"line\">\tVue.component(<span class=\"string\">'mycom1'</span>, com1);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong></p>\n<ul>\n<li>用Vue.component()定义组件名称的时候有两种命名方式：1、驼峰命名：Xxx；2、xxx。注意，使用驼峰命名时，tag标签不能使用驼峰名称，应将相应的大写字母替换为-加小写字母，例如：Vue.component(‘myCom’, com1)，那么tag标签应为： &lt;my-com&gt; &lt;/my-com&gt;</li>\n</ul>\n<p><strong>方式二</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 组件的名称即为对应tag标签的名称 --&gt;</span><br><span class=\"line\">&lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 使用Vue.component(<span class=\"string\">'组件的名称'</span>, 创建出来的组件模板对象)，定义全局组件</span><br><span class=\"line\">\tVue.component(<span class=\"string\">'mycom1'</span>, Vue.extend(&#123;</span><br><span class=\"line\">\t\ttemplate: <span class=\"string\">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class=\"line\">\t&#125;));</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>方式二就像是方式一的简化版，但是注意：<br>在template中定义的内容只能存在一个根节点元素，即上面例子中template中不能出现和 &lt;h3&gt;平级的标签。<br>比如下面这种写法就是<strong>错误的</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'mycom1'</span>, Vue.extend(&#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;'</span></span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>解决办法就是，外层嵌套一个根标签就行了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'mycom1'</span>, Vue.extend(&#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'&lt;div&gt;&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p><strong>方式三</strong><br>1、JavaScript中仍使用Vue.component来定义全局组件，和方式二相似，但是里面不再是template: ‘HTML结构’了，而是引用一个外部标签的id值，即template:’id’。<br>2、在被Vue实例控制的app外面，定义&lt;template id=”id”&gt;你的HTML结构&lt;/template&gt;<br>这种方式的好处就是是就组件代码都是定义在HTML结构中的，有智能代码提示；而JavaScript中定义组件仅是写一个引用。<br>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t&lt;!-- 页面引用 --&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">\t&lt;!-- 比如仅存在一个根节点元素 --&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">\t\t&lt;h1&gt;&lt;/h1&gt;&gt;</span><br><span class=\"line\">\t\t&lt;h2&gt;&lt;/h2&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//JavaScript部分</span><br><span class=\"line\">Vue.component(<span class=\"string\">'mycom'</span>, &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#tmp'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>定义私</strong>有组件<br>除了上面讲到的定义全局组件，我们也可以定义私有组件，使用components: {}函数。<br>如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;tem&gt;&lt;/tem&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">    &lt;h3&gt;这是私有组件&lt;/h3&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">        tem: &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'#tmp'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"组件元素\"><a href=\"#组件元素\" class=\"headerlink\" title=\"组件元素\"></a>组件元素</h5><p><strong>组件的</strong>data<br>在组件中，同样可以有自己的data数据，但是用法和Vue实例中的data用法有所不同：<br>1、组件中的data必须是一个方法，即</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: <span class=\"function\"><span class=\"title\">function</span></span>()&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>2、组件中的data方法必须返回一个Object对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">return</span> object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">Vue.component(<span class=\"string\">'mycom1'</span>, Vue.extend(&#123;</span><br><span class=\"line\">\tdata: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">\t\t\tmsg: <span class=\"string\">'这是组件的data'</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'&lt;h3&gt;这是使用Vue.extend 创建的组件-- &#123;&#123;msg&#125;&#125;&lt;/h3&gt;'</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>组件的</strong>切换<br>在遇到登录注册表单时，通常我们需要对两个按钮进行切换实现显示不同的表单，那么Vue中的组件切换正符合了这个功能要求。</p>\n<p><strong>方式一</strong></p>\n<p>可以使用Vue提供的v-if和v-else来实现两个组件间的切换，但是，仅支持切换两个组件</p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#\"</span> @click.prevent=<span class=\"string\">\"flag=true\"</span>&gt;登录&lt;/a&gt;</span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#\"</span> @click.prevent=<span class=\"string\">\"flag=false\"</span>&gt;注册&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;login v-if=<span class=\"string\">\"flag\"</span>&gt;&lt;/login&gt;</span><br><span class=\"line\">    &lt;register v-else=<span class=\"string\">\"flag\"</span>&gt;&lt;/register&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"login\"</span>&gt;</span><br><span class=\"line\">    &lt;h3&gt;这是登录表单&lt;/h3&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"register\"</span>&gt;</span><br><span class=\"line\">\t&lt;h3&gt;这是注册表单&lt;/h3&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">// 创建登录组件</span><br><span class=\"line\">Vue.component(<span class=\"string\">'login'</span>, &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#login'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建注册组件</span><br><span class=\"line\">Vue.component(<span class=\"string\">'register'</span>, &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#register'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">    \tflag: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>定义flag参数，当flag=true就显示组件，当flar=false就隐藏组件</p>\n<p><strong>方式二</strong></p>\n<p>Vue提供了component来展示对应名称的组件。其中component是一个占位符，:is属性，可以用来指定要展示的组件名称</p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#\"</span> @click.prevent=<span class=\"string\">\"comName='login'\"</span>&gt;登录&lt;/a&gt;</span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#\"</span> @click.prevent=<span class=\"string\">\"comName='register'\"</span>&gt;注册&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;component :is=<span class=\"string\">\"comName\"</span>&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"login\"</span>&gt;</span><br><span class=\"line\">    &lt;h3&gt;这是登录表单&lt;/h3&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"register\"</span>&gt;</span><br><span class=\"line\">\t&lt;h3&gt;这是注册表单&lt;/h3&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">// 创建登录组件</span><br><span class=\"line\">Vue.component(<span class=\"string\">'login'</span>, &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#login'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建注册组件</span><br><span class=\"line\">Vue.component(<span class=\"string\">'register'</span>, &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#register'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">    \tcomName: <span class=\"string\">'login'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>即使用Vue提供的component，它能够实现自动对组件进行展示和隐藏，通过:is=’组件名称’。</p>\n<h5 id=\"父子组件间传值\"><a href=\"#父子组件间传值\" class=\"headerlink\" title=\"父子组件间传值\"></a>父子组件间传值</h5><p><strong>父组件</strong>给子组件传值</p>\n<p>父组件给子组件传值，即实现在子组件中调用父组件中的methods或是获取父组件中的data.</p>\n<p><strong>传参数</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1&gt;&lt;/com1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">        \tmsg: <span class=\"string\">'这是父组件data值'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">        \t<span class=\"function\"><span class=\"title\">show</span></span>()&#123;</span><br><span class=\"line\">        \t\tconsole.log(<span class=\"string\">\"这是父组件的show方法\"</span>);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">        \tcom1: &#123;</span><br><span class=\"line\">        \t\ttemplate: <span class=\"string\">'&lt;h2&gt;这是子组件&lt;/h2&gt;'</span></span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>如上，当我们直接在子组件中引用父组件data中定义的msg数据，将上面的修改为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com1: &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'&lt;h2&gt;这是子组件--&#123;&#123;msg&#125;&#125;&lt;/h2&gt;'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么就会报错。所以就证实了默认在子组件中不能访问父组件中的data或methods。<br>为了解决子组件获取父组件数据，Vue提供了以下方式获取：</p>\n<ul>\n<li>1、父组件在引用子组件的时候，通过属性绑定的方式v-bind:，把需要传递给子组件的数据以属性绑定的形式传递到子组件内部，供子组件使用。</li>\n<li>2、在子组件中，通过props: []获取到父组件传递过来的数据；这样就完成了父组件向子组件传值</li>\n</ul>\n<p><strong>实例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1 :fatoson=<span class=\"string\">\"msg\"</span>&gt;&lt;/com1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">        \tmsg: <span class=\"string\">'这是父组件data值'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">        \tcom1: &#123;</span><br><span class=\"line\">        \t\ttemplate: <span class=\"string\">'&lt;h2&gt;这是子组件--&#123;&#123;fatoson&#125;&#125;&lt;/h2&gt;'</span>,</span><br><span class=\"line\">        \t\tprops: [<span class=\"string\">'fatoson'</span>]</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，我们在子组件实例中使用了v-bind绑定了一个参数fatoson，其值是：msg即在父组件data中定义的值；那么就相当于父组件的一个data数据被Vue绑定到了子组件实例中，且父组件data值的别名是fatoson，那么在子组件中通过props: []属性就能获取到这个别名，然后就实现了父组件向子组件传值。需要注意以下：</p>\n<ul>\n<li>1、我们可以将为子组件绑定的参数名称是父组件值的别名。即此时msg相当于fatoson。</li>\n<li>2、注意命名中若是驼峰命名，在HTML中必须用-替换。</li>\n<li>3、注意props是Vue为父组将向子组件传值提供的一个参数，且他是唯一的数组类型的。</li>\n<li>4、注意子组件通过props获取到的父组件的值是只读的，即不能修改。</li>\n</ul>\n<p><strong>传方法</strong><br>上面讲了父组件给子组件传递普通的参数，下面我们将了解到父组件怎样给子组件传递方法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1 @open=<span class=\"string\">\"show\"</span>&gt;&lt;/com1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">    \t&lt;div&gt;</span><br><span class=\"line\">    \t\t&lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class=\"line\">    \t\t&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"myclick\"</span> value=<span class=\"string\">\"子组件按钮，点击触发父组件方法\"</span>/&gt;</span><br><span class=\"line\">    \t&lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">        \tmsg: <span class=\"string\">'这是父组件data值'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">        \t<span class=\"function\"><span class=\"title\">show</span></span>()&#123;</span><br><span class=\"line\">        \t\tconsole.log(<span class=\"string\">\"这是父组件的show方法\"</span>);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">        \tcom1: &#123;</span><br><span class=\"line\">        \t\ttemplate: <span class=\"string\">'#tmp'</span>,</span><br><span class=\"line\">        \t\tprops: [<span class=\"string\">'fatoson'</span>],</span><br><span class=\"line\">        \t\tmethods: &#123;</span><br><span class=\"line\">        \t\t\t<span class=\"function\"><span class=\"title\">myclick</span></span>()&#123;</span><br><span class=\"line\">       \t\t \t\t\tthis.<span class=\"variable\">$emit</span>(<span class=\"string\">'open'</span>);</span><br><span class=\"line\">        \t\t\t&#125;</span><br><span class=\"line\">        \t\t&#125;</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong></p>\n<ul>\n<li>1、这里子组件的template数据引用外部的&lt;template&gt;&lt;/template&gt;中的HTML代码。</li>\n<li>2、与传值思路相同，传递方法也需要在子组件实例中使用v-on即@来绑定方法，方法别名@open，方法的值是show是在父组件中定义的方法名。</li>\n<li>3、与传值思路相同，传值使用了props来接受传递的参数，那么传方法提供了$emit()元素</li>\n</ul>\n<p><strong>综合</strong><br>上面讲的父组件向子组件传递方法，那么既然是方法就肯定能传递方法参数。我们只需要在父组件方法中指定值名称即可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@子组件接收的方法别名=<span class=\"string\">\"父组件中的方法(父组件中的参数值或data)\"</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1 @open=<span class=\"string\">\"show(fatosonval)\"</span>&gt;&lt;/com1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">    \t&lt;div&gt;</span><br><span class=\"line\">    \t\t&lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class=\"line\">    \t\t&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"myclick\"</span> value=<span class=\"string\">\"子组件按钮，点击触发父组件方法\"</span>/&gt;</span><br><span class=\"line\">    \t&lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">        \tfatosonval: &#123;</span><br><span class=\"line\">        \t\tid: <span class=\"string\">'1'</span>,</span><br><span class=\"line\">        \t\tname: <span class=\"string\">'Loonycoder'</span></span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">        \tshow(data)&#123;</span><br><span class=\"line\">        \t\tconsole.log(data);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">        \tcom1: &#123;</span><br><span class=\"line\">        \t\ttemplate: <span class=\"string\">'#tmp'</span>,</span><br><span class=\"line\">        \t\tmethods: &#123;</span><br><span class=\"line\">        \t\t\t<span class=\"function\"><span class=\"title\">myclick</span></span>()&#123;</span><br><span class=\"line\">       \t\t \t\t\tthis.<span class=\"variable\">$emit</span>(<span class=\"string\">'open'</span>);</span><br><span class=\"line\">        \t\t\t&#125;</span><br><span class=\"line\">        \t\t&#125;</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>子组件</strong>给父组件传值<br>即实现在父组件中调用子组件中的方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1 @open=<span class=\"string\">\"show\"</span>&gt;&lt;/com1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">    \t&lt;div&gt;</span><br><span class=\"line\">    \t\t&lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class=\"line\">    \t\t&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"myclick\"</span> value=<span class=\"string\">\"子组件按钮，点击触发父组件方法\"</span>/&gt;</span><br><span class=\"line\">    \t&lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">        \tfatosonval: null</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">        \tshow(data)&#123;</span><br><span class=\"line\">        \t\tconsole.log(data);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">        \tcom1: &#123;</span><br><span class=\"line\">        \t\ttemplate: <span class=\"string\">'#tmp'</span>,</span><br><span class=\"line\">        \t\t<span class=\"function\"><span class=\"title\">data</span></span>()&#123;</span><br><span class=\"line\">        \t\t\t<span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">        \t\t\t\tsonval: &#123; name: <span class=\"string\">'Loonycoder'</span>, age: 24 &#125;</span><br><span class=\"line\">        \t\t\t&#125;</span><br><span class=\"line\">        \t\t&#125;,</span><br><span class=\"line\">        \t\tmethods: &#123;</span><br><span class=\"line\">        \t\t\t<span class=\"function\"><span class=\"title\">myclick</span></span>()&#123;</span><br><span class=\"line\">       \t\t \t\t\tthis.<span class=\"variable\">$emit</span>(<span class=\"string\">'open'</span>, this.sonval);</span><br><span class=\"line\">        \t\t\t&#125;</span><br><span class=\"line\">        \t\t&#125;</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>之前我们实现父组件向子组件传值的时候，需要在@open()中指定父组件中的data，而子组件给父组件传值的时候就不需要再指定了，而是直接在调用子组件中的open（这是父组件方法的别名），将子组件的值写进$emit(‘方法别名’, data参数)中即可。</p>\n<h5 id=\"Vue获取DOM元素和组件\"><a href=\"#Vue获取DOM元素和组件\" class=\"headerlink\" title=\"Vue获取DOM元素和组件\"></a>Vue获取DOM元素和组件</h5><p>首先我们需要明白的就是Vue并不提倡我们操作DOM元素，Vue的宗旨就是让我们只关心业务逻辑。<br>那么通常我们需要获取一个如&lt;h2&gt;&lt;/h2&gt;中的值，采用原生JS通常需要先为tag标签定义一个id属性，然后通过JS代码document.getElementById(‘id’).innterText来获取到&lt;h2&gt;中的文本数据，而Vue也实现了操作原生DOM的功能：</p>\n<ul>\n<li>在需要获取的HTML标签中指定<code>ref</code>属性，其值可自定义。</li>\n<li>在Vue实例中，使用<code>this.$refs.指定的值</code>来获取DOM对象，进行操作。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 ref=<span class=\"string\">\"h2\"</span>&gt;这是h2的文本数据&lt;/h2&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(this.<span class=\"variable\">$refs</span>.h2.innerText);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>通过$refs还能轻易获取子组件中的data和methods数据</strong><br>首先需要为子组件引用实例定义ref=”com1”属性，然后在Vue实例中通过this.$refs.com1即可获取子组件中的所有对象，即还能获取到子组件中的data和methods<br>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1 ref=<span class=\"string\">\"com1\"</span>&gt;&lt;/com1&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"show\"</span> value=<span class=\"string\">\"获取元素\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;h2 ref=<span class=\"string\">\"h2\"</span>&gt;这是父组件&lt;/h2&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">show</span></span>()&#123;</span><br><span class=\"line\">                // console.log(this.<span class=\"variable\">$refs</span>.h2.innerText);</span><br><span class=\"line\">                // console.log(this.<span class=\"variable\">$refs</span>.com1); //获取子组件中的所有实例对象</span><br><span class=\"line\">                // console.log(this.<span class=\"variable\">$refs</span>.com1.sonval); //获取子组件中定义的data值</span><br><span class=\"line\">                console.log(this.<span class=\"variable\">$refs</span>.com1.sonshow()); //调用子组件中定义的方法</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">            com1: &#123;</span><br><span class=\"line\">                template: <span class=\"string\">'#tmp'</span>,</span><br><span class=\"line\">                <span class=\"function\"><span class=\"title\">data</span></span>() &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">                        sonval: &#123; name: <span class=\"string\">'Loonycoder'</span>, age: 24 &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                methods: &#123;</span><br><span class=\"line\">                    <span class=\"function\"><span class=\"title\">sonshow</span></span>() &#123;</span><br><span class=\"line\">                        console.log(<span class=\"string\">'子组件的方法'</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Vue创建组件\"><a href=\"#Vue创建组件\" class=\"headerlink\" title=\"Vue创建组件\"></a>Vue创建组件</h4><h5 id=\"什么是组件\"><a href=\"#什么是组件\" class=\"headerlink\" title=\"什么是组件\"></a>什么是组件</h5><p>什么是组件？组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样地方功能，就可以去调用对应的组件即可。<br>组件化和模块化的区别：</p>\n<ul>\n<li>模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的只能单一；</li>\n<li>组件化：是从UI界面的角度进行划分的；前端的组件化，方便了UI组件的重用；</li>\n</ul>\n<h5 id=\"定义Vue组件\"><a href=\"#定义Vue组件\" class=\"headerlink\" title=\"定义Vue组件\"></a>定义Vue组件</h5><p><strong>方式一</strong><br>1、使用Vue.extend来创建全局的Vue组件<br>2、通过template属性来指定组件要展示的HTML结构<br>3、通过Vue.component()定义全局组件<br>4、在HTML指定位置通过Tag标签的形式应用你的组件，组件的名称即是tag标签的名称</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t&lt;!-- 组件的名称即为对应tag标签的名称 --&gt;</span><br><span class=\"line\">\t&lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\t// 创建组件</span><br><span class=\"line\">\tvar com1 = Vue.extend(&#123;</span><br><span class=\"line\">\t\ttemplate: <span class=\"string\">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 使用Vue.component(<span class=\"string\">'组件的名称'</span>, 创建出来的组件模板对象)，定义全局组件</span><br><span class=\"line\">\tVue.component(<span class=\"string\">'mycom1'</span>, com1);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong></p>\n<ul>\n<li>用Vue.component()定义组件名称的时候有两种命名方式：1、驼峰命名：Xxx；2、xxx。注意，使用驼峰命名时，tag标签不能使用驼峰名称，应将相应的大写字母替换为-加小写字母，例如：Vue.component(‘myCom’, com1)，那么tag标签应为： &lt;my-com&gt; &lt;/my-com&gt;</li>\n</ul>\n<p><strong>方式二</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 组件的名称即为对应tag标签的名称 --&gt;</span><br><span class=\"line\">&lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 使用Vue.component(<span class=\"string\">'组件的名称'</span>, 创建出来的组件模板对象)，定义全局组件</span><br><span class=\"line\">\tVue.component(<span class=\"string\">'mycom1'</span>, Vue.extend(&#123;</span><br><span class=\"line\">\t\ttemplate: <span class=\"string\">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class=\"line\">\t&#125;));</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>方式二就像是方式一的简化版，但是注意：<br>在template中定义的内容只能存在一个根节点元素，即上面例子中template中不能出现和 &lt;h3&gt;平级的标签。<br>比如下面这种写法就是<strong>错误的</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'mycom1'</span>, Vue.extend(&#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;'</span></span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>解决办法就是，外层嵌套一个根标签就行了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">'mycom1'</span>, Vue.extend(&#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'&lt;div&gt;&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p><strong>方式三</strong><br>1、JavaScript中仍使用Vue.component来定义全局组件，和方式二相似，但是里面不再是template: ‘HTML结构’了，而是引用一个外部标签的id值，即template:’id’。<br>2、在被Vue实例控制的app外面，定义&lt;template id=”id”&gt;你的HTML结构&lt;/template&gt;<br>这种方式的好处就是是就组件代码都是定义在HTML结构中的，有智能代码提示；而JavaScript中定义组件仅是写一个引用。<br>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t&lt;!-- 页面引用 --&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">\t&lt;!-- 比如仅存在一个根节点元素 --&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">\t\t&lt;h1&gt;&lt;/h1&gt;&gt;</span><br><span class=\"line\">\t\t&lt;h2&gt;&lt;/h2&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//JavaScript部分</span><br><span class=\"line\">Vue.component(<span class=\"string\">'mycom'</span>, &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#tmp'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>定义私</strong>有组件<br>除了上面讲到的定义全局组件，我们也可以定义私有组件，使用components: {}函数。<br>如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;tem&gt;&lt;/tem&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">    &lt;h3&gt;这是私有组件&lt;/h3&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">        tem: &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'#tmp'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"组件元素\"><a href=\"#组件元素\" class=\"headerlink\" title=\"组件元素\"></a>组件元素</h5><p><strong>组件的</strong>data<br>在组件中，同样可以有自己的data数据，但是用法和Vue实例中的data用法有所不同：<br>1、组件中的data必须是一个方法，即</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: <span class=\"function\"><span class=\"title\">function</span></span>()&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>2、组件中的data方法必须返回一个Object对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">return</span> object</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">Vue.component(<span class=\"string\">'mycom1'</span>, Vue.extend(&#123;</span><br><span class=\"line\">\tdata: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">\t\t\tmsg: <span class=\"string\">'这是组件的data'</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'&lt;h3&gt;这是使用Vue.extend 创建的组件-- &#123;&#123;msg&#125;&#125;&lt;/h3&gt;'</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>组件的</strong>切换<br>在遇到登录注册表单时，通常我们需要对两个按钮进行切换实现显示不同的表单，那么Vue中的组件切换正符合了这个功能要求。</p>\n<p><strong>方式一</strong></p>\n<p>可以使用Vue提供的v-if和v-else来实现两个组件间的切换，但是，仅支持切换两个组件</p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#\"</span> @click.prevent=<span class=\"string\">\"flag=true\"</span>&gt;登录&lt;/a&gt;</span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#\"</span> @click.prevent=<span class=\"string\">\"flag=false\"</span>&gt;注册&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;login v-if=<span class=\"string\">\"flag\"</span>&gt;&lt;/login&gt;</span><br><span class=\"line\">    &lt;register v-else=<span class=\"string\">\"flag\"</span>&gt;&lt;/register&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"login\"</span>&gt;</span><br><span class=\"line\">    &lt;h3&gt;这是登录表单&lt;/h3&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"register\"</span>&gt;</span><br><span class=\"line\">\t&lt;h3&gt;这是注册表单&lt;/h3&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">// 创建登录组件</span><br><span class=\"line\">Vue.component(<span class=\"string\">'login'</span>, &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#login'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建注册组件</span><br><span class=\"line\">Vue.component(<span class=\"string\">'register'</span>, &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#register'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">    \tflag: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>定义flag参数，当flag=true就显示组件，当flar=false就隐藏组件</p>\n<p><strong>方式二</strong></p>\n<p>Vue提供了component来展示对应名称的组件。其中component是一个占位符，:is属性，可以用来指定要展示的组件名称</p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#\"</span> @click.prevent=<span class=\"string\">\"comName='login'\"</span>&gt;登录&lt;/a&gt;</span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#\"</span> @click.prevent=<span class=\"string\">\"comName='register'\"</span>&gt;注册&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;component :is=<span class=\"string\">\"comName\"</span>&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"login\"</span>&gt;</span><br><span class=\"line\">    &lt;h3&gt;这是登录表单&lt;/h3&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template id=<span class=\"string\">\"register\"</span>&gt;</span><br><span class=\"line\">\t&lt;h3&gt;这是注册表单&lt;/h3&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">// 创建登录组件</span><br><span class=\"line\">Vue.component(<span class=\"string\">'login'</span>, &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#login'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建注册组件</span><br><span class=\"line\">Vue.component(<span class=\"string\">'register'</span>, &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#register'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">    \tcomName: <span class=\"string\">'login'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>即使用Vue提供的component，它能够实现自动对组件进行展示和隐藏，通过:is=’组件名称’。</p>\n<h5 id=\"父子组件间传值\"><a href=\"#父子组件间传值\" class=\"headerlink\" title=\"父子组件间传值\"></a>父子组件间传值</h5><p><strong>父组件</strong>给子组件传值</p>\n<p>父组件给子组件传值，即实现在子组件中调用父组件中的methods或是获取父组件中的data.</p>\n<p><strong>传参数</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1&gt;&lt;/com1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">        \tmsg: <span class=\"string\">'这是父组件data值'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">        \t<span class=\"function\"><span class=\"title\">show</span></span>()&#123;</span><br><span class=\"line\">        \t\tconsole.log(<span class=\"string\">\"这是父组件的show方法\"</span>);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">        \tcom1: &#123;</span><br><span class=\"line\">        \t\ttemplate: <span class=\"string\">'&lt;h2&gt;这是子组件&lt;/h2&gt;'</span></span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>如上，当我们直接在子组件中引用父组件data中定义的msg数据，将上面的修改为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com1: &#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'&lt;h2&gt;这是子组件--&#123;&#123;msg&#125;&#125;&lt;/h2&gt;'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么就会报错。所以就证实了默认在子组件中不能访问父组件中的data或methods。<br>为了解决子组件获取父组件数据，Vue提供了以下方式获取：</p>\n<ul>\n<li>1、父组件在引用子组件的时候，通过属性绑定的方式v-bind:，把需要传递给子组件的数据以属性绑定的形式传递到子组件内部，供子组件使用。</li>\n<li>2、在子组件中，通过props: []获取到父组件传递过来的数据；这样就完成了父组件向子组件传值</li>\n</ul>\n<p><strong>实例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1 :fatoson=<span class=\"string\">\"msg\"</span>&gt;&lt;/com1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">        \tmsg: <span class=\"string\">'这是父组件data值'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">        \tcom1: &#123;</span><br><span class=\"line\">        \t\ttemplate: <span class=\"string\">'&lt;h2&gt;这是子组件--&#123;&#123;fatoson&#125;&#125;&lt;/h2&gt;'</span>,</span><br><span class=\"line\">        \t\tprops: [<span class=\"string\">'fatoson'</span>]</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，我们在子组件实例中使用了v-bind绑定了一个参数fatoson，其值是：msg即在父组件data中定义的值；那么就相当于父组件的一个data数据被Vue绑定到了子组件实例中，且父组件data值的别名是fatoson，那么在子组件中通过props: []属性就能获取到这个别名，然后就实现了父组件向子组件传值。需要注意以下：</p>\n<ul>\n<li>1、我们可以将为子组件绑定的参数名称是父组件值的别名。即此时msg相当于fatoson。</li>\n<li>2、注意命名中若是驼峰命名，在HTML中必须用-替换。</li>\n<li>3、注意props是Vue为父组将向子组件传值提供的一个参数，且他是唯一的数组类型的。</li>\n<li>4、注意子组件通过props获取到的父组件的值是只读的，即不能修改。</li>\n</ul>\n<p><strong>传方法</strong><br>上面讲了父组件给子组件传递普通的参数，下面我们将了解到父组件怎样给子组件传递方法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1 @open=<span class=\"string\">\"show\"</span>&gt;&lt;/com1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">    \t&lt;div&gt;</span><br><span class=\"line\">    \t\t&lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class=\"line\">    \t\t&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"myclick\"</span> value=<span class=\"string\">\"子组件按钮，点击触发父组件方法\"</span>/&gt;</span><br><span class=\"line\">    \t&lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">        \tmsg: <span class=\"string\">'这是父组件data值'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">        \t<span class=\"function\"><span class=\"title\">show</span></span>()&#123;</span><br><span class=\"line\">        \t\tconsole.log(<span class=\"string\">\"这是父组件的show方法\"</span>);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">        \tcom1: &#123;</span><br><span class=\"line\">        \t\ttemplate: <span class=\"string\">'#tmp'</span>,</span><br><span class=\"line\">        \t\tprops: [<span class=\"string\">'fatoson'</span>],</span><br><span class=\"line\">        \t\tmethods: &#123;</span><br><span class=\"line\">        \t\t\t<span class=\"function\"><span class=\"title\">myclick</span></span>()&#123;</span><br><span class=\"line\">       \t\t \t\t\tthis.<span class=\"variable\">$emit</span>(<span class=\"string\">'open'</span>);</span><br><span class=\"line\">        \t\t\t&#125;</span><br><span class=\"line\">        \t\t&#125;</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong></p>\n<ul>\n<li>1、这里子组件的template数据引用外部的&lt;template&gt;&lt;/template&gt;中的HTML代码。</li>\n<li>2、与传值思路相同，传递方法也需要在子组件实例中使用v-on即@来绑定方法，方法别名@open，方法的值是show是在父组件中定义的方法名。</li>\n<li>3、与传值思路相同，传值使用了props来接受传递的参数，那么传方法提供了$emit()元素</li>\n</ul>\n<p><strong>综合</strong><br>上面讲的父组件向子组件传递方法，那么既然是方法就肯定能传递方法参数。我们只需要在父组件方法中指定值名称即可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@子组件接收的方法别名=<span class=\"string\">\"父组件中的方法(父组件中的参数值或data)\"</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1 @open=<span class=\"string\">\"show(fatosonval)\"</span>&gt;&lt;/com1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">    \t&lt;div&gt;</span><br><span class=\"line\">    \t\t&lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class=\"line\">    \t\t&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"myclick\"</span> value=<span class=\"string\">\"子组件按钮，点击触发父组件方法\"</span>/&gt;</span><br><span class=\"line\">    \t&lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">        \tfatosonval: &#123;</span><br><span class=\"line\">        \t\tid: <span class=\"string\">'1'</span>,</span><br><span class=\"line\">        \t\tname: <span class=\"string\">'Loonycoder'</span></span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">        \tshow(data)&#123;</span><br><span class=\"line\">        \t\tconsole.log(data);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">        \tcom1: &#123;</span><br><span class=\"line\">        \t\ttemplate: <span class=\"string\">'#tmp'</span>,</span><br><span class=\"line\">        \t\tmethods: &#123;</span><br><span class=\"line\">        \t\t\t<span class=\"function\"><span class=\"title\">myclick</span></span>()&#123;</span><br><span class=\"line\">       \t\t \t\t\tthis.<span class=\"variable\">$emit</span>(<span class=\"string\">'open'</span>);</span><br><span class=\"line\">        \t\t\t&#125;</span><br><span class=\"line\">        \t\t&#125;</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>子组件</strong>给父组件传值<br>即实现在父组件中调用子组件中的方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1 @open=<span class=\"string\">\"show\"</span>&gt;&lt;/com1&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">    \t&lt;div&gt;</span><br><span class=\"line\">    \t\t&lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class=\"line\">    \t\t&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"myclick\"</span> value=<span class=\"string\">\"子组件按钮，点击触发父组件方法\"</span>/&gt;</span><br><span class=\"line\">    \t&lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">        \tfatosonval: null</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">        \tshow(data)&#123;</span><br><span class=\"line\">        \t\tconsole.log(data);</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">        \tcom1: &#123;</span><br><span class=\"line\">        \t\ttemplate: <span class=\"string\">'#tmp'</span>,</span><br><span class=\"line\">        \t\t<span class=\"function\"><span class=\"title\">data</span></span>()&#123;</span><br><span class=\"line\">        \t\t\t<span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">        \t\t\t\tsonval: &#123; name: <span class=\"string\">'Loonycoder'</span>, age: 24 &#125;</span><br><span class=\"line\">        \t\t\t&#125;</span><br><span class=\"line\">        \t\t&#125;,</span><br><span class=\"line\">        \t\tmethods: &#123;</span><br><span class=\"line\">        \t\t\t<span class=\"function\"><span class=\"title\">myclick</span></span>()&#123;</span><br><span class=\"line\">       \t\t \t\t\tthis.<span class=\"variable\">$emit</span>(<span class=\"string\">'open'</span>, this.sonval);</span><br><span class=\"line\">        \t\t\t&#125;</span><br><span class=\"line\">        \t\t&#125;</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>之前我们实现父组件向子组件传值的时候，需要在@open()中指定父组件中的data，而子组件给父组件传值的时候就不需要再指定了，而是直接在调用子组件中的open（这是父组件方法的别名），将子组件的值写进$emit(‘方法别名’, data参数)中即可。</p>\n<h5 id=\"Vue获取DOM元素和组件\"><a href=\"#Vue获取DOM元素和组件\" class=\"headerlink\" title=\"Vue获取DOM元素和组件\"></a>Vue获取DOM元素和组件</h5><p>首先我们需要明白的就是Vue并不提倡我们操作DOM元素，Vue的宗旨就是让我们只关心业务逻辑。<br>那么通常我们需要获取一个如&lt;h2&gt;&lt;/h2&gt;中的值，采用原生JS通常需要先为tag标签定义一个id属性，然后通过JS代码document.getElementById(‘id’).innterText来获取到&lt;h2&gt;中的文本数据，而Vue也实现了操作原生DOM的功能：</p>\n<ul>\n<li>在需要获取的HTML标签中指定<code>ref</code>属性，其值可自定义。</li>\n<li>在Vue实例中，使用<code>this.$refs.指定的值</code>来获取DOM对象，进行操作。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 ref=<span class=\"string\">\"h2\"</span>&gt;这是h2的文本数据&lt;/h2&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(this.<span class=\"variable\">$refs</span>.h2.innerText);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>通过$refs还能轻易获取子组件中的data和methods数据</strong><br>首先需要为子组件引用实例定义ref=”com1”属性，然后在Vue实例中通过this.$refs.com1即可获取子组件中的所有对象，即还能获取到子组件中的data和methods<br>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;!-- 父组件实例 --&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">        &lt;!-- 子组件实例 --&gt;</span><br><span class=\"line\">        &lt;com1 ref=<span class=\"string\">\"com1\"</span>&gt;&lt;/com1&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"show\"</span> value=<span class=\"string\">\"获取元素\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;h2 ref=<span class=\"string\">\"h2\"</span>&gt;这是父组件&lt;/h2&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">show</span></span>()&#123;</span><br><span class=\"line\">                // console.log(this.<span class=\"variable\">$refs</span>.h2.innerText);</span><br><span class=\"line\">                // console.log(this.<span class=\"variable\">$refs</span>.com1); //获取子组件中的所有实例对象</span><br><span class=\"line\">                // console.log(this.<span class=\"variable\">$refs</span>.com1.sonval); //获取子组件中定义的data值</span><br><span class=\"line\">                console.log(this.<span class=\"variable\">$refs</span>.com1.sonshow()); //调用子组件中定义的方法</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // 子组件</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">            com1: &#123;</span><br><span class=\"line\">                template: <span class=\"string\">'#tmp'</span>,</span><br><span class=\"line\">                <span class=\"function\"><span class=\"title\">data</span></span>() &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">                        sonval: &#123; name: <span class=\"string\">'Loonycoder'</span>, age: 24 &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                methods: &#123;</span><br><span class=\"line\">                    <span class=\"function\"><span class=\"title\">sonshow</span></span>() &#123;</span><br><span class=\"line\">                        console.log(<span class=\"string\">'子组件的方法'</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n"},{"title":"容器化部署神器——Docker","date":"2018-11-13T16:00:00.000Z","_content":"\n![docker](/images/docker1.jpg)\n**Docker**是一种容器技术，它的存在就是为了解决容器技术本身的复杂性。Docker容器拥有很高的性能，同时同一台宿主机中可以运行更多的容器，是用户尽可能的充分利用系统资源。\n\n#### 概念\n> 1.什么是虚拟化？\n在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及储存等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，是用户可以比原来的组态更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制。\n\n- 全虚拟化架构\n虚拟机的监视器（hypervisor）是类似于用户的应用程序运行在主机的OS之上，如VMware的workstation，这种虚拟化产品提供了虚拟的硬件。\n\n> 2.容器技术\n容器和管理程序虚拟化（hypervisor virtualization, HV）不同，管理程序虚拟化通过中间层将一台或多台独立的机器虚拟运行在物理硬件之上，而**容器**是直接运行在操作系统内核之上的用户空间。因此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行在同一台宿主机上。\n\n**限制**\n1、由于“客居”与操作系统，容器只能运行与底层主机相同或相似的操作系统，比如在Ubuntu服务中运行CentOS，但无法运行Windows。\n2、相对于彻底隔离的管理程序虚拟化，容器被认为是不安全的。\n最新的容器技术引入了OpenVZ、Solaris Zones以及Linux容器（LXC）。使用这些新技术，容器不再仅仅是一个单纯的运行环境。在自己的权限类内，容器更像一个完整宿主机。和传统虚拟化及半虚拟化想比，容器不需要模拟层（emulation layer）和管理层（hypervisor layer），而使用操作系统的系统调用接口。\n\n#### Docker特点\n1、上手快\n2、用户可以很容易的把自己的程序Docker化。Docker依赖于“写时复制”（copy-on-write）模型，开箱即用。\n快速高效的开发声明周期\n\n#### Docker组件\n\n##### Docker客户端和服务器\nDocker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。\n![docker](/images/docker2.png)\n\n##### Docker镜像\n**镜像** 是构建Docker的基石。用户及基于镜像来运行自己的容器。镜像也是Docker声明周期中的“构建”部分。奖项是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。\n\n##### Registry 注册中心\nDocker用Registry来保存用户构建的镜像。Registry分为共有和私有两种。Docker公司运营公共的Registry叫做Docker Hub。\n\n##### Docker容器\nDocker可以帮助你构建和部署容器，你只需要把你的程序打包放进容器即可。容器是基于镜像启动的，容器找那个可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中构建和打包阶段，而容器则是启动或执行阶段。容器基于镜像启动。\n![docker](/images/docker3.png)\n\n#### Docker的安装与启动\n前提：本例中使用了CentOS7作为服务器\n通过以下命令在线在CentOS7中安装Docker：\n```bash\nyum install docker\n```\n![docker](/images/docker4.png)\n\n**查看Docker版本**\n```bash\n[root@localhost ~]# docker -v\nDocker version 1.13.1, build 8633870/1.13.1\n```\n\n#### 启动与停止Docker\nsystemctl命令是系统服务管理器指令，它是service和chkconfig两个命令组合。\n\n1.启动Docker\n```bash\nsystemctl start docker\n```\n2.停止Docker\n```bash\nsystemctl stop docker\n```\n3.重启Docker\n```bash\nsystemctl restart docker\n```\n4.查看Docker状态\n```bash\nsystemctl status docker\n```\n5.开机启动Docker\n```bash\nsystemctl enable docker\n```\n6.查看Docker概要信息\n```bash\ndocker info\n```\n7.查看Docker帮助文档\n```bash\ndocker -help\n```\n\n#### Docker镜像操作\nDocker镜像由文件系统堆叠而成（是一种文件的储存形式）。最低端是一个文件引导系统，即bootfs。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要一些文件的，而这些文件就可以被称为Docker镜像。\n![docker](/images/docker5.png)\n\n1、列出镜像\n```bash\n[root@localhost ~]# docker images\n```\n![docker](/images/docker6.png)\n\n- REPOSITORY: 镜像所在的仓库名称\n- TAG： 镜像标签\n- IMAGE ID：镜像ID\n- CREATED：镜像的创建日期（不是获取该镜像的日期）\n- SIZE：镜像大小\n\n这些镜像都储存在Docker宿主机的/var/lib/docker目录下。\n\n2、搜索镜像\n```bash\n[root@localhost ~]# docker search 镜像名称\n```\n![docker](/images/docker7.png)\n\n3、从Docker Hub拉取镜像\n去Docker Hub官网查找所需的Docker镜像：<https://hub.docker.com/explore/> ，然后通过以下命令在线pull：\n```bash\n[root@localhost ~]# docker pull 镜像名称\n[root@localhost ~]# docker pull 镜像名称:版本\n```\n因为官方提供的Docker镜像加速服务很慢，我们可以配置ustc的镜像。输入以下命令配置ustc镜像：\n```bash\n[root@localhost ~]# vi /etc/docker/daemon.json\n```\n没有就创建，向其中写入：\n```bash\n{\n        \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]\n}\n```\n重启Docker服务：\n```bash\n[root@localhost ~]# systemctl restart docker\n```\n\n4、删除镜像\n删除指定镜像\n```bash\n[root@localhost ~]# docker rmi $IMAGE_ID  #这个$IMAGE_ID数值可以根据`docker images`命令查看\n```\n删除所有镜像\n```bash\n[root@localhost ~]# docker rmi `docker images -q`\n```\n\n#### Docker容器操作\n1.查看正在运行的容器\n```bash\n[root@localhost ~]# docker ps\n```\n2.查看所有的容器（启动过的历史容器）\n```bash\n[root@localhost ~]# docker ps -a\n```\n3.查看最后一次运行的容器\n```bash\n[root@localhost ~]# docker ps -|\n```\n4.查看停止的容器\n```bash\n[root@localhost ~]# docker ps -f status=exited\n```\n5.删除容器\n删除指定容器：\n```bash\n[root@localhost ~]# docker rm $CONTAINER_ID/NAME\n```\n删除所有容器：\n```bash\n[root@localhost ~]# docker rm `docker ps -a -q`\n```\n\n#### 创建和启动容器\n\n**创建容器常用的参数说明**\n1.创建容器命令：docker run\n2.-i: 表示运行容器\n3.-t: 表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。\n4.—name: 为创建的容器命名\n5.-v: 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录或文件映射。注意：最好做目录映射，在宿主机上修改，然后共享到容器上。\n6.-d: 在run后面加上-d参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。\n7.-p： 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射。\n\n##### 交互式容器\n创建一个交互式容器并取名为mycentos5:\n```bash\nroot@localhost ~]# docker run -it --name=mycentos5 centos:7 /bin/bash\n[root@53f33e279914 /]#\n```\n此时我们可以新建一个连接，通过docker ps命令看到刚才创建的容器正在启动中：\n![docker](/images/docker8.png)\n通过exit命令可以退出当前容器：\n```bash\n[root@53f33e279914 /]# exit\nexit\n[root@localhost ~]#\n```\n此时再通过docker ps命令查看刚才启动的容器也停止了。\n\n##### 守护式容器\n输入以下命令创建一个名字为mycentos6的容器：\n```bash\n[root@localhost ~]# docker run -di --name=mycentos6 centos:7\n```\n创建后这个容器会在后台运行，而不是直接进入到这个容器中。可以通过docker ps命令查看。\n登录守护式容器：\n```bash\n[root@localhost ~]# docker exec -it mycentos6 /bin/bash\n```\n可以通过exit命令退出，但是容器不会停止。\n\n##### 停止和启动容器\n停止正在运行的容器\n```bash\n[root@localhost ~]# docker stop 容器名称\n```\n启动已运行过的容器：\n```bash\n[root@localhost ~]# docker start 容器名称\n```\n\n#### 其他操作\n\n##### 文件拷贝\n将文件拷贝到容器内可以用如下命令：\n```bash\n[root@localhost ~]# docker cp 需要拷贝的文件或目录 容器名称:容器目录\n```\n将文件从容器中拷贝出来\n```bash\n[root@localhost ~]# docker cp 容器名称:容器目录 需要拷贝的文件或目录\n```\n##### 目录挂载\n在创建容器的时候，将宿主机的目录和容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而影响容器。格式为：\n```bash\n[root@localhost ~]# docker run -di -v 宿主机目录:容器目录\n```\n##### 查看容器\n```bash\n[root@localhost ~]# docker inspect mycentos5\n```\n\n**部署应用**\n\n#### MySQL部署\n1.拉取MySQL镜像\n```bash\n[root@localhost ~]# docker pull mysql:5.7\n```\n2.创建MySQL容器\n```bash\n[root@localhost ~]# docker run -di --name docker_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.7\n```\n如上我们创建一个名称为docker_mysql的MySQL5.7版本的守护式容器，且配置MySQL登录密码是root。\n- -p 代表端口映射，格式为 宿主机映射端口:容器运行端口\n- -e 代表添加环境变量， MYSQL_ROOT_PASSWORD是root用户的登录密码\n3.进入MySQL容器，登录MySQL\n```bash\n[root@localhost ~]# docker exec -it docker_mysql /bin/bash\n```\n登录MySQL\n```bash\nmysql -u root -p\n```\n4.远程连接MySQL\n![docker](/images/docker9.png)\n\n#### Tomcat部署\n1.拉取Tomcat-8 && JDK-8 镜像\n```bash\n[root@localhost ~]# docker pull tomcat:8-jre8\n```\n2.部署Web应用\n为了更好的演示Docker部署Tomcat的使用方式，我们可以先将需要部署的web项目发送到服务器的某个路径下，我这里在/root/目录下创建了/root/site/目录作为项目的根目录，在其中创建index.html文件并写入：\n```bash\n<html>\n<head>\n<title>Hello</title>\n</head>\n<body>\n<h2>Hello Docker-Tomcat!</h2>\n</body>\n</html>\n```\n3.创建Tomcat容器\n```bash\n[root@localhost ~]# docker run -di --name=docker_tomcat -p 9000:8080 -v /root/site/:/usr/local/tomcat/webapps/ROOT --privileged=true tomcat:8-jre8\n```\n以上就创建一个Tomcat容器，其容器名称Wiedocker_tomcat，-di表示是一个守护式容器；-p 9000:8080表示此容器端口映射为9000->8080，即对外的端口是9000，映射到容器里Tomcat服务器的端口8080，--privileged是以root权限运行。\n![docker](/images/docker10.png)\n通过命令看到，当我们启动了容器，其中的Tomcat服务器也自动启动了。当然对于部署Nginx或MySQL的Docker容器，当启动容器时都会启动对应的服务。\n**注意**\n上面我们指定了宿主机的/root/site/目录映射到docker_tomcat容器的/usr/local/tomcat/webapps/ROOT目录，为什么是这个目录呢？\nDocker虚拟化，它会在内部虚拟一个操作系统，是在其宿主机内核上的一层空间，所有有一定的目录结构，我们可以通过docker exec -it docker_tomcat /bin/bash命令进入到docker_tomcat容器内部，通过ls命令查看目录会发现其Tomcat服务器确实安装在docker_tomcat容器的/usr/local/tomcat目录下。\n最后，我们在浏览器上访问：<http://192.168.148.132:9000/>，即发现页面展示了我们刚才在/root/site/目录下创建的index.html网页：\n![docker](/images/docker11.png)\n所以，如果你想要修改容器中Tomcat的端口号，直接进入容器的/usr/local/tomcat/conf/server.xml自改即可。\n\n#### Nginx部署\n1.拉取Nginx镜像\n```bash\ndocker pull nginx\n```\n2.创建Nginx容器\n```bash\ndocker run -di --name=docker_nginx -p 80:80 nginx\n```\n测试\n![docker](/images/docker12.png)\n在浏览器上访问：<http://192.168.148.132/>可以进入到Nginx的欢迎页。\n\n#### 其他\n以上我们介绍了MySQL、Tomcat、Nginx容器的创建，对于其他的服务，如Redis等操作基本相同，不再阐述。\n\n#### 备份与迁移\n1.容器保存为镜像\n可以通过以下命令将我们已创建（配置好的）容器打包为镜像，这样我们以后就能用该镜像再次创建新的容器了：\n```bash\ndocker commit docker_tomcat my_tomcat\n```\ndocker_tomcat是容器名称；my_tomcat是新的镜像名称。\n2.镜像备份\n通过以下命令可以将镜像打包为tar文件：\n```bash\ndocker save -o my_tomcat.tar my_tomcat\n```\n-o输出到的文件\n3.镜像恢复与备份\n当我们删除了docker_tomcat镜像后，可以通过以下命令将刚才打包备份的.tar镜像文件恢复成一个Docker镜像：\n```bash\ndocker load -i my_tomcat.tar\n```\n-i输入的文件。\n\n","source":"_posts/docker.md","raw":"---\ntitle: 容器化部署神器——Docker\ncategories:\n    - Docker\n    \ndate: 2018-11-14\ntags:\n\t- DevOps\n    - 服务器\n---\n\n![docker](/images/docker1.jpg)\n**Docker**是一种容器技术，它的存在就是为了解决容器技术本身的复杂性。Docker容器拥有很高的性能，同时同一台宿主机中可以运行更多的容器，是用户尽可能的充分利用系统资源。\n\n#### 概念\n> 1.什么是虚拟化？\n在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及储存等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，是用户可以比原来的组态更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制。\n\n- 全虚拟化架构\n虚拟机的监视器（hypervisor）是类似于用户的应用程序运行在主机的OS之上，如VMware的workstation，这种虚拟化产品提供了虚拟的硬件。\n\n> 2.容器技术\n容器和管理程序虚拟化（hypervisor virtualization, HV）不同，管理程序虚拟化通过中间层将一台或多台独立的机器虚拟运行在物理硬件之上，而**容器**是直接运行在操作系统内核之上的用户空间。因此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行在同一台宿主机上。\n\n**限制**\n1、由于“客居”与操作系统，容器只能运行与底层主机相同或相似的操作系统，比如在Ubuntu服务中运行CentOS，但无法运行Windows。\n2、相对于彻底隔离的管理程序虚拟化，容器被认为是不安全的。\n最新的容器技术引入了OpenVZ、Solaris Zones以及Linux容器（LXC）。使用这些新技术，容器不再仅仅是一个单纯的运行环境。在自己的权限类内，容器更像一个完整宿主机。和传统虚拟化及半虚拟化想比，容器不需要模拟层（emulation layer）和管理层（hypervisor layer），而使用操作系统的系统调用接口。\n\n#### Docker特点\n1、上手快\n2、用户可以很容易的把自己的程序Docker化。Docker依赖于“写时复制”（copy-on-write）模型，开箱即用。\n快速高效的开发声明周期\n\n#### Docker组件\n\n##### Docker客户端和服务器\nDocker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。\n![docker](/images/docker2.png)\n\n##### Docker镜像\n**镜像** 是构建Docker的基石。用户及基于镜像来运行自己的容器。镜像也是Docker声明周期中的“构建”部分。奖项是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。\n\n##### Registry 注册中心\nDocker用Registry来保存用户构建的镜像。Registry分为共有和私有两种。Docker公司运营公共的Registry叫做Docker Hub。\n\n##### Docker容器\nDocker可以帮助你构建和部署容器，你只需要把你的程序打包放进容器即可。容器是基于镜像启动的，容器找那个可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中构建和打包阶段，而容器则是启动或执行阶段。容器基于镜像启动。\n![docker](/images/docker3.png)\n\n#### Docker的安装与启动\n前提：本例中使用了CentOS7作为服务器\n通过以下命令在线在CentOS7中安装Docker：\n```bash\nyum install docker\n```\n![docker](/images/docker4.png)\n\n**查看Docker版本**\n```bash\n[root@localhost ~]# docker -v\nDocker version 1.13.1, build 8633870/1.13.1\n```\n\n#### 启动与停止Docker\nsystemctl命令是系统服务管理器指令，它是service和chkconfig两个命令组合。\n\n1.启动Docker\n```bash\nsystemctl start docker\n```\n2.停止Docker\n```bash\nsystemctl stop docker\n```\n3.重启Docker\n```bash\nsystemctl restart docker\n```\n4.查看Docker状态\n```bash\nsystemctl status docker\n```\n5.开机启动Docker\n```bash\nsystemctl enable docker\n```\n6.查看Docker概要信息\n```bash\ndocker info\n```\n7.查看Docker帮助文档\n```bash\ndocker -help\n```\n\n#### Docker镜像操作\nDocker镜像由文件系统堆叠而成（是一种文件的储存形式）。最低端是一个文件引导系统，即bootfs。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要一些文件的，而这些文件就可以被称为Docker镜像。\n![docker](/images/docker5.png)\n\n1、列出镜像\n```bash\n[root@localhost ~]# docker images\n```\n![docker](/images/docker6.png)\n\n- REPOSITORY: 镜像所在的仓库名称\n- TAG： 镜像标签\n- IMAGE ID：镜像ID\n- CREATED：镜像的创建日期（不是获取该镜像的日期）\n- SIZE：镜像大小\n\n这些镜像都储存在Docker宿主机的/var/lib/docker目录下。\n\n2、搜索镜像\n```bash\n[root@localhost ~]# docker search 镜像名称\n```\n![docker](/images/docker7.png)\n\n3、从Docker Hub拉取镜像\n去Docker Hub官网查找所需的Docker镜像：<https://hub.docker.com/explore/> ，然后通过以下命令在线pull：\n```bash\n[root@localhost ~]# docker pull 镜像名称\n[root@localhost ~]# docker pull 镜像名称:版本\n```\n因为官方提供的Docker镜像加速服务很慢，我们可以配置ustc的镜像。输入以下命令配置ustc镜像：\n```bash\n[root@localhost ~]# vi /etc/docker/daemon.json\n```\n没有就创建，向其中写入：\n```bash\n{\n        \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]\n}\n```\n重启Docker服务：\n```bash\n[root@localhost ~]# systemctl restart docker\n```\n\n4、删除镜像\n删除指定镜像\n```bash\n[root@localhost ~]# docker rmi $IMAGE_ID  #这个$IMAGE_ID数值可以根据`docker images`命令查看\n```\n删除所有镜像\n```bash\n[root@localhost ~]# docker rmi `docker images -q`\n```\n\n#### Docker容器操作\n1.查看正在运行的容器\n```bash\n[root@localhost ~]# docker ps\n```\n2.查看所有的容器（启动过的历史容器）\n```bash\n[root@localhost ~]# docker ps -a\n```\n3.查看最后一次运行的容器\n```bash\n[root@localhost ~]# docker ps -|\n```\n4.查看停止的容器\n```bash\n[root@localhost ~]# docker ps -f status=exited\n```\n5.删除容器\n删除指定容器：\n```bash\n[root@localhost ~]# docker rm $CONTAINER_ID/NAME\n```\n删除所有容器：\n```bash\n[root@localhost ~]# docker rm `docker ps -a -q`\n```\n\n#### 创建和启动容器\n\n**创建容器常用的参数说明**\n1.创建容器命令：docker run\n2.-i: 表示运行容器\n3.-t: 表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。\n4.—name: 为创建的容器命名\n5.-v: 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录或文件映射。注意：最好做目录映射，在宿主机上修改，然后共享到容器上。\n6.-d: 在run后面加上-d参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。\n7.-p： 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射。\n\n##### 交互式容器\n创建一个交互式容器并取名为mycentos5:\n```bash\nroot@localhost ~]# docker run -it --name=mycentos5 centos:7 /bin/bash\n[root@53f33e279914 /]#\n```\n此时我们可以新建一个连接，通过docker ps命令看到刚才创建的容器正在启动中：\n![docker](/images/docker8.png)\n通过exit命令可以退出当前容器：\n```bash\n[root@53f33e279914 /]# exit\nexit\n[root@localhost ~]#\n```\n此时再通过docker ps命令查看刚才启动的容器也停止了。\n\n##### 守护式容器\n输入以下命令创建一个名字为mycentos6的容器：\n```bash\n[root@localhost ~]# docker run -di --name=mycentos6 centos:7\n```\n创建后这个容器会在后台运行，而不是直接进入到这个容器中。可以通过docker ps命令查看。\n登录守护式容器：\n```bash\n[root@localhost ~]# docker exec -it mycentos6 /bin/bash\n```\n可以通过exit命令退出，但是容器不会停止。\n\n##### 停止和启动容器\n停止正在运行的容器\n```bash\n[root@localhost ~]# docker stop 容器名称\n```\n启动已运行过的容器：\n```bash\n[root@localhost ~]# docker start 容器名称\n```\n\n#### 其他操作\n\n##### 文件拷贝\n将文件拷贝到容器内可以用如下命令：\n```bash\n[root@localhost ~]# docker cp 需要拷贝的文件或目录 容器名称:容器目录\n```\n将文件从容器中拷贝出来\n```bash\n[root@localhost ~]# docker cp 容器名称:容器目录 需要拷贝的文件或目录\n```\n##### 目录挂载\n在创建容器的时候，将宿主机的目录和容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而影响容器。格式为：\n```bash\n[root@localhost ~]# docker run -di -v 宿主机目录:容器目录\n```\n##### 查看容器\n```bash\n[root@localhost ~]# docker inspect mycentos5\n```\n\n**部署应用**\n\n#### MySQL部署\n1.拉取MySQL镜像\n```bash\n[root@localhost ~]# docker pull mysql:5.7\n```\n2.创建MySQL容器\n```bash\n[root@localhost ~]# docker run -di --name docker_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.7\n```\n如上我们创建一个名称为docker_mysql的MySQL5.7版本的守护式容器，且配置MySQL登录密码是root。\n- -p 代表端口映射，格式为 宿主机映射端口:容器运行端口\n- -e 代表添加环境变量， MYSQL_ROOT_PASSWORD是root用户的登录密码\n3.进入MySQL容器，登录MySQL\n```bash\n[root@localhost ~]# docker exec -it docker_mysql /bin/bash\n```\n登录MySQL\n```bash\nmysql -u root -p\n```\n4.远程连接MySQL\n![docker](/images/docker9.png)\n\n#### Tomcat部署\n1.拉取Tomcat-8 && JDK-8 镜像\n```bash\n[root@localhost ~]# docker pull tomcat:8-jre8\n```\n2.部署Web应用\n为了更好的演示Docker部署Tomcat的使用方式，我们可以先将需要部署的web项目发送到服务器的某个路径下，我这里在/root/目录下创建了/root/site/目录作为项目的根目录，在其中创建index.html文件并写入：\n```bash\n<html>\n<head>\n<title>Hello</title>\n</head>\n<body>\n<h2>Hello Docker-Tomcat!</h2>\n</body>\n</html>\n```\n3.创建Tomcat容器\n```bash\n[root@localhost ~]# docker run -di --name=docker_tomcat -p 9000:8080 -v /root/site/:/usr/local/tomcat/webapps/ROOT --privileged=true tomcat:8-jre8\n```\n以上就创建一个Tomcat容器，其容器名称Wiedocker_tomcat，-di表示是一个守护式容器；-p 9000:8080表示此容器端口映射为9000->8080，即对外的端口是9000，映射到容器里Tomcat服务器的端口8080，--privileged是以root权限运行。\n![docker](/images/docker10.png)\n通过命令看到，当我们启动了容器，其中的Tomcat服务器也自动启动了。当然对于部署Nginx或MySQL的Docker容器，当启动容器时都会启动对应的服务。\n**注意**\n上面我们指定了宿主机的/root/site/目录映射到docker_tomcat容器的/usr/local/tomcat/webapps/ROOT目录，为什么是这个目录呢？\nDocker虚拟化，它会在内部虚拟一个操作系统，是在其宿主机内核上的一层空间，所有有一定的目录结构，我们可以通过docker exec -it docker_tomcat /bin/bash命令进入到docker_tomcat容器内部，通过ls命令查看目录会发现其Tomcat服务器确实安装在docker_tomcat容器的/usr/local/tomcat目录下。\n最后，我们在浏览器上访问：<http://192.168.148.132:9000/>，即发现页面展示了我们刚才在/root/site/目录下创建的index.html网页：\n![docker](/images/docker11.png)\n所以，如果你想要修改容器中Tomcat的端口号，直接进入容器的/usr/local/tomcat/conf/server.xml自改即可。\n\n#### Nginx部署\n1.拉取Nginx镜像\n```bash\ndocker pull nginx\n```\n2.创建Nginx容器\n```bash\ndocker run -di --name=docker_nginx -p 80:80 nginx\n```\n测试\n![docker](/images/docker12.png)\n在浏览器上访问：<http://192.168.148.132/>可以进入到Nginx的欢迎页。\n\n#### 其他\n以上我们介绍了MySQL、Tomcat、Nginx容器的创建，对于其他的服务，如Redis等操作基本相同，不再阐述。\n\n#### 备份与迁移\n1.容器保存为镜像\n可以通过以下命令将我们已创建（配置好的）容器打包为镜像，这样我们以后就能用该镜像再次创建新的容器了：\n```bash\ndocker commit docker_tomcat my_tomcat\n```\ndocker_tomcat是容器名称；my_tomcat是新的镜像名称。\n2.镜像备份\n通过以下命令可以将镜像打包为tar文件：\n```bash\ndocker save -o my_tomcat.tar my_tomcat\n```\n-o输出到的文件\n3.镜像恢复与备份\n当我们删除了docker_tomcat镜像后，可以通过以下命令将刚才打包备份的.tar镜像文件恢复成一个Docker镜像：\n```bash\ndocker load -i my_tomcat.tar\n```\n-i输入的文件。\n\n","slug":"docker","published":1,"updated":"2020-02-21T15:32:12.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiz0000uv9s6eatecnns","content":"<p><img src=\"/images/docker1.jpg\" alt=\"docker\"><br><strong>Docker</strong>是一种容器技术，它的存在就是为了解决容器技术本身的复杂性。Docker容器拥有很高的性能，同时同一台宿主机中可以运行更多的容器，是用户尽可能的充分利用系统资源。</p>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><blockquote>\n<p>1.什么是虚拟化？<br>在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及储存等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，是用户可以比原来的组态更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制。</p>\n</blockquote>\n<ul>\n<li>全虚拟化架构<br>虚拟机的监视器（hypervisor）是类似于用户的应用程序运行在主机的OS之上，如VMware的workstation，这种虚拟化产品提供了虚拟的硬件。</li>\n</ul>\n<blockquote>\n<p>2.容器技术<br>容器和管理程序虚拟化（hypervisor virtualization, HV）不同，管理程序虚拟化通过中间层将一台或多台独立的机器虚拟运行在物理硬件之上，而<strong>容器</strong>是直接运行在操作系统内核之上的用户空间。因此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行在同一台宿主机上。</p>\n</blockquote>\n<p><strong>限制</strong><br>1、由于“客居”与操作系统，容器只能运行与底层主机相同或相似的操作系统，比如在Ubuntu服务中运行CentOS，但无法运行Windows。<br>2、相对于彻底隔离的管理程序虚拟化，容器被认为是不安全的。<br>最新的容器技术引入了OpenVZ、Solaris Zones以及Linux容器（LXC）。使用这些新技术，容器不再仅仅是一个单纯的运行环境。在自己的权限类内，容器更像一个完整宿主机。和传统虚拟化及半虚拟化想比，容器不需要模拟层（emulation layer）和管理层（hypervisor layer），而使用操作系统的系统调用接口。</p>\n<h4 id=\"Docker特点\"><a href=\"#Docker特点\" class=\"headerlink\" title=\"Docker特点\"></a>Docker特点</h4><p>1、上手快<br>2、用户可以很容易的把自己的程序Docker化。Docker依赖于“写时复制”（copy-on-write）模型，开箱即用。<br>快速高效的开发声明周期</p>\n<h4 id=\"Docker组件\"><a href=\"#Docker组件\" class=\"headerlink\" title=\"Docker组件\"></a>Docker组件</h4><h5 id=\"Docker客户端和服务器\"><a href=\"#Docker客户端和服务器\" class=\"headerlink\" title=\"Docker客户端和服务器\"></a>Docker客户端和服务器</h5><p>Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。<br><img src=\"/images/docker2.png\" alt=\"docker\"></p>\n<h5 id=\"Docker镜像\"><a href=\"#Docker镜像\" class=\"headerlink\" title=\"Docker镜像\"></a>Docker镜像</h5><p><strong>镜像</strong> 是构建Docker的基石。用户及基于镜像来运行自己的容器。镜像也是Docker声明周期中的“构建”部分。奖项是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。</p>\n<h5 id=\"Registry-注册中心\"><a href=\"#Registry-注册中心\" class=\"headerlink\" title=\"Registry 注册中心\"></a>Registry 注册中心</h5><p>Docker用Registry来保存用户构建的镜像。Registry分为共有和私有两种。Docker公司运营公共的Registry叫做Docker Hub。</p>\n<h5 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h5><p>Docker可以帮助你构建和部署容器，你只需要把你的程序打包放进容器即可。容器是基于镜像启动的，容器找那个可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中构建和打包阶段，而容器则是启动或执行阶段。容器基于镜像启动。<br><img src=\"/images/docker3.png\" alt=\"docker\"></p>\n<h4 id=\"Docker的安装与启动\"><a href=\"#Docker的安装与启动\" class=\"headerlink\" title=\"Docker的安装与启动\"></a>Docker的安装与启动</h4><p>前提：本例中使用了CentOS7作为服务器<br>通过以下命令在线在CentOS7中安装Docker：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install docker</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/docker4.png\" alt=\"docker\"></p>\n<p><strong>查看Docker版本</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker -v</span></span><br><span class=\"line\">Docker version 1.13.1, build 8633870/1.13.1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"启动与停止Docker\"><a href=\"#启动与停止Docker\" class=\"headerlink\" title=\"启动与停止Docker\"></a>启动与停止Docker</h4><p>systemctl命令是系统服务管理器指令，它是service和chkconfig两个命令组合。</p>\n<p>1.启动Docker</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure>\n<p>2.停止Docker</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop docker</span><br></pre></td></tr></table></figure>\n<p>3.重启Docker</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure>\n<p>4.查看Docker状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status docker</span><br></pre></td></tr></table></figure>\n<p>5.开机启动Docker</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure>\n<p>6.查看Docker概要信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n<p>7.查看Docker帮助文档</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Docker镜像操作\"><a href=\"#Docker镜像操作\" class=\"headerlink\" title=\"Docker镜像操作\"></a>Docker镜像操作</h4><p>Docker镜像由文件系统堆叠而成（是一种文件的储存形式）。最低端是一个文件引导系统，即bootfs。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要一些文件的，而这些文件就可以被称为Docker镜像。<br><img src=\"/images/docker5.png\" alt=\"docker\"></p>\n<p>1、列出镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker images</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/docker6.png\" alt=\"docker\"></p>\n<ul>\n<li>REPOSITORY: 镜像所在的仓库名称</li>\n<li>TAG： 镜像标签</li>\n<li>IMAGE ID：镜像ID</li>\n<li>CREATED：镜像的创建日期（不是获取该镜像的日期）</li>\n<li>SIZE：镜像大小</li>\n</ul>\n<p>这些镜像都储存在Docker宿主机的/var/lib/docker目录下。</p>\n<p>2、搜索镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker search 镜像名称</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/docker7.png\" alt=\"docker\"></p>\n<p>3、从Docker Hub拉取镜像<br>去Docker Hub官网查找所需的Docker镜像：<a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/explore/</a> ，然后通过以下命令在线pull：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker pull 镜像名称</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker pull 镜像名称:版本</span></span><br></pre></td></tr></table></figure>\n<p>因为官方提供的Docker镜像加速服务很慢，我们可以配置ustc的镜像。输入以下命令配置ustc镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># vi /etc/docker/daemon.json</span></span><br></pre></td></tr></table></figure>\n<p>没有就创建，向其中写入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"string\">\"registry-mirrors\"</span>: [<span class=\"string\">\"https://docker.mirrors.ustc.edu.cn\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启Docker服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># systemctl restart docker</span></span><br></pre></td></tr></table></figure>\n\n<p>4、删除镜像<br>删除指定镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker rmi $IMAGE_ID  #这个$IMAGE_ID数值可以根据`docker images`命令查看</span></span><br></pre></td></tr></table></figure>\n<p>删除所有镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker rmi `docker images -q`</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Docker容器操作\"><a href=\"#Docker容器操作\" class=\"headerlink\" title=\"Docker容器操作\"></a>Docker容器操作</h4><p>1.查看正在运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker ps</span></span><br></pre></td></tr></table></figure>\n<p>2.查看所有的容器（启动过的历史容器）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker ps -a</span></span><br></pre></td></tr></table></figure>\n<p>3.查看最后一次运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker ps -|</span></span><br></pre></td></tr></table></figure>\n<p>4.查看停止的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker ps -f status=exited</span></span><br></pre></td></tr></table></figure>\n<p>5.删除容器<br>删除指定容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker rm $CONTAINER_ID/NAME</span></span><br></pre></td></tr></table></figure>\n<p>删除所有容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker rm `docker ps -a -q`</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建和启动容器\"><a href=\"#创建和启动容器\" class=\"headerlink\" title=\"创建和启动容器\"></a>创建和启动容器</h4><p><strong>创建容器常用的参数说明</strong><br>1.创建容器命令：docker run<br>2.-i: 表示运行容器<br>3.-t: 表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。<br>4.—name: 为创建的容器命名<br>5.-v: 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录或文件映射。注意：最好做目录映射，在宿主机上修改，然后共享到容器上。<br>6.-d: 在run后面加上-d参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。<br>7.-p： 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射。</p>\n<h5 id=\"交互式容器\"><a href=\"#交互式容器\" class=\"headerlink\" title=\"交互式容器\"></a>交互式容器</h5><p>创建一个交互式容器并取名为mycentos5:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@localhost ~]<span class=\"comment\"># docker run -it --name=mycentos5 centos:7 /bin/bash</span></span><br><span class=\"line\">[root@53f33e279914 /]<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n<p>此时我们可以新建一个连接，通过docker ps命令看到刚才创建的容器正在启动中：<br><img src=\"/images/docker8.png\" alt=\"docker\"><br>通过exit命令可以退出当前容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@53f33e279914 /]<span class=\"comment\"># exit</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n<p>此时再通过docker ps命令查看刚才启动的容器也停止了。</p>\n<h5 id=\"守护式容器\"><a href=\"#守护式容器\" class=\"headerlink\" title=\"守护式容器\"></a>守护式容器</h5><p>输入以下命令创建一个名字为mycentos6的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker run -di --name=mycentos6 centos:7</span></span><br></pre></td></tr></table></figure>\n<p>创建后这个容器会在后台运行，而不是直接进入到这个容器中。可以通过docker ps命令查看。<br>登录守护式容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker exec -it mycentos6 /bin/bash</span></span><br></pre></td></tr></table></figure>\n<p>可以通过exit命令退出，但是容器不会停止。</p>\n<h5 id=\"停止和启动容器\"><a href=\"#停止和启动容器\" class=\"headerlink\" title=\"停止和启动容器\"></a>停止和启动容器</h5><p>停止正在运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker stop 容器名称</span></span><br></pre></td></tr></table></figure>\n<p>启动已运行过的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker start 容器名称</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"其他操作\"><a href=\"#其他操作\" class=\"headerlink\" title=\"其他操作\"></a>其他操作</h4><h5 id=\"文件拷贝\"><a href=\"#文件拷贝\" class=\"headerlink\" title=\"文件拷贝\"></a>文件拷贝</h5><p>将文件拷贝到容器内可以用如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker cp 需要拷贝的文件或目录 容器名称:容器目录</span></span><br></pre></td></tr></table></figure>\n<p>将文件从容器中拷贝出来</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker cp 容器名称:容器目录 需要拷贝的文件或目录</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"目录挂载\"><a href=\"#目录挂载\" class=\"headerlink\" title=\"目录挂载\"></a>目录挂载</h5><p>在创建容器的时候，将宿主机的目录和容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而影响容器。格式为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker run -di -v 宿主机目录:容器目录</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"查看容器\"><a href=\"#查看容器\" class=\"headerlink\" title=\"查看容器\"></a>查看容器</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker inspect mycentos5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>部署应用</strong></p>\n<h4 id=\"MySQL部署\"><a href=\"#MySQL部署\" class=\"headerlink\" title=\"MySQL部署\"></a>MySQL部署</h4><p>1.拉取MySQL镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker pull mysql:5.7</span></span><br></pre></td></tr></table></figure>\n<p>2.创建MySQL容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker run -di --name docker_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.7</span></span><br></pre></td></tr></table></figure>\n<p>如上我们创建一个名称为docker_mysql的MySQL5.7版本的守护式容器，且配置MySQL登录密码是root。</p>\n<ul>\n<li>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</li>\n<li>-e 代表添加环境变量， MYSQL_ROOT_PASSWORD是root用户的登录密码</li>\n</ul>\n<p>3.进入MySQL容器，登录MySQL</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker exec -it docker_mysql /bin/bash</span></span><br></pre></td></tr></table></figure>\n<p>登录MySQL</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br></pre></td></tr></table></figure>\n<p>4.远程连接MySQL<br><img src=\"/images/docker9.png\" alt=\"docker\"></p>\n<h4 id=\"Tomcat部署\"><a href=\"#Tomcat部署\" class=\"headerlink\" title=\"Tomcat部署\"></a>Tomcat部署</h4><p>1.拉取Tomcat-8 &amp;&amp; JDK-8 镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker pull tomcat:8-jre8</span></span><br></pre></td></tr></table></figure>\n<p>2.部署Web应用<br>为了更好的演示Docker部署Tomcat的使用方式，我们可以先将需要部署的web项目发送到服务器的某个路径下，我这里在/root/目录下创建了/root/site/目录作为项目的根目录，在其中创建index.html文件并写入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h2&gt;Hello Docker-Tomcat!&lt;/h2&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>3.创建Tomcat容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker run -di --name=docker_tomcat -p 9000:8080 -v /root/site/:/usr/local/tomcat/webapps/ROOT --privileged=true tomcat:8-jre8</span></span><br></pre></td></tr></table></figure>\n<p>以上就创建一个Tomcat容器，其容器名称Wiedocker_tomcat，-di表示是一个守护式容器；-p 9000:8080表示此容器端口映射为9000-&gt;8080，即对外的端口是9000，映射到容器里Tomcat服务器的端口8080，–privileged是以root权限运行。<br><img src=\"/images/docker10.png\" alt=\"docker\"><br>通过命令看到，当我们启动了容器，其中的Tomcat服务器也自动启动了。当然对于部署Nginx或MySQL的Docker容器，当启动容器时都会启动对应的服务。<br><strong>注意</strong><br>上面我们指定了宿主机的/root/site/目录映射到docker_tomcat容器的/usr/local/tomcat/webapps/ROOT目录，为什么是这个目录呢？<br>Docker虚拟化，它会在内部虚拟一个操作系统，是在其宿主机内核上的一层空间，所有有一定的目录结构，我们可以通过docker exec -it docker_tomcat /bin/bash命令进入到docker_tomcat容器内部，通过ls命令查看目录会发现其Tomcat服务器确实安装在docker_tomcat容器的/usr/local/tomcat目录下。<br>最后，我们在浏览器上访问：<a href=\"http://192.168.148.132:9000/\" target=\"_blank\" rel=\"noopener\">http://192.168.148.132:9000/</a>，即发现页面展示了我们刚才在/root/site/目录下创建的index.html网页：<br><img src=\"/images/docker11.png\" alt=\"docker\"><br>所以，如果你想要修改容器中Tomcat的端口号，直接进入容器的/usr/local/tomcat/conf/server.xml自改即可。</p>\n<h4 id=\"Nginx部署\"><a href=\"#Nginx部署\" class=\"headerlink\" title=\"Nginx部署\"></a>Nginx部署</h4><p>1.拉取Nginx镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull nginx</span><br></pre></td></tr></table></figure>\n<p>2.创建Nginx容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -di --name=docker_nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>\n<p>测试<br><img src=\"/images/docker12.png\" alt=\"docker\"><br>在浏览器上访问：<a href=\"http://192.168.148.132/\" target=\"_blank\" rel=\"noopener\">http://192.168.148.132/</a>可以进入到Nginx的欢迎页。</p>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><p>以上我们介绍了MySQL、Tomcat、Nginx容器的创建，对于其他的服务，如Redis等操作基本相同，不再阐述。</p>\n<h4 id=\"备份与迁移\"><a href=\"#备份与迁移\" class=\"headerlink\" title=\"备份与迁移\"></a>备份与迁移</h4><p>1.容器保存为镜像<br>可以通过以下命令将我们已创建（配置好的）容器打包为镜像，这样我们以后就能用该镜像再次创建新的容器了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit docker_tomcat my_tomcat</span><br></pre></td></tr></table></figure>\n<p>docker_tomcat是容器名称；my_tomcat是新的镜像名称。<br>2.镜像备份<br>通过以下命令可以将镜像打包为tar文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save -o my_tomcat.tar my_tomcat</span><br></pre></td></tr></table></figure>\n<p>-o输出到的文件<br>3.镜像恢复与备份<br>当我们删除了docker_tomcat镜像后，可以通过以下命令将刚才打包备份的.tar镜像文件恢复成一个Docker镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load -i my_tomcat.tar</span><br></pre></td></tr></table></figure>\n<p>-i输入的文件。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/docker1.jpg\" alt=\"docker\"><br><strong>Docker</strong>是一种容器技术，它的存在就是为了解决容器技术本身的复杂性。Docker容器拥有很高的性能，同时同一台宿主机中可以运行更多的容器，是用户尽可能的充分利用系统资源。</p>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><blockquote>\n<p>1.什么是虚拟化？<br>在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及储存等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，是用户可以比原来的组态更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制。</p>\n</blockquote>\n<ul>\n<li>全虚拟化架构<br>虚拟机的监视器（hypervisor）是类似于用户的应用程序运行在主机的OS之上，如VMware的workstation，这种虚拟化产品提供了虚拟的硬件。</li>\n</ul>\n<blockquote>\n<p>2.容器技术<br>容器和管理程序虚拟化（hypervisor virtualization, HV）不同，管理程序虚拟化通过中间层将一台或多台独立的机器虚拟运行在物理硬件之上，而<strong>容器</strong>是直接运行在操作系统内核之上的用户空间。因此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行在同一台宿主机上。</p>\n</blockquote>\n<p><strong>限制</strong><br>1、由于“客居”与操作系统，容器只能运行与底层主机相同或相似的操作系统，比如在Ubuntu服务中运行CentOS，但无法运行Windows。<br>2、相对于彻底隔离的管理程序虚拟化，容器被认为是不安全的。<br>最新的容器技术引入了OpenVZ、Solaris Zones以及Linux容器（LXC）。使用这些新技术，容器不再仅仅是一个单纯的运行环境。在自己的权限类内，容器更像一个完整宿主机。和传统虚拟化及半虚拟化想比，容器不需要模拟层（emulation layer）和管理层（hypervisor layer），而使用操作系统的系统调用接口。</p>\n<h4 id=\"Docker特点\"><a href=\"#Docker特点\" class=\"headerlink\" title=\"Docker特点\"></a>Docker特点</h4><p>1、上手快<br>2、用户可以很容易的把自己的程序Docker化。Docker依赖于“写时复制”（copy-on-write）模型，开箱即用。<br>快速高效的开发声明周期</p>\n<h4 id=\"Docker组件\"><a href=\"#Docker组件\" class=\"headerlink\" title=\"Docker组件\"></a>Docker组件</h4><h5 id=\"Docker客户端和服务器\"><a href=\"#Docker客户端和服务器\" class=\"headerlink\" title=\"Docker客户端和服务器\"></a>Docker客户端和服务器</h5><p>Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。<br><img src=\"/images/docker2.png\" alt=\"docker\"></p>\n<h5 id=\"Docker镜像\"><a href=\"#Docker镜像\" class=\"headerlink\" title=\"Docker镜像\"></a>Docker镜像</h5><p><strong>镜像</strong> 是构建Docker的基石。用户及基于镜像来运行自己的容器。镜像也是Docker声明周期中的“构建”部分。奖项是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。</p>\n<h5 id=\"Registry-注册中心\"><a href=\"#Registry-注册中心\" class=\"headerlink\" title=\"Registry 注册中心\"></a>Registry 注册中心</h5><p>Docker用Registry来保存用户构建的镜像。Registry分为共有和私有两种。Docker公司运营公共的Registry叫做Docker Hub。</p>\n<h5 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h5><p>Docker可以帮助你构建和部署容器，你只需要把你的程序打包放进容器即可。容器是基于镜像启动的，容器找那个可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中构建和打包阶段，而容器则是启动或执行阶段。容器基于镜像启动。<br><img src=\"/images/docker3.png\" alt=\"docker\"></p>\n<h4 id=\"Docker的安装与启动\"><a href=\"#Docker的安装与启动\" class=\"headerlink\" title=\"Docker的安装与启动\"></a>Docker的安装与启动</h4><p>前提：本例中使用了CentOS7作为服务器<br>通过以下命令在线在CentOS7中安装Docker：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install docker</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/docker4.png\" alt=\"docker\"></p>\n<p><strong>查看Docker版本</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker -v</span></span><br><span class=\"line\">Docker version 1.13.1, build 8633870/1.13.1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"启动与停止Docker\"><a href=\"#启动与停止Docker\" class=\"headerlink\" title=\"启动与停止Docker\"></a>启动与停止Docker</h4><p>systemctl命令是系统服务管理器指令，它是service和chkconfig两个命令组合。</p>\n<p>1.启动Docker</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure>\n<p>2.停止Docker</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop docker</span><br></pre></td></tr></table></figure>\n<p>3.重启Docker</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure>\n<p>4.查看Docker状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status docker</span><br></pre></td></tr></table></figure>\n<p>5.开机启动Docker</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure>\n<p>6.查看Docker概要信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n<p>7.查看Docker帮助文档</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Docker镜像操作\"><a href=\"#Docker镜像操作\" class=\"headerlink\" title=\"Docker镜像操作\"></a>Docker镜像操作</h4><p>Docker镜像由文件系统堆叠而成（是一种文件的储存形式）。最低端是一个文件引导系统，即bootfs。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要一些文件的，而这些文件就可以被称为Docker镜像。<br><img src=\"/images/docker5.png\" alt=\"docker\"></p>\n<p>1、列出镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker images</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/docker6.png\" alt=\"docker\"></p>\n<ul>\n<li>REPOSITORY: 镜像所在的仓库名称</li>\n<li>TAG： 镜像标签</li>\n<li>IMAGE ID：镜像ID</li>\n<li>CREATED：镜像的创建日期（不是获取该镜像的日期）</li>\n<li>SIZE：镜像大小</li>\n</ul>\n<p>这些镜像都储存在Docker宿主机的/var/lib/docker目录下。</p>\n<p>2、搜索镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker search 镜像名称</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/docker7.png\" alt=\"docker\"></p>\n<p>3、从Docker Hub拉取镜像<br>去Docker Hub官网查找所需的Docker镜像：<a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/explore/</a> ，然后通过以下命令在线pull：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker pull 镜像名称</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker pull 镜像名称:版本</span></span><br></pre></td></tr></table></figure>\n<p>因为官方提供的Docker镜像加速服务很慢，我们可以配置ustc的镜像。输入以下命令配置ustc镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># vi /etc/docker/daemon.json</span></span><br></pre></td></tr></table></figure>\n<p>没有就创建，向其中写入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"string\">\"registry-mirrors\"</span>: [<span class=\"string\">\"https://docker.mirrors.ustc.edu.cn\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启Docker服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># systemctl restart docker</span></span><br></pre></td></tr></table></figure>\n\n<p>4、删除镜像<br>删除指定镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker rmi $IMAGE_ID  #这个$IMAGE_ID数值可以根据`docker images`命令查看</span></span><br></pre></td></tr></table></figure>\n<p>删除所有镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker rmi `docker images -q`</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Docker容器操作\"><a href=\"#Docker容器操作\" class=\"headerlink\" title=\"Docker容器操作\"></a>Docker容器操作</h4><p>1.查看正在运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker ps</span></span><br></pre></td></tr></table></figure>\n<p>2.查看所有的容器（启动过的历史容器）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker ps -a</span></span><br></pre></td></tr></table></figure>\n<p>3.查看最后一次运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker ps -|</span></span><br></pre></td></tr></table></figure>\n<p>4.查看停止的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker ps -f status=exited</span></span><br></pre></td></tr></table></figure>\n<p>5.删除容器<br>删除指定容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker rm $CONTAINER_ID/NAME</span></span><br></pre></td></tr></table></figure>\n<p>删除所有容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker rm `docker ps -a -q`</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建和启动容器\"><a href=\"#创建和启动容器\" class=\"headerlink\" title=\"创建和启动容器\"></a>创建和启动容器</h4><p><strong>创建容器常用的参数说明</strong><br>1.创建容器命令：docker run<br>2.-i: 表示运行容器<br>3.-t: 表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。<br>4.—name: 为创建的容器命名<br>5.-v: 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录或文件映射。注意：最好做目录映射，在宿主机上修改，然后共享到容器上。<br>6.-d: 在run后面加上-d参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。<br>7.-p： 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射。</p>\n<h5 id=\"交互式容器\"><a href=\"#交互式容器\" class=\"headerlink\" title=\"交互式容器\"></a>交互式容器</h5><p>创建一个交互式容器并取名为mycentos5:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@localhost ~]<span class=\"comment\"># docker run -it --name=mycentos5 centos:7 /bin/bash</span></span><br><span class=\"line\">[root@53f33e279914 /]<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n<p>此时我们可以新建一个连接，通过docker ps命令看到刚才创建的容器正在启动中：<br><img src=\"/images/docker8.png\" alt=\"docker\"><br>通过exit命令可以退出当前容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@53f33e279914 /]<span class=\"comment\"># exit</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n<p>此时再通过docker ps命令查看刚才启动的容器也停止了。</p>\n<h5 id=\"守护式容器\"><a href=\"#守护式容器\" class=\"headerlink\" title=\"守护式容器\"></a>守护式容器</h5><p>输入以下命令创建一个名字为mycentos6的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker run -di --name=mycentos6 centos:7</span></span><br></pre></td></tr></table></figure>\n<p>创建后这个容器会在后台运行，而不是直接进入到这个容器中。可以通过docker ps命令查看。<br>登录守护式容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker exec -it mycentos6 /bin/bash</span></span><br></pre></td></tr></table></figure>\n<p>可以通过exit命令退出，但是容器不会停止。</p>\n<h5 id=\"停止和启动容器\"><a href=\"#停止和启动容器\" class=\"headerlink\" title=\"停止和启动容器\"></a>停止和启动容器</h5><p>停止正在运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker stop 容器名称</span></span><br></pre></td></tr></table></figure>\n<p>启动已运行过的容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker start 容器名称</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"其他操作\"><a href=\"#其他操作\" class=\"headerlink\" title=\"其他操作\"></a>其他操作</h4><h5 id=\"文件拷贝\"><a href=\"#文件拷贝\" class=\"headerlink\" title=\"文件拷贝\"></a>文件拷贝</h5><p>将文件拷贝到容器内可以用如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker cp 需要拷贝的文件或目录 容器名称:容器目录</span></span><br></pre></td></tr></table></figure>\n<p>将文件从容器中拷贝出来</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker cp 容器名称:容器目录 需要拷贝的文件或目录</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"目录挂载\"><a href=\"#目录挂载\" class=\"headerlink\" title=\"目录挂载\"></a>目录挂载</h5><p>在创建容器的时候，将宿主机的目录和容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而影响容器。格式为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker run -di -v 宿主机目录:容器目录</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"查看容器\"><a href=\"#查看容器\" class=\"headerlink\" title=\"查看容器\"></a>查看容器</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker inspect mycentos5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>部署应用</strong></p>\n<h4 id=\"MySQL部署\"><a href=\"#MySQL部署\" class=\"headerlink\" title=\"MySQL部署\"></a>MySQL部署</h4><p>1.拉取MySQL镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker pull mysql:5.7</span></span><br></pre></td></tr></table></figure>\n<p>2.创建MySQL容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker run -di --name docker_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.7</span></span><br></pre></td></tr></table></figure>\n<p>如上我们创建一个名称为docker_mysql的MySQL5.7版本的守护式容器，且配置MySQL登录密码是root。</p>\n<ul>\n<li>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</li>\n<li>-e 代表添加环境变量， MYSQL_ROOT_PASSWORD是root用户的登录密码</li>\n</ul>\n<p>3.进入MySQL容器，登录MySQL</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker exec -it docker_mysql /bin/bash</span></span><br></pre></td></tr></table></figure>\n<p>登录MySQL</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br></pre></td></tr></table></figure>\n<p>4.远程连接MySQL<br><img src=\"/images/docker9.png\" alt=\"docker\"></p>\n<h4 id=\"Tomcat部署\"><a href=\"#Tomcat部署\" class=\"headerlink\" title=\"Tomcat部署\"></a>Tomcat部署</h4><p>1.拉取Tomcat-8 &amp;&amp; JDK-8 镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker pull tomcat:8-jre8</span></span><br></pre></td></tr></table></figure>\n<p>2.部署Web应用<br>为了更好的演示Docker部署Tomcat的使用方式，我们可以先将需要部署的web项目发送到服务器的某个路径下，我这里在/root/目录下创建了/root/site/目录作为项目的根目录，在其中创建index.html文件并写入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h2&gt;Hello Docker-Tomcat!&lt;/h2&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>3.创建Tomcat容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker run -di --name=docker_tomcat -p 9000:8080 -v /root/site/:/usr/local/tomcat/webapps/ROOT --privileged=true tomcat:8-jre8</span></span><br></pre></td></tr></table></figure>\n<p>以上就创建一个Tomcat容器，其容器名称Wiedocker_tomcat，-di表示是一个守护式容器；-p 9000:8080表示此容器端口映射为9000-&gt;8080，即对外的端口是9000，映射到容器里Tomcat服务器的端口8080，–privileged是以root权限运行。<br><img src=\"/images/docker10.png\" alt=\"docker\"><br>通过命令看到，当我们启动了容器，其中的Tomcat服务器也自动启动了。当然对于部署Nginx或MySQL的Docker容器，当启动容器时都会启动对应的服务。<br><strong>注意</strong><br>上面我们指定了宿主机的/root/site/目录映射到docker_tomcat容器的/usr/local/tomcat/webapps/ROOT目录，为什么是这个目录呢？<br>Docker虚拟化，它会在内部虚拟一个操作系统，是在其宿主机内核上的一层空间，所有有一定的目录结构，我们可以通过docker exec -it docker_tomcat /bin/bash命令进入到docker_tomcat容器内部，通过ls命令查看目录会发现其Tomcat服务器确实安装在docker_tomcat容器的/usr/local/tomcat目录下。<br>最后，我们在浏览器上访问：<a href=\"http://192.168.148.132:9000/\" target=\"_blank\" rel=\"noopener\">http://192.168.148.132:9000/</a>，即发现页面展示了我们刚才在/root/site/目录下创建的index.html网页：<br><img src=\"/images/docker11.png\" alt=\"docker\"><br>所以，如果你想要修改容器中Tomcat的端口号，直接进入容器的/usr/local/tomcat/conf/server.xml自改即可。</p>\n<h4 id=\"Nginx部署\"><a href=\"#Nginx部署\" class=\"headerlink\" title=\"Nginx部署\"></a>Nginx部署</h4><p>1.拉取Nginx镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull nginx</span><br></pre></td></tr></table></figure>\n<p>2.创建Nginx容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -di --name=docker_nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>\n<p>测试<br><img src=\"/images/docker12.png\" alt=\"docker\"><br>在浏览器上访问：<a href=\"http://192.168.148.132/\" target=\"_blank\" rel=\"noopener\">http://192.168.148.132/</a>可以进入到Nginx的欢迎页。</p>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><p>以上我们介绍了MySQL、Tomcat、Nginx容器的创建，对于其他的服务，如Redis等操作基本相同，不再阐述。</p>\n<h4 id=\"备份与迁移\"><a href=\"#备份与迁移\" class=\"headerlink\" title=\"备份与迁移\"></a>备份与迁移</h4><p>1.容器保存为镜像<br>可以通过以下命令将我们已创建（配置好的）容器打包为镜像，这样我们以后就能用该镜像再次创建新的容器了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit docker_tomcat my_tomcat</span><br></pre></td></tr></table></figure>\n<p>docker_tomcat是容器名称；my_tomcat是新的镜像名称。<br>2.镜像备份<br>通过以下命令可以将镜像打包为tar文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save -o my_tomcat.tar my_tomcat</span><br></pre></td></tr></table></figure>\n<p>-o输出到的文件<br>3.镜像恢复与备份<br>当我们删除了docker_tomcat镜像后，可以通过以下命令将刚才打包备份的.tar镜像文件恢复成一个Docker镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load -i my_tomcat.tar</span><br></pre></td></tr></table></figure>\n<p>-i输入的文件。</p>\n"},{"title":"Vue路由","date":"2018-09-14T16:00:00.000Z","_content":"\n### Vue路由\n\n#### 什么是Vue路由？\n\n- **后端路由：**即请求的URL地址都对应后端的接口，请求URL响应对应的服务器的资源。\n- **前端路由：**对于单页面程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以单页面程序中的页面跳转主要通过hash实现。\n\n#### 入门\n\n##### 导入类库\n首先需要导入vue-router组件类库：\n```bash\n<script type=\"text/javascript\" src=\"../lib/vue-router.js\"></script>\n```\n当导入类库后，window全局对象中就存在了一个路由的构造函数： VueRouter；就像导入Vue类库后存在一个Vue的构造函数一样，我们能够通过new VueRouter的方式实例化路由对象。\n如果你使用了new VueRouter({});构造函数来实例化了一个路由对象，你会发现浏览器路径中会出现#/路径，这个路径就是前面讲到的URL中的hash，他并不会向后端发送任何请求，而仅仅是作页面跳转，如果你#/后拼接了一个不存在的路径，自然也不会进行跳转，页面也不会发送任何请求。\n**实例：**\n![vue](/images/vue15.png)\n\n##### 基本使用\n上面我们讲到了使用new VueRouter({})的方式实例化一个路由对象，其中包含几个参数：\n```bash\n<!-- HTML -->\n<div id=\"app\">\n    \n    <!-- 给路由对象创建一个容器，包裹在父组件`app`内\n        相当于一个占位符，路由规则匹配到的组件内容就会展示到`<router-view></router-view>`中\n    -->\n    <router-view></router-view>\n</div>\n\n<!-- ===============分割线===================== -->\n\n<!-- JavaScript -->\n//创建login组件\nvar login = {\n    template: 'login组件'\n}\n\n//创建register组件\nvar register = {\n    template: 'register组件'\n}\n\n// Router实例\nvar 路由对象名称 = new VueRouter({\n    routes: [\n        { path: '/监听URL路径', component: login(组件名称) },\n        { path: '/监听URL路径', component: register(组件名称) }\n    ]\n});\n\n// Vue实例\nvar vm = new Vue({\n    el: 'app',\n    data: {},\n    methods: {},\n    router: 路由对象名称   \n});\n\n```\n\n**解释：**\n- 1、routes 表示这个路由对象中的 路由匹配规则，可以存在多个规则（注意：这里是routes而不是routers）\n- 2、属性一：path 表示监听哪个路由连接地址，即你想跳转都哪个路径上，应在这里注册实现跳转到对应的组件上\n- 3、属性二：component 表示如果路由匹配了前面的path，则展示component属性对应的那个组件\n- 4、component的属性值必须是一个组件的模板对象，不能是组件的引用名称\n- 5、经过1-4的步骤基本完成了路由对象的创建，下面要将这个路由对象注入到Vue实例中，使用router: 组件对象名称实现\n- 6、创建对应需要监听的组件，如上我们创建了login和register组件，与之前讲的不同是这里是一个var 组件名称其值是一个组件对象，和之前的Vue.component方式相似，但是这里仅仅是一个组件对象，并没有注册到Vue实例中，因为没有组件名称，所以不能在HTML中使用&lt;login&gt;&lt;/login&gt; ，注意这里的login是组件对象的名称。\n\n**步骤：**\n- 1、创建router实例new VueRouter，完成相关属性的定义；\n- 2、将这个路由对象注册到Vue实例中，使用router: 路由对象名称的方式；\n- 3、创建第一步中定义的组件名称对应的组件，直接在&lt;script&gt;中定义var组件对象名称即可，在template中定义具体的HTML视图，或是通过template: '#id'引用外部视图也行。\n- 4、在Vue实例控制域app中，创建&lt;router-view&gt;&lt;/router-view&gt;，相当于router容器，你想在页面上展示几个组件就应该在页面中创建几个容器。\n\n如上，我们可以写具体的跳转链接了：\n```bash\n<div id=\"app>\n    <a href=\"#/login\">登录</a>\n    <a href=\"#/register\">注册</a>\n</div>\n```\n\n如上，当我们点击登录或注册，Vue-router就会监听都对应的URL地址，然后在path规则中刚好匹配到规则login，那么就会跳转到对应的组件component: login的login组件中。\n可能你会疑惑了，为什么这里的href需要写为#/login而不是/login或login，你尝试一下就知道了，因为vue-router监听URL地址是基于hash的，不加#/就会找不到路径。\n如果你觉得每次都加#/麻烦的话，Vue-router页提供了一个Tag:&lt;router-link to=\"URL地址\"&gt;&lt;/router-link&gt;，其在浏览器中会被解析为&lt;a&gt;标签。\n\n**实例**\n```bash\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n    <div id=\"app\">\n        <h1>父组件</h1>\n\n        <a href=\"#/login\">登录</a>\n        <router-link to=\"register\">注册</router-link>\n\n        <router-view></router-view>\n    </div>\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\" src=\"../lib/vue-router.js\"></script>\n    <script type=\"text/javascript\">\n\n        var login = {\n            template: '<h2>登录组件</h2>'\n        }\n\n        var register = {\n            template: '<h2>注册组件</h2>'\n        }\n\n        var routerObj = new VueRouter({\n            routes: [\n                { path: '/login', component: login },\n                { path: '/register', component: register }\n            ]\n        });\n\n        var vm = new Vue({\n            el: '#app',\n            data: {},\n            methods: {},\n            router: routerObj\n        });\n    </script>\n</body>\n</html>\n```\n\n但是上面的实例中，我们发现默认进入的根路径中仅有一个父组件名称，一般我们的登录页面应该直接显示登录框，所以vue-router提供了重定向的动能{path: '', redirect: ''}，即在router: []中监听根路径，如果监听都访问的是根路径就重定向到登录URL就好了。\n\n```bash\nvar routerObj = new VueRouter({\n    routes: [\n        { path: '/', redirect: '/login' },\n        { path: '/login', component: login },\n        { path: '/register', component: register }\n    ]\n});\n```\n\n#### 路由参数传递\n在进行页面跳转，即路由的时候，我们可能需要在发送URL时传递一些参数，常见的就如<http://www.loonycoder.com/api?id=1&name='loonycoder'>这种格式。\n那么在URL中传递的参数，vue-router提供了一种获取方式：this.$route。\n那么什么时候能获取到传递的参数呢？ 回顾前面讲到的Vue声明周期函数，那么在自定义组件中自然也存在生命周期函数，所以最早操作组件data和methods中数据的阶段就是created这个声明周期函数的阶段。\n实例：\n![vue](/images/vue16.png)\n![vue](/images/vue17.png)\n\n上面打印的值中，我们能看到，我们再VueRouter中创建的path匹配规则，实际在HTML中会被渲染为相关的正则表达式，来实现路径的匹配。\n其次，我们还能发现，在URL中拼接的参数id在this.$route对象的query属性中，我们通过this.$route.query.id即可获得传递的id值：2。\n\n#### 路由嵌套\n路由嵌套，顾名思义即在父级路由内部存在子路由。例如：\n> 根路径：<http://www.loonycoder.com>\n> 父级路由地址：<http://www.loonycoder.com/api>\n> 子级路由地址：<http://www.loonycoder.com/api/login>\n\n**实例：**\n```bash\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n    <div id=\"app\">\n        <router-link to=\"/account\">Account</router-link>\n\n        <router-view></router-view>\n    </div>\n\n    <template id=\"tmp\">\n        <div>\n            <h1>这是Account组件</h1>\n\n            <router-link to=\"/account/login\">登录</router-link>\n            <router-link to=\"/account/register\">注册</router-link>\n\n            <router-view></router-view>\n        </div>\n    </template>\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\" src=\"../lib/vue-router.js\"></script>\n    <script type=\"text/javascript\">\n\n        var account = {\n            template: '#tmp'\n        }\n\n        var login = {\n            template: '<h2>登录组件</h2>',\n        }\n\n        var register = {\n            template: '<h2>注册组件</h2>'\n        }\n\n        var routerObj = new VueRouter({\n            routes: [\n                { \n                    path: '/account', \n                    component: account,\n                    children: [\n                        { path: 'login', component: login },\n                        { path: 'register', component: register }\n                    ]\n                },\n            ]\n        });\n\n        var vm = new Vue({\n            el: '#app',\n            data: {},\n            methods: {},\n            router: routerObj\n        });\n    </script>\n</body>\n</html>\n```\n\n如上，我们使用了routes: []中的另外一个属性：children，顾名思义就是表示这个父规则/account下存在一些子规则，且在URL中应该体现出来：\n![vue](/images/vue18.png)\n\n**注意：**\n在children中定义的子组件的path规则不能加/，即如上的，直接写path: login即可，这样请求account/login地址时，vue-router会找/account规则下的login规则，且不加/vue-router才会自动将login视为account下的子路径，并自动拼接account/，否则不会自动拼接，那么也无法完成路由的嵌套。\n\n#### 命名视图\n我们常见的后台开发页面，经常遇到上、左、中的布局方式；那么以前我们可能使用iframe实现页面间的跳转，但是现在我们学习的路由要比其更加的方便好用。\n**命名视图**的思想就是为每一个页面展示的视图都起一个名字，目的是为了为每个&lt;router-view&gt;&lt;/router-view&gt;容器刚好匹配一个指定的视图。使用方式：\n```bash\n<router-view></router-view>\n<router-view name=\"left\"></router-view>\n<router-view name=\"main\"></router-view>\n\nroutes: [\n    { \n        path: '/', components: {\n            'default': header\n            'left': left\n            'main': main\n        }\n    }\n]\n```\n\n**解释：**\n其中的path是根路径/，而使用components代替之前的component，目的就是可匹配其下的多个规则；default表示默认的视图组件是header这个组件，即会匹配到第一个&lt;router-view&gt;视图容器中；下面的两个组件会根据name名称需要对应的组件。\n实现上、左、中的布局：\n**思路：**\n1、我们需要创建三个组件，名称分别为：header、left、main；并且在app中创建三个&lt;router-view&gt;&lt;/router-view&gt;路由容器。\n2、采用**命名视图**的方式为每个视图都起一个名字：&lt;router-view name=\"left\"&gt;&lt;/router-view&gt; …\n3、注册路由实例。\n实例：\n![vue](/images/vue19.png)\n![vue](/images/vue20.png)\n","source":"_posts/Vue4.md","raw":"---\ntitle: Vue路由\ncategories:\n    - Web前端\ndate: 2018-09-15\ntags:\n\t- 前端框架\n\n---\n\n### Vue路由\n\n#### 什么是Vue路由？\n\n- **后端路由：**即请求的URL地址都对应后端的接口，请求URL响应对应的服务器的资源。\n- **前端路由：**对于单页面程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以单页面程序中的页面跳转主要通过hash实现。\n\n#### 入门\n\n##### 导入类库\n首先需要导入vue-router组件类库：\n```bash\n<script type=\"text/javascript\" src=\"../lib/vue-router.js\"></script>\n```\n当导入类库后，window全局对象中就存在了一个路由的构造函数： VueRouter；就像导入Vue类库后存在一个Vue的构造函数一样，我们能够通过new VueRouter的方式实例化路由对象。\n如果你使用了new VueRouter({});构造函数来实例化了一个路由对象，你会发现浏览器路径中会出现#/路径，这个路径就是前面讲到的URL中的hash，他并不会向后端发送任何请求，而仅仅是作页面跳转，如果你#/后拼接了一个不存在的路径，自然也不会进行跳转，页面也不会发送任何请求。\n**实例：**\n![vue](/images/vue15.png)\n\n##### 基本使用\n上面我们讲到了使用new VueRouter({})的方式实例化一个路由对象，其中包含几个参数：\n```bash\n<!-- HTML -->\n<div id=\"app\">\n    \n    <!-- 给路由对象创建一个容器，包裹在父组件`app`内\n        相当于一个占位符，路由规则匹配到的组件内容就会展示到`<router-view></router-view>`中\n    -->\n    <router-view></router-view>\n</div>\n\n<!-- ===============分割线===================== -->\n\n<!-- JavaScript -->\n//创建login组件\nvar login = {\n    template: 'login组件'\n}\n\n//创建register组件\nvar register = {\n    template: 'register组件'\n}\n\n// Router实例\nvar 路由对象名称 = new VueRouter({\n    routes: [\n        { path: '/监听URL路径', component: login(组件名称) },\n        { path: '/监听URL路径', component: register(组件名称) }\n    ]\n});\n\n// Vue实例\nvar vm = new Vue({\n    el: 'app',\n    data: {},\n    methods: {},\n    router: 路由对象名称   \n});\n\n```\n\n**解释：**\n- 1、routes 表示这个路由对象中的 路由匹配规则，可以存在多个规则（注意：这里是routes而不是routers）\n- 2、属性一：path 表示监听哪个路由连接地址，即你想跳转都哪个路径上，应在这里注册实现跳转到对应的组件上\n- 3、属性二：component 表示如果路由匹配了前面的path，则展示component属性对应的那个组件\n- 4、component的属性值必须是一个组件的模板对象，不能是组件的引用名称\n- 5、经过1-4的步骤基本完成了路由对象的创建，下面要将这个路由对象注入到Vue实例中，使用router: 组件对象名称实现\n- 6、创建对应需要监听的组件，如上我们创建了login和register组件，与之前讲的不同是这里是一个var 组件名称其值是一个组件对象，和之前的Vue.component方式相似，但是这里仅仅是一个组件对象，并没有注册到Vue实例中，因为没有组件名称，所以不能在HTML中使用&lt;login&gt;&lt;/login&gt; ，注意这里的login是组件对象的名称。\n\n**步骤：**\n- 1、创建router实例new VueRouter，完成相关属性的定义；\n- 2、将这个路由对象注册到Vue实例中，使用router: 路由对象名称的方式；\n- 3、创建第一步中定义的组件名称对应的组件，直接在&lt;script&gt;中定义var组件对象名称即可，在template中定义具体的HTML视图，或是通过template: '#id'引用外部视图也行。\n- 4、在Vue实例控制域app中，创建&lt;router-view&gt;&lt;/router-view&gt;，相当于router容器，你想在页面上展示几个组件就应该在页面中创建几个容器。\n\n如上，我们可以写具体的跳转链接了：\n```bash\n<div id=\"app>\n    <a href=\"#/login\">登录</a>\n    <a href=\"#/register\">注册</a>\n</div>\n```\n\n如上，当我们点击登录或注册，Vue-router就会监听都对应的URL地址，然后在path规则中刚好匹配到规则login，那么就会跳转到对应的组件component: login的login组件中。\n可能你会疑惑了，为什么这里的href需要写为#/login而不是/login或login，你尝试一下就知道了，因为vue-router监听URL地址是基于hash的，不加#/就会找不到路径。\n如果你觉得每次都加#/麻烦的话，Vue-router页提供了一个Tag:&lt;router-link to=\"URL地址\"&gt;&lt;/router-link&gt;，其在浏览器中会被解析为&lt;a&gt;标签。\n\n**实例**\n```bash\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n    <div id=\"app\">\n        <h1>父组件</h1>\n\n        <a href=\"#/login\">登录</a>\n        <router-link to=\"register\">注册</router-link>\n\n        <router-view></router-view>\n    </div>\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\" src=\"../lib/vue-router.js\"></script>\n    <script type=\"text/javascript\">\n\n        var login = {\n            template: '<h2>登录组件</h2>'\n        }\n\n        var register = {\n            template: '<h2>注册组件</h2>'\n        }\n\n        var routerObj = new VueRouter({\n            routes: [\n                { path: '/login', component: login },\n                { path: '/register', component: register }\n            ]\n        });\n\n        var vm = new Vue({\n            el: '#app',\n            data: {},\n            methods: {},\n            router: routerObj\n        });\n    </script>\n</body>\n</html>\n```\n\n但是上面的实例中，我们发现默认进入的根路径中仅有一个父组件名称，一般我们的登录页面应该直接显示登录框，所以vue-router提供了重定向的动能{path: '', redirect: ''}，即在router: []中监听根路径，如果监听都访问的是根路径就重定向到登录URL就好了。\n\n```bash\nvar routerObj = new VueRouter({\n    routes: [\n        { path: '/', redirect: '/login' },\n        { path: '/login', component: login },\n        { path: '/register', component: register }\n    ]\n});\n```\n\n#### 路由参数传递\n在进行页面跳转，即路由的时候，我们可能需要在发送URL时传递一些参数，常见的就如<http://www.loonycoder.com/api?id=1&name='loonycoder'>这种格式。\n那么在URL中传递的参数，vue-router提供了一种获取方式：this.$route。\n那么什么时候能获取到传递的参数呢？ 回顾前面讲到的Vue声明周期函数，那么在自定义组件中自然也存在生命周期函数，所以最早操作组件data和methods中数据的阶段就是created这个声明周期函数的阶段。\n实例：\n![vue](/images/vue16.png)\n![vue](/images/vue17.png)\n\n上面打印的值中，我们能看到，我们再VueRouter中创建的path匹配规则，实际在HTML中会被渲染为相关的正则表达式，来实现路径的匹配。\n其次，我们还能发现，在URL中拼接的参数id在this.$route对象的query属性中，我们通过this.$route.query.id即可获得传递的id值：2。\n\n#### 路由嵌套\n路由嵌套，顾名思义即在父级路由内部存在子路由。例如：\n> 根路径：<http://www.loonycoder.com>\n> 父级路由地址：<http://www.loonycoder.com/api>\n> 子级路由地址：<http://www.loonycoder.com/api/login>\n\n**实例：**\n```bash\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n    <div id=\"app\">\n        <router-link to=\"/account\">Account</router-link>\n\n        <router-view></router-view>\n    </div>\n\n    <template id=\"tmp\">\n        <div>\n            <h1>这是Account组件</h1>\n\n            <router-link to=\"/account/login\">登录</router-link>\n            <router-link to=\"/account/register\">注册</router-link>\n\n            <router-view></router-view>\n        </div>\n    </template>\n    <script type=\"text/javascript\" src=\"../lib/vue.js\"></script>\n    <script type=\"text/javascript\" src=\"../lib/vue-router.js\"></script>\n    <script type=\"text/javascript\">\n\n        var account = {\n            template: '#tmp'\n        }\n\n        var login = {\n            template: '<h2>登录组件</h2>',\n        }\n\n        var register = {\n            template: '<h2>注册组件</h2>'\n        }\n\n        var routerObj = new VueRouter({\n            routes: [\n                { \n                    path: '/account', \n                    component: account,\n                    children: [\n                        { path: 'login', component: login },\n                        { path: 'register', component: register }\n                    ]\n                },\n            ]\n        });\n\n        var vm = new Vue({\n            el: '#app',\n            data: {},\n            methods: {},\n            router: routerObj\n        });\n    </script>\n</body>\n</html>\n```\n\n如上，我们使用了routes: []中的另外一个属性：children，顾名思义就是表示这个父规则/account下存在一些子规则，且在URL中应该体现出来：\n![vue](/images/vue18.png)\n\n**注意：**\n在children中定义的子组件的path规则不能加/，即如上的，直接写path: login即可，这样请求account/login地址时，vue-router会找/account规则下的login规则，且不加/vue-router才会自动将login视为account下的子路径，并自动拼接account/，否则不会自动拼接，那么也无法完成路由的嵌套。\n\n#### 命名视图\n我们常见的后台开发页面，经常遇到上、左、中的布局方式；那么以前我们可能使用iframe实现页面间的跳转，但是现在我们学习的路由要比其更加的方便好用。\n**命名视图**的思想就是为每一个页面展示的视图都起一个名字，目的是为了为每个&lt;router-view&gt;&lt;/router-view&gt;容器刚好匹配一个指定的视图。使用方式：\n```bash\n<router-view></router-view>\n<router-view name=\"left\"></router-view>\n<router-view name=\"main\"></router-view>\n\nroutes: [\n    { \n        path: '/', components: {\n            'default': header\n            'left': left\n            'main': main\n        }\n    }\n]\n```\n\n**解释：**\n其中的path是根路径/，而使用components代替之前的component，目的就是可匹配其下的多个规则；default表示默认的视图组件是header这个组件，即会匹配到第一个&lt;router-view&gt;视图容器中；下面的两个组件会根据name名称需要对应的组件。\n实现上、左、中的布局：\n**思路：**\n1、我们需要创建三个组件，名称分别为：header、left、main；并且在app中创建三个&lt;router-view&gt;&lt;/router-view&gt;路由容器。\n2、采用**命名视图**的方式为每个视图都起一个名字：&lt;router-view name=\"left\"&gt;&lt;/router-view&gt; …\n3、注册路由实例。\n实例：\n![vue](/images/vue19.png)\n![vue](/images/vue20.png)\n","slug":"Vue4","published":1,"updated":"2020-02-21T15:29:13.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiz0000vv9s64ws6dbsb","content":"<h3 id=\"Vue路由\"><a href=\"#Vue路由\" class=\"headerlink\" title=\"Vue路由\"></a>Vue路由</h3><h4 id=\"什么是Vue路由？\"><a href=\"#什么是Vue路由？\" class=\"headerlink\" title=\"什么是Vue路由？\"></a>什么是Vue路由？</h4><ul>\n<li><strong>后端路由：</strong>即请求的URL地址都对应后端的接口，请求URL响应对应的服务器的资源。</li>\n<li><strong>前端路由：</strong>对于单页面程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以单页面程序中的页面跳转主要通过hash实现。</li>\n</ul>\n<h4 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h4><h5 id=\"导入类库\"><a href=\"#导入类库\" class=\"headerlink\" title=\"导入类库\"></a>导入类库</h5><p>首先需要导入vue-router组件类库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue-router.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>当导入类库后，window全局对象中就存在了一个路由的构造函数： VueRouter；就像导入Vue类库后存在一个Vue的构造函数一样，我们能够通过new VueRouter的方式实例化路由对象。<br>如果你使用了new VueRouter({});构造函数来实例化了一个路由对象，你会发现浏览器路径中会出现#/路径，这个路径就是前面讲到的URL中的hash，他并不会向后端发送任何请求，而仅仅是作页面跳转，如果你#/后拼接了一个不存在的路径，自然也不会进行跳转，页面也不会发送任何请求。<br><strong>实例：</strong><br><img src=\"/images/vue15.png\" alt=\"vue\"></p>\n<h5 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h5><p>上面我们讲到了使用new VueRouter({})的方式实例化一个路由对象，其中包含几个参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- HTML --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;!-- 给路由对象创建一个容器，包裹在父组件`app`内</span><br><span class=\"line\">        相当于一个占位符，路由规则匹配到的组件内容就会展示到`&lt;router-view&gt;&lt;/router-view&gt;`中</span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- ===============分割线===================== --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- JavaScript --&gt;</span><br><span class=\"line\">//创建login组件</span><br><span class=\"line\">var login = &#123;</span><br><span class=\"line\">    template: <span class=\"string\">'login组件'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//创建register组件</span><br><span class=\"line\">var register = &#123;</span><br><span class=\"line\">    template: <span class=\"string\">'register组件'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Router实例</span><br><span class=\"line\">var 路由对象名称 = new VueRouter(&#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123; path: <span class=\"string\">'/监听URL路径'</span>, component: login(组件名称) &#125;,</span><br><span class=\"line\">        &#123; path: <span class=\"string\">'/监听URL路径'</span>, component: register(组件名称) &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Vue实例</span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'app'</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    router: 路由对象名称   </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong></p>\n<ul>\n<li>1、routes 表示这个路由对象中的 路由匹配规则，可以存在多个规则（注意：这里是routes而不是routers）</li>\n<li>2、属性一：path 表示监听哪个路由连接地址，即你想跳转都哪个路径上，应在这里注册实现跳转到对应的组件上</li>\n<li>3、属性二：component 表示如果路由匹配了前面的path，则展示component属性对应的那个组件</li>\n<li>4、component的属性值必须是一个组件的模板对象，不能是组件的引用名称</li>\n<li>5、经过1-4的步骤基本完成了路由对象的创建，下面要将这个路由对象注入到Vue实例中，使用router: 组件对象名称实现</li>\n<li>6、创建对应需要监听的组件，如上我们创建了login和register组件，与之前讲的不同是这里是一个var 组件名称其值是一个组件对象，和之前的Vue.component方式相似，但是这里仅仅是一个组件对象，并没有注册到Vue实例中，因为没有组件名称，所以不能在HTML中使用&lt;login&gt;&lt;/login&gt; ，注意这里的login是组件对象的名称。</li>\n</ul>\n<p><strong>步骤：</strong></p>\n<ul>\n<li>1、创建router实例new VueRouter，完成相关属性的定义；</li>\n<li>2、将这个路由对象注册到Vue实例中，使用router: 路由对象名称的方式；</li>\n<li>3、创建第一步中定义的组件名称对应的组件，直接在&lt;script&gt;中定义var组件对象名称即可，在template中定义具体的HTML视图，或是通过template: ‘#id’引用外部视图也行。</li>\n<li>4、在Vue实例控制域app中，创建&lt;router-view&gt;&lt;/router-view&gt;，相当于router容器，你想在页面上展示几个组件就应该在页面中创建几个容器。</li>\n</ul>\n<p>如上，我们可以写具体的跳转链接了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;a href=\"</span><span class=\"comment\">#/login\"&gt;登录&lt;/a&gt;</span></span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#/register\"</span>&gt;注册&lt;/a&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，当我们点击登录或注册，Vue-router就会监听都对应的URL地址，然后在path规则中刚好匹配到规则login，那么就会跳转到对应的组件component: login的login组件中。<br>可能你会疑惑了，为什么这里的href需要写为#/login而不是/login或login，你尝试一下就知道了，因为vue-router监听URL地址是基于hash的，不加#/就会找不到路径。<br>如果你觉得每次都加#/麻烦的话，Vue-router页提供了一个Tag:&lt;router-link to=”URL地址”&gt;&lt;/router-link&gt;，其在浏览器中会被解析为&lt;a&gt;标签。</p>\n<p><strong>实例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">        &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;a href=<span class=\"string\">\"#/login\"</span>&gt;登录&lt;/a&gt;</span><br><span class=\"line\">        &lt;router-link to=<span class=\"string\">\"register\"</span>&gt;注册&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue-router.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        var login = &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'&lt;h2&gt;登录组件&lt;/h2&gt;'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var register = &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'&lt;h2&gt;注册组件&lt;/h2&gt;'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var routerObj = new VueRouter(&#123;</span><br><span class=\"line\">            routes: [</span><br><span class=\"line\">                &#123; path: <span class=\"string\">'/login'</span>, component: login &#125;,</span><br><span class=\"line\">                &#123; path: <span class=\"string\">'/register'</span>, component: register &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">            data: &#123;&#125;,</span><br><span class=\"line\">            methods: &#123;&#125;,</span><br><span class=\"line\">            router: routerObj</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是上面的实例中，我们发现默认进入的根路径中仅有一个父组件名称，一般我们的登录页面应该直接显示登录框，所以vue-router提供了重定向的动能{path: ‘’, redirect: ‘’}，即在router: []中监听根路径，如果监听都访问的是根路径就重定向到登录URL就好了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var routerObj = new VueRouter(&#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123; path: <span class=\"string\">'/'</span>, redirect: <span class=\"string\">'/login'</span> &#125;,</span><br><span class=\"line\">        &#123; path: <span class=\"string\">'/login'</span>, component: login &#125;,</span><br><span class=\"line\">        &#123; path: <span class=\"string\">'/register'</span>, component: register &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"路由参数传递\"><a href=\"#路由参数传递\" class=\"headerlink\" title=\"路由参数传递\"></a>路由参数传递</h4><p>在进行页面跳转，即路由的时候，我们可能需要在发送URL时传递一些参数，常见的就如<a href=\"http://www.loonycoder.com/api?id=1&amp;name=&#39;loonycoder&#39;\" target=\"_blank\" rel=\"noopener\">http://www.loonycoder.com/api?id=1&amp;name=&#39;loonycoder&#39;</a>这种格式。<br>那么在URL中传递的参数，vue-router提供了一种获取方式：this.$route。<br>那么什么时候能获取到传递的参数呢？ 回顾前面讲到的Vue声明周期函数，那么在自定义组件中自然也存在生命周期函数，所以最早操作组件data和methods中数据的阶段就是created这个声明周期函数的阶段。<br>实例：<br><img src=\"/images/vue16.png\" alt=\"vue\"><br><img src=\"/images/vue17.png\" alt=\"vue\"></p>\n<p>上面打印的值中，我们能看到，我们再VueRouter中创建的path匹配规则，实际在HTML中会被渲染为相关的正则表达式，来实现路径的匹配。<br>其次，我们还能发现，在URL中拼接的参数id在this.$route对象的query属性中，我们通过this.$route.query.id即可获得传递的id值：2。</p>\n<h4 id=\"路由嵌套\"><a href=\"#路由嵌套\" class=\"headerlink\" title=\"路由嵌套\"></a>路由嵌套</h4><p>路由嵌套，顾名思义即在父级路由内部存在子路由。例如：</p>\n<blockquote>\n<p>根路径：<a href=\"http://www.loonycoder.com\" target=\"_blank\" rel=\"noopener\">http://www.loonycoder.com</a><br>父级路由地址：<a href=\"http://www.loonycoder.com/api\" target=\"_blank\" rel=\"noopener\">http://www.loonycoder.com/api</a><br>子级路由地址：<a href=\"http://www.loonycoder.com/api/login\" target=\"_blank\" rel=\"noopener\">http://www.loonycoder.com/api/login</a></p>\n</blockquote>\n<p><strong>实例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">        &lt;router-link to=<span class=\"string\">\"/account\"</span>&gt;Account&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;h1&gt;这是Account组件&lt;/h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;router-link to=<span class=\"string\">\"/account/login\"</span>&gt;登录&lt;/router-link&gt;</span><br><span class=\"line\">            &lt;router-link to=<span class=\"string\">\"/account/register\"</span>&gt;注册&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue-router.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        var account = &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'#tmp'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var login = &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'&lt;h2&gt;登录组件&lt;/h2&gt;'</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var register = &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'&lt;h2&gt;注册组件&lt;/h2&gt;'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var routerObj = new VueRouter(&#123;</span><br><span class=\"line\">            routes: [</span><br><span class=\"line\">                &#123; </span><br><span class=\"line\">                    path: <span class=\"string\">'/account'</span>, </span><br><span class=\"line\">                    component: account,</span><br><span class=\"line\">                    children: [</span><br><span class=\"line\">                        &#123; path: <span class=\"string\">'login'</span>, component: login &#125;,</span><br><span class=\"line\">                        &#123; path: <span class=\"string\">'register'</span>, component: register &#125;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">            data: &#123;&#125;,</span><br><span class=\"line\">            methods: &#123;&#125;,</span><br><span class=\"line\">            router: routerObj</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，我们使用了routes: []中的另外一个属性：children，顾名思义就是表示这个父规则/account下存在一些子规则，且在URL中应该体现出来：<br><img src=\"/images/vue18.png\" alt=\"vue\"></p>\n<p><strong>注意：</strong><br>在children中定义的子组件的path规则不能加/，即如上的，直接写path: login即可，这样请求account/login地址时，vue-router会找/account规则下的login规则，且不加/vue-router才会自动将login视为account下的子路径，并自动拼接account/，否则不会自动拼接，那么也无法完成路由的嵌套。</p>\n<h4 id=\"命名视图\"><a href=\"#命名视图\" class=\"headerlink\" title=\"命名视图\"></a>命名视图</h4><p>我们常见的后台开发页面，经常遇到上、左、中的布局方式；那么以前我们可能使用iframe实现页面间的跳转，但是现在我们学习的路由要比其更加的方便好用。<br><strong>命名视图</strong>的思想就是为每一个页面展示的视图都起一个名字，目的是为了为每个&lt;router-view&gt;&lt;/router-view&gt;容器刚好匹配一个指定的视图。使用方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;router-view name=<span class=\"string\">\"left\"</span>&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;router-view name=<span class=\"string\">\"main\"</span>&gt;&lt;/router-view&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">routes: [</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        path: <span class=\"string\">'/'</span>, components: &#123;</span><br><span class=\"line\">            <span class=\"string\">'default'</span>: header</span><br><span class=\"line\">            <span class=\"string\">'left'</span>: left</span><br><span class=\"line\">            <span class=\"string\">'main'</span>: main</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong><br>其中的path是根路径/，而使用components代替之前的component，目的就是可匹配其下的多个规则；default表示默认的视图组件是header这个组件，即会匹配到第一个&lt;router-view&gt;视图容器中；下面的两个组件会根据name名称需要对应的组件。<br>实现上、左、中的布局：<br><strong>思路：</strong><br>1、我们需要创建三个组件，名称分别为：header、left、main；并且在app中创建三个&lt;router-view&gt;&lt;/router-view&gt;路由容器。<br>2、采用<strong>命名视图</strong>的方式为每个视图都起一个名字：&lt;router-view name=”left”&gt;&lt;/router-view&gt; …<br>3、注册路由实例。<br>实例：<br><img src=\"/images/vue19.png\" alt=\"vue\"><br><img src=\"/images/vue20.png\" alt=\"vue\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Vue路由\"><a href=\"#Vue路由\" class=\"headerlink\" title=\"Vue路由\"></a>Vue路由</h3><h4 id=\"什么是Vue路由？\"><a href=\"#什么是Vue路由？\" class=\"headerlink\" title=\"什么是Vue路由？\"></a>什么是Vue路由？</h4><ul>\n<li><strong>后端路由：</strong>即请求的URL地址都对应后端的接口，请求URL响应对应的服务器的资源。</li>\n<li><strong>前端路由：</strong>对于单页面程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以单页面程序中的页面跳转主要通过hash实现。</li>\n</ul>\n<h4 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h4><h5 id=\"导入类库\"><a href=\"#导入类库\" class=\"headerlink\" title=\"导入类库\"></a>导入类库</h5><p>首先需要导入vue-router组件类库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue-router.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>当导入类库后，window全局对象中就存在了一个路由的构造函数： VueRouter；就像导入Vue类库后存在一个Vue的构造函数一样，我们能够通过new VueRouter的方式实例化路由对象。<br>如果你使用了new VueRouter({});构造函数来实例化了一个路由对象，你会发现浏览器路径中会出现#/路径，这个路径就是前面讲到的URL中的hash，他并不会向后端发送任何请求，而仅仅是作页面跳转，如果你#/后拼接了一个不存在的路径，自然也不会进行跳转，页面也不会发送任何请求。<br><strong>实例：</strong><br><img src=\"/images/vue15.png\" alt=\"vue\"></p>\n<h5 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h5><p>上面我们讲到了使用new VueRouter({})的方式实例化一个路由对象，其中包含几个参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- HTML --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;!-- 给路由对象创建一个容器，包裹在父组件`app`内</span><br><span class=\"line\">        相当于一个占位符，路由规则匹配到的组件内容就会展示到`&lt;router-view&gt;&lt;/router-view&gt;`中</span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- ===============分割线===================== --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- JavaScript --&gt;</span><br><span class=\"line\">//创建login组件</span><br><span class=\"line\">var login = &#123;</span><br><span class=\"line\">    template: <span class=\"string\">'login组件'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//创建register组件</span><br><span class=\"line\">var register = &#123;</span><br><span class=\"line\">    template: <span class=\"string\">'register组件'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Router实例</span><br><span class=\"line\">var 路由对象名称 = new VueRouter(&#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123; path: <span class=\"string\">'/监听URL路径'</span>, component: login(组件名称) &#125;,</span><br><span class=\"line\">        &#123; path: <span class=\"string\">'/监听URL路径'</span>, component: register(组件名称) &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Vue实例</span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'app'</span>,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    router: 路由对象名称   </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong></p>\n<ul>\n<li>1、routes 表示这个路由对象中的 路由匹配规则，可以存在多个规则（注意：这里是routes而不是routers）</li>\n<li>2、属性一：path 表示监听哪个路由连接地址，即你想跳转都哪个路径上，应在这里注册实现跳转到对应的组件上</li>\n<li>3、属性二：component 表示如果路由匹配了前面的path，则展示component属性对应的那个组件</li>\n<li>4、component的属性值必须是一个组件的模板对象，不能是组件的引用名称</li>\n<li>5、经过1-4的步骤基本完成了路由对象的创建，下面要将这个路由对象注入到Vue实例中，使用router: 组件对象名称实现</li>\n<li>6、创建对应需要监听的组件，如上我们创建了login和register组件，与之前讲的不同是这里是一个var 组件名称其值是一个组件对象，和之前的Vue.component方式相似，但是这里仅仅是一个组件对象，并没有注册到Vue实例中，因为没有组件名称，所以不能在HTML中使用&lt;login&gt;&lt;/login&gt; ，注意这里的login是组件对象的名称。</li>\n</ul>\n<p><strong>步骤：</strong></p>\n<ul>\n<li>1、创建router实例new VueRouter，完成相关属性的定义；</li>\n<li>2、将这个路由对象注册到Vue实例中，使用router: 路由对象名称的方式；</li>\n<li>3、创建第一步中定义的组件名称对应的组件，直接在&lt;script&gt;中定义var组件对象名称即可，在template中定义具体的HTML视图，或是通过template: ‘#id’引用外部视图也行。</li>\n<li>4、在Vue实例控制域app中，创建&lt;router-view&gt;&lt;/router-view&gt;，相当于router容器，你想在页面上展示几个组件就应该在页面中创建几个容器。</li>\n</ul>\n<p>如上，我们可以写具体的跳转链接了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"app&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;a href=\"</span><span class=\"comment\">#/login\"&gt;登录&lt;/a&gt;</span></span><br><span class=\"line\">    &lt;a href=<span class=\"string\">\"#/register\"</span>&gt;注册&lt;/a&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，当我们点击登录或注册，Vue-router就会监听都对应的URL地址，然后在path规则中刚好匹配到规则login，那么就会跳转到对应的组件component: login的login组件中。<br>可能你会疑惑了，为什么这里的href需要写为#/login而不是/login或login，你尝试一下就知道了，因为vue-router监听URL地址是基于hash的，不加#/就会找不到路径。<br>如果你觉得每次都加#/麻烦的话，Vue-router页提供了一个Tag:&lt;router-link to=”URL地址”&gt;&lt;/router-link&gt;，其在浏览器中会被解析为&lt;a&gt;标签。</p>\n<p><strong>实例</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">        &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;a href=<span class=\"string\">\"#/login\"</span>&gt;登录&lt;/a&gt;</span><br><span class=\"line\">        &lt;router-link to=<span class=\"string\">\"register\"</span>&gt;注册&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue-router.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        var login = &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'&lt;h2&gt;登录组件&lt;/h2&gt;'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var register = &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'&lt;h2&gt;注册组件&lt;/h2&gt;'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var routerObj = new VueRouter(&#123;</span><br><span class=\"line\">            routes: [</span><br><span class=\"line\">                &#123; path: <span class=\"string\">'/login'</span>, component: login &#125;,</span><br><span class=\"line\">                &#123; path: <span class=\"string\">'/register'</span>, component: register &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">            data: &#123;&#125;,</span><br><span class=\"line\">            methods: &#123;&#125;,</span><br><span class=\"line\">            router: routerObj</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是上面的实例中，我们发现默认进入的根路径中仅有一个父组件名称，一般我们的登录页面应该直接显示登录框，所以vue-router提供了重定向的动能{path: ‘’, redirect: ‘’}，即在router: []中监听根路径，如果监听都访问的是根路径就重定向到登录URL就好了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var routerObj = new VueRouter(&#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123; path: <span class=\"string\">'/'</span>, redirect: <span class=\"string\">'/login'</span> &#125;,</span><br><span class=\"line\">        &#123; path: <span class=\"string\">'/login'</span>, component: login &#125;,</span><br><span class=\"line\">        &#123; path: <span class=\"string\">'/register'</span>, component: register &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"路由参数传递\"><a href=\"#路由参数传递\" class=\"headerlink\" title=\"路由参数传递\"></a>路由参数传递</h4><p>在进行页面跳转，即路由的时候，我们可能需要在发送URL时传递一些参数，常见的就如<a href=\"http://www.loonycoder.com/api?id=1&amp;name=&#39;loonycoder&#39;\" target=\"_blank\" rel=\"noopener\">http://www.loonycoder.com/api?id=1&amp;name=&#39;loonycoder&#39;</a>这种格式。<br>那么在URL中传递的参数，vue-router提供了一种获取方式：this.$route。<br>那么什么时候能获取到传递的参数呢？ 回顾前面讲到的Vue声明周期函数，那么在自定义组件中自然也存在生命周期函数，所以最早操作组件data和methods中数据的阶段就是created这个声明周期函数的阶段。<br>实例：<br><img src=\"/images/vue16.png\" alt=\"vue\"><br><img src=\"/images/vue17.png\" alt=\"vue\"></p>\n<p>上面打印的值中，我们能看到，我们再VueRouter中创建的path匹配规则，实际在HTML中会被渲染为相关的正则表达式，来实现路径的匹配。<br>其次，我们还能发现，在URL中拼接的参数id在this.$route对象的query属性中，我们通过this.$route.query.id即可获得传递的id值：2。</p>\n<h4 id=\"路由嵌套\"><a href=\"#路由嵌套\" class=\"headerlink\" title=\"路由嵌套\"></a>路由嵌套</h4><p>路由嵌套，顾名思义即在父级路由内部存在子路由。例如：</p>\n<blockquote>\n<p>根路径：<a href=\"http://www.loonycoder.com\" target=\"_blank\" rel=\"noopener\">http://www.loonycoder.com</a><br>父级路由地址：<a href=\"http://www.loonycoder.com/api\" target=\"_blank\" rel=\"noopener\">http://www.loonycoder.com/api</a><br>子级路由地址：<a href=\"http://www.loonycoder.com/api/login\" target=\"_blank\" rel=\"noopener\">http://www.loonycoder.com/api/login</a></p>\n</blockquote>\n<p><strong>实例：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">        &lt;router-link to=<span class=\"string\">\"/account\"</span>&gt;Account&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;template id=<span class=\"string\">\"tmp\"</span>&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;h1&gt;这是Account组件&lt;/h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;router-link to=<span class=\"string\">\"/account/login\"</span>&gt;登录&lt;/router-link&gt;</span><br><span class=\"line\">            &lt;router-link to=<span class=\"string\">\"/account/register\"</span>&gt;注册&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"../lib/vue-router.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script <span class=\"built_in\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        var account = &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'#tmp'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var login = &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'&lt;h2&gt;登录组件&lt;/h2&gt;'</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var register = &#123;</span><br><span class=\"line\">            template: <span class=\"string\">'&lt;h2&gt;注册组件&lt;/h2&gt;'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        var routerObj = new VueRouter(&#123;</span><br><span class=\"line\">            routes: [</span><br><span class=\"line\">                &#123; </span><br><span class=\"line\">                    path: <span class=\"string\">'/account'</span>, </span><br><span class=\"line\">                    component: account,</span><br><span class=\"line\">                    children: [</span><br><span class=\"line\">                        &#123; path: <span class=\"string\">'login'</span>, component: login &#125;,</span><br><span class=\"line\">                        &#123; path: <span class=\"string\">'register'</span>, component: register &#125;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        var vm = new Vue(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">            data: &#123;&#125;,</span><br><span class=\"line\">            methods: &#123;&#125;,</span><br><span class=\"line\">            router: routerObj</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，我们使用了routes: []中的另外一个属性：children，顾名思义就是表示这个父规则/account下存在一些子规则，且在URL中应该体现出来：<br><img src=\"/images/vue18.png\" alt=\"vue\"></p>\n<p><strong>注意：</strong><br>在children中定义的子组件的path规则不能加/，即如上的，直接写path: login即可，这样请求account/login地址时，vue-router会找/account规则下的login规则，且不加/vue-router才会自动将login视为account下的子路径，并自动拼接account/，否则不会自动拼接，那么也无法完成路由的嵌套。</p>\n<h4 id=\"命名视图\"><a href=\"#命名视图\" class=\"headerlink\" title=\"命名视图\"></a>命名视图</h4><p>我们常见的后台开发页面，经常遇到上、左、中的布局方式；那么以前我们可能使用iframe实现页面间的跳转，但是现在我们学习的路由要比其更加的方便好用。<br><strong>命名视图</strong>的思想就是为每一个页面展示的视图都起一个名字，目的是为了为每个&lt;router-view&gt;&lt;/router-view&gt;容器刚好匹配一个指定的视图。使用方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;router-view name=<span class=\"string\">\"left\"</span>&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;router-view name=<span class=\"string\">\"main\"</span>&gt;&lt;/router-view&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">routes: [</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        path: <span class=\"string\">'/'</span>, components: &#123;</span><br><span class=\"line\">            <span class=\"string\">'default'</span>: header</span><br><span class=\"line\">            <span class=\"string\">'left'</span>: left</span><br><span class=\"line\">            <span class=\"string\">'main'</span>: main</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释：</strong><br>其中的path是根路径/，而使用components代替之前的component，目的就是可匹配其下的多个规则；default表示默认的视图组件是header这个组件，即会匹配到第一个&lt;router-view&gt;视图容器中；下面的两个组件会根据name名称需要对应的组件。<br>实现上、左、中的布局：<br><strong>思路：</strong><br>1、我们需要创建三个组件，名称分别为：header、left、main；并且在app中创建三个&lt;router-view&gt;&lt;/router-view&gt;路由容器。<br>2、采用<strong>命名视图</strong>的方式为每个视图都起一个名字：&lt;router-view name=”left”&gt;&lt;/router-view&gt; …<br>3、注册路由实例。<br>实例：<br><img src=\"/images/vue19.png\" alt=\"vue\"><br><img src=\"/images/vue20.png\" alt=\"vue\"></p>\n"},{"title":"初识Vue","date":"2018-08-23T16:00:00.000Z","_content":"\n### 什么是Vue.js\n\n+ Vue.js是目前很火的前端框架；与Angualr.js和React.js并称为前端三大主流框架。\n+ Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，\n+ 在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。\n\n---\n\n### 后端的MVC和前端的MVVM之间的区别\n\n+ MVC是后端的分层开发概念\n+ MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）\n\n+ Model： 页面需要展示的数据\n+ View: 视图、HTML\n+ VM: 数据（Model）和视图（View）之间的调度者\n\n**图解**\n![vue图解](/images/vue1.png)\n\n---\n\n### 入门案例\n\n```bash\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <!-- 插值表达式 -->\n    <p>{{ msg }}</p>\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: {     // data中存放的是el中需要的数据\n            msg: 'Hello Vue!'\n        }\n    });\n</script>\n\n</body>\n</html>\n```\n\n**解释**\n\n1、首先需要引入Vue.js\n2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到\n3、创建Vue实例，这个实例其实就是MVVM中的vm调度者\n4、el: 表示当时Vue实例的控制区域；data: 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。\n5、在指定Vue实例区域下，展示我们已经声明的元素msg，使用：即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）\n\n---\n\n### 常用指令\n\n#### v-cloak\n\n在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在vue.js还没有加载完毕时，视图层不会将识别为Vue中的插值表达式，而是作为字符串显示到页面上。\n为了解决这个问题，Vue.js提供了v-cloak指令，可以解决插值表达式闪烁的问题。\n\n```bash\n<p v-cloak>{{ msg }}</p>\n```\n\n**扩展**\n\n解决插值表达式闪烁问题，除了v-cloak指令，Vue还提供了v-text指令。\n\n```bash\n<p v-text=\"msg\"></p>\n```\n\n**v-cloak与v-text的区别**\nv-text默认会覆盖掉元素中原有的内容\nv-cloak不会覆盖掉原有的内容\n![vue2](/images/vue2.png)\n\n#### v-bind\n\n**在上面，我们了解了v-text输出Vue元素，但是如果我们需要显示的数据是一段HTML代码，v-text和都将无能为力，\n为此，Vue提供了专门渲染HTML数据的指令：v-html**\n\n![vue3](/images/vue3.png)\n\n上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用）这样可以吗？\n\n```bash\n<input type=\"button\" value=\"msg\"/>\n```\n\n回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。\n为了解决上述问题，Vue提供了v-bind:指令来绑定一些HTML属性：\n\n```bash\n<input type=\"button\" v-bind:value=\"msg\">\n```\n\n如上，被v-bind:绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外v-bind:还有一个简易写法：\n\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" value=\"msg\" />\n    <input type=\"button\" v-bind:value=\"msg\">\n    <input type=\"button\" :value=\"msg\">\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '戳我'\n        }\n    });\n</script>\n```\n\n效果如图：\n![vue4](/images/vue4.png)\n\n#### v-on\n\nVue提供了事件绑定机制的指令：v-on:；用其我们可以用来绑定一些常见的触发事件：click、mouseover ...\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" :value=\"msg\" v-on:click=\"show\">\n    <input type=\"button\" :value=\"msg\" v-on:mouseover=\"show\">\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '戳我'\n        },\n        methods: {\n            show: function(){\n                alert(\"hello\");\n            }\n        }\n    });\n</script>\n```\n\n其中methods是Vue内置的对象，用于存放一些自定义的方法函数\n\n**拓展**\n\n使用js内置的函数setInterval(定时器)，实现跑马灯效果：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" value=\"开始\" @click=\"action\">\n    <input type=\"button\" value=\"停止\" @click=\"stop\">\n    <p>{{msg}}</p>\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '嘻嘻，哈哈',\n            intervalId: null\n        },\n        methods: {\n            action(){\n                if(this.intervalId != null) return;\n\n                // 定时器\n                this.intervalId = setInterval(() => {\n                    // 截取首字符\n                    var start = this.msg.substring(0, 1);\n                    // 截取第一个字符后的所有字符\n                    var end = this.msg.substring(1);\n                    // 将后面的字符拼接到前面，实现循环的效果\n                    this.msg = end + start;\n                },400)\n            },\n            stop(){\n                // 停止定时器\n                clearInterval(this.intervalId)\n                // 每次清除定时器后需要将intervalId重新设置为null\n                this.intervalId = null;\n            }\n        }\n    });\n</script>\n```\n\n**解释**\n\n1、v-on:也有简写形式：@，用法如上。\n2、在视图层取VM中的数据我们可以使用或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：this.数据属性名（其中的this表示当前VM实例对象）。\n3、methodName:function(){}在ES6中有一个简便的写法：methodName(){}。 4、setInterval()和clearInterval()是js中内置的函数，用法如上。\n5、正常我们调用函数会写：name(function(){})，而ES6也提供了一个方式：methodName(() => {})，这种用法的好处就解决了this指向问题，因为如果元素定义在了函数内部，那么其中的this就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的=>。\n\n效果如图：\n![vue5](/images/vue5.png)\n\n\n#### 事件修饰符\n\n> .stop 阻止冒泡\n> .prevent 阻止默认事件\n> .capture 添加时间侦听器时使用时间捕获模式\n> .self 只当事件在该元素本身（比如不是子元素）触发时触发回调\n> .once 事件只触发一次\n\n用法：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <div @click=\"divClick\">\n        <input type=\"button\" value=\"戳我\" @click.stop=\"btnClick\">\n        <input type=\"button\" value=\"戳我\" @click.prevent=\"btnClick\">\n    </div>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '嘻嘻，哈哈',\n        },\n        methods: {\n            divClick() {\n                console.log(\"这是div的点击事件\");\n            },\n            btnClick() {\n                console.log(\"这是btn的点击事件\");\n            }\n        }\n    });\n</script>\n```\n\n#### v-model\n\n- 唯一的双向绑定指令：v-model\n- 单向绑定指令：v-bing\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"text\" v-model=\"msg\">\n    <p>{{msg}}</p>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: 'hello!',\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n---\n\n### Vue中的样式\n\n\n#### 外联样式\n- 数组\n```bash\n<h2 :class=\"['italic','color']\">LoonyCoder</h2>\n```\n其中的italic、color是自定义的类名，需在外部定义CSS样式\n\n- 数组中嵌套对象\n```bash\n<h2 :class=\"['italic',{'color': flag}]\">LoonyCoder</h2>\n```\n其中的flag是Vue绑定的变量，在data进行声明\n\n- 直接使用对象\n```bash\n<h2 :class=\"{italic:true, color:flag}\">LoonyCoder</h2>\n```\n\n实例：\n```bash\n<style>\n    .italic {\n        font-style: italic;\n    }\n\n    .color {\n        color: skyblue;\n    }\n</style>\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <h2 :class=\"['italic','color']\">LoonyCoder</h2>\n    <h2 :class=\"['italic', {'color':flag}]\">LoonyCoder</h2>\n    <h2 :class=\"{italic:false, color:flag}\">LoonyCoder</h2>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            flag: true\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### 内联样式\n\n- 将样式对象定义到data中，并在:style中引用\n```bash\n<h2 :style=\"styleObj\">LoonyCoder</h2>\n\ndata: {\n    styleObj: { 'color': 'red', 'font-weight': '200px'}\n}\n```\n\n- 在:style中通过数组，引用多个data上的样式对象\n```bash\n<h2 :style=\"[styleObj, styleObj2]\">LoonyCoder</h2>\n\ndata: {\n    styleObj: { 'color': 'red', 'font-weight': '200px'},\n    styleObj2: { 'font-style': 'italic' }\n}\n```\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <h2 :style=\"styleObj\">LoonyCoder</h2>\n    <h2 :style=\"[styleObj, styleObj2]\">LoonyCoder</h2>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            styleObj: { 'color': 'red', 'font-weight': '200px' },\n            styleObj2: { 'font-style': 'italic' }\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### v-for\n\nVue提供了遍历集合、数组的指令：v-for；用法: v-for=\"别名 in 集合名\"\n\n#### 迭代数组\n```bash\n<p v-for=\"item, i in list\">索引：{{i}} --- 值：{{item}}</p>\n\ndata: {\n    list: [1,2,3,4]\n}\n```\n**其中的i是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义**\n\n#### 迭代对象数组\n```bash\n<p v-for=\"item in list2\">id: {{item.id}} --- name: {{item.name}}</p>\n\ndata: {\n    list2: [\n            { id:1, name: '嘻嘻' },\n            { id:2, name: '哈哈' }\n        ],\n}\n```\n\n**迭代对象数组，通过 的方式，这个属性名就是对象数组中定义的元素属性名**\n\n#### 迭代对象\n```bash\n<p v-for=\"(val, key) in user\">键: {{key}} --- 值: {{val}}</p>\n\ndata: {\n    user: {\n            id: 1,\n            name: 'LoonyCoder'\n        }\n}\n```\n\n**迭代对象，迭代得到的是对象的value值和key值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。**\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <p v-for=\"item, i in list\">索引：{{i}} --- 值：{{item}}</p>\n    <p v-for=\"item in list2\">id: {{item.id}} --- name: {{item.name}}</p>\n    <p v-for=\"(val, key) in user\">键: {{key}} --- 值: {{val}}</p>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            list: [1,2,3,4], \n            list2: [\n                { id:1, name: '嘻嘻' },\n                { id:2, name: '哈哈' }\n            ],\n            user: {\n                id: 1,\n                name: 'LoonyCoder'\n            }\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### 注意\n在vue2.0+版本里，当使用v-for渲染数据，必须制定对应的key值（这里的key是一个属性，不是前面迭代的key值）。\n\n**用法：**\n```bash\n<p v-for=\"item in user\" :key=\"item.id\">\n```\n其中:key就说明了key属性必须是通过v-bind绑定的元素，而:key=\"\"中指定的值必须是string/number类型的值，比如此处使用的是item.id中ID是number值，并且是唯一的。\n**目的：**\n避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。\n\n#### v-show和v-if\n\nVue提供了两个指令来实现元素显示状态的切换：v-if v-show\n**区别**\n- v-if的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。\n- v-show的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的display:none样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" @click=\"flag=!flag\" value=\"toggle\">\n\n    <h3 v-if=\"flag\">这是v-if控制的元素</h3>\n    <h3 v-show=\"flag\">这是v-show控制的元素</h3>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            flag: false\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n效果如下：\n![vue6](/images/vue6.png)","source":"_posts/Vue1.md","raw":"---\ntitle: 初识Vue\ncategories:\n    - Web前端\ndate: 2018-08-24\ntags:\n\t- 前端框架\n\t\n---\n\n### 什么是Vue.js\n\n+ Vue.js是目前很火的前端框架；与Angualr.js和React.js并称为前端三大主流框架。\n+ Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，\n+ 在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。\n\n---\n\n### 后端的MVC和前端的MVVM之间的区别\n\n+ MVC是后端的分层开发概念\n+ MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）\n\n+ Model： 页面需要展示的数据\n+ View: 视图、HTML\n+ VM: 数据（Model）和视图（View）之间的调度者\n\n**图解**\n![vue图解](/images/vue1.png)\n\n---\n\n### 入门案例\n\n```bash\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <!-- 插值表达式 -->\n    <p>{{ msg }}</p>\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: {     // data中存放的是el中需要的数据\n            msg: 'Hello Vue!'\n        }\n    });\n</script>\n\n</body>\n</html>\n```\n\n**解释**\n\n1、首先需要引入Vue.js\n2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到\n3、创建Vue实例，这个实例其实就是MVVM中的vm调度者\n4、el: 表示当时Vue实例的控制区域；data: 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。\n5、在指定Vue实例区域下，展示我们已经声明的元素msg，使用：即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）\n\n---\n\n### 常用指令\n\n#### v-cloak\n\n在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在vue.js还没有加载完毕时，视图层不会将识别为Vue中的插值表达式，而是作为字符串显示到页面上。\n为了解决这个问题，Vue.js提供了v-cloak指令，可以解决插值表达式闪烁的问题。\n\n```bash\n<p v-cloak>{{ msg }}</p>\n```\n\n**扩展**\n\n解决插值表达式闪烁问题，除了v-cloak指令，Vue还提供了v-text指令。\n\n```bash\n<p v-text=\"msg\"></p>\n```\n\n**v-cloak与v-text的区别**\nv-text默认会覆盖掉元素中原有的内容\nv-cloak不会覆盖掉原有的内容\n![vue2](/images/vue2.png)\n\n#### v-bind\n\n**在上面，我们了解了v-text输出Vue元素，但是如果我们需要显示的数据是一段HTML代码，v-text和都将无能为力，\n为此，Vue提供了专门渲染HTML数据的指令：v-html**\n\n![vue3](/images/vue3.png)\n\n上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用）这样可以吗？\n\n```bash\n<input type=\"button\" value=\"msg\"/>\n```\n\n回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。\n为了解决上述问题，Vue提供了v-bind:指令来绑定一些HTML属性：\n\n```bash\n<input type=\"button\" v-bind:value=\"msg\">\n```\n\n如上，被v-bind:绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外v-bind:还有一个简易写法：\n\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" value=\"msg\" />\n    <input type=\"button\" v-bind:value=\"msg\">\n    <input type=\"button\" :value=\"msg\">\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '戳我'\n        }\n    });\n</script>\n```\n\n效果如图：\n![vue4](/images/vue4.png)\n\n#### v-on\n\nVue提供了事件绑定机制的指令：v-on:；用其我们可以用来绑定一些常见的触发事件：click、mouseover ...\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" :value=\"msg\" v-on:click=\"show\">\n    <input type=\"button\" :value=\"msg\" v-on:mouseover=\"show\">\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '戳我'\n        },\n        methods: {\n            show: function(){\n                alert(\"hello\");\n            }\n        }\n    });\n</script>\n```\n\n其中methods是Vue内置的对象，用于存放一些自定义的方法函数\n\n**拓展**\n\n使用js内置的函数setInterval(定时器)，实现跑马灯效果：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" value=\"开始\" @click=\"action\">\n    <input type=\"button\" value=\"停止\" @click=\"stop\">\n    <p>{{msg}}</p>\n</div>\n\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '嘻嘻，哈哈',\n            intervalId: null\n        },\n        methods: {\n            action(){\n                if(this.intervalId != null) return;\n\n                // 定时器\n                this.intervalId = setInterval(() => {\n                    // 截取首字符\n                    var start = this.msg.substring(0, 1);\n                    // 截取第一个字符后的所有字符\n                    var end = this.msg.substring(1);\n                    // 将后面的字符拼接到前面，实现循环的效果\n                    this.msg = end + start;\n                },400)\n            },\n            stop(){\n                // 停止定时器\n                clearInterval(this.intervalId)\n                // 每次清除定时器后需要将intervalId重新设置为null\n                this.intervalId = null;\n            }\n        }\n    });\n</script>\n```\n\n**解释**\n\n1、v-on:也有简写形式：@，用法如上。\n2、在视图层取VM中的数据我们可以使用或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：this.数据属性名（其中的this表示当前VM实例对象）。\n3、methodName:function(){}在ES6中有一个简便的写法：methodName(){}。 4、setInterval()和clearInterval()是js中内置的函数，用法如上。\n5、正常我们调用函数会写：name(function(){})，而ES6也提供了一个方式：methodName(() => {})，这种用法的好处就解决了this指向问题，因为如果元素定义在了函数内部，那么其中的this就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的=>。\n\n效果如图：\n![vue5](/images/vue5.png)\n\n\n#### 事件修饰符\n\n> .stop 阻止冒泡\n> .prevent 阻止默认事件\n> .capture 添加时间侦听器时使用时间捕获模式\n> .self 只当事件在该元素本身（比如不是子元素）触发时触发回调\n> .once 事件只触发一次\n\n用法：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <div @click=\"divClick\">\n        <input type=\"button\" value=\"戳我\" @click.stop=\"btnClick\">\n        <input type=\"button\" value=\"戳我\" @click.prevent=\"btnClick\">\n    </div>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: '嘻嘻，哈哈',\n        },\n        methods: {\n            divClick() {\n                console.log(\"这是div的点击事件\");\n            },\n            btnClick() {\n                console.log(\"这是btn的点击事件\");\n            }\n        }\n    });\n</script>\n```\n\n#### v-model\n\n- 唯一的双向绑定指令：v-model\n- 单向绑定指令：v-bing\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"text\" v-model=\"msg\">\n    <p>{{msg}}</p>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            msg: 'hello!',\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n---\n\n### Vue中的样式\n\n\n#### 外联样式\n- 数组\n```bash\n<h2 :class=\"['italic','color']\">LoonyCoder</h2>\n```\n其中的italic、color是自定义的类名，需在外部定义CSS样式\n\n- 数组中嵌套对象\n```bash\n<h2 :class=\"['italic',{'color': flag}]\">LoonyCoder</h2>\n```\n其中的flag是Vue绑定的变量，在data进行声明\n\n- 直接使用对象\n```bash\n<h2 :class=\"{italic:true, color:flag}\">LoonyCoder</h2>\n```\n\n实例：\n```bash\n<style>\n    .italic {\n        font-style: italic;\n    }\n\n    .color {\n        color: skyblue;\n    }\n</style>\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <h2 :class=\"['italic','color']\">LoonyCoder</h2>\n    <h2 :class=\"['italic', {'color':flag}]\">LoonyCoder</h2>\n    <h2 :class=\"{italic:false, color:flag}\">LoonyCoder</h2>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            flag: true\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### 内联样式\n\n- 将样式对象定义到data中，并在:style中引用\n```bash\n<h2 :style=\"styleObj\">LoonyCoder</h2>\n\ndata: {\n    styleObj: { 'color': 'red', 'font-weight': '200px'}\n}\n```\n\n- 在:style中通过数组，引用多个data上的样式对象\n```bash\n<h2 :style=\"[styleObj, styleObj2]\">LoonyCoder</h2>\n\ndata: {\n    styleObj: { 'color': 'red', 'font-weight': '200px'},\n    styleObj2: { 'font-style': 'italic' }\n}\n```\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <h2 :style=\"styleObj\">LoonyCoder</h2>\n    <h2 :style=\"[styleObj, styleObj2]\">LoonyCoder</h2>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            styleObj: { 'color': 'red', 'font-weight': '200px' },\n            styleObj2: { 'font-style': 'italic' }\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### v-for\n\nVue提供了遍历集合、数组的指令：v-for；用法: v-for=\"别名 in 集合名\"\n\n#### 迭代数组\n```bash\n<p v-for=\"item, i in list\">索引：{{i}} --- 值：{{item}}</p>\n\ndata: {\n    list: [1,2,3,4]\n}\n```\n**其中的i是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义**\n\n#### 迭代对象数组\n```bash\n<p v-for=\"item in list2\">id: {{item.id}} --- name: {{item.name}}</p>\n\ndata: {\n    list2: [\n            { id:1, name: '嘻嘻' },\n            { id:2, name: '哈哈' }\n        ],\n}\n```\n\n**迭代对象数组，通过 的方式，这个属性名就是对象数组中定义的元素属性名**\n\n#### 迭代对象\n```bash\n<p v-for=\"(val, key) in user\">键: {{key}} --- 值: {{val}}</p>\n\ndata: {\n    user: {\n            id: 1,\n            name: 'LoonyCoder'\n        }\n}\n```\n\n**迭代对象，迭代得到的是对象的value值和key值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。**\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <p v-for=\"item, i in list\">索引：{{i}} --- 值：{{item}}</p>\n    <p v-for=\"item in list2\">id: {{item.id}} --- name: {{item.name}}</p>\n    <p v-for=\"(val, key) in user\">键: {{key}} --- 值: {{val}}</p>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            list: [1,2,3,4], \n            list2: [\n                { id:1, name: '嘻嘻' },\n                { id:2, name: '哈哈' }\n            ],\n            user: {\n                id: 1,\n                name: 'LoonyCoder'\n            }\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n#### 注意\n在vue2.0+版本里，当使用v-for渲染数据，必须制定对应的key值（这里的key是一个属性，不是前面迭代的key值）。\n\n**用法：**\n```bash\n<p v-for=\"item in user\" :key=\"item.id\">\n```\n其中:key就说明了key属性必须是通过v-bind绑定的元素，而:key=\"\"中指定的值必须是string/number类型的值，比如此处使用的是item.id中ID是number值，并且是唯一的。\n**目的：**\n避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。\n\n#### v-show和v-if\n\nVue提供了两个指令来实现元素显示状态的切换：v-if v-show\n**区别**\n- v-if的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。\n- v-show的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的display:none样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。\n\n实例：\n```bash\n<!-- Vue实例的控制区域 -->\n<div id=\"app\">\n    <input type=\"button\" @click=\"flag=!flag\" value=\"toggle\">\n\n    <h3 v-if=\"flag\">这是v-if控制的元素</h3>\n    <h3 v-show=\"flag\">这是v-show控制的元素</h3>\n</div>\n<!-- js部分 -->\n<script src=\"../lib/vue.js\"></script>\n<script>\n    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者\n    var vm = new Vue({\n        el: '#app', // element的简写，表示我们当前new的这个Vue实例的区域\n        data: { // data中存放的是el中需要的数据\n            flag: false\n        },\n        methods: {\n\n        }\n    });\n</script>\n```\n\n效果如下：\n![vue6](/images/vue6.png)","slug":"Vue1","published":1,"updated":"2020-02-21T15:28:15.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiz2000zv9s697sy4v92","content":"<h3 id=\"什么是Vue-js\"><a href=\"#什么是Vue-js\" class=\"headerlink\" title=\"什么是Vue.js\"></a>什么是Vue.js</h3><ul>\n<li>Vue.js是目前很火的前端框架；与Angualr.js和React.js并称为前端三大主流框架。</li>\n<li>Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，</li>\n<li>在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。</li>\n</ul>\n<hr>\n<h3 id=\"后端的MVC和前端的MVVM之间的区别\"><a href=\"#后端的MVC和前端的MVVM之间的区别\" class=\"headerlink\" title=\"后端的MVC和前端的MVVM之间的区别\"></a>后端的MVC和前端的MVVM之间的区别</h3><ul>\n<li><p>MVC是后端的分层开发概念</p>\n</li>\n<li><p>MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）</p>\n</li>\n<li><p>Model： 页面需要展示的数据</p>\n</li>\n<li><p>View: 视图、HTML</p>\n</li>\n<li><p>VM: 数据（Model）和视图（View）之间的调度者</p>\n</li>\n</ul>\n<p><strong>图解</strong><br><img src=\"/images/vue1.png\" alt=\"vue图解\"></p>\n<hr>\n<h3 id=\"入门案例\"><a href=\"#入门案例\" class=\"headerlink\" title=\"入门案例\"></a>入门案例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- 插值表达式 --&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123;     // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'Hello Vue!'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<p>1、首先需要引入Vue.js<br>2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到<br>3、创建Vue实例，这个实例其实就是MVVM中的vm调度者<br>4、el: 表示当时Vue实例的控制区域；data: 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。<br>5、在指定Vue实例区域下，展示我们已经声明的元素msg，使用：即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）</p>\n<hr>\n<h3 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h3><h4 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h4><p>在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在vue.js还没有加载完毕时，视图层不会将识别为Vue中的插值表达式，而是作为字符串显示到页面上。<br>为了解决这个问题，Vue.js提供了v-cloak指令，可以解决插值表达式闪烁的问题。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>扩展</strong></p>\n<p>解决插值表达式闪烁问题，除了v-cloak指令，Vue还提供了v-text指令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-text=<span class=\"string\">\"msg\"</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>v-cloak与v-text的区别</strong><br>v-text默认会覆盖掉元素中原有的内容<br>v-cloak不会覆盖掉原有的内容<br><img src=\"/images/vue2.png\" alt=\"vue2\"></p>\n<h4 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h4><p><strong>在上面，我们了解了v-text输出Vue元素，但是如果我们需要显示的数据是一段HTML代码，v-text和都将无能为力，<br>为此，Vue提供了专门渲染HTML数据的指令：v-html</strong></p>\n<p><img src=\"/images/vue3.png\" alt=\"vue3\"></p>\n<p>上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用）这样可以吗？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"msg\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。<br>为了解决上述问题，Vue提供了v-bind:指令来绑定一些HTML属性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> v-bind:value=<span class=\"string\">\"msg\"</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，被v-bind:绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外v-bind:还有一个简易写法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"msg\"</span> /&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> v-bind:value=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'戳我'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果如图：<br><img src=\"/images/vue4.png\" alt=\"vue4\"></p>\n<h4 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h4><p>Vue提供了事件绑定机制的指令：v-on:；用其我们可以用来绑定一些常见的触发事件：click、mouseover …</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span> v-on:click=<span class=\"string\">\"show\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span> v-on:mouseover=<span class=\"string\">\"show\"</span>&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'戳我'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            show: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">                alert(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中methods是Vue内置的对象，用于存放一些自定义的方法函数</p>\n<p><strong>拓展</strong></p>\n<p>使用js内置的函数setInterval(定时器)，实现跑马灯效果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"开始\"</span> @click=<span class=\"string\">\"action\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"停止\"</span> @click=<span class=\"string\">\"stop\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'嘻嘻，哈哈'</span>,</span><br><span class=\"line\">            intervalId: null</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">action</span></span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(this.intervalId != null) <span class=\"built_in\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                // 定时器</span><br><span class=\"line\">                this.intervalId = setInterval(() =&gt; &#123;</span><br><span class=\"line\">                    // 截取首字符</span><br><span class=\"line\">                    var start = this.msg.substring(0, 1);</span><br><span class=\"line\">                    // 截取第一个字符后的所有字符</span><br><span class=\"line\">                    var end = this.msg.substring(1);</span><br><span class=\"line\">                    // 将后面的字符拼接到前面，实现循环的效果</span><br><span class=\"line\">                    this.msg = end + start;</span><br><span class=\"line\">                &#125;,400)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">stop</span></span>()&#123;</span><br><span class=\"line\">                // 停止定时器</span><br><span class=\"line\">                clearInterval(this.intervalId)</span><br><span class=\"line\">                // 每次清除定时器后需要将intervalId重新设置为null</span><br><span class=\"line\">                this.intervalId = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<p>1、v-on:也有简写形式：@，用法如上。<br>2、在视图层取VM中的数据我们可以使用或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：this.数据属性名（其中的this表示当前VM实例对象）。<br>3、methodName:function(){}在ES6中有一个简便的写法：methodName(){}。 4、setInterval()和clearInterval()是js中内置的函数，用法如上。<br>5、正常我们调用函数会写：name(function(){})，而ES6也提供了一个方式：methodName(() =&gt; {})，这种用法的好处就解决了this指向问题，因为如果元素定义在了函数内部，那么其中的this就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的=&gt;。</p>\n<p>效果如图：<br><img src=\"/images/vue5.png\" alt=\"vue5\"></p>\n<h4 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h4><blockquote>\n<p>.stop 阻止冒泡<br>.prevent 阻止默认事件<br>.capture 添加时间侦听器时使用时间捕获模式<br>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调<br>.once 事件只触发一次</p>\n</blockquote>\n<p>用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;div @click=<span class=\"string\">\"divClick\"</span>&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"戳我\"</span> @click.stop=<span class=\"string\">\"btnClick\"</span>&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"戳我\"</span> @click.prevent=<span class=\"string\">\"btnClick\"</span>&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'嘻嘻，哈哈'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">divClick</span></span>() &#123;</span><br><span class=\"line\">                console.log(<span class=\"string\">\"这是div的点击事件\"</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">btnClick</span></span>() &#123;</span><br><span class=\"line\">                console.log(<span class=\"string\">\"这是btn的点击事件\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h4><ul>\n<li>唯一的双向绑定指令：v-model</li>\n<li>单向绑定指令：v-bing</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'hello!'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"Vue中的样式\"><a href=\"#Vue中的样式\" class=\"headerlink\" title=\"Vue中的样式\"></a>Vue中的样式</h3><h4 id=\"外联样式\"><a href=\"#外联样式\" class=\"headerlink\" title=\"外联样式\"></a>外联样式</h4><ul>\n<li><p>数组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"['italic','color']\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n<p>其中的italic、color是自定义的类名，需在外部定义CSS样式</p>\n</li>\n<li><p>数组中嵌套对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"['italic',&#123;'color': flag&#125;]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n<p>其中的flag是Vue绑定的变量，在data进行声明</p>\n</li>\n<li><p>直接使用对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"&#123;italic:true, color:flag&#125;\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .italic &#123;</span><br><span class=\"line\">        font-style: italic;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .color &#123;</span><br><span class=\"line\">        color: skyblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"['italic','color']\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"['italic', &#123;'color':flag&#125;]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"&#123;italic:false, color:flag&#125;\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            flag: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内联样式\"><a href=\"#内联样式\" class=\"headerlink\" title=\"内联样式\"></a>内联样式</h4><ul>\n<li><p>将样式对象定义到data中，并在:style中引用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :style=<span class=\"string\">\"styleObj\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在:style中通过数组，引用多个data上的样式对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :style=<span class=\"string\">\"[styleObj, styleObj2]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span>&#125;,</span><br><span class=\"line\">    styleObj2: &#123; <span class=\"string\">'font-style'</span>: <span class=\"string\">'italic'</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;h2 :style=<span class=\"string\">\"styleObj\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :style=<span class=\"string\">\"[styleObj, styleObj2]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span> &#125;,</span><br><span class=\"line\">            styleObj2: &#123; <span class=\"string\">'font-style'</span>: <span class=\"string\">'italic'</span> &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h4><p>Vue提供了遍历集合、数组的指令：v-for；用法: v-for=”别名 in 集合名”</p>\n<h4 id=\"迭代数组\"><a href=\"#迭代数组\" class=\"headerlink\" title=\"迭代数组\"></a>迭代数组</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item, i in list\"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    list: [1,2,3,4]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>其中的i是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义</strong></p>\n<h4 id=\"迭代对象数组\"><a href=\"#迭代对象数组\" class=\"headerlink\" title=\"迭代对象数组\"></a>迭代对象数组</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item in list2\"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    list2: [</span><br><span class=\"line\">            &#123; id:1, name: <span class=\"string\">'嘻嘻'</span> &#125;,</span><br><span class=\"line\">            &#123; id:2, name: <span class=\"string\">'哈哈'</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>迭代对象数组，通过 的方式，这个属性名就是对象数组中定义的元素属性名</strong></p>\n<h4 id=\"迭代对象\"><a href=\"#迭代对象\" class=\"headerlink\" title=\"迭代对象\"></a>迭代对象</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"(val, key) in user\"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">            id: 1,</span><br><span class=\"line\">            name: <span class=\"string\">'LoonyCoder'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>迭代对象，迭代得到的是对象的value值和key值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。</strong></p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"item, i in list\"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"item in list2\"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"(val, key) in user\"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            list: [1,2,3,4], </span><br><span class=\"line\">            list2: [</span><br><span class=\"line\">                &#123; id:1, name: <span class=\"string\">'嘻嘻'</span> &#125;,</span><br><span class=\"line\">                &#123; id:2, name: <span class=\"string\">'哈哈'</span> &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            user: &#123;</span><br><span class=\"line\">                id: 1,</span><br><span class=\"line\">                name: <span class=\"string\">'LoonyCoder'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>在vue2.0+版本里，当使用v-for渲染数据，必须制定对应的key值（这里的key是一个属性，不是前面迭代的key值）。</p>\n<p><strong>用法：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item in user\"</span> :key=<span class=\"string\">\"item.id\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>其中:key就说明了key属性必须是通过v-bind绑定的元素，而:key=””中指定的值必须是string/number类型的值，比如此处使用的是item.id中ID是number值，并且是唯一的。<br><strong>目的：</strong><br>避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。</p>\n<h4 id=\"v-show和v-if\"><a href=\"#v-show和v-if\" class=\"headerlink\" title=\"v-show和v-if\"></a>v-show和v-if</h4><p>Vue提供了两个指令来实现元素显示状态的切换：v-if v-show<br><strong>区别</strong></p>\n<ul>\n<li>v-if的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。</li>\n<li>v-show的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的display:none样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"flag=!flag\"</span> value=<span class=\"string\">\"toggle\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;h3 v-if=<span class=\"string\">\"flag\"</span>&gt;这是v-if控制的元素&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3 v-show=<span class=\"string\">\"flag\"</span>&gt;这是v-show控制的元素&lt;/h3&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            flag: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果如下：<br><img src=\"/images/vue6.png\" alt=\"vue6\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是Vue-js\"><a href=\"#什么是Vue-js\" class=\"headerlink\" title=\"什么是Vue.js\"></a>什么是Vue.js</h3><ul>\n<li>Vue.js是目前很火的前端框架；与Angualr.js和React.js并称为前端三大主流框架。</li>\n<li>Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，</li>\n<li>在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。</li>\n</ul>\n<hr>\n<h3 id=\"后端的MVC和前端的MVVM之间的区别\"><a href=\"#后端的MVC和前端的MVVM之间的区别\" class=\"headerlink\" title=\"后端的MVC和前端的MVVM之间的区别\"></a>后端的MVC和前端的MVVM之间的区别</h3><ul>\n<li><p>MVC是后端的分层开发概念</p>\n</li>\n<li><p>MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）</p>\n</li>\n<li><p>Model： 页面需要展示的数据</p>\n</li>\n<li><p>View: 视图、HTML</p>\n</li>\n<li><p>VM: 数据（Model）和视图（View）之间的调度者</p>\n</li>\n</ul>\n<p><strong>图解</strong><br><img src=\"/images/vue1.png\" alt=\"vue图解\"></p>\n<hr>\n<h3 id=\"入门案例\"><a href=\"#入门案例\" class=\"headerlink\" title=\"入门案例\"></a>入门案例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- 插值表达式 --&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123;     // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'Hello Vue!'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<p>1、首先需要引入Vue.js<br>2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到<br>3、创建Vue实例，这个实例其实就是MVVM中的vm调度者<br>4、el: 表示当时Vue实例的控制区域；data: 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。<br>5、在指定Vue实例区域下，展示我们已经声明的元素msg，使用：即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）</p>\n<hr>\n<h3 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h3><h4 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h4><p>在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在vue.js还没有加载完毕时，视图层不会将识别为Vue中的插值表达式，而是作为字符串显示到页面上。<br>为了解决这个问题，Vue.js提供了v-cloak指令，可以解决插值表达式闪烁的问题。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>扩展</strong></p>\n<p>解决插值表达式闪烁问题，除了v-cloak指令，Vue还提供了v-text指令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-text=<span class=\"string\">\"msg\"</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>v-cloak与v-text的区别</strong><br>v-text默认会覆盖掉元素中原有的内容<br>v-cloak不会覆盖掉原有的内容<br><img src=\"/images/vue2.png\" alt=\"vue2\"></p>\n<h4 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h4><p><strong>在上面，我们了解了v-text输出Vue元素，但是如果我们需要显示的数据是一段HTML代码，v-text和都将无能为力，<br>为此，Vue提供了专门渲染HTML数据的指令：v-html</strong></p>\n<p><img src=\"/images/vue3.png\" alt=\"vue3\"></p>\n<p>上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用）这样可以吗？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"msg\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。<br>为了解决上述问题，Vue提供了v-bind:指令来绑定一些HTML属性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> v-bind:value=<span class=\"string\">\"msg\"</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，被v-bind:绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外v-bind:还有一个简易写法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"msg\"</span> /&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> v-bind:value=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'戳我'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果如图：<br><img src=\"/images/vue4.png\" alt=\"vue4\"></p>\n<h4 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h4><p>Vue提供了事件绑定机制的指令：v-on:；用其我们可以用来绑定一些常见的触发事件：click、mouseover …</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span> v-on:click=<span class=\"string\">\"show\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> :value=<span class=\"string\">\"msg\"</span> v-on:mouseover=<span class=\"string\">\"show\"</span>&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'戳我'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            show: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">                alert(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中methods是Vue内置的对象，用于存放一些自定义的方法函数</p>\n<p><strong>拓展</strong></p>\n<p>使用js内置的函数setInterval(定时器)，实现跑马灯效果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"开始\"</span> @click=<span class=\"string\">\"action\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"停止\"</span> @click=<span class=\"string\">\"stop\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'嘻嘻，哈哈'</span>,</span><br><span class=\"line\">            intervalId: null</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">action</span></span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(this.intervalId != null) <span class=\"built_in\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                // 定时器</span><br><span class=\"line\">                this.intervalId = setInterval(() =&gt; &#123;</span><br><span class=\"line\">                    // 截取首字符</span><br><span class=\"line\">                    var start = this.msg.substring(0, 1);</span><br><span class=\"line\">                    // 截取第一个字符后的所有字符</span><br><span class=\"line\">                    var end = this.msg.substring(1);</span><br><span class=\"line\">                    // 将后面的字符拼接到前面，实现循环的效果</span><br><span class=\"line\">                    this.msg = end + start;</span><br><span class=\"line\">                &#125;,400)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">stop</span></span>()&#123;</span><br><span class=\"line\">                // 停止定时器</span><br><span class=\"line\">                clearInterval(this.intervalId)</span><br><span class=\"line\">                // 每次清除定时器后需要将intervalId重新设置为null</span><br><span class=\"line\">                this.intervalId = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<p>1、v-on:也有简写形式：@，用法如上。<br>2、在视图层取VM中的数据我们可以使用或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：this.数据属性名（其中的this表示当前VM实例对象）。<br>3、methodName:function(){}在ES6中有一个简便的写法：methodName(){}。 4、setInterval()和clearInterval()是js中内置的函数，用法如上。<br>5、正常我们调用函数会写：name(function(){})，而ES6也提供了一个方式：methodName(() =&gt; {})，这种用法的好处就解决了this指向问题，因为如果元素定义在了函数内部，那么其中的this就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的=&gt;。</p>\n<p>效果如图：<br><img src=\"/images/vue5.png\" alt=\"vue5\"></p>\n<h4 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h4><blockquote>\n<p>.stop 阻止冒泡<br>.prevent 阻止默认事件<br>.capture 添加时间侦听器时使用时间捕获模式<br>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调<br>.once 事件只触发一次</p>\n</blockquote>\n<p>用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;div @click=<span class=\"string\">\"divClick\"</span>&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"戳我\"</span> @click.stop=<span class=\"string\">\"btnClick\"</span>&gt;</span><br><span class=\"line\">        &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> value=<span class=\"string\">\"戳我\"</span> @click.prevent=<span class=\"string\">\"btnClick\"</span>&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'嘻嘻，哈哈'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">divClick</span></span>() &#123;</span><br><span class=\"line\">                console.log(<span class=\"string\">\"这是div的点击事件\"</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">btnClick</span></span>() &#123;</span><br><span class=\"line\">                console.log(<span class=\"string\">\"这是btn的点击事件\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h4><ul>\n<li>唯一的双向绑定指令：v-model</li>\n<li>单向绑定指令：v-bing</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> v-model=<span class=\"string\">\"msg\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            msg: <span class=\"string\">'hello!'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"Vue中的样式\"><a href=\"#Vue中的样式\" class=\"headerlink\" title=\"Vue中的样式\"></a>Vue中的样式</h3><h4 id=\"外联样式\"><a href=\"#外联样式\" class=\"headerlink\" title=\"外联样式\"></a>外联样式</h4><ul>\n<li><p>数组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"['italic','color']\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n<p>其中的italic、color是自定义的类名，需在外部定义CSS样式</p>\n</li>\n<li><p>数组中嵌套对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"['italic',&#123;'color': flag&#125;]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n<p>其中的flag是Vue绑定的变量，在data进行声明</p>\n</li>\n<li><p>直接使用对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :class=<span class=\"string\">\"&#123;italic:true, color:flag&#125;\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .italic &#123;</span><br><span class=\"line\">        font-style: italic;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .color &#123;</span><br><span class=\"line\">        color: skyblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"['italic','color']\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"['italic', &#123;'color':flag&#125;]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :class=<span class=\"string\">\"&#123;italic:false, color:flag&#125;\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            flag: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内联样式\"><a href=\"#内联样式\" class=\"headerlink\" title=\"内联样式\"></a>内联样式</h4><ul>\n<li><p>将样式对象定义到data中，并在:style中引用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :style=<span class=\"string\">\"styleObj\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在:style中通过数组，引用多个data上的样式对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2 :style=<span class=\"string\">\"[styleObj, styleObj2]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span>&#125;,</span><br><span class=\"line\">    styleObj2: &#123; <span class=\"string\">'font-style'</span>: <span class=\"string\">'italic'</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;h2 :style=<span class=\"string\">\"styleObj\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">    &lt;h2 :style=<span class=\"string\">\"[styleObj, styleObj2]\"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            styleObj: &#123; <span class=\"string\">'color'</span>: <span class=\"string\">'red'</span>, <span class=\"string\">'font-weight'</span>: <span class=\"string\">'200px'</span> &#125;,</span><br><span class=\"line\">            styleObj2: &#123; <span class=\"string\">'font-style'</span>: <span class=\"string\">'italic'</span> &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h4><p>Vue提供了遍历集合、数组的指令：v-for；用法: v-for=”别名 in 集合名”</p>\n<h4 id=\"迭代数组\"><a href=\"#迭代数组\" class=\"headerlink\" title=\"迭代数组\"></a>迭代数组</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item, i in list\"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    list: [1,2,3,4]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>其中的i是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义</strong></p>\n<h4 id=\"迭代对象数组\"><a href=\"#迭代对象数组\" class=\"headerlink\" title=\"迭代对象数组\"></a>迭代对象数组</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item in list2\"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    list2: [</span><br><span class=\"line\">            &#123; id:1, name: <span class=\"string\">'嘻嘻'</span> &#125;,</span><br><span class=\"line\">            &#123; id:2, name: <span class=\"string\">'哈哈'</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>迭代对象数组，通过 的方式，这个属性名就是对象数组中定义的元素属性名</strong></p>\n<h4 id=\"迭代对象\"><a href=\"#迭代对象\" class=\"headerlink\" title=\"迭代对象\"></a>迭代对象</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"(val, key) in user\"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">            id: 1,</span><br><span class=\"line\">            name: <span class=\"string\">'LoonyCoder'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>迭代对象，迭代得到的是对象的value值和key值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。</strong></p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"item, i in list\"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"item in list2\"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p v-for=<span class=\"string\">\"(val, key) in user\"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            list: [1,2,3,4], </span><br><span class=\"line\">            list2: [</span><br><span class=\"line\">                &#123; id:1, name: <span class=\"string\">'嘻嘻'</span> &#125;,</span><br><span class=\"line\">                &#123; id:2, name: <span class=\"string\">'哈哈'</span> &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            user: &#123;</span><br><span class=\"line\">                id: 1,</span><br><span class=\"line\">                name: <span class=\"string\">'LoonyCoder'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>在vue2.0+版本里，当使用v-for渲染数据，必须制定对应的key值（这里的key是一个属性，不是前面迭代的key值）。</p>\n<p><strong>用法：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-for=<span class=\"string\">\"item in user\"</span> :key=<span class=\"string\">\"item.id\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>其中:key就说明了key属性必须是通过v-bind绑定的元素，而:key=””中指定的值必须是string/number类型的值，比如此处使用的是item.id中ID是number值，并且是唯一的。<br><strong>目的：</strong><br>避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。</p>\n<h4 id=\"v-show和v-if\"><a href=\"#v-show和v-if\" class=\"headerlink\" title=\"v-show和v-if\"></a>v-show和v-if</h4><p>Vue提供了两个指令来实现元素显示状态的切换：v-if v-show<br><strong>区别</strong></p>\n<ul>\n<li>v-if的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。</li>\n<li>v-show的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的display:none样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"button\"</span> @click=<span class=\"string\">\"flag=!flag\"</span> value=<span class=\"string\">\"toggle\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;h3 v-if=<span class=\"string\">\"flag\"</span>&gt;这是v-if控制的元素&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3 v-show=<span class=\"string\">\"flag\"</span>&gt;这是v-show控制的元素&lt;/h3&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- js部分 --&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"../lib/vue.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class=\"line\">    var vm = new Vue(&#123;</span><br><span class=\"line\">        el: <span class=\"string\">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class=\"line\">        data: &#123; // data中存放的是el中需要的数据</span><br><span class=\"line\">            flag: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果如下：<br><img src=\"/images/vue6.png\" alt=\"vue6\"></p>\n"},{"title":"杂记","date":"2020-02-13T16:00:00.000Z","_content":"\n近些日子在拉勾网上看到了史上最难Java题，顺便答了一下，结果10道题错了6道，表示十分遗憾。后愤然去网上搜集各种资料，果然还是太年轻，于此记录以告诫自己，学无止境！\n\n### Apache Dubbo的默认集群容错方案\n\nA、Failover Cluster\nB、Failfast Cluster\nC、Failsafe Cluster\nD、Failback Cluster\n\n**答案：A**\n\n**解析：**\nDubbo提供了随机、轮询、最少调用优先等多种负载均衡策略，提供对zk等多种注册中心等支持，能够自动完成服务的注册与发现。Dubbo提供可视化的管理后台，方便对服务状态进行监控和管理。dubbo的数据通信默认使用netty来实现，拥有非常不错的性能。Dubbo默认的容错方案是Failover Cluster，即：失败自动切换，当出现失败，重试其它服务器。\n\n除此之外，还提供以下其他容错方式：\n\n- Failfast Cluster\n快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n- Failsafe Cluster\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n- Failback Cluster\n失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n- Forking Cluster\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n- Broadcast Cluster\n广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n\n---\n\n### 下面关于Kafka说法错误的是:\n\nA、消息是按照topic进行划分的，一个topic就是一个queue，一个topic可以有多个消费方，当生产方在某个topic发出一条消息后，所有订阅了这个topic的消费方都可以接受到这条消息\nB、kafka为每个topic维护了多个partition分区，能保证一个topic的消息消费有序\nC、所有的消息读写都是在主partition中进行，其他副本分区只会从主分区复制数据\nD、消息的发送有三种方式：同步、异步、以及oneway，异步为默认方式\n\n**答案：B、D**\n\n**解析：**\n![kafka](/images/kafka1.png)\n![kafka](/images/kafka2.png)\nKafka只保证一个分区内的消息有序，**不能保证一个topic的不同分区之间的消息有序。**\n为了保证较高的处理效率，所有的消息读写都是在主patition中进行，其他副本分区只会从主分区复制数据。Kafka会在Zookeeper上针对每个Topic维护一个称为ISR(in-sync replica)，就是已同步的副本集。如果某个主分区不可用了，Kafka就会从ISR集合中选择一个副本作为新的主分区。\n消息的发送有三种方式：同步、异步以及oneway。**同步模式下后台线程中发送消息时同步获取结果，这也是默认模式。**\n异步的模式允许生产者批量发送数据，可以极大的提高性能，但是会增加丢失数据的风险。oneway模式只发送消息不需要返回发送结果，消息可靠性最低，但是低延迟、高吞吐，适用于对可靠性要求不高的场景。\n\n---\n\n### 下面关于排序算法的描述正确的是:\n\nA、冒泡排序和插入排序都是稳定的排序算法\nB、如果数组已经按照顺序排好序，使用插入排序，时间复杂度是O(n)\nC、快速排序每次选择最大值座位基准值能够加入排序过程\nD、快速排序最好情况的时间复杂度是O(nlogn)\n\n**答案：A、B、D**\n\n**解析：**\n快速排序时间复杂度：\n1、 最优情况：被选出来的基准值都是当前子数组的中间数。\n不断地把一个规模为 n 的问题分解成规模为 n/2 的问题，一直分解到规模大小为 1。如果 n 等于 2，只需要分一次;如果 n 等于 4，需要分 2 次，以此类推，对于规模为 n 的问题，一共要进行 log(n) 次的切分。\n把规模大小为 n 的问题分解成 n/2 的两个子问题时，和基准值进行了 n-1 次比较，复杂度就是 O(n)。\n因此，在最优情况下，快速排序的复杂度是 O(nlogn)。\n\n2、最坏情况：基准值选择了子数组里的最大或者最小值\n每次都把子数组分成了两个更小的子数组，其中一个的长度为 1，另外一个的长度只比原子数组少 1，这样就需要n次的切分。\n因此，算法复杂度为 O(n²)。\n\n---\n\n### 以下有关JVM的说法正确的是:\n\nA、程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的。\nB、虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的。\nC、方法区用于存储JVM加载的类信息、常量、静态变量、以及编译器编译后的代码等数据，是线程共享的。\nD、堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用空间时，会抛出OOM异常\n\n**答案：A、B、C、D**\n\n**解析：**\n**虚拟机栈** 也叫方法栈，是线程私有的，线程在执行每个方法时都会同时创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。\n**本地方法栈** 与虚拟机栈类似，也是用来保存线程执行方法时的信息，不同的是，执行java方法使用虚拟机栈，而执行native方法使用本地方法栈。\n**程序计数器** 保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器。程序计数器为执行java方法服务，执行native方法时，程序计数器为空。\n栈、本地方法栈、程序计数器这三个部分都是线程独占的。\n**堆** 是JVM管理的内存中最大的一块，堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用的空间时，会抛出OOM异常。根据对象存活的周期不同，jvm把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理。\n方法区 也是各个线程共享的内存区域，又叫非堆区。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，JDK7中的永久代和JDK8中的Metaspace都是方法区的一种实现。\n\n---\n\n### 关于TCP的关闭过程，说法正确的是:\n\nA、处于TIME_WAIT状态的连接等待2MSL后真正关闭连接\nB、对一个established状态的TCP连接，在调用shutdown函数之前调用close接口，可以让主动调用的一方进入半关闭状态\nC、主动发送FIN消息的连接端，收到对方回应ack之前不能发只能收，在收到对方回复ack之后不能发也不能收，进入CLOSING状态\nD、虽然TCP是可靠传输，但在已经成功建立连接的TCP连接上，也可能存在报文丢失\n\n**答案：A、D**\n\n**解析：**\n![TCP](/images/tcp1.png)\nA、等待2倍最大报文段生存时间之后在关闭链接，原因有两个：\n- 一、保证TCP协议的全双工连接能够可靠关闭\n- 二、保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆\n\nB、shutdown可以使TCP半双工，但是如果之前调用了close，则直接关闭了socket\n\nC、收到了ack之后的状态，也是不能发只能收，进入FIN_WAIT_2\n通信中client和server两端的链接都是ESTABLISHED状态，然后client先主动发起了关闭链接请求，client向server发送了一个fin包，表示client端已经没有数据要发送了，然后client进入了FIN_WAIT_1状态。\nserver端收到fin后，返回ack，然后进入CLOSE_WAIT状态。此时server属于半关闭状态，因为此时client向server方向已经不会发送数据了，可是server向client端可能还有数据要发送。\n当server端数据发送完毕后，server端会向client端发送fin，表示server端也没有数据要发送了，此时server进入LAST_ACK状态，就等待client的应答就可以关闭链接了。\nclient端收到server端的fin后，回复ack，然后进入TIME_WAIT状态。TIME_WAIT状态下需要等待2倍的最大报文段生存时间，来保证链接的可靠关闭。之后才会进入CLOSED关闭状态。而server端收到ack后直接就进入CLOSED状态。\n\nD、由于TCP的下层网络（IP）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。\n\n---\n\n### 关于B+树比B树更适合做索引，以下说法正确的是:\n\nA、叶节点之间有指针相连，B+树更适合范围检索\nB、非叶节点只保存关键字和指针，同样大小非叶节点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低\nC、B+树的查询效率比较稳定。任何关键字的查找必须走一条从根节点到叶节点的路。所有关键字查询的路径长度相同，效率相当\nD、非叶节点上，增加了指向同一层下一个非叶节点的指针，将节点的最低利用率从1/2提高到2/3\n\n**答案：A、B、C**\n\n**解析：**\nB+树更适合索引系统，原因有：\n1、由于叶节点之间有指针相连，B+树更适合范围检索;\n2、由于非叶节点只保存关键字和指针，同样大小非叶节点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低;\n3、B+树的查询效率比较稳定。任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，效率相当。\n\n---\n\n### 以下关于Netty说法，正确的是:\n\nA、Netty线程模型采用\"服务端监听线程\"和\"IO线程\"分离的方式\nB、通常情况下在NIO非阻塞模式下，Netty为每个Channel分配一个EventLoop，并且它的整个生命周期的时间都由这个EventLoop来处理\nC、一个EventLoop可以绑定多个Channel\nD、一般接收消息时，由pipeline处理完成会把消息提交到业务线程池进行处理\n\n**答案：A、B、C、D**\n\n**解析：**\nNetty线程模型采用“服务端监听线程”和“IO线程”分离的方式，boss线程组负责监听事件，创建socket并绑定到Worker线程组。\nWorker线程组负责IO处理。线程组由EventLoopGroup实现，其中包含了多个EventLoop事件处理器，每个EventLoop包含一个处理线程。\n通常情况下在NIO非阻塞模式下，Netty为每个Channel分配一个EventLoop，并且它的整个生命周期中的事件都由这个EventLoop来处理。\n一个EventLoop可以绑定多个Channel。\nEventLoop的处理模型，Netty4中Channel的读写事件都是由Worker线程来处理。\n请求处理中最主要的就是ChannelPipeline，其中包含了一组ChannelHandler。\n这些Handler组成了责任链模式，依次对Channel中的消息进行处理。\n一般接收消息时，由pipeline处理完成会把消息提交到业务线程池进行处理，当业务线程处理完成时，会封装成task，提交回Channel对应的EventLoop来写回返回值。\n\n### Mybatis在执行SQL时，正确的调用顺序是:\n\n①SqlSessionFactory\n②SqlSession\n③StatementHandler\n④ParameterHandler\n⑤ResultSetHandler\n⑥Executor\n⑦TypeHandler\n\nA、①②③④⑤⑥⑦\nB、①②⑥③④⑦⑤\nC、①②④③⑦⑥⑤\nD、①②③⑦④⑥⑤\n\n**答案：B**\n\n**解析：**\n![mybatisflow](/images/mybatisflow.png)\n在执行sql时，首先会从SqlSessionFactory中创建一个新的SqlSession。\nsql语句是通过sqlSession中的Executor来执行，Executor根据SqlSession传递的参数执行query()方法，然后创建一个StatementHandler对象，将必要的参数传递给StatementHandler，由StatementHandler来完成对数据库的查询。\nStatementHandler调用ParameterHandler的setParameters方法，把用户传递的参数转换成JDBC Statement所需要的参数， 调用原生JDBC来执行语句。\n最后由ResultSetHandler的handleResultSets方法对JDBC返回的ResultSet结果集转换成对象集，并逐级返回结果，完成一次sql语句执行。\n\n---\n\n### 以下关于向线程池提交任务，正确的步骤是:\n\n①判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务\n②判断线程池中的线程数是否大于设置的核心线程数，创建核心线程执行任务\n③判断缓冲队列是否满了，如果没满，放入队列等待执行\n④执行拒绝策略\n\nA、②①③④\nB、②③①④\nC、①②③④\nD、①③②④\n\n**答案：B**\n\n**解析：**\n![thread](/images/thread.png)\n我们看看向线程池提交任务时的执行顺序。\n向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。\n如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。\n如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。\n如果已经达到了最大线程数，则执行指定的拒绝策略。\n\n---\n\n### 以下关于类的加载机制错误的是:\n\nA、类的加载指的是将编译好的class类文件中的字节码读入到内存中，将其放在堆内并创建对应的Class对象\nB、加载是文件到内存的过程。通过类的完全限定名查找类字节码文件，并利用字节码文件创建一个Class对象\nC、准备阶段是进行内存分配。为类变量也就是类中由static修饰的变量分配内存，并且设置初始值是0或者null，而不是代码中设置的具体值\nD、解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。\n\n**答案：A**\n\n**解析：**\n![classloader](/images/classloader.png)\n类的加载指的是将编译好的class类文件中的字节码读入到内存中，将其放在方法区内并创建对应的Class对象。\n类的加载分为加载、链接、初始化，其中链接又包括验证、准备、解析三步。\n看到图中上半部分深绿色，我们逐个分析：\n加载是文件到内存的过程。通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个Class对象\n验证是对类文件内容验证。目的在于确保Class文件符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种：\n文件格式验证，元数据验证，字节码验证，符号引用验证。\n准备阶段是进行内存分配。为类变量也就是类中由static修饰的变量分配内存，并且设置初始值，这里要注意，初始值是0或者null，而不是代码中设置的具体值，代码中设置的值是在初始化阶段完成的。另外这里也不包含用final修饰的静态变量，因为final在编译的时候就会分配了。\n解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。\n最后是初始化：主要完成静态块执行与静态变量的赋值。这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。\n只有对类主动使用时，才会进行初始化，初始化的触发条件包括创建类的实例的时候、访问类的静态方法或者静态变量的时候、Class.forName()反射类的时候、或者某个子类被初始化的时候。\n\n","source":"_posts/interview.md","raw":"---\ntitle: 杂记\ncategories:\n    - Interview\n    \ndate: 2020-2-14\ntags:\n\t- Java\n    - 面试题\n---\n\n近些日子在拉勾网上看到了史上最难Java题，顺便答了一下，结果10道题错了6道，表示十分遗憾。后愤然去网上搜集各种资料，果然还是太年轻，于此记录以告诫自己，学无止境！\n\n### Apache Dubbo的默认集群容错方案\n\nA、Failover Cluster\nB、Failfast Cluster\nC、Failsafe Cluster\nD、Failback Cluster\n\n**答案：A**\n\n**解析：**\nDubbo提供了随机、轮询、最少调用优先等多种负载均衡策略，提供对zk等多种注册中心等支持，能够自动完成服务的注册与发现。Dubbo提供可视化的管理后台，方便对服务状态进行监控和管理。dubbo的数据通信默认使用netty来实现，拥有非常不错的性能。Dubbo默认的容错方案是Failover Cluster，即：失败自动切换，当出现失败，重试其它服务器。\n\n除此之外，还提供以下其他容错方式：\n\n- Failfast Cluster\n快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n- Failsafe Cluster\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n- Failback Cluster\n失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n- Forking Cluster\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n- Broadcast Cluster\n广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n\n---\n\n### 下面关于Kafka说法错误的是:\n\nA、消息是按照topic进行划分的，一个topic就是一个queue，一个topic可以有多个消费方，当生产方在某个topic发出一条消息后，所有订阅了这个topic的消费方都可以接受到这条消息\nB、kafka为每个topic维护了多个partition分区，能保证一个topic的消息消费有序\nC、所有的消息读写都是在主partition中进行，其他副本分区只会从主分区复制数据\nD、消息的发送有三种方式：同步、异步、以及oneway，异步为默认方式\n\n**答案：B、D**\n\n**解析：**\n![kafka](/images/kafka1.png)\n![kafka](/images/kafka2.png)\nKafka只保证一个分区内的消息有序，**不能保证一个topic的不同分区之间的消息有序。**\n为了保证较高的处理效率，所有的消息读写都是在主patition中进行，其他副本分区只会从主分区复制数据。Kafka会在Zookeeper上针对每个Topic维护一个称为ISR(in-sync replica)，就是已同步的副本集。如果某个主分区不可用了，Kafka就会从ISR集合中选择一个副本作为新的主分区。\n消息的发送有三种方式：同步、异步以及oneway。**同步模式下后台线程中发送消息时同步获取结果，这也是默认模式。**\n异步的模式允许生产者批量发送数据，可以极大的提高性能，但是会增加丢失数据的风险。oneway模式只发送消息不需要返回发送结果，消息可靠性最低，但是低延迟、高吞吐，适用于对可靠性要求不高的场景。\n\n---\n\n### 下面关于排序算法的描述正确的是:\n\nA、冒泡排序和插入排序都是稳定的排序算法\nB、如果数组已经按照顺序排好序，使用插入排序，时间复杂度是O(n)\nC、快速排序每次选择最大值座位基准值能够加入排序过程\nD、快速排序最好情况的时间复杂度是O(nlogn)\n\n**答案：A、B、D**\n\n**解析：**\n快速排序时间复杂度：\n1、 最优情况：被选出来的基准值都是当前子数组的中间数。\n不断地把一个规模为 n 的问题分解成规模为 n/2 的问题，一直分解到规模大小为 1。如果 n 等于 2，只需要分一次;如果 n 等于 4，需要分 2 次，以此类推，对于规模为 n 的问题，一共要进行 log(n) 次的切分。\n把规模大小为 n 的问题分解成 n/2 的两个子问题时，和基准值进行了 n-1 次比较，复杂度就是 O(n)。\n因此，在最优情况下，快速排序的复杂度是 O(nlogn)。\n\n2、最坏情况：基准值选择了子数组里的最大或者最小值\n每次都把子数组分成了两个更小的子数组，其中一个的长度为 1，另外一个的长度只比原子数组少 1，这样就需要n次的切分。\n因此，算法复杂度为 O(n²)。\n\n---\n\n### 以下有关JVM的说法正确的是:\n\nA、程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的。\nB、虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的。\nC、方法区用于存储JVM加载的类信息、常量、静态变量、以及编译器编译后的代码等数据，是线程共享的。\nD、堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用空间时，会抛出OOM异常\n\n**答案：A、B、C、D**\n\n**解析：**\n**虚拟机栈** 也叫方法栈，是线程私有的，线程在执行每个方法时都会同时创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。\n**本地方法栈** 与虚拟机栈类似，也是用来保存线程执行方法时的信息，不同的是，执行java方法使用虚拟机栈，而执行native方法使用本地方法栈。\n**程序计数器** 保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器。程序计数器为执行java方法服务，执行native方法时，程序计数器为空。\n栈、本地方法栈、程序计数器这三个部分都是线程独占的。\n**堆** 是JVM管理的内存中最大的一块，堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用的空间时，会抛出OOM异常。根据对象存活的周期不同，jvm把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理。\n方法区 也是各个线程共享的内存区域，又叫非堆区。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，JDK7中的永久代和JDK8中的Metaspace都是方法区的一种实现。\n\n---\n\n### 关于TCP的关闭过程，说法正确的是:\n\nA、处于TIME_WAIT状态的连接等待2MSL后真正关闭连接\nB、对一个established状态的TCP连接，在调用shutdown函数之前调用close接口，可以让主动调用的一方进入半关闭状态\nC、主动发送FIN消息的连接端，收到对方回应ack之前不能发只能收，在收到对方回复ack之后不能发也不能收，进入CLOSING状态\nD、虽然TCP是可靠传输，但在已经成功建立连接的TCP连接上，也可能存在报文丢失\n\n**答案：A、D**\n\n**解析：**\n![TCP](/images/tcp1.png)\nA、等待2倍最大报文段生存时间之后在关闭链接，原因有两个：\n- 一、保证TCP协议的全双工连接能够可靠关闭\n- 二、保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆\n\nB、shutdown可以使TCP半双工，但是如果之前调用了close，则直接关闭了socket\n\nC、收到了ack之后的状态，也是不能发只能收，进入FIN_WAIT_2\n通信中client和server两端的链接都是ESTABLISHED状态，然后client先主动发起了关闭链接请求，client向server发送了一个fin包，表示client端已经没有数据要发送了，然后client进入了FIN_WAIT_1状态。\nserver端收到fin后，返回ack，然后进入CLOSE_WAIT状态。此时server属于半关闭状态，因为此时client向server方向已经不会发送数据了，可是server向client端可能还有数据要发送。\n当server端数据发送完毕后，server端会向client端发送fin，表示server端也没有数据要发送了，此时server进入LAST_ACK状态，就等待client的应答就可以关闭链接了。\nclient端收到server端的fin后，回复ack，然后进入TIME_WAIT状态。TIME_WAIT状态下需要等待2倍的最大报文段生存时间，来保证链接的可靠关闭。之后才会进入CLOSED关闭状态。而server端收到ack后直接就进入CLOSED状态。\n\nD、由于TCP的下层网络（IP）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。\n\n---\n\n### 关于B+树比B树更适合做索引，以下说法正确的是:\n\nA、叶节点之间有指针相连，B+树更适合范围检索\nB、非叶节点只保存关键字和指针，同样大小非叶节点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低\nC、B+树的查询效率比较稳定。任何关键字的查找必须走一条从根节点到叶节点的路。所有关键字查询的路径长度相同，效率相当\nD、非叶节点上，增加了指向同一层下一个非叶节点的指针，将节点的最低利用率从1/2提高到2/3\n\n**答案：A、B、C**\n\n**解析：**\nB+树更适合索引系统，原因有：\n1、由于叶节点之间有指针相连，B+树更适合范围检索;\n2、由于非叶节点只保存关键字和指针，同样大小非叶节点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低;\n3、B+树的查询效率比较稳定。任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，效率相当。\n\n---\n\n### 以下关于Netty说法，正确的是:\n\nA、Netty线程模型采用\"服务端监听线程\"和\"IO线程\"分离的方式\nB、通常情况下在NIO非阻塞模式下，Netty为每个Channel分配一个EventLoop，并且它的整个生命周期的时间都由这个EventLoop来处理\nC、一个EventLoop可以绑定多个Channel\nD、一般接收消息时，由pipeline处理完成会把消息提交到业务线程池进行处理\n\n**答案：A、B、C、D**\n\n**解析：**\nNetty线程模型采用“服务端监听线程”和“IO线程”分离的方式，boss线程组负责监听事件，创建socket并绑定到Worker线程组。\nWorker线程组负责IO处理。线程组由EventLoopGroup实现，其中包含了多个EventLoop事件处理器，每个EventLoop包含一个处理线程。\n通常情况下在NIO非阻塞模式下，Netty为每个Channel分配一个EventLoop，并且它的整个生命周期中的事件都由这个EventLoop来处理。\n一个EventLoop可以绑定多个Channel。\nEventLoop的处理模型，Netty4中Channel的读写事件都是由Worker线程来处理。\n请求处理中最主要的就是ChannelPipeline，其中包含了一组ChannelHandler。\n这些Handler组成了责任链模式，依次对Channel中的消息进行处理。\n一般接收消息时，由pipeline处理完成会把消息提交到业务线程池进行处理，当业务线程处理完成时，会封装成task，提交回Channel对应的EventLoop来写回返回值。\n\n### Mybatis在执行SQL时，正确的调用顺序是:\n\n①SqlSessionFactory\n②SqlSession\n③StatementHandler\n④ParameterHandler\n⑤ResultSetHandler\n⑥Executor\n⑦TypeHandler\n\nA、①②③④⑤⑥⑦\nB、①②⑥③④⑦⑤\nC、①②④③⑦⑥⑤\nD、①②③⑦④⑥⑤\n\n**答案：B**\n\n**解析：**\n![mybatisflow](/images/mybatisflow.png)\n在执行sql时，首先会从SqlSessionFactory中创建一个新的SqlSession。\nsql语句是通过sqlSession中的Executor来执行，Executor根据SqlSession传递的参数执行query()方法，然后创建一个StatementHandler对象，将必要的参数传递给StatementHandler，由StatementHandler来完成对数据库的查询。\nStatementHandler调用ParameterHandler的setParameters方法，把用户传递的参数转换成JDBC Statement所需要的参数， 调用原生JDBC来执行语句。\n最后由ResultSetHandler的handleResultSets方法对JDBC返回的ResultSet结果集转换成对象集，并逐级返回结果，完成一次sql语句执行。\n\n---\n\n### 以下关于向线程池提交任务，正确的步骤是:\n\n①判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务\n②判断线程池中的线程数是否大于设置的核心线程数，创建核心线程执行任务\n③判断缓冲队列是否满了，如果没满，放入队列等待执行\n④执行拒绝策略\n\nA、②①③④\nB、②③①④\nC、①②③④\nD、①③②④\n\n**答案：B**\n\n**解析：**\n![thread](/images/thread.png)\n我们看看向线程池提交任务时的执行顺序。\n向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。\n如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。\n如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。\n如果已经达到了最大线程数，则执行指定的拒绝策略。\n\n---\n\n### 以下关于类的加载机制错误的是:\n\nA、类的加载指的是将编译好的class类文件中的字节码读入到内存中，将其放在堆内并创建对应的Class对象\nB、加载是文件到内存的过程。通过类的完全限定名查找类字节码文件，并利用字节码文件创建一个Class对象\nC、准备阶段是进行内存分配。为类变量也就是类中由static修饰的变量分配内存，并且设置初始值是0或者null，而不是代码中设置的具体值\nD、解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。\n\n**答案：A**\n\n**解析：**\n![classloader](/images/classloader.png)\n类的加载指的是将编译好的class类文件中的字节码读入到内存中，将其放在方法区内并创建对应的Class对象。\n类的加载分为加载、链接、初始化，其中链接又包括验证、准备、解析三步。\n看到图中上半部分深绿色，我们逐个分析：\n加载是文件到内存的过程。通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个Class对象\n验证是对类文件内容验证。目的在于确保Class文件符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种：\n文件格式验证，元数据验证，字节码验证，符号引用验证。\n准备阶段是进行内存分配。为类变量也就是类中由static修饰的变量分配内存，并且设置初始值，这里要注意，初始值是0或者null，而不是代码中设置的具体值，代码中设置的值是在初始化阶段完成的。另外这里也不包含用final修饰的静态变量，因为final在编译的时候就会分配了。\n解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。\n最后是初始化：主要完成静态块执行与静态变量的赋值。这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。\n只有对类主动使用时，才会进行初始化，初始化的触发条件包括创建类的实例的时候、访问类的静态方法或者静态变量的时候、Class.forName()反射类的时候、或者某个子类被初始化的时候。\n\n","slug":"interview","published":1,"updated":"2020-02-19T13:58:12.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiz30011v9s66923d2og","content":"<p>近些日子在拉勾网上看到了史上最难Java题，顺便答了一下，结果10道题错了6道，表示十分遗憾。后愤然去网上搜集各种资料，果然还是太年轻，于此记录以告诫自己，学无止境！</p>\n<h3 id=\"Apache-Dubbo的默认集群容错方案\"><a href=\"#Apache-Dubbo的默认集群容错方案\" class=\"headerlink\" title=\"Apache Dubbo的默认集群容错方案\"></a>Apache Dubbo的默认集群容错方案</h3><p>A、Failover Cluster<br>B、Failfast Cluster<br>C、Failsafe Cluster<br>D、Failback Cluster</p>\n<p><strong>答案：A</strong></p>\n<p><strong>解析：</strong><br>Dubbo提供了随机、轮询、最少调用优先等多种负载均衡策略，提供对zk等多种注册中心等支持，能够自动完成服务的注册与发现。Dubbo提供可视化的管理后台，方便对服务状态进行监控和管理。dubbo的数据通信默认使用netty来实现，拥有非常不错的性能。Dubbo默认的容错方案是Failover Cluster，即：失败自动切换，当出现失败，重试其它服务器。</p>\n<p>除此之外，还提供以下其他容错方式：</p>\n<ul>\n<li>Failfast Cluster<br>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>\n<li>Failsafe Cluster<br>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li>\n<li>Failback Cluster<br>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li>\n<li>Forking Cluster<br>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</li>\n<li>Broadcast Cluster<br>广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>\n</ul>\n<hr>\n<h3 id=\"下面关于Kafka说法错误的是\"><a href=\"#下面关于Kafka说法错误的是\" class=\"headerlink\" title=\"下面关于Kafka说法错误的是:\"></a>下面关于Kafka说法错误的是:</h3><p>A、消息是按照topic进行划分的，一个topic就是一个queue，一个topic可以有多个消费方，当生产方在某个topic发出一条消息后，所有订阅了这个topic的消费方都可以接受到这条消息<br>B、kafka为每个topic维护了多个partition分区，能保证一个topic的消息消费有序<br>C、所有的消息读写都是在主partition中进行，其他副本分区只会从主分区复制数据<br>D、消息的发送有三种方式：同步、异步、以及oneway，异步为默认方式</p>\n<p><strong>答案：B、D</strong></p>\n<p><strong>解析：</strong><br><img src=\"/images/kafka1.png\" alt=\"kafka\"><br><img src=\"/images/kafka2.png\" alt=\"kafka\"><br>Kafka只保证一个分区内的消息有序，<strong>不能保证一个topic的不同分区之间的消息有序。</strong><br>为了保证较高的处理效率，所有的消息读写都是在主patition中进行，其他副本分区只会从主分区复制数据。Kafka会在Zookeeper上针对每个Topic维护一个称为ISR(in-sync replica)，就是已同步的副本集。如果某个主分区不可用了，Kafka就会从ISR集合中选择一个副本作为新的主分区。<br>消息的发送有三种方式：同步、异步以及oneway。<strong>同步模式下后台线程中发送消息时同步获取结果，这也是默认模式。</strong><br>异步的模式允许生产者批量发送数据，可以极大的提高性能，但是会增加丢失数据的风险。oneway模式只发送消息不需要返回发送结果，消息可靠性最低，但是低延迟、高吞吐，适用于对可靠性要求不高的场景。</p>\n<hr>\n<h3 id=\"下面关于排序算法的描述正确的是\"><a href=\"#下面关于排序算法的描述正确的是\" class=\"headerlink\" title=\"下面关于排序算法的描述正确的是:\"></a>下面关于排序算法的描述正确的是:</h3><p>A、冒泡排序和插入排序都是稳定的排序算法<br>B、如果数组已经按照顺序排好序，使用插入排序，时间复杂度是O(n)<br>C、快速排序每次选择最大值座位基准值能够加入排序过程<br>D、快速排序最好情况的时间复杂度是O(nlogn)</p>\n<p><strong>答案：A、B、D</strong></p>\n<p><strong>解析：</strong><br>快速排序时间复杂度：<br>1、 最优情况：被选出来的基准值都是当前子数组的中间数。<br>不断地把一个规模为 n 的问题分解成规模为 n/2 的问题，一直分解到规模大小为 1。如果 n 等于 2，只需要分一次;如果 n 等于 4，需要分 2 次，以此类推，对于规模为 n 的问题，一共要进行 log(n) 次的切分。<br>把规模大小为 n 的问题分解成 n/2 的两个子问题时，和基准值进行了 n-1 次比较，复杂度就是 O(n)。<br>因此，在最优情况下，快速排序的复杂度是 O(nlogn)。</p>\n<p>2、最坏情况：基准值选择了子数组里的最大或者最小值<br>每次都把子数组分成了两个更小的子数组，其中一个的长度为 1，另外一个的长度只比原子数组少 1，这样就需要n次的切分。<br>因此，算法复杂度为 O(n²)。</p>\n<hr>\n<h3 id=\"以下有关JVM的说法正确的是\"><a href=\"#以下有关JVM的说法正确的是\" class=\"headerlink\" title=\"以下有关JVM的说法正确的是:\"></a>以下有关JVM的说法正确的是:</h3><p>A、程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的。<br>B、虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的。<br>C、方法区用于存储JVM加载的类信息、常量、静态变量、以及编译器编译后的代码等数据，是线程共享的。<br>D、堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用空间时，会抛出OOM异常</p>\n<p><strong>答案：A、B、C、D</strong></p>\n<p><strong>解析：</strong><br><strong>虚拟机栈</strong> 也叫方法栈，是线程私有的，线程在执行每个方法时都会同时创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。<br><strong>本地方法栈</strong> 与虚拟机栈类似，也是用来保存线程执行方法时的信息，不同的是，执行java方法使用虚拟机栈，而执行native方法使用本地方法栈。<br><strong>程序计数器</strong> 保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器。程序计数器为执行java方法服务，执行native方法时，程序计数器为空。<br>栈、本地方法栈、程序计数器这三个部分都是线程独占的。<br><strong>堆</strong> 是JVM管理的内存中最大的一块，堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用的空间时，会抛出OOM异常。根据对象存活的周期不同，jvm把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理。<br>方法区 也是各个线程共享的内存区域，又叫非堆区。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，JDK7中的永久代和JDK8中的Metaspace都是方法区的一种实现。</p>\n<hr>\n<h3 id=\"关于TCP的关闭过程，说法正确的是\"><a href=\"#关于TCP的关闭过程，说法正确的是\" class=\"headerlink\" title=\"关于TCP的关闭过程，说法正确的是:\"></a>关于TCP的关闭过程，说法正确的是:</h3><p>A、处于TIME_WAIT状态的连接等待2MSL后真正关闭连接<br>B、对一个established状态的TCP连接，在调用shutdown函数之前调用close接口，可以让主动调用的一方进入半关闭状态<br>C、主动发送FIN消息的连接端，收到对方回应ack之前不能发只能收，在收到对方回复ack之后不能发也不能收，进入CLOSING状态<br>D、虽然TCP是可靠传输，但在已经成功建立连接的TCP连接上，也可能存在报文丢失</p>\n<p><strong>答案：A、D</strong></p>\n<p><strong>解析：</strong><br><img src=\"/images/tcp1.png\" alt=\"TCP\"><br>A、等待2倍最大报文段生存时间之后在关闭链接，原因有两个：</p>\n<ul>\n<li>一、保证TCP协议的全双工连接能够可靠关闭</li>\n<li>二、保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆</li>\n</ul>\n<p>B、shutdown可以使TCP半双工，但是如果之前调用了close，则直接关闭了socket</p>\n<p>C、收到了ack之后的状态，也是不能发只能收，进入FIN_WAIT_2<br>通信中client和server两端的链接都是ESTABLISHED状态，然后client先主动发起了关闭链接请求，client向server发送了一个fin包，表示client端已经没有数据要发送了，然后client进入了FIN_WAIT_1状态。<br>server端收到fin后，返回ack，然后进入CLOSE_WAIT状态。此时server属于半关闭状态，因为此时client向server方向已经不会发送数据了，可是server向client端可能还有数据要发送。<br>当server端数据发送完毕后，server端会向client端发送fin，表示server端也没有数据要发送了，此时server进入LAST_ACK状态，就等待client的应答就可以关闭链接了。<br>client端收到server端的fin后，回复ack，然后进入TIME_WAIT状态。TIME_WAIT状态下需要等待2倍的最大报文段生存时间，来保证链接的可靠关闭。之后才会进入CLOSED关闭状态。而server端收到ack后直接就进入CLOSED状态。</p>\n<p>D、由于TCP的下层网络（IP）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。</p>\n<hr>\n<h3 id=\"关于B-树比B树更适合做索引，以下说法正确的是\"><a href=\"#关于B-树比B树更适合做索引，以下说法正确的是\" class=\"headerlink\" title=\"关于B+树比B树更适合做索引，以下说法正确的是:\"></a>关于B+树比B树更适合做索引，以下说法正确的是:</h3><p>A、叶节点之间有指针相连，B+树更适合范围检索<br>B、非叶节点只保存关键字和指针，同样大小非叶节点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低<br>C、B+树的查询效率比较稳定。任何关键字的查找必须走一条从根节点到叶节点的路。所有关键字查询的路径长度相同，效率相当<br>D、非叶节点上，增加了指向同一层下一个非叶节点的指针，将节点的最低利用率从1/2提高到2/3</p>\n<p><strong>答案：A、B、C</strong></p>\n<p><strong>解析：</strong><br>B+树更适合索引系统，原因有：<br>1、由于叶节点之间有指针相连，B+树更适合范围检索;<br>2、由于非叶节点只保存关键字和指针，同样大小非叶节点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低;<br>3、B+树的查询效率比较稳定。任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，效率相当。</p>\n<hr>\n<h3 id=\"以下关于Netty说法，正确的是\"><a href=\"#以下关于Netty说法，正确的是\" class=\"headerlink\" title=\"以下关于Netty说法，正确的是:\"></a>以下关于Netty说法，正确的是:</h3><p>A、Netty线程模型采用”服务端监听线程”和”IO线程”分离的方式<br>B、通常情况下在NIO非阻塞模式下，Netty为每个Channel分配一个EventLoop，并且它的整个生命周期的时间都由这个EventLoop来处理<br>C、一个EventLoop可以绑定多个Channel<br>D、一般接收消息时，由pipeline处理完成会把消息提交到业务线程池进行处理</p>\n<p><strong>答案：A、B、C、D</strong></p>\n<p><strong>解析：</strong><br>Netty线程模型采用“服务端监听线程”和“IO线程”分离的方式，boss线程组负责监听事件，创建socket并绑定到Worker线程组。<br>Worker线程组负责IO处理。线程组由EventLoopGroup实现，其中包含了多个EventLoop事件处理器，每个EventLoop包含一个处理线程。<br>通常情况下在NIO非阻塞模式下，Netty为每个Channel分配一个EventLoop，并且它的整个生命周期中的事件都由这个EventLoop来处理。<br>一个EventLoop可以绑定多个Channel。<br>EventLoop的处理模型，Netty4中Channel的读写事件都是由Worker线程来处理。<br>请求处理中最主要的就是ChannelPipeline，其中包含了一组ChannelHandler。<br>这些Handler组成了责任链模式，依次对Channel中的消息进行处理。<br>一般接收消息时，由pipeline处理完成会把消息提交到业务线程池进行处理，当业务线程处理完成时，会封装成task，提交回Channel对应的EventLoop来写回返回值。</p>\n<h3 id=\"Mybatis在执行SQL时，正确的调用顺序是\"><a href=\"#Mybatis在执行SQL时，正确的调用顺序是\" class=\"headerlink\" title=\"Mybatis在执行SQL时，正确的调用顺序是:\"></a>Mybatis在执行SQL时，正确的调用顺序是:</h3><p>①SqlSessionFactory<br>②SqlSession<br>③StatementHandler<br>④ParameterHandler<br>⑤ResultSetHandler<br>⑥Executor<br>⑦TypeHandler</p>\n<p>A、①②③④⑤⑥⑦<br>B、①②⑥③④⑦⑤<br>C、①②④③⑦⑥⑤<br>D、①②③⑦④⑥⑤</p>\n<p><strong>答案：B</strong></p>\n<p><strong>解析：</strong><br><img src=\"/images/mybatisflow.png\" alt=\"mybatisflow\"><br>在执行sql时，首先会从SqlSessionFactory中创建一个新的SqlSession。<br>sql语句是通过sqlSession中的Executor来执行，Executor根据SqlSession传递的参数执行query()方法，然后创建一个StatementHandler对象，将必要的参数传递给StatementHandler，由StatementHandler来完成对数据库的查询。<br>StatementHandler调用ParameterHandler的setParameters方法，把用户传递的参数转换成JDBC Statement所需要的参数， 调用原生JDBC来执行语句。<br>最后由ResultSetHandler的handleResultSets方法对JDBC返回的ResultSet结果集转换成对象集，并逐级返回结果，完成一次sql语句执行。</p>\n<hr>\n<h3 id=\"以下关于向线程池提交任务，正确的步骤是\"><a href=\"#以下关于向线程池提交任务，正确的步骤是\" class=\"headerlink\" title=\"以下关于向线程池提交任务，正确的步骤是:\"></a>以下关于向线程池提交任务，正确的步骤是:</h3><p>①判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务<br>②判断线程池中的线程数是否大于设置的核心线程数，创建核心线程执行任务<br>③判断缓冲队列是否满了，如果没满，放入队列等待执行<br>④执行拒绝策略</p>\n<p>A、②①③④<br>B、②③①④<br>C、①②③④<br>D、①③②④</p>\n<p><strong>答案：B</strong></p>\n<p><strong>解析：</strong><br><img src=\"/images/thread.png\" alt=\"thread\"><br>我们看看向线程池提交任务时的执行顺序。<br>向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。<br>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。<br>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。<br>如果已经达到了最大线程数，则执行指定的拒绝策略。</p>\n<hr>\n<h3 id=\"以下关于类的加载机制错误的是\"><a href=\"#以下关于类的加载机制错误的是\" class=\"headerlink\" title=\"以下关于类的加载机制错误的是:\"></a>以下关于类的加载机制错误的是:</h3><p>A、类的加载指的是将编译好的class类文件中的字节码读入到内存中，将其放在堆内并创建对应的Class对象<br>B、加载是文件到内存的过程。通过类的完全限定名查找类字节码文件，并利用字节码文件创建一个Class对象<br>C、准备阶段是进行内存分配。为类变量也就是类中由static修饰的变量分配内存，并且设置初始值是0或者null，而不是代码中设置的具体值<br>D、解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。</p>\n<p><strong>答案：A</strong></p>\n<p><strong>解析：</strong><br><img src=\"/images/classloader.png\" alt=\"classloader\"><br>类的加载指的是将编译好的class类文件中的字节码读入到内存中，将其放在方法区内并创建对应的Class对象。<br>类的加载分为加载、链接、初始化，其中链接又包括验证、准备、解析三步。<br>看到图中上半部分深绿色，我们逐个分析：<br>加载是文件到内存的过程。通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个Class对象<br>验证是对类文件内容验证。目的在于确保Class文件符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种：<br>文件格式验证，元数据验证，字节码验证，符号引用验证。<br>准备阶段是进行内存分配。为类变量也就是类中由static修饰的变量分配内存，并且设置初始值，这里要注意，初始值是0或者null，而不是代码中设置的具体值，代码中设置的值是在初始化阶段完成的。另外这里也不包含用final修饰的静态变量，因为final在编译的时候就会分配了。<br>解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。<br>最后是初始化：主要完成静态块执行与静态变量的赋值。这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。<br>只有对类主动使用时，才会进行初始化，初始化的触发条件包括创建类的实例的时候、访问类的静态方法或者静态变量的时候、Class.forName()反射类的时候、或者某个子类被初始化的时候。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>近些日子在拉勾网上看到了史上最难Java题，顺便答了一下，结果10道题错了6道，表示十分遗憾。后愤然去网上搜集各种资料，果然还是太年轻，于此记录以告诫自己，学无止境！</p>\n<h3 id=\"Apache-Dubbo的默认集群容错方案\"><a href=\"#Apache-Dubbo的默认集群容错方案\" class=\"headerlink\" title=\"Apache Dubbo的默认集群容错方案\"></a>Apache Dubbo的默认集群容错方案</h3><p>A、Failover Cluster<br>B、Failfast Cluster<br>C、Failsafe Cluster<br>D、Failback Cluster</p>\n<p><strong>答案：A</strong></p>\n<p><strong>解析：</strong><br>Dubbo提供了随机、轮询、最少调用优先等多种负载均衡策略，提供对zk等多种注册中心等支持，能够自动完成服务的注册与发现。Dubbo提供可视化的管理后台，方便对服务状态进行监控和管理。dubbo的数据通信默认使用netty来实现，拥有非常不错的性能。Dubbo默认的容错方案是Failover Cluster，即：失败自动切换，当出现失败，重试其它服务器。</p>\n<p>除此之外，还提供以下其他容错方式：</p>\n<ul>\n<li>Failfast Cluster<br>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>\n<li>Failsafe Cluster<br>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li>\n<li>Failback Cluster<br>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li>\n<li>Forking Cluster<br>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</li>\n<li>Broadcast Cluster<br>广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>\n</ul>\n<hr>\n<h3 id=\"下面关于Kafka说法错误的是\"><a href=\"#下面关于Kafka说法错误的是\" class=\"headerlink\" title=\"下面关于Kafka说法错误的是:\"></a>下面关于Kafka说法错误的是:</h3><p>A、消息是按照topic进行划分的，一个topic就是一个queue，一个topic可以有多个消费方，当生产方在某个topic发出一条消息后，所有订阅了这个topic的消费方都可以接受到这条消息<br>B、kafka为每个topic维护了多个partition分区，能保证一个topic的消息消费有序<br>C、所有的消息读写都是在主partition中进行，其他副本分区只会从主分区复制数据<br>D、消息的发送有三种方式：同步、异步、以及oneway，异步为默认方式</p>\n<p><strong>答案：B、D</strong></p>\n<p><strong>解析：</strong><br><img src=\"/images/kafka1.png\" alt=\"kafka\"><br><img src=\"/images/kafka2.png\" alt=\"kafka\"><br>Kafka只保证一个分区内的消息有序，<strong>不能保证一个topic的不同分区之间的消息有序。</strong><br>为了保证较高的处理效率，所有的消息读写都是在主patition中进行，其他副本分区只会从主分区复制数据。Kafka会在Zookeeper上针对每个Topic维护一个称为ISR(in-sync replica)，就是已同步的副本集。如果某个主分区不可用了，Kafka就会从ISR集合中选择一个副本作为新的主分区。<br>消息的发送有三种方式：同步、异步以及oneway。<strong>同步模式下后台线程中发送消息时同步获取结果，这也是默认模式。</strong><br>异步的模式允许生产者批量发送数据，可以极大的提高性能，但是会增加丢失数据的风险。oneway模式只发送消息不需要返回发送结果，消息可靠性最低，但是低延迟、高吞吐，适用于对可靠性要求不高的场景。</p>\n<hr>\n<h3 id=\"下面关于排序算法的描述正确的是\"><a href=\"#下面关于排序算法的描述正确的是\" class=\"headerlink\" title=\"下面关于排序算法的描述正确的是:\"></a>下面关于排序算法的描述正确的是:</h3><p>A、冒泡排序和插入排序都是稳定的排序算法<br>B、如果数组已经按照顺序排好序，使用插入排序，时间复杂度是O(n)<br>C、快速排序每次选择最大值座位基准值能够加入排序过程<br>D、快速排序最好情况的时间复杂度是O(nlogn)</p>\n<p><strong>答案：A、B、D</strong></p>\n<p><strong>解析：</strong><br>快速排序时间复杂度：<br>1、 最优情况：被选出来的基准值都是当前子数组的中间数。<br>不断地把一个规模为 n 的问题分解成规模为 n/2 的问题，一直分解到规模大小为 1。如果 n 等于 2，只需要分一次;如果 n 等于 4，需要分 2 次，以此类推，对于规模为 n 的问题，一共要进行 log(n) 次的切分。<br>把规模大小为 n 的问题分解成 n/2 的两个子问题时，和基准值进行了 n-1 次比较，复杂度就是 O(n)。<br>因此，在最优情况下，快速排序的复杂度是 O(nlogn)。</p>\n<p>2、最坏情况：基准值选择了子数组里的最大或者最小值<br>每次都把子数组分成了两个更小的子数组，其中一个的长度为 1，另外一个的长度只比原子数组少 1，这样就需要n次的切分。<br>因此，算法复杂度为 O(n²)。</p>\n<hr>\n<h3 id=\"以下有关JVM的说法正确的是\"><a href=\"#以下有关JVM的说法正确的是\" class=\"headerlink\" title=\"以下有关JVM的说法正确的是:\"></a>以下有关JVM的说法正确的是:</h3><p>A、程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的。<br>B、虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的。<br>C、方法区用于存储JVM加载的类信息、常量、静态变量、以及编译器编译后的代码等数据，是线程共享的。<br>D、堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用空间时，会抛出OOM异常</p>\n<p><strong>答案：A、B、C、D</strong></p>\n<p><strong>解析：</strong><br><strong>虚拟机栈</strong> 也叫方法栈，是线程私有的，线程在执行每个方法时都会同时创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。<br><strong>本地方法栈</strong> 与虚拟机栈类似，也是用来保存线程执行方法时的信息，不同的是，执行java方法使用虚拟机栈，而执行native方法使用本地方法栈。<br><strong>程序计数器</strong> 保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器。程序计数器为执行java方法服务，执行native方法时，程序计数器为空。<br>栈、本地方法栈、程序计数器这三个部分都是线程独占的。<br><strong>堆</strong> 是JVM管理的内存中最大的一块，堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用的空间时，会抛出OOM异常。根据对象存活的周期不同，jvm把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理。<br>方法区 也是各个线程共享的内存区域，又叫非堆区。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，JDK7中的永久代和JDK8中的Metaspace都是方法区的一种实现。</p>\n<hr>\n<h3 id=\"关于TCP的关闭过程，说法正确的是\"><a href=\"#关于TCP的关闭过程，说法正确的是\" class=\"headerlink\" title=\"关于TCP的关闭过程，说法正确的是:\"></a>关于TCP的关闭过程，说法正确的是:</h3><p>A、处于TIME_WAIT状态的连接等待2MSL后真正关闭连接<br>B、对一个established状态的TCP连接，在调用shutdown函数之前调用close接口，可以让主动调用的一方进入半关闭状态<br>C、主动发送FIN消息的连接端，收到对方回应ack之前不能发只能收，在收到对方回复ack之后不能发也不能收，进入CLOSING状态<br>D、虽然TCP是可靠传输，但在已经成功建立连接的TCP连接上，也可能存在报文丢失</p>\n<p><strong>答案：A、D</strong></p>\n<p><strong>解析：</strong><br><img src=\"/images/tcp1.png\" alt=\"TCP\"><br>A、等待2倍最大报文段生存时间之后在关闭链接，原因有两个：</p>\n<ul>\n<li>一、保证TCP协议的全双工连接能够可靠关闭</li>\n<li>二、保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆</li>\n</ul>\n<p>B、shutdown可以使TCP半双工，但是如果之前调用了close，则直接关闭了socket</p>\n<p>C、收到了ack之后的状态，也是不能发只能收，进入FIN_WAIT_2<br>通信中client和server两端的链接都是ESTABLISHED状态，然后client先主动发起了关闭链接请求，client向server发送了一个fin包，表示client端已经没有数据要发送了，然后client进入了FIN_WAIT_1状态。<br>server端收到fin后，返回ack，然后进入CLOSE_WAIT状态。此时server属于半关闭状态，因为此时client向server方向已经不会发送数据了，可是server向client端可能还有数据要发送。<br>当server端数据发送完毕后，server端会向client端发送fin，表示server端也没有数据要发送了，此时server进入LAST_ACK状态，就等待client的应答就可以关闭链接了。<br>client端收到server端的fin后，回复ack，然后进入TIME_WAIT状态。TIME_WAIT状态下需要等待2倍的最大报文段生存时间，来保证链接的可靠关闭。之后才会进入CLOSED关闭状态。而server端收到ack后直接就进入CLOSED状态。</p>\n<p>D、由于TCP的下层网络（IP）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。</p>\n<hr>\n<h3 id=\"关于B-树比B树更适合做索引，以下说法正确的是\"><a href=\"#关于B-树比B树更适合做索引，以下说法正确的是\" class=\"headerlink\" title=\"关于B+树比B树更适合做索引，以下说法正确的是:\"></a>关于B+树比B树更适合做索引，以下说法正确的是:</h3><p>A、叶节点之间有指针相连，B+树更适合范围检索<br>B、非叶节点只保存关键字和指针，同样大小非叶节点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低<br>C、B+树的查询效率比较稳定。任何关键字的查找必须走一条从根节点到叶节点的路。所有关键字查询的路径长度相同，效率相当<br>D、非叶节点上，增加了指向同一层下一个非叶节点的指针，将节点的最低利用率从1/2提高到2/3</p>\n<p><strong>答案：A、B、C</strong></p>\n<p><strong>解析：</strong><br>B+树更适合索引系统，原因有：<br>1、由于叶节点之间有指针相连，B+树更适合范围检索;<br>2、由于非叶节点只保存关键字和指针，同样大小非叶节点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低;<br>3、B+树的查询效率比较稳定。任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，效率相当。</p>\n<hr>\n<h3 id=\"以下关于Netty说法，正确的是\"><a href=\"#以下关于Netty说法，正确的是\" class=\"headerlink\" title=\"以下关于Netty说法，正确的是:\"></a>以下关于Netty说法，正确的是:</h3><p>A、Netty线程模型采用”服务端监听线程”和”IO线程”分离的方式<br>B、通常情况下在NIO非阻塞模式下，Netty为每个Channel分配一个EventLoop，并且它的整个生命周期的时间都由这个EventLoop来处理<br>C、一个EventLoop可以绑定多个Channel<br>D、一般接收消息时，由pipeline处理完成会把消息提交到业务线程池进行处理</p>\n<p><strong>答案：A、B、C、D</strong></p>\n<p><strong>解析：</strong><br>Netty线程模型采用“服务端监听线程”和“IO线程”分离的方式，boss线程组负责监听事件，创建socket并绑定到Worker线程组。<br>Worker线程组负责IO处理。线程组由EventLoopGroup实现，其中包含了多个EventLoop事件处理器，每个EventLoop包含一个处理线程。<br>通常情况下在NIO非阻塞模式下，Netty为每个Channel分配一个EventLoop，并且它的整个生命周期中的事件都由这个EventLoop来处理。<br>一个EventLoop可以绑定多个Channel。<br>EventLoop的处理模型，Netty4中Channel的读写事件都是由Worker线程来处理。<br>请求处理中最主要的就是ChannelPipeline，其中包含了一组ChannelHandler。<br>这些Handler组成了责任链模式，依次对Channel中的消息进行处理。<br>一般接收消息时，由pipeline处理完成会把消息提交到业务线程池进行处理，当业务线程处理完成时，会封装成task，提交回Channel对应的EventLoop来写回返回值。</p>\n<h3 id=\"Mybatis在执行SQL时，正确的调用顺序是\"><a href=\"#Mybatis在执行SQL时，正确的调用顺序是\" class=\"headerlink\" title=\"Mybatis在执行SQL时，正确的调用顺序是:\"></a>Mybatis在执行SQL时，正确的调用顺序是:</h3><p>①SqlSessionFactory<br>②SqlSession<br>③StatementHandler<br>④ParameterHandler<br>⑤ResultSetHandler<br>⑥Executor<br>⑦TypeHandler</p>\n<p>A、①②③④⑤⑥⑦<br>B、①②⑥③④⑦⑤<br>C、①②④③⑦⑥⑤<br>D、①②③⑦④⑥⑤</p>\n<p><strong>答案：B</strong></p>\n<p><strong>解析：</strong><br><img src=\"/images/mybatisflow.png\" alt=\"mybatisflow\"><br>在执行sql时，首先会从SqlSessionFactory中创建一个新的SqlSession。<br>sql语句是通过sqlSession中的Executor来执行，Executor根据SqlSession传递的参数执行query()方法，然后创建一个StatementHandler对象，将必要的参数传递给StatementHandler，由StatementHandler来完成对数据库的查询。<br>StatementHandler调用ParameterHandler的setParameters方法，把用户传递的参数转换成JDBC Statement所需要的参数， 调用原生JDBC来执行语句。<br>最后由ResultSetHandler的handleResultSets方法对JDBC返回的ResultSet结果集转换成对象集，并逐级返回结果，完成一次sql语句执行。</p>\n<hr>\n<h3 id=\"以下关于向线程池提交任务，正确的步骤是\"><a href=\"#以下关于向线程池提交任务，正确的步骤是\" class=\"headerlink\" title=\"以下关于向线程池提交任务，正确的步骤是:\"></a>以下关于向线程池提交任务，正确的步骤是:</h3><p>①判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务<br>②判断线程池中的线程数是否大于设置的核心线程数，创建核心线程执行任务<br>③判断缓冲队列是否满了，如果没满，放入队列等待执行<br>④执行拒绝策略</p>\n<p>A、②①③④<br>B、②③①④<br>C、①②③④<br>D、①③②④</p>\n<p><strong>答案：B</strong></p>\n<p><strong>解析：</strong><br><img src=\"/images/thread.png\" alt=\"thread\"><br>我们看看向线程池提交任务时的执行顺序。<br>向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。<br>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。<br>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。<br>如果已经达到了最大线程数，则执行指定的拒绝策略。</p>\n<hr>\n<h3 id=\"以下关于类的加载机制错误的是\"><a href=\"#以下关于类的加载机制错误的是\" class=\"headerlink\" title=\"以下关于类的加载机制错误的是:\"></a>以下关于类的加载机制错误的是:</h3><p>A、类的加载指的是将编译好的class类文件中的字节码读入到内存中，将其放在堆内并创建对应的Class对象<br>B、加载是文件到内存的过程。通过类的完全限定名查找类字节码文件，并利用字节码文件创建一个Class对象<br>C、准备阶段是进行内存分配。为类变量也就是类中由static修饰的变量分配内存，并且设置初始值是0或者null，而不是代码中设置的具体值<br>D、解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。</p>\n<p><strong>答案：A</strong></p>\n<p><strong>解析：</strong><br><img src=\"/images/classloader.png\" alt=\"classloader\"><br>类的加载指的是将编译好的class类文件中的字节码读入到内存中，将其放在方法区内并创建对应的Class对象。<br>类的加载分为加载、链接、初始化，其中链接又包括验证、准备、解析三步。<br>看到图中上半部分深绿色，我们逐个分析：<br>加载是文件到内存的过程。通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个Class对象<br>验证是对类文件内容验证。目的在于确保Class文件符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种：<br>文件格式验证，元数据验证，字节码验证，符号引用验证。<br>准备阶段是进行内存分配。为类变量也就是类中由static修饰的变量分配内存，并且设置初始值，这里要注意，初始值是0或者null，而不是代码中设置的具体值，代码中设置的值是在初始化阶段完成的。另外这里也不包含用final修饰的静态变量，因为final在编译的时候就会分配了。<br>解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。<br>最后是初始化：主要完成静态块执行与静态变量的赋值。这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。<br>只有对类主动使用时，才会进行初始化，初始化的触发条件包括创建类的实例的时候、访问类的静态方法或者静态变量的时候、Class.forName()反射类的时候、或者某个子类被初始化的时候。</p>\n"},{"title":"高性能的HTTP服务器——Nginx","date":"2018-11-20T16:00:00.000Z","_content":"\n![nginx](/images/nginx.jpg)\nNginx是一款高性能HTTP服务器、反向代理服务器及电子邮件（IMAP、POP3）代理服务器，官方测试nginx能够支持5万并发连接。\n**Nginx应用场景：**\n1、http服务器。Nginx是一个http服务器，可以独立提供http服务。可以做网页静态服务器。\n2、虚拟主机。可以实现在一台服务器虚拟出多个网站。\n3、反向代理，负载均衡。当网站的并发量过大需要配置服务器集群时可以使用Nginx做反向代理。并且多台服务器可以平均分摊负载。\n\n### 写在前面\n#### 本文章默认使用的软件：\n- CentOS 7\n- Nginx-1.12.2\n- JDK 8.0\n- Tomcat 8\n\n#### 开发工具：\n- VMware fusion\n- SecureCRT\n\n### 安装Nginx\n\n#### 环境准备\n1、安装gcc的环境\n```bash\nyum install gcc-c++\n```\n2、PCRE（perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式）\n```bash\nyum install -y pcre pcre-devel\n```\n3、Zlib（zlib提供了很多压缩和解压的方式，nginx使用http包的内容进行gzip）\n```bash\nyum install -y zlib zlib-devel\n```\n4、OpenSSL（一个强大的安全套接字层密码库，为nginx支持的https(即在SSL协议上传输http)协议服务）\n```bash\nyum install -y openssl openssl-devel\n```\n\n#### 安装\n在本地电脑下载nginx的压缩包（我这里是nginx-1.12.2.tar.gz），然后打开SecureCRT连接服务器，使用命令gz将本地的文件上传到Linux服务器上。\n> 注：如果在SecureCRT上输入gz显示command not found，是因为Linux虚拟机上没有安装lrsz服务。\n执行：\n```bash\nyum -y indtall lrzsz\n```\n然后可以输入rz命令选择要上传的文件。默认上传到当前路径上。\n\n**1、解压**\n```bash\ntar zxvf nginx-1.12.2.tar.gz\n```\n**2、创建Makefile文件，执行命令**\n```bash\n[root@localhost ~]# cd nginx-1.12.2\n[root@localhost nginx-1.12.2]# ./configure\n```\n![nginx](/images/nginx1.png)\n完成后可以看到Makefile文件：\n![nginx](/images/nginx2.png)\n**拓展**\nMakefile是一种配置文件，Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译…。Makefile就像一个Shell脚本一样。\n\n**3、编译**\n执行命令：\n```bash\n[root@localhost nginx-1.12.2]# make\n```\n\n**4、安装**\n执行命令：\n```bash\n[root@localhost nginx-1.12.2]# make install\n```\n到此，Nginx安装已经完成。\n\n---\n\n### Nginx启动与访问\n上面我本编译安装的Nginx其实默认被安装在CentOS7系统的/usr/local/nginx目录。\n![nginx](/images/nginx3.png)\n#### 启动Nginx\n```bash\n[root@localhost nginx]# cd sbin\n[root@localhost sbin]# ./nginx\n```\n此时已经启动成功Nginx，可以直接在浏览器上输入虚拟机IP（可通过ip addr命令查看），即可访问到Nginx欢迎界面，如果显示未连接，可以：\n1、先使用本机的终端工具ping虚拟机IP地址看是否成功\n```bash\nping ip\n```\n如果ping成功，请看下一步，如果失败，请检查虚拟机是否联网。\n2、关闭CentOS7的防火墙，开放80端口\n```bash\n[root@localhost sbin]# systemctl stop firewalld.service #停止firewall\n[root@localhost sbin]# systemctl disable firewalld.service #禁止firewall开机启动\n[root@localhost sbin]# firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）\n```\n一般情况下就能访问到了：\n![nginx](/images/nginx4.png)\n\n#### 查看Nginx进程\n```bash\n[root@localhost sbin]# ps aux|grep nginx\n```\n\n#### 关闭Nginx\n```bash\n[root@localhost sbin]# ./nginx -s stop\n```\n或者\n```bash\n[root@localhost sbin]# ./nginx -s quit\n```\n\n#### 重启Nginx\n```bash\n[root@localhost sbin]# ./nginx -s reload\n```\n\n#### 检查Nginx配置文件是否正确\n```bash\n[root@localhost sbin]# ./nginx -t\n```\n\n---\n\n### 部署静态网站\n经过上面的操作，我们已经正常启动了Nginx，那么如何将我们的静态项目部署到服务器的Nginx上呢？\n为了模拟操作，我这里只部署一个index.html网页为例：\n\n1、**上传静态网站**\n```bash\n# 回到根目录下\n[root@localhost sbin]# cd ../\n\n# 创建文件夹`my`，视为我们的项目文件夹\n[root@localhost nginx]# mkdir my\n\n# 在文件夹`my`下创建一个`index.html`网页\n[root@localhost nginx]# cd my\n[root@localhost my]# vi index.html\n```\n写入\n```bash\n<html>\n\n<head>\n<title>Hello</title>\n</head>\n<body>\n\n<h2>Hello Nginx!</h2>\n</body>\n</html>\n```\n\n2、**修改Nginx的配置文件**\n修改/usr/local/nginx/conf/nginx.conf文件：\n```bash\n[root@localhost my]# cd ../conf\n[root@localhost conf]# vi nginx.conf\n```\n在http {}这个节点下新创建一个server {}节点：\n```bash\nserver {\n    listen 81;\n    server_name localhost;\n    location / {\n        root my;\n        index index.html;\n    }\n}\n```\n如此，我们已经将81端口绑定了/nginx文件夹下的名称为my的项目。重启Nginx，访问：192.168.148.132:81即可以访问到我们刚才新创建的网页：index.html。\n\n#### 绑定域名\n**域名**是由一串用“.”分隔的字符逐层的Internet上某一台计算机或计算机组的名称，用于在数据传输时表示计算机的电子方位。域名是一个IP地址的“面具”。域名的目的是便于记忆和沟通的一组服务器的地址。域名按照**域名系统DNS**的规则流程组成，在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。通常，域名表示互联网协议（IP）资源。\n一个域名对应一个IP地址，一个IP地址可以被多个域名绑定。\n为了模拟，我们可以在本地hosts文件中配置域名和IP映射关系，这样就不用走DNS服务器了。\n因为hosts文件内容不能直接修改，需要把hosts文件拷贝出来然后修改后再替换进去就行了(我这里使用的MacOS系统)。\n\n1、**修改hosts**\n```bash\ncp /private/etc/hosts ~/Desktop/\nvi ~/Desktop/hosts\n```\n添加：\n```bash\n192.168.148.132 www.loonycoder.com\n```\n然后替换原来的\n```bash\ncp ~/Desktop/hosts /private/etc/\n```\n\n2、**修改Nginx配置文件**\n```bash\n[root@localhost conf]# vi /usr/local/nginx/conf/nginx.conf\n```\n为了模拟效果，我们可以先把之前新增的server {}节点81端口改为80端口：\n```bash\nserver {\n    listen 80;\n    server_name localhost;\n    location / {\n        root my;\n        index index.html;\n    }\n}\n```\n重启Nginx：\n```bash\n[root@localhost conf]# cd ../sbin\n[root@localhost sbin]# ./nginx -s stop\n[root@localhost sbin]# ./nginx\n```\n访问192.168.148.132发现还是Nginx的Welcome页面，因为nginx.conf默认配置的80端口就是指向Nginx欢迎页，且默认的server_name就是localhost。那么想实现不同的域名访问不同的资源且还必须是80端口，就需要绑定域名：\n修改nginx.conf\n```bash\nserver {\n    listen 80;\n    server_name www.loonycoder.com;\n    location / {\n        root my;\n        index index.html;\n    }\n}\n```\n如上，很简单，只需要把server_name改为我们要绑定的域名地址就好了，然后重启Nginx，在浏览器上访问<www.loonycoder.com>就展示我们之前创建的index.html，而输入192.168.148.132访问的还是Nginx的欢迎页，这就实现了域名的绑定。多个域名绑定同一个IP地址，但是不同的域名指向了不同的资源地址。\n\n---\n\n### Nginx反向代理\n> 什么是反向代理？\n反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n> 正向代理\n![nginx](/images/nginx5.png)\n**正向代理**，主要针对客户端。当用户通过PC向Internet发送请求时，可以通过一个代理服务器来统一处理请求并转发给Internet，比如一个教室的所有学生机都需要通过老师的教师机才能实现联网，那么这个教师机就相当于一个代理服务器，负责将PC的网络请求转发给Internet，然后Internet将相应的数据再通过代理服务器转发给不同的PC。\n\n> 反向代理\n![nginx](/images/nginx6.png)\n**反向代理**的过程则刚好相反，主要针对服务器。当用户通过网络请求不同的资源，而这些资源被分布在不同的服务器上，那么不同的请求就应该指向对应不同的服务器，那么就需要一个中介：反向代理服务器。通过反向代理服务器将不同的资源请求信息发送给不同的服务器，然后服务器将不同的信心都返回给反向代理服务器，最后通过反向代理服务器将这些结果信息展示在Internet上。\n\n#### 配置反向代理\n这里我们以一个非常实用的案例来演示如何配置Nginx的反向代理实现不同的域名访问不同的页面。\n1、在服务器上安装JDK8和Tomcat8\n通过rz命令将本地的JDK和Tomcat安装包上传到服务器。因为Tomcat解压即可用，我们这里记录一下如何安装JDK：\n```bash\n# 解压\ntar zxvf jdk-8u191-linux-x64.tar.gz\n\n# 配置JDK环境\nvi /etc/profile\n```\n在profile文件的结尾处添加如下环境配置：\n```bash\nexport JAVA_HOME=/root/jdk1.8.0_191    \nexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport PATH=$PATH:$JAVA_HOME/bin\n```\n:wq!保存并退出，输入命令：\n```bash\n[root@localhost ~]# source /etc/profile\n```\n\n更新配置。然后输入java -version显示则说明JDK配置成功。\n解压Tomcat，在其bin目录下执行命令./startup.sh启动Tomcat服务器，然后我们再浏览器上访问：<http://192.168.148.132:8080/>显示Tomcat的欢迎页面则配置成功。\n\n2、拷贝项目到Tomcat服务器下\n为了模拟，我们在tomcat/webapps/ROOT/下创建一个index.html网页：\n```bash\n[root@localhost ROOT]# vi index.html\n```\n并写入：\n```bash\n<html>\n<head>\n<title>Hello</title>\n</head>\n<body>\n<h2>Hello Tomcat!</h2>\n</body>\n</html>\n```\n\n保存并退出，再次访问<http://192.168.148.132:8080/>发现展示的即是我们刚创建的页面\n![nginx](/images/nginx7.png)\n\n3、配置反向代理\n之前讲了**反向代理**的概念，那么很实用的一个例子就是，当我们想在购买的阿里云服务器上部署两个项目，一个项目是用Nginx部署的静态网站（占用80端口），另一个项目部署在Tomcat服务器上（占用8080端口）。\n这时，我们固然是可以通过：ip:8080来访问我们的Web项目的，但是请求路径上显示了端口好久显得很别扭，为此，我们通过Nginx的反向代理就能解决：\n- 3.1在本地配置一个二级域名映射\n修改本机的hosts文件，添加：\n```bash\n192.168.148.132 site.loonycoder.com\n```\n这时我们访问<site.loonycoder.com>默认进入nginx的欢迎页，这是正确的。\n注意：此时的<site.loonycoder.com>是<loonycoder.com>的一个二级子域名。\n\n- 3.2 修改服务器Nginx的配置文件，添加如下配置\n```bash\nupstream site {\n        server 192.168.148.132:8080;\n}\nserver {\n        listen 80;\n        server_name site.loonycoder.com;\n        location / {\n            proxy_pass http://site;\n            index index.html;\n        }\n}\n```\n注意，其中server {}节点下的proxy_pass表示反向代理的地址，其中http://site这个site其实是指向上面upstream site {}节点的site名称，因此要保持两者名称一致。但实际上我们不采用这种方式也能实现反向代理：\n```bash\n# upstream site {\n#         server 192.168.148.132:8080;\n# }\nserver {\n        listen 80;\n        server_name site.loonycoder.com;\n        location / {\n            # proxy_pass http://site;\n            proxy_pass http://192.168.148.132:8080;\n            index index.html;\n        }\n}\n```\n\n两者的区别就是第一种方式通过指向的方式可以配置更多，必须实现**负载均衡**就需要在upstream site {}节点下配置。\n\n---\n\n### Nginx配置负载均衡\n> 什么是负载均衡？\n**负载均衡（Load Balance）**，其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。\n**负载均衡** 是建立在现有网络结构上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽，增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。\n1.**模拟负载均衡**，我们可以提供多个Tomcat服务器，采用不同的端口区分。\n为了模拟**负载均衡**效果，可以copy 2份虚拟机上的Tomcat服务器，命名为tomcat-2，tomcat-3:\n```bash\n[root@localhost ~]# cp ~/apache-tomcat-8.5.33 ~/tomcat-2\n[root@localhost ~]# cp ~/apache-tomcat-8.5.33 ~/tomcat-3\n```\n修改端口号分别为8180，8280。我们主要修改/tomcat/conf/server.xml配置文件中的<Server port=\"8005\"和<Connector port=\"8080\"这两个节点的端口\n```bash\n# 修改tomcat-2服务器的`/conf/server.xml`参数\n<Server port=\"8006\" shutdown=\"SHUTDOWN\">\n        <Connector port=\"8180\" protocol=\"HTTP/1.1\"  \n\n# 修改tomcat-3服务器的`/conf/server.xml`参数\n<Server port=\"8007\" shutdown=\"SHUTDOWN\">\n        <Connector port=\"8280\" protocol=\"HTTP/1.1\"\n```\n如上，我们在虚拟机上配置了三个Tomcat服务器，分别使用8080，8180，8280端口。\n\n2.**配置负载均衡**\n修改Nginx下的配置文件\n```bash\n[root@localhost ~]# vi /usr/local/nginx/conf/nginx.conf\n```\n修改之前配置的upstream site {}节点：\n```bash\nupstream site {\n     server 192.168.148.132:8080;\n     server 192.168.148.132:8180;\n     server 192.168.148.132:8280;\n}\nserver {\n    listen 80;\n    server_name site.loonycoder.com;\n    location / {\n        proxy_pass http://site;\n        index index.html;\n    }\n}\n```\n这样我们就给Nginx配置了3台服务器，都指向了site.loonycoder.com这个域名地址，那么访问这个地址时同时会访问这三台服务器，也就是三台服务器平均分摊访问压力。\n为了更好的实现效果，我们可以依次修改tomcat-2和tomcat-3服务器的/webapps/ROOT/index.html网页显示数据，更容易区分每次访问的是哪台服务器。\n然后运行这三个Tomcat服务器，在浏览器上访问：site.loonycoder.com，多次刷新页面，每次访问的都是不同的页面，且依次是配置负载均衡的三台服务器次序。\n如果你想让某个服务器承担更大的压力，可以为其设置权重：\n```bash\nupstream site {\n     server 192.168.148.132:8080;\n     server 192.168.148.132:8180 weight=2;\n     server 192.168.148.132:8280;\n}\n```","source":"_posts/nginx.md","raw":"---\ntitle: 高性能的HTTP服务器——Nginx\ncategories:\n    - Nginx\n    \ndate: 2018-11-21\ntags:\n\t- HTTP服务器\n\n---\n\n![nginx](/images/nginx.jpg)\nNginx是一款高性能HTTP服务器、反向代理服务器及电子邮件（IMAP、POP3）代理服务器，官方测试nginx能够支持5万并发连接。\n**Nginx应用场景：**\n1、http服务器。Nginx是一个http服务器，可以独立提供http服务。可以做网页静态服务器。\n2、虚拟主机。可以实现在一台服务器虚拟出多个网站。\n3、反向代理，负载均衡。当网站的并发量过大需要配置服务器集群时可以使用Nginx做反向代理。并且多台服务器可以平均分摊负载。\n\n### 写在前面\n#### 本文章默认使用的软件：\n- CentOS 7\n- Nginx-1.12.2\n- JDK 8.0\n- Tomcat 8\n\n#### 开发工具：\n- VMware fusion\n- SecureCRT\n\n### 安装Nginx\n\n#### 环境准备\n1、安装gcc的环境\n```bash\nyum install gcc-c++\n```\n2、PCRE（perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式）\n```bash\nyum install -y pcre pcre-devel\n```\n3、Zlib（zlib提供了很多压缩和解压的方式，nginx使用http包的内容进行gzip）\n```bash\nyum install -y zlib zlib-devel\n```\n4、OpenSSL（一个强大的安全套接字层密码库，为nginx支持的https(即在SSL协议上传输http)协议服务）\n```bash\nyum install -y openssl openssl-devel\n```\n\n#### 安装\n在本地电脑下载nginx的压缩包（我这里是nginx-1.12.2.tar.gz），然后打开SecureCRT连接服务器，使用命令gz将本地的文件上传到Linux服务器上。\n> 注：如果在SecureCRT上输入gz显示command not found，是因为Linux虚拟机上没有安装lrsz服务。\n执行：\n```bash\nyum -y indtall lrzsz\n```\n然后可以输入rz命令选择要上传的文件。默认上传到当前路径上。\n\n**1、解压**\n```bash\ntar zxvf nginx-1.12.2.tar.gz\n```\n**2、创建Makefile文件，执行命令**\n```bash\n[root@localhost ~]# cd nginx-1.12.2\n[root@localhost nginx-1.12.2]# ./configure\n```\n![nginx](/images/nginx1.png)\n完成后可以看到Makefile文件：\n![nginx](/images/nginx2.png)\n**拓展**\nMakefile是一种配置文件，Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译…。Makefile就像一个Shell脚本一样。\n\n**3、编译**\n执行命令：\n```bash\n[root@localhost nginx-1.12.2]# make\n```\n\n**4、安装**\n执行命令：\n```bash\n[root@localhost nginx-1.12.2]# make install\n```\n到此，Nginx安装已经完成。\n\n---\n\n### Nginx启动与访问\n上面我本编译安装的Nginx其实默认被安装在CentOS7系统的/usr/local/nginx目录。\n![nginx](/images/nginx3.png)\n#### 启动Nginx\n```bash\n[root@localhost nginx]# cd sbin\n[root@localhost sbin]# ./nginx\n```\n此时已经启动成功Nginx，可以直接在浏览器上输入虚拟机IP（可通过ip addr命令查看），即可访问到Nginx欢迎界面，如果显示未连接，可以：\n1、先使用本机的终端工具ping虚拟机IP地址看是否成功\n```bash\nping ip\n```\n如果ping成功，请看下一步，如果失败，请检查虚拟机是否联网。\n2、关闭CentOS7的防火墙，开放80端口\n```bash\n[root@localhost sbin]# systemctl stop firewalld.service #停止firewall\n[root@localhost sbin]# systemctl disable firewalld.service #禁止firewall开机启动\n[root@localhost sbin]# firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）\n```\n一般情况下就能访问到了：\n![nginx](/images/nginx4.png)\n\n#### 查看Nginx进程\n```bash\n[root@localhost sbin]# ps aux|grep nginx\n```\n\n#### 关闭Nginx\n```bash\n[root@localhost sbin]# ./nginx -s stop\n```\n或者\n```bash\n[root@localhost sbin]# ./nginx -s quit\n```\n\n#### 重启Nginx\n```bash\n[root@localhost sbin]# ./nginx -s reload\n```\n\n#### 检查Nginx配置文件是否正确\n```bash\n[root@localhost sbin]# ./nginx -t\n```\n\n---\n\n### 部署静态网站\n经过上面的操作，我们已经正常启动了Nginx，那么如何将我们的静态项目部署到服务器的Nginx上呢？\n为了模拟操作，我这里只部署一个index.html网页为例：\n\n1、**上传静态网站**\n```bash\n# 回到根目录下\n[root@localhost sbin]# cd ../\n\n# 创建文件夹`my`，视为我们的项目文件夹\n[root@localhost nginx]# mkdir my\n\n# 在文件夹`my`下创建一个`index.html`网页\n[root@localhost nginx]# cd my\n[root@localhost my]# vi index.html\n```\n写入\n```bash\n<html>\n\n<head>\n<title>Hello</title>\n</head>\n<body>\n\n<h2>Hello Nginx!</h2>\n</body>\n</html>\n```\n\n2、**修改Nginx的配置文件**\n修改/usr/local/nginx/conf/nginx.conf文件：\n```bash\n[root@localhost my]# cd ../conf\n[root@localhost conf]# vi nginx.conf\n```\n在http {}这个节点下新创建一个server {}节点：\n```bash\nserver {\n    listen 81;\n    server_name localhost;\n    location / {\n        root my;\n        index index.html;\n    }\n}\n```\n如此，我们已经将81端口绑定了/nginx文件夹下的名称为my的项目。重启Nginx，访问：192.168.148.132:81即可以访问到我们刚才新创建的网页：index.html。\n\n#### 绑定域名\n**域名**是由一串用“.”分隔的字符逐层的Internet上某一台计算机或计算机组的名称，用于在数据传输时表示计算机的电子方位。域名是一个IP地址的“面具”。域名的目的是便于记忆和沟通的一组服务器的地址。域名按照**域名系统DNS**的规则流程组成，在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。通常，域名表示互联网协议（IP）资源。\n一个域名对应一个IP地址，一个IP地址可以被多个域名绑定。\n为了模拟，我们可以在本地hosts文件中配置域名和IP映射关系，这样就不用走DNS服务器了。\n因为hosts文件内容不能直接修改，需要把hosts文件拷贝出来然后修改后再替换进去就行了(我这里使用的MacOS系统)。\n\n1、**修改hosts**\n```bash\ncp /private/etc/hosts ~/Desktop/\nvi ~/Desktop/hosts\n```\n添加：\n```bash\n192.168.148.132 www.loonycoder.com\n```\n然后替换原来的\n```bash\ncp ~/Desktop/hosts /private/etc/\n```\n\n2、**修改Nginx配置文件**\n```bash\n[root@localhost conf]# vi /usr/local/nginx/conf/nginx.conf\n```\n为了模拟效果，我们可以先把之前新增的server {}节点81端口改为80端口：\n```bash\nserver {\n    listen 80;\n    server_name localhost;\n    location / {\n        root my;\n        index index.html;\n    }\n}\n```\n重启Nginx：\n```bash\n[root@localhost conf]# cd ../sbin\n[root@localhost sbin]# ./nginx -s stop\n[root@localhost sbin]# ./nginx\n```\n访问192.168.148.132发现还是Nginx的Welcome页面，因为nginx.conf默认配置的80端口就是指向Nginx欢迎页，且默认的server_name就是localhost。那么想实现不同的域名访问不同的资源且还必须是80端口，就需要绑定域名：\n修改nginx.conf\n```bash\nserver {\n    listen 80;\n    server_name www.loonycoder.com;\n    location / {\n        root my;\n        index index.html;\n    }\n}\n```\n如上，很简单，只需要把server_name改为我们要绑定的域名地址就好了，然后重启Nginx，在浏览器上访问<www.loonycoder.com>就展示我们之前创建的index.html，而输入192.168.148.132访问的还是Nginx的欢迎页，这就实现了域名的绑定。多个域名绑定同一个IP地址，但是不同的域名指向了不同的资源地址。\n\n---\n\n### Nginx反向代理\n> 什么是反向代理？\n反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n> 正向代理\n![nginx](/images/nginx5.png)\n**正向代理**，主要针对客户端。当用户通过PC向Internet发送请求时，可以通过一个代理服务器来统一处理请求并转发给Internet，比如一个教室的所有学生机都需要通过老师的教师机才能实现联网，那么这个教师机就相当于一个代理服务器，负责将PC的网络请求转发给Internet，然后Internet将相应的数据再通过代理服务器转发给不同的PC。\n\n> 反向代理\n![nginx](/images/nginx6.png)\n**反向代理**的过程则刚好相反，主要针对服务器。当用户通过网络请求不同的资源，而这些资源被分布在不同的服务器上，那么不同的请求就应该指向对应不同的服务器，那么就需要一个中介：反向代理服务器。通过反向代理服务器将不同的资源请求信息发送给不同的服务器，然后服务器将不同的信心都返回给反向代理服务器，最后通过反向代理服务器将这些结果信息展示在Internet上。\n\n#### 配置反向代理\n这里我们以一个非常实用的案例来演示如何配置Nginx的反向代理实现不同的域名访问不同的页面。\n1、在服务器上安装JDK8和Tomcat8\n通过rz命令将本地的JDK和Tomcat安装包上传到服务器。因为Tomcat解压即可用，我们这里记录一下如何安装JDK：\n```bash\n# 解压\ntar zxvf jdk-8u191-linux-x64.tar.gz\n\n# 配置JDK环境\nvi /etc/profile\n```\n在profile文件的结尾处添加如下环境配置：\n```bash\nexport JAVA_HOME=/root/jdk1.8.0_191    \nexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport PATH=$PATH:$JAVA_HOME/bin\n```\n:wq!保存并退出，输入命令：\n```bash\n[root@localhost ~]# source /etc/profile\n```\n\n更新配置。然后输入java -version显示则说明JDK配置成功。\n解压Tomcat，在其bin目录下执行命令./startup.sh启动Tomcat服务器，然后我们再浏览器上访问：<http://192.168.148.132:8080/>显示Tomcat的欢迎页面则配置成功。\n\n2、拷贝项目到Tomcat服务器下\n为了模拟，我们在tomcat/webapps/ROOT/下创建一个index.html网页：\n```bash\n[root@localhost ROOT]# vi index.html\n```\n并写入：\n```bash\n<html>\n<head>\n<title>Hello</title>\n</head>\n<body>\n<h2>Hello Tomcat!</h2>\n</body>\n</html>\n```\n\n保存并退出，再次访问<http://192.168.148.132:8080/>发现展示的即是我们刚创建的页面\n![nginx](/images/nginx7.png)\n\n3、配置反向代理\n之前讲了**反向代理**的概念，那么很实用的一个例子就是，当我们想在购买的阿里云服务器上部署两个项目，一个项目是用Nginx部署的静态网站（占用80端口），另一个项目部署在Tomcat服务器上（占用8080端口）。\n这时，我们固然是可以通过：ip:8080来访问我们的Web项目的，但是请求路径上显示了端口好久显得很别扭，为此，我们通过Nginx的反向代理就能解决：\n- 3.1在本地配置一个二级域名映射\n修改本机的hosts文件，添加：\n```bash\n192.168.148.132 site.loonycoder.com\n```\n这时我们访问<site.loonycoder.com>默认进入nginx的欢迎页，这是正确的。\n注意：此时的<site.loonycoder.com>是<loonycoder.com>的一个二级子域名。\n\n- 3.2 修改服务器Nginx的配置文件，添加如下配置\n```bash\nupstream site {\n        server 192.168.148.132:8080;\n}\nserver {\n        listen 80;\n        server_name site.loonycoder.com;\n        location / {\n            proxy_pass http://site;\n            index index.html;\n        }\n}\n```\n注意，其中server {}节点下的proxy_pass表示反向代理的地址，其中http://site这个site其实是指向上面upstream site {}节点的site名称，因此要保持两者名称一致。但实际上我们不采用这种方式也能实现反向代理：\n```bash\n# upstream site {\n#         server 192.168.148.132:8080;\n# }\nserver {\n        listen 80;\n        server_name site.loonycoder.com;\n        location / {\n            # proxy_pass http://site;\n            proxy_pass http://192.168.148.132:8080;\n            index index.html;\n        }\n}\n```\n\n两者的区别就是第一种方式通过指向的方式可以配置更多，必须实现**负载均衡**就需要在upstream site {}节点下配置。\n\n---\n\n### Nginx配置负载均衡\n> 什么是负载均衡？\n**负载均衡（Load Balance）**，其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。\n**负载均衡** 是建立在现有网络结构上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽，增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。\n1.**模拟负载均衡**，我们可以提供多个Tomcat服务器，采用不同的端口区分。\n为了模拟**负载均衡**效果，可以copy 2份虚拟机上的Tomcat服务器，命名为tomcat-2，tomcat-3:\n```bash\n[root@localhost ~]# cp ~/apache-tomcat-8.5.33 ~/tomcat-2\n[root@localhost ~]# cp ~/apache-tomcat-8.5.33 ~/tomcat-3\n```\n修改端口号分别为8180，8280。我们主要修改/tomcat/conf/server.xml配置文件中的<Server port=\"8005\"和<Connector port=\"8080\"这两个节点的端口\n```bash\n# 修改tomcat-2服务器的`/conf/server.xml`参数\n<Server port=\"8006\" shutdown=\"SHUTDOWN\">\n        <Connector port=\"8180\" protocol=\"HTTP/1.1\"  \n\n# 修改tomcat-3服务器的`/conf/server.xml`参数\n<Server port=\"8007\" shutdown=\"SHUTDOWN\">\n        <Connector port=\"8280\" protocol=\"HTTP/1.1\"\n```\n如上，我们在虚拟机上配置了三个Tomcat服务器，分别使用8080，8180，8280端口。\n\n2.**配置负载均衡**\n修改Nginx下的配置文件\n```bash\n[root@localhost ~]# vi /usr/local/nginx/conf/nginx.conf\n```\n修改之前配置的upstream site {}节点：\n```bash\nupstream site {\n     server 192.168.148.132:8080;\n     server 192.168.148.132:8180;\n     server 192.168.148.132:8280;\n}\nserver {\n    listen 80;\n    server_name site.loonycoder.com;\n    location / {\n        proxy_pass http://site;\n        index index.html;\n    }\n}\n```\n这样我们就给Nginx配置了3台服务器，都指向了site.loonycoder.com这个域名地址，那么访问这个地址时同时会访问这三台服务器，也就是三台服务器平均分摊访问压力。\n为了更好的实现效果，我们可以依次修改tomcat-2和tomcat-3服务器的/webapps/ROOT/index.html网页显示数据，更容易区分每次访问的是哪台服务器。\n然后运行这三个Tomcat服务器，在浏览器上访问：site.loonycoder.com，多次刷新页面，每次访问的都是不同的页面，且依次是配置负载均衡的三台服务器次序。\n如果你想让某个服务器承担更大的压力，可以为其设置权重：\n```bash\nupstream site {\n     server 192.168.148.132:8080;\n     server 192.168.148.132:8180 weight=2;\n     server 192.168.148.132:8280;\n}\n```","slug":"nginx","published":1,"updated":"2020-02-21T15:32:21.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiz40016v9s66tede85g","content":"<p><img src=\"/images/nginx.jpg\" alt=\"nginx\"><br>Nginx是一款高性能HTTP服务器、反向代理服务器及电子邮件（IMAP、POP3）代理服务器，官方测试nginx能够支持5万并发连接。<br><strong>Nginx应用场景：</strong><br>1、http服务器。Nginx是一个http服务器，可以独立提供http服务。可以做网页静态服务器。<br>2、虚拟主机。可以实现在一台服务器虚拟出多个网站。<br>3、反向代理，负载均衡。当网站的并发量过大需要配置服务器集群时可以使用Nginx做反向代理。并且多台服务器可以平均分摊负载。</p>\n<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><h4 id=\"本文章默认使用的软件：\"><a href=\"#本文章默认使用的软件：\" class=\"headerlink\" title=\"本文章默认使用的软件：\"></a>本文章默认使用的软件：</h4><ul>\n<li>CentOS 7</li>\n<li>Nginx-1.12.2</li>\n<li>JDK 8.0</li>\n<li>Tomcat 8</li>\n</ul>\n<h4 id=\"开发工具：\"><a href=\"#开发工具：\" class=\"headerlink\" title=\"开发工具：\"></a>开发工具：</h4><ul>\n<li>VMware fusion</li>\n<li>SecureCRT</li>\n</ul>\n<h3 id=\"安装Nginx\"><a href=\"#安装Nginx\" class=\"headerlink\" title=\"安装Nginx\"></a>安装Nginx</h3><h4 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h4><p>1、安装gcc的环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install gcc-c++</span><br></pre></td></tr></table></figure>\n<p>2、PCRE（perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>\n<p>3、Zlib（zlib提供了很多压缩和解压的方式，nginx使用http包的内容进行gzip）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure>\n<p>4、OpenSSL（一个强大的安全套接字层密码库，为nginx支持的https(即在SSL协议上传输http)协议服务）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>在本地电脑下载nginx的压缩包（我这里是nginx-1.12.2.tar.gz），然后打开SecureCRT连接服务器，使用命令gz将本地的文件上传到Linux服务器上。</p>\n<blockquote>\n<p>注：如果在SecureCRT上输入gz显示command not found，是因为Linux虚拟机上没有安装lrsz服务。<br>执行：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y indtall lrzsz</span><br></pre></td></tr></table></figure>\n<p>然后可以输入rz命令选择要上传的文件。默认上传到当前路径上。</p>\n<p><strong>1、解压</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>\n<p><strong>2、创建Makefile文件，执行命令</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># cd nginx-1.12.2</span></span><br><span class=\"line\">[root@localhost nginx-1.12.2]<span class=\"comment\"># ./configure</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/nginx1.png\" alt=\"nginx\"><br>完成后可以看到Makefile文件：<br><img src=\"/images/nginx2.png\" alt=\"nginx\"><br><strong>拓展</strong><br>Makefile是一种配置文件，Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译…。Makefile就像一个Shell脚本一样。</p>\n<p><strong>3、编译</strong><br>执行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx-1.12.2]<span class=\"comment\"># make</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>4、安装</strong><br>执行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx-1.12.2]<span class=\"comment\"># make install</span></span><br></pre></td></tr></table></figure>\n<p>到此，Nginx安装已经完成。</p>\n<hr>\n<h3 id=\"Nginx启动与访问\"><a href=\"#Nginx启动与访问\" class=\"headerlink\" title=\"Nginx启动与访问\"></a>Nginx启动与访问</h3><p>上面我本编译安装的Nginx其实默认被安装在CentOS7系统的/usr/local/nginx目录。<br><img src=\"/images/nginx3.png\" alt=\"nginx\"></p>\n<h4 id=\"启动Nginx\"><a href=\"#启动Nginx\" class=\"headerlink\" title=\"启动Nginx\"></a>启动Nginx</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx]<span class=\"comment\"># cd sbin</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx</span></span><br></pre></td></tr></table></figure>\n<p>此时已经启动成功Nginx，可以直接在浏览器上输入虚拟机IP（可通过ip addr命令查看），即可访问到Nginx欢迎界面，如果显示未连接，可以：<br>1、先使用本机的终端工具ping虚拟机IP地址看是否成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping ip</span><br></pre></td></tr></table></figure>\n<p>如果ping成功，请看下一步，如果失败，请检查虚拟机是否联网。<br>2、关闭CentOS7的防火墙，开放80端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># systemctl stop firewalld.service #停止firewall</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># systemctl disable firewalld.service #禁止firewall开机启动</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br></pre></td></tr></table></figure>\n<p>一般情况下就能访问到了：<br><img src=\"/images/nginx4.png\" alt=\"nginx\"></p>\n<h4 id=\"查看Nginx进程\"><a href=\"#查看Nginx进程\" class=\"headerlink\" title=\"查看Nginx进程\"></a>查看Nginx进程</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ps aux|grep nginx</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"关闭Nginx\"><a href=\"#关闭Nginx\" class=\"headerlink\" title=\"关闭Nginx\"></a>关闭Nginx</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx -s stop</span></span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx -s quit</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重启Nginx\"><a href=\"#重启Nginx\" class=\"headerlink\" title=\"重启Nginx\"></a>重启Nginx</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx -s reload</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"检查Nginx配置文件是否正确\"><a href=\"#检查Nginx配置文件是否正确\" class=\"headerlink\" title=\"检查Nginx配置文件是否正确\"></a>检查Nginx配置文件是否正确</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx -t</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"部署静态网站\"><a href=\"#部署静态网站\" class=\"headerlink\" title=\"部署静态网站\"></a>部署静态网站</h3><p>经过上面的操作，我们已经正常启动了Nginx，那么如何将我们的静态项目部署到服务器的Nginx上呢？<br>为了模拟操作，我这里只部署一个index.html网页为例：</p>\n<p>1、<strong>上传静态网站</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回到根目录下</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># cd ../</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建文件夹`my`，视为我们的项目文件夹</span></span><br><span class=\"line\">[root@localhost nginx]<span class=\"comment\"># mkdir my</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在文件夹`my`下创建一个`index.html`网页</span></span><br><span class=\"line\">[root@localhost nginx]<span class=\"comment\"># cd my</span></span><br><span class=\"line\">[root@localhost my]<span class=\"comment\"># vi index.html</span></span><br></pre></td></tr></table></figure>\n<p>写入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;h2&gt;Hello Nginx!&lt;/h2&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、<strong>修改Nginx的配置文件</strong><br>修改/usr/local/nginx/conf/nginx.conf文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost my]<span class=\"comment\"># cd ../conf</span></span><br><span class=\"line\">[root@localhost conf]<span class=\"comment\"># vi nginx.conf</span></span><br></pre></td></tr></table></figure>\n<p>在http {}这个节点下新创建一个server {}节点：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 81;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root my;</span><br><span class=\"line\">        index index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如此，我们已经将81端口绑定了/nginx文件夹下的名称为my的项目。重启Nginx，访问：192.168.148.132:81即可以访问到我们刚才新创建的网页：index.html。</p>\n<h4 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h4><p><strong>域名</strong>是由一串用“.”分隔的字符逐层的Internet上某一台计算机或计算机组的名称，用于在数据传输时表示计算机的电子方位。域名是一个IP地址的“面具”。域名的目的是便于记忆和沟通的一组服务器的地址。域名按照<strong>域名系统DNS</strong>的规则流程组成，在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。通常，域名表示互联网协议（IP）资源。<br>一个域名对应一个IP地址，一个IP地址可以被多个域名绑定。<br>为了模拟，我们可以在本地hosts文件中配置域名和IP映射关系，这样就不用走DNS服务器了。<br>因为hosts文件内容不能直接修改，需要把hosts文件拷贝出来然后修改后再替换进去就行了(我这里使用的MacOS系统)。</p>\n<p>1、<strong>修改hosts</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /private/etc/hosts ~/Desktop/</span><br><span class=\"line\">vi ~/Desktop/hosts</span><br></pre></td></tr></table></figure>\n<p>添加：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192.168.148.132 www.loonycoder.com</span><br></pre></td></tr></table></figure>\n<p>然后替换原来的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ~/Desktop/hosts /private/etc/</span><br></pre></td></tr></table></figure>\n\n<p>2、<strong>修改Nginx配置文件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost conf]<span class=\"comment\"># vi /usr/local/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure>\n<p>为了模拟效果，我们可以先把之前新增的server {}节点81端口改为80端口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root my;</span><br><span class=\"line\">        index index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启Nginx：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost conf]<span class=\"comment\"># cd ../sbin</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx -s stop</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx</span></span><br></pre></td></tr></table></figure>\n<p>访问192.168.148.132发现还是Nginx的Welcome页面，因为nginx.conf默认配置的80端口就是指向Nginx欢迎页，且默认的server_name就是localhost。那么想实现不同的域名访问不同的资源且还必须是80端口，就需要绑定域名：<br>修改nginx.conf</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.loonycoder.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root my;</span><br><span class=\"line\">        index index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上，很简单，只需要把server_name改为我们要绑定的域名地址就好了，然后重启Nginx，在浏览器上访问&lt;<a href=\"http://www.loonycoder.com&gt;就展示我们之前创建的index.html，而输入192.168.148.132访问的还是Nginx的欢迎页，这就实现了域名的绑定。多个域名绑定同一个IP地址，但是不同的域名指向了不同的资源地址。\" target=\"_blank\" rel=\"noopener\">www.loonycoder.com&gt;就展示我们之前创建的index.html，而输入192.168.148.132访问的还是Nginx的欢迎页，这就实现了域名的绑定。多个域名绑定同一个IP地址，但是不同的域名指向了不同的资源地址。</a></p>\n<hr>\n<h3 id=\"Nginx反向代理\"><a href=\"#Nginx反向代理\" class=\"headerlink\" title=\"Nginx反向代理\"></a>Nginx反向代理</h3><blockquote>\n<p>什么是反向代理？<br>反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n</blockquote>\n<blockquote>\n<p>正向代理<br><img src=\"/images/nginx5.png\" alt=\"nginx\"><br><strong>正向代理</strong>，主要针对客户端。当用户通过PC向Internet发送请求时，可以通过一个代理服务器来统一处理请求并转发给Internet，比如一个教室的所有学生机都需要通过老师的教师机才能实现联网，那么这个教师机就相当于一个代理服务器，负责将PC的网络请求转发给Internet，然后Internet将相应的数据再通过代理服务器转发给不同的PC。</p>\n</blockquote>\n<blockquote>\n<p>反向代理<br><img src=\"/images/nginx6.png\" alt=\"nginx\"><br><strong>反向代理</strong>的过程则刚好相反，主要针对服务器。当用户通过网络请求不同的资源，而这些资源被分布在不同的服务器上，那么不同的请求就应该指向对应不同的服务器，那么就需要一个中介：反向代理服务器。通过反向代理服务器将不同的资源请求信息发送给不同的服务器，然后服务器将不同的信心都返回给反向代理服务器，最后通过反向代理服务器将这些结果信息展示在Internet上。</p>\n</blockquote>\n<h4 id=\"配置反向代理\"><a href=\"#配置反向代理\" class=\"headerlink\" title=\"配置反向代理\"></a>配置反向代理</h4><p>这里我们以一个非常实用的案例来演示如何配置Nginx的反向代理实现不同的域名访问不同的页面。<br>1、在服务器上安装JDK8和Tomcat8<br>通过rz命令将本地的JDK和Tomcat安装包上传到服务器。因为Tomcat解压即可用，我们这里记录一下如何安装JDK：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">tar zxvf jdk-8u191-linux-x64.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置JDK环境</span></span><br><span class=\"line\">vi /etc/profile</span><br></pre></td></tr></table></figure>\n<p>在profile文件的结尾处添加如下环境配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/root/jdk1.8.0_191    </span><br><span class=\"line\"><span class=\"built_in\">export</span> CLASSPATH=.:<span class=\"variable\">$JAVA_HOME</span>/jre/lib/rt.jar:<span class=\"variable\">$JAVA_HOME</span>/lib/dt.jar:<span class=\"variable\">$JAVA_HOME</span>/lib/tools.jar</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>\n<p>:wq!保存并退出，输入命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># source /etc/profile</span></span><br></pre></td></tr></table></figure>\n\n<p>更新配置。然后输入java -version显示则说明JDK配置成功。<br>解压Tomcat，在其bin目录下执行命令./startup.sh启动Tomcat服务器，然后我们再浏览器上访问：<a href=\"http://192.168.148.132:8080/\" target=\"_blank\" rel=\"noopener\">http://192.168.148.132:8080/</a>显示Tomcat的欢迎页面则配置成功。</p>\n<p>2、拷贝项目到Tomcat服务器下<br>为了模拟，我们在tomcat/webapps/ROOT/下创建一个index.html网页：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ROOT]<span class=\"comment\"># vi index.html</span></span><br></pre></td></tr></table></figure>\n<p>并写入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h2&gt;Hello Tomcat!&lt;/h2&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>保存并退出，再次访问<a href=\"http://192.168.148.132:8080/\" target=\"_blank\" rel=\"noopener\">http://192.168.148.132:8080/</a>发现展示的即是我们刚创建的页面<br><img src=\"/images/nginx7.png\" alt=\"nginx\"></p>\n<p>3、配置反向代理<br>之前讲了<strong>反向代理</strong>的概念，那么很实用的一个例子就是，当我们想在购买的阿里云服务器上部署两个项目，一个项目是用Nginx部署的静态网站（占用80端口），另一个项目部署在Tomcat服务器上（占用8080端口）。<br>这时，我们固然是可以通过：ip:8080来访问我们的Web项目的，但是请求路径上显示了端口好久显得很别扭，为此，我们通过Nginx的反向代理就能解决：</p>\n<ul>\n<li><p>3.1在本地配置一个二级域名映射<br>修改本机的hosts文件，添加：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192.168.148.132 site.loonycoder.com</span><br></pre></td></tr></table></figure>\n<p>这时我们访问&lt;site.loonycoder.com&gt;默认进入nginx的欢迎页，这是正确的。<br>注意：此时的&lt;site.loonycoder.com&gt;是&lt;loonycoder.com&gt;的一个二级子域名。</p>\n</li>\n<li><p>3.2 修改服务器Nginx的配置文件，添加如下配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream site &#123;</span><br><span class=\"line\">        server 192.168.148.132:8080;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name site.loonycoder.com;</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            proxy_pass http://site;</span><br><span class=\"line\">            index index.html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，其中server {}节点下的proxy_pass表示反向代理的地址，其中<a href=\"http://site这个site其实是指向上面upstream\" target=\"_blank\" rel=\"noopener\">http://site这个site其实是指向上面upstream</a> site {}节点的site名称，因此要保持两者名称一致。但实际上我们不采用这种方式也能实现反向代理：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># upstream site &#123;</span></span><br><span class=\"line\"><span class=\"comment\">#         server 192.168.148.132:8080;</span></span><br><span class=\"line\"><span class=\"comment\"># &#125;</span></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name site.loonycoder.com;</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            <span class=\"comment\"># proxy_pass http://site;</span></span><br><span class=\"line\">            proxy_pass http://192.168.148.132:8080;</span><br><span class=\"line\">            index index.html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>两者的区别就是第一种方式通过指向的方式可以配置更多，必须实现<strong>负载均衡</strong>就需要在upstream site {}节点下配置。</p>\n<hr>\n<h3 id=\"Nginx配置负载均衡\"><a href=\"#Nginx配置负载均衡\" class=\"headerlink\" title=\"Nginx配置负载均衡\"></a>Nginx配置负载均衡</h3><blockquote>\n<p>什么是负载均衡？<br><strong>负载均衡（Load Balance）</strong>，其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。<br><strong>负载均衡</strong> 是建立在现有网络结构上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽，增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。<br>1.<strong>模拟负载均衡</strong>，我们可以提供多个Tomcat服务器，采用不同的端口区分。<br>为了模拟<strong>负载均衡</strong>效果，可以copy 2份虚拟机上的Tomcat服务器，命名为tomcat-2，tomcat-3:</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># cp ~/apache-tomcat-8.5.33 ~/tomcat-2</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># cp ~/apache-tomcat-8.5.33 ~/tomcat-3</span></span><br></pre></td></tr></table></figure>\n<p>修改端口号分别为8180，8280。我们主要修改/tomcat/conf/server.xml配置文件中的&lt;Server port=”8005”和&lt;Connector port=”8080”这两个节点的端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改tomcat-2服务器的`/conf/server.xml`参数</span></span><br><span class=\"line\">&lt;Server port=<span class=\"string\">\"8006\"</span> shutdown=<span class=\"string\">\"SHUTDOWN\"</span>&gt;</span><br><span class=\"line\">        &lt;Connector port=<span class=\"string\">\"8180\"</span> protocol=<span class=\"string\">\"HTTP/1.1\"</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改tomcat-3服务器的`/conf/server.xml`参数</span></span><br><span class=\"line\">&lt;Server port=<span class=\"string\">\"8007\"</span> shutdown=<span class=\"string\">\"SHUTDOWN\"</span>&gt;</span><br><span class=\"line\">        &lt;Connector port=<span class=\"string\">\"8280\"</span> protocol=<span class=\"string\">\"HTTP/1.1\"</span></span><br></pre></td></tr></table></figure>\n<p>如上，我们在虚拟机上配置了三个Tomcat服务器，分别使用8080，8180，8280端口。</p>\n<p>2.<strong>配置负载均衡</strong><br>修改Nginx下的配置文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># vi /usr/local/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure>\n<p>修改之前配置的upstream site {}节点：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream site &#123;</span><br><span class=\"line\">     server 192.168.148.132:8080;</span><br><span class=\"line\">     server 192.168.148.132:8180;</span><br><span class=\"line\">     server 192.168.148.132:8280;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name site.loonycoder.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://site;</span><br><span class=\"line\">        index index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就给Nginx配置了3台服务器，都指向了site.loonycoder.com这个域名地址，那么访问这个地址时同时会访问这三台服务器，也就是三台服务器平均分摊访问压力。<br>为了更好的实现效果，我们可以依次修改tomcat-2和tomcat-3服务器的/webapps/ROOT/index.html网页显示数据，更容易区分每次访问的是哪台服务器。<br>然后运行这三个Tomcat服务器，在浏览器上访问：site.loonycoder.com，多次刷新页面，每次访问的都是不同的页面，且依次是配置负载均衡的三台服务器次序。<br>如果你想让某个服务器承担更大的压力，可以为其设置权重：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream site &#123;</span><br><span class=\"line\">     server 192.168.148.132:8080;</span><br><span class=\"line\">     server 192.168.148.132:8180 weight=2;</span><br><span class=\"line\">     server 192.168.148.132:8280;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/nginx.jpg\" alt=\"nginx\"><br>Nginx是一款高性能HTTP服务器、反向代理服务器及电子邮件（IMAP、POP3）代理服务器，官方测试nginx能够支持5万并发连接。<br><strong>Nginx应用场景：</strong><br>1、http服务器。Nginx是一个http服务器，可以独立提供http服务。可以做网页静态服务器。<br>2、虚拟主机。可以实现在一台服务器虚拟出多个网站。<br>3、反向代理，负载均衡。当网站的并发量过大需要配置服务器集群时可以使用Nginx做反向代理。并且多台服务器可以平均分摊负载。</p>\n<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><h4 id=\"本文章默认使用的软件：\"><a href=\"#本文章默认使用的软件：\" class=\"headerlink\" title=\"本文章默认使用的软件：\"></a>本文章默认使用的软件：</h4><ul>\n<li>CentOS 7</li>\n<li>Nginx-1.12.2</li>\n<li>JDK 8.0</li>\n<li>Tomcat 8</li>\n</ul>\n<h4 id=\"开发工具：\"><a href=\"#开发工具：\" class=\"headerlink\" title=\"开发工具：\"></a>开发工具：</h4><ul>\n<li>VMware fusion</li>\n<li>SecureCRT</li>\n</ul>\n<h3 id=\"安装Nginx\"><a href=\"#安装Nginx\" class=\"headerlink\" title=\"安装Nginx\"></a>安装Nginx</h3><h4 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h4><p>1、安装gcc的环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install gcc-c++</span><br></pre></td></tr></table></figure>\n<p>2、PCRE（perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>\n<p>3、Zlib（zlib提供了很多压缩和解压的方式，nginx使用http包的内容进行gzip）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure>\n<p>4、OpenSSL（一个强大的安全套接字层密码库，为nginx支持的https(即在SSL协议上传输http)协议服务）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>在本地电脑下载nginx的压缩包（我这里是nginx-1.12.2.tar.gz），然后打开SecureCRT连接服务器，使用命令gz将本地的文件上传到Linux服务器上。</p>\n<blockquote>\n<p>注：如果在SecureCRT上输入gz显示command not found，是因为Linux虚拟机上没有安装lrsz服务。<br>执行：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y indtall lrzsz</span><br></pre></td></tr></table></figure>\n<p>然后可以输入rz命令选择要上传的文件。默认上传到当前路径上。</p>\n<p><strong>1、解压</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>\n<p><strong>2、创建Makefile文件，执行命令</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># cd nginx-1.12.2</span></span><br><span class=\"line\">[root@localhost nginx-1.12.2]<span class=\"comment\"># ./configure</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/nginx1.png\" alt=\"nginx\"><br>完成后可以看到Makefile文件：<br><img src=\"/images/nginx2.png\" alt=\"nginx\"><br><strong>拓展</strong><br>Makefile是一种配置文件，Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译…。Makefile就像一个Shell脚本一样。</p>\n<p><strong>3、编译</strong><br>执行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx-1.12.2]<span class=\"comment\"># make</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>4、安装</strong><br>执行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx-1.12.2]<span class=\"comment\"># make install</span></span><br></pre></td></tr></table></figure>\n<p>到此，Nginx安装已经完成。</p>\n<hr>\n<h3 id=\"Nginx启动与访问\"><a href=\"#Nginx启动与访问\" class=\"headerlink\" title=\"Nginx启动与访问\"></a>Nginx启动与访问</h3><p>上面我本编译安装的Nginx其实默认被安装在CentOS7系统的/usr/local/nginx目录。<br><img src=\"/images/nginx3.png\" alt=\"nginx\"></p>\n<h4 id=\"启动Nginx\"><a href=\"#启动Nginx\" class=\"headerlink\" title=\"启动Nginx\"></a>启动Nginx</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx]<span class=\"comment\"># cd sbin</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx</span></span><br></pre></td></tr></table></figure>\n<p>此时已经启动成功Nginx，可以直接在浏览器上输入虚拟机IP（可通过ip addr命令查看），即可访问到Nginx欢迎界面，如果显示未连接，可以：<br>1、先使用本机的终端工具ping虚拟机IP地址看是否成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping ip</span><br></pre></td></tr></table></figure>\n<p>如果ping成功，请看下一步，如果失败，请检查虚拟机是否联网。<br>2、关闭CentOS7的防火墙，开放80端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># systemctl stop firewalld.service #停止firewall</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># systemctl disable firewalld.service #禁止firewall开机启动</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br></pre></td></tr></table></figure>\n<p>一般情况下就能访问到了：<br><img src=\"/images/nginx4.png\" alt=\"nginx\"></p>\n<h4 id=\"查看Nginx进程\"><a href=\"#查看Nginx进程\" class=\"headerlink\" title=\"查看Nginx进程\"></a>查看Nginx进程</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ps aux|grep nginx</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"关闭Nginx\"><a href=\"#关闭Nginx\" class=\"headerlink\" title=\"关闭Nginx\"></a>关闭Nginx</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx -s stop</span></span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx -s quit</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重启Nginx\"><a href=\"#重启Nginx\" class=\"headerlink\" title=\"重启Nginx\"></a>重启Nginx</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx -s reload</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"检查Nginx配置文件是否正确\"><a href=\"#检查Nginx配置文件是否正确\" class=\"headerlink\" title=\"检查Nginx配置文件是否正确\"></a>检查Nginx配置文件是否正确</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx -t</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"部署静态网站\"><a href=\"#部署静态网站\" class=\"headerlink\" title=\"部署静态网站\"></a>部署静态网站</h3><p>经过上面的操作，我们已经正常启动了Nginx，那么如何将我们的静态项目部署到服务器的Nginx上呢？<br>为了模拟操作，我这里只部署一个index.html网页为例：</p>\n<p>1、<strong>上传静态网站</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回到根目录下</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># cd ../</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建文件夹`my`，视为我们的项目文件夹</span></span><br><span class=\"line\">[root@localhost nginx]<span class=\"comment\"># mkdir my</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在文件夹`my`下创建一个`index.html`网页</span></span><br><span class=\"line\">[root@localhost nginx]<span class=\"comment\"># cd my</span></span><br><span class=\"line\">[root@localhost my]<span class=\"comment\"># vi index.html</span></span><br></pre></td></tr></table></figure>\n<p>写入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;h2&gt;Hello Nginx!&lt;/h2&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、<strong>修改Nginx的配置文件</strong><br>修改/usr/local/nginx/conf/nginx.conf文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost my]<span class=\"comment\"># cd ../conf</span></span><br><span class=\"line\">[root@localhost conf]<span class=\"comment\"># vi nginx.conf</span></span><br></pre></td></tr></table></figure>\n<p>在http {}这个节点下新创建一个server {}节点：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 81;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root my;</span><br><span class=\"line\">        index index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如此，我们已经将81端口绑定了/nginx文件夹下的名称为my的项目。重启Nginx，访问：192.168.148.132:81即可以访问到我们刚才新创建的网页：index.html。</p>\n<h4 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h4><p><strong>域名</strong>是由一串用“.”分隔的字符逐层的Internet上某一台计算机或计算机组的名称，用于在数据传输时表示计算机的电子方位。域名是一个IP地址的“面具”。域名的目的是便于记忆和沟通的一组服务器的地址。域名按照<strong>域名系统DNS</strong>的规则流程组成，在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。通常，域名表示互联网协议（IP）资源。<br>一个域名对应一个IP地址，一个IP地址可以被多个域名绑定。<br>为了模拟，我们可以在本地hosts文件中配置域名和IP映射关系，这样就不用走DNS服务器了。<br>因为hosts文件内容不能直接修改，需要把hosts文件拷贝出来然后修改后再替换进去就行了(我这里使用的MacOS系统)。</p>\n<p>1、<strong>修改hosts</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /private/etc/hosts ~/Desktop/</span><br><span class=\"line\">vi ~/Desktop/hosts</span><br></pre></td></tr></table></figure>\n<p>添加：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192.168.148.132 www.loonycoder.com</span><br></pre></td></tr></table></figure>\n<p>然后替换原来的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ~/Desktop/hosts /private/etc/</span><br></pre></td></tr></table></figure>\n\n<p>2、<strong>修改Nginx配置文件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost conf]<span class=\"comment\"># vi /usr/local/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure>\n<p>为了模拟效果，我们可以先把之前新增的server {}节点81端口改为80端口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root my;</span><br><span class=\"line\">        index index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启Nginx：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost conf]<span class=\"comment\"># cd ../sbin</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx -s stop</span></span><br><span class=\"line\">[root@localhost sbin]<span class=\"comment\"># ./nginx</span></span><br></pre></td></tr></table></figure>\n<p>访问192.168.148.132发现还是Nginx的Welcome页面，因为nginx.conf默认配置的80端口就是指向Nginx欢迎页，且默认的server_name就是localhost。那么想实现不同的域名访问不同的资源且还必须是80端口，就需要绑定域名：<br>修改nginx.conf</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.loonycoder.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root my;</span><br><span class=\"line\">        index index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上，很简单，只需要把server_name改为我们要绑定的域名地址就好了，然后重启Nginx，在浏览器上访问&lt;<a href=\"http://www.loonycoder.com&gt;就展示我们之前创建的index.html，而输入192.168.148.132访问的还是Nginx的欢迎页，这就实现了域名的绑定。多个域名绑定同一个IP地址，但是不同的域名指向了不同的资源地址。\" target=\"_blank\" rel=\"noopener\">www.loonycoder.com&gt;就展示我们之前创建的index.html，而输入192.168.148.132访问的还是Nginx的欢迎页，这就实现了域名的绑定。多个域名绑定同一个IP地址，但是不同的域名指向了不同的资源地址。</a></p>\n<hr>\n<h3 id=\"Nginx反向代理\"><a href=\"#Nginx反向代理\" class=\"headerlink\" title=\"Nginx反向代理\"></a>Nginx反向代理</h3><blockquote>\n<p>什么是反向代理？<br>反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n</blockquote>\n<blockquote>\n<p>正向代理<br><img src=\"/images/nginx5.png\" alt=\"nginx\"><br><strong>正向代理</strong>，主要针对客户端。当用户通过PC向Internet发送请求时，可以通过一个代理服务器来统一处理请求并转发给Internet，比如一个教室的所有学生机都需要通过老师的教师机才能实现联网，那么这个教师机就相当于一个代理服务器，负责将PC的网络请求转发给Internet，然后Internet将相应的数据再通过代理服务器转发给不同的PC。</p>\n</blockquote>\n<blockquote>\n<p>反向代理<br><img src=\"/images/nginx6.png\" alt=\"nginx\"><br><strong>反向代理</strong>的过程则刚好相反，主要针对服务器。当用户通过网络请求不同的资源，而这些资源被分布在不同的服务器上，那么不同的请求就应该指向对应不同的服务器，那么就需要一个中介：反向代理服务器。通过反向代理服务器将不同的资源请求信息发送给不同的服务器，然后服务器将不同的信心都返回给反向代理服务器，最后通过反向代理服务器将这些结果信息展示在Internet上。</p>\n</blockquote>\n<h4 id=\"配置反向代理\"><a href=\"#配置反向代理\" class=\"headerlink\" title=\"配置反向代理\"></a>配置反向代理</h4><p>这里我们以一个非常实用的案例来演示如何配置Nginx的反向代理实现不同的域名访问不同的页面。<br>1、在服务器上安装JDK8和Tomcat8<br>通过rz命令将本地的JDK和Tomcat安装包上传到服务器。因为Tomcat解压即可用，我们这里记录一下如何安装JDK：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">tar zxvf jdk-8u191-linux-x64.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置JDK环境</span></span><br><span class=\"line\">vi /etc/profile</span><br></pre></td></tr></table></figure>\n<p>在profile文件的结尾处添加如下环境配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/root/jdk1.8.0_191    </span><br><span class=\"line\"><span class=\"built_in\">export</span> CLASSPATH=.:<span class=\"variable\">$JAVA_HOME</span>/jre/lib/rt.jar:<span class=\"variable\">$JAVA_HOME</span>/lib/dt.jar:<span class=\"variable\">$JAVA_HOME</span>/lib/tools.jar</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>\n<p>:wq!保存并退出，输入命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># source /etc/profile</span></span><br></pre></td></tr></table></figure>\n\n<p>更新配置。然后输入java -version显示则说明JDK配置成功。<br>解压Tomcat，在其bin目录下执行命令./startup.sh启动Tomcat服务器，然后我们再浏览器上访问：<a href=\"http://192.168.148.132:8080/\" target=\"_blank\" rel=\"noopener\">http://192.168.148.132:8080/</a>显示Tomcat的欢迎页面则配置成功。</p>\n<p>2、拷贝项目到Tomcat服务器下<br>为了模拟，我们在tomcat/webapps/ROOT/下创建一个index.html网页：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ROOT]<span class=\"comment\"># vi index.html</span></span><br></pre></td></tr></table></figure>\n<p>并写入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h2&gt;Hello Tomcat!&lt;/h2&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>保存并退出，再次访问<a href=\"http://192.168.148.132:8080/\" target=\"_blank\" rel=\"noopener\">http://192.168.148.132:8080/</a>发现展示的即是我们刚创建的页面<br><img src=\"/images/nginx7.png\" alt=\"nginx\"></p>\n<p>3、配置反向代理<br>之前讲了<strong>反向代理</strong>的概念，那么很实用的一个例子就是，当我们想在购买的阿里云服务器上部署两个项目，一个项目是用Nginx部署的静态网站（占用80端口），另一个项目部署在Tomcat服务器上（占用8080端口）。<br>这时，我们固然是可以通过：ip:8080来访问我们的Web项目的，但是请求路径上显示了端口好久显得很别扭，为此，我们通过Nginx的反向代理就能解决：</p>\n<ul>\n<li><p>3.1在本地配置一个二级域名映射<br>修改本机的hosts文件，添加：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192.168.148.132 site.loonycoder.com</span><br></pre></td></tr></table></figure>\n<p>这时我们访问&lt;site.loonycoder.com&gt;默认进入nginx的欢迎页，这是正确的。<br>注意：此时的&lt;site.loonycoder.com&gt;是&lt;loonycoder.com&gt;的一个二级子域名。</p>\n</li>\n<li><p>3.2 修改服务器Nginx的配置文件，添加如下配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream site &#123;</span><br><span class=\"line\">        server 192.168.148.132:8080;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name site.loonycoder.com;</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            proxy_pass http://site;</span><br><span class=\"line\">            index index.html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，其中server {}节点下的proxy_pass表示反向代理的地址，其中<a href=\"http://site这个site其实是指向上面upstream\" target=\"_blank\" rel=\"noopener\">http://site这个site其实是指向上面upstream</a> site {}节点的site名称，因此要保持两者名称一致。但实际上我们不采用这种方式也能实现反向代理：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># upstream site &#123;</span></span><br><span class=\"line\"><span class=\"comment\">#         server 192.168.148.132:8080;</span></span><br><span class=\"line\"><span class=\"comment\"># &#125;</span></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name site.loonycoder.com;</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            <span class=\"comment\"># proxy_pass http://site;</span></span><br><span class=\"line\">            proxy_pass http://192.168.148.132:8080;</span><br><span class=\"line\">            index index.html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>两者的区别就是第一种方式通过指向的方式可以配置更多，必须实现<strong>负载均衡</strong>就需要在upstream site {}节点下配置。</p>\n<hr>\n<h3 id=\"Nginx配置负载均衡\"><a href=\"#Nginx配置负载均衡\" class=\"headerlink\" title=\"Nginx配置负载均衡\"></a>Nginx配置负载均衡</h3><blockquote>\n<p>什么是负载均衡？<br><strong>负载均衡（Load Balance）</strong>，其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。<br><strong>负载均衡</strong> 是建立在现有网络结构上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽，增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。<br>1.<strong>模拟负载均衡</strong>，我们可以提供多个Tomcat服务器，采用不同的端口区分。<br>为了模拟<strong>负载均衡</strong>效果，可以copy 2份虚拟机上的Tomcat服务器，命名为tomcat-2，tomcat-3:</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># cp ~/apache-tomcat-8.5.33 ~/tomcat-2</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># cp ~/apache-tomcat-8.5.33 ~/tomcat-3</span></span><br></pre></td></tr></table></figure>\n<p>修改端口号分别为8180，8280。我们主要修改/tomcat/conf/server.xml配置文件中的&lt;Server port=”8005”和&lt;Connector port=”8080”这两个节点的端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改tomcat-2服务器的`/conf/server.xml`参数</span></span><br><span class=\"line\">&lt;Server port=<span class=\"string\">\"8006\"</span> shutdown=<span class=\"string\">\"SHUTDOWN\"</span>&gt;</span><br><span class=\"line\">        &lt;Connector port=<span class=\"string\">\"8180\"</span> protocol=<span class=\"string\">\"HTTP/1.1\"</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改tomcat-3服务器的`/conf/server.xml`参数</span></span><br><span class=\"line\">&lt;Server port=<span class=\"string\">\"8007\"</span> shutdown=<span class=\"string\">\"SHUTDOWN\"</span>&gt;</span><br><span class=\"line\">        &lt;Connector port=<span class=\"string\">\"8280\"</span> protocol=<span class=\"string\">\"HTTP/1.1\"</span></span><br></pre></td></tr></table></figure>\n<p>如上，我们在虚拟机上配置了三个Tomcat服务器，分别使用8080，8180，8280端口。</p>\n<p>2.<strong>配置负载均衡</strong><br>修改Nginx下的配置文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># vi /usr/local/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure>\n<p>修改之前配置的upstream site {}节点：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream site &#123;</span><br><span class=\"line\">     server 192.168.148.132:8080;</span><br><span class=\"line\">     server 192.168.148.132:8180;</span><br><span class=\"line\">     server 192.168.148.132:8280;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name site.loonycoder.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://site;</span><br><span class=\"line\">        index index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就给Nginx配置了3台服务器，都指向了site.loonycoder.com这个域名地址，那么访问这个地址时同时会访问这三台服务器，也就是三台服务器平均分摊访问压力。<br>为了更好的实现效果，我们可以依次修改tomcat-2和tomcat-3服务器的/webapps/ROOT/index.html网页显示数据，更容易区分每次访问的是哪台服务器。<br>然后运行这三个Tomcat服务器，在浏览器上访问：site.loonycoder.com，多次刷新页面，每次访问的都是不同的页面，且依次是配置负载均衡的三台服务器次序。<br>如果你想让某个服务器承担更大的压力，可以为其设置权重：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream site &#123;</span><br><span class=\"line\">     server 192.168.148.132:8080;</span><br><span class=\"line\">     server 192.168.148.132:8180 weight=2;</span><br><span class=\"line\">     server 192.168.148.132:8280;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Redis高可用解决方案总结","date":"2018-12-05T16:00:00.000Z","_content":"![redis](/images/redis-logo.png)\n本文主要针对 Redis 常见的几种使用方式及其优缺点展开分析。\n\n### 常见使用方式\nRedis 的几种常见使用方式包括：\n\n- Redis 单副本；\n\n- Redis 多副本（主从）；\n\n- Redis Sentinel（哨兵）；\n\n- Redis Cluster；\n\n- Redis 自研。\n\n---\n\n### 各种使用方式的优缺点\n\n#### Redis 单副本\n\nRedis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。\n![redis](/images/redis1.jpg)\n**优点**：\n\n架构简单，部署方便；\n\n高性价比：缓存使用时无需备用节点（单实例可用性可以用 supervisor 或 crontab 保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；\n\n高性能。\n\n**缺点**：\n\n不保证数据的可靠性；\n\n在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；\n\n高性能受限于单核 CPU 的处理能力（Redis 是单线程机制），CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代。\n\n#### Redis 多副本（主从）\n\nRedis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。\n![redis](/images/redis2.jpg)\n\n**优点**：\n\n高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；\n\n读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。\n\n**缺点**：\n\n故障恢复复杂，如果没有 RedisHA 系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；\n\n主库的写能力受到单机的限制，可以考虑分片；\n\n主库的存储能力受到单机的限制，可以考虑 Pika；\n\n原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘 IO 和 CPU（压缩）资源消耗；发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。\n\n#### Redis 多副本（主从）\nRedis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。\n\n其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1（n>=1）的奇数个。\n![redis](/images/redis3.jpg)\n![redis](/images/redis4.jpg)\n**优点**：\n\nRedis Sentinel 集群部署简单；\n\n能够解决 Redis 主从模式下的高可用切换问题；\n\n很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求；\n\n可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。\n\n**缺点**：\n\n部署相对 Redis 主从模式要复杂一些，原理理解更繁琐；\n\n资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供服务；\n\nRedis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。\n\n不能解决读写分离问题，实现起来相对复杂。\n\n**建议**：\n\n如果监控同一业务，可以选择一套 Sentinel 集群监控多组 Redis 数据节点的方案，反之选择一套 Sentinel 监控一组 Redis 数据节点的方案。\n\nsentinel monitor配置中的建议设置成 Sentinel 节点的一半加 1，当 Sentinel 部署在多个 IDC 的时候，单个 IDC 部署的 Sentinel 数量不建议超过（Sentinel 数量 – quorum）。\n\n合理设置参数，防止误切，控制切换灵敏度控制：\n\na. quorum\n\nb. down-after-milliseconds 30000\n\nc. failover-timeout 180000\n\nd. maxclient\n\ne. timeout\n\n部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱。\n\nRedis 建议使用 pipeline 和 multi-keys 操作，减少 RTT 次数，提高请求效率。\n\n自行搞定配置中心（zookeeper），方便客户端对实例的链接访问。\n\n#### Redis Cluster\nRedis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。\n\nRedis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。\n\nRedis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。\n![redis](/images/redis5.jpg)\n**优点**：\n\n无中心架构；\n\n数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；\n\n可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；\n\n高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；\n\n降低运维成本，提高系统的扩展性和可用性。\n\n**缺点**：\n\nClient 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。\n\n节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。\n\n数据通过异步复制，不保证数据的强一致性。\n\n多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。\n\nSlave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。\n\nKey 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。\n\nKey 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。\n\nKey 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。\n\n不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。\n\n复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。\n\n避免产生 hot-key，导致主库节点成为系统的短板。\n\n避免产生 big-key，导致网卡撑爆、慢查询等。\n\n重试时间应该大于 cluster-node-time 时间。\n\nRedis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。\n\n#### Redis 自研\nRedis 自研的高可用解决方案，主要体现在配置中心、故障探测和 failover 的处理机制上，通常需要根据企业业务的实际线上环境来定制化。\n![redis](/images/redis6.jpg)\n![redis](/images/redis7.jpg)\n优点：\n\n高可靠性、高可用性；\n\n自主可控性高；\n\n贴切业务实际需求，可缩性好，兼容性好。\n\n缺点：\n\n实现复杂，开发成本高；\n\n需要建立配套的周边设施，如监控，域名服务，存储元数据信息的数据库等；\n\n维护成本高。\n\n","source":"_posts/redis-2.md","raw":"---\ntitle: Redis高可用解决方案总结\ncategories:\n    - 数据库\n    \ndate: 2018-12-06\ntags:\n\t- 数据库\n    - Redis\n---\n![redis](/images/redis-logo.png)\n本文主要针对 Redis 常见的几种使用方式及其优缺点展开分析。\n\n### 常见使用方式\nRedis 的几种常见使用方式包括：\n\n- Redis 单副本；\n\n- Redis 多副本（主从）；\n\n- Redis Sentinel（哨兵）；\n\n- Redis Cluster；\n\n- Redis 自研。\n\n---\n\n### 各种使用方式的优缺点\n\n#### Redis 单副本\n\nRedis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。\n![redis](/images/redis1.jpg)\n**优点**：\n\n架构简单，部署方便；\n\n高性价比：缓存使用时无需备用节点（单实例可用性可以用 supervisor 或 crontab 保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；\n\n高性能。\n\n**缺点**：\n\n不保证数据的可靠性；\n\n在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；\n\n高性能受限于单核 CPU 的处理能力（Redis 是单线程机制），CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代。\n\n#### Redis 多副本（主从）\n\nRedis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。\n![redis](/images/redis2.jpg)\n\n**优点**：\n\n高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；\n\n读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。\n\n**缺点**：\n\n故障恢复复杂，如果没有 RedisHA 系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；\n\n主库的写能力受到单机的限制，可以考虑分片；\n\n主库的存储能力受到单机的限制，可以考虑 Pika；\n\n原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘 IO 和 CPU（压缩）资源消耗；发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。\n\n#### Redis 多副本（主从）\nRedis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。\n\n其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1（n>=1）的奇数个。\n![redis](/images/redis3.jpg)\n![redis](/images/redis4.jpg)\n**优点**：\n\nRedis Sentinel 集群部署简单；\n\n能够解决 Redis 主从模式下的高可用切换问题；\n\n很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求；\n\n可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。\n\n**缺点**：\n\n部署相对 Redis 主从模式要复杂一些，原理理解更繁琐；\n\n资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供服务；\n\nRedis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。\n\n不能解决读写分离问题，实现起来相对复杂。\n\n**建议**：\n\n如果监控同一业务，可以选择一套 Sentinel 集群监控多组 Redis 数据节点的方案，反之选择一套 Sentinel 监控一组 Redis 数据节点的方案。\n\nsentinel monitor配置中的建议设置成 Sentinel 节点的一半加 1，当 Sentinel 部署在多个 IDC 的时候，单个 IDC 部署的 Sentinel 数量不建议超过（Sentinel 数量 – quorum）。\n\n合理设置参数，防止误切，控制切换灵敏度控制：\n\na. quorum\n\nb. down-after-milliseconds 30000\n\nc. failover-timeout 180000\n\nd. maxclient\n\ne. timeout\n\n部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱。\n\nRedis 建议使用 pipeline 和 multi-keys 操作，减少 RTT 次数，提高请求效率。\n\n自行搞定配置中心（zookeeper），方便客户端对实例的链接访问。\n\n#### Redis Cluster\nRedis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。\n\nRedis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。\n\nRedis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。\n![redis](/images/redis5.jpg)\n**优点**：\n\n无中心架构；\n\n数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；\n\n可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；\n\n高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；\n\n降低运维成本，提高系统的扩展性和可用性。\n\n**缺点**：\n\nClient 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。\n\n节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。\n\n数据通过异步复制，不保证数据的强一致性。\n\n多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。\n\nSlave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。\n\nKey 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。\n\nKey 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。\n\nKey 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。\n\n不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。\n\n复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。\n\n避免产生 hot-key，导致主库节点成为系统的短板。\n\n避免产生 big-key，导致网卡撑爆、慢查询等。\n\n重试时间应该大于 cluster-node-time 时间。\n\nRedis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。\n\n#### Redis 自研\nRedis 自研的高可用解决方案，主要体现在配置中心、故障探测和 failover 的处理机制上，通常需要根据企业业务的实际线上环境来定制化。\n![redis](/images/redis6.jpg)\n![redis](/images/redis7.jpg)\n优点：\n\n高可靠性、高可用性；\n\n自主可控性高；\n\n贴切业务实际需求，可缩性好，兼容性好。\n\n缺点：\n\n实现复杂，开发成本高；\n\n需要建立配套的周边设施，如监控，域名服务，存储元数据信息的数据库等；\n\n维护成本高。\n\n","slug":"redis-2","published":1,"updated":"2020-02-21T17:15:07.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiz50017v9s61sf51iof","content":"<p><img src=\"/images/redis-logo.png\" alt=\"redis\"><br>本文主要针对 Redis 常见的几种使用方式及其优缺点展开分析。</p>\n<h3 id=\"常见使用方式\"><a href=\"#常见使用方式\" class=\"headerlink\" title=\"常见使用方式\"></a>常见使用方式</h3><p>Redis 的几种常见使用方式包括：</p>\n<ul>\n<li><p>Redis 单副本；</p>\n</li>\n<li><p>Redis 多副本（主从）；</p>\n</li>\n<li><p>Redis Sentinel（哨兵）；</p>\n</li>\n<li><p>Redis Cluster；</p>\n</li>\n<li><p>Redis 自研。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"各种使用方式的优缺点\"><a href=\"#各种使用方式的优缺点\" class=\"headerlink\" title=\"各种使用方式的优缺点\"></a>各种使用方式的优缺点</h3><h4 id=\"Redis-单副本\"><a href=\"#Redis-单副本\" class=\"headerlink\" title=\"Redis 单副本\"></a>Redis 单副本</h4><p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。<br><img src=\"/images/redis1.jpg\" alt=\"redis\"><br><strong>优点</strong>：</p>\n<p>架构简单，部署方便；</p>\n<p>高性价比：缓存使用时无需备用节点（单实例可用性可以用 supervisor 或 crontab 保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；</p>\n<p>高性能。</p>\n<p><strong>缺点</strong>：</p>\n<p>不保证数据的可靠性；</p>\n<p>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；</p>\n<p>高性能受限于单核 CPU 的处理能力（Redis 是单线程机制），CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代。</p>\n<h4 id=\"Redis-多副本（主从）\"><a href=\"#Redis-多副本（主从）\" class=\"headerlink\" title=\"Redis 多副本（主从）\"></a>Redis 多副本（主从）</h4><p>Redis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。<br><img src=\"/images/redis2.jpg\" alt=\"redis\"></p>\n<p><strong>优点</strong>：</p>\n<p>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；</p>\n<p>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</p>\n<p><strong>缺点</strong>：</p>\n<p>故障恢复复杂，如果没有 RedisHA 系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；</p>\n<p>主库的写能力受到单机的限制，可以考虑分片；</p>\n<p>主库的存储能力受到单机的限制，可以考虑 Pika；</p>\n<p>原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘 IO 和 CPU（压缩）资源消耗；发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</p>\n<h4 id=\"Redis-多副本（主从）-1\"><a href=\"#Redis-多副本（主从）-1\" class=\"headerlink\" title=\"Redis 多副本（主从）\"></a>Redis 多副本（主从）</h4><p>Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。</p>\n<p>其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1（n&gt;=1）的奇数个。<br><img src=\"/images/redis3.jpg\" alt=\"redis\"><br><img src=\"/images/redis4.jpg\" alt=\"redis\"><br><strong>优点</strong>：</p>\n<p>Redis Sentinel 集群部署简单；</p>\n<p>能够解决 Redis 主从模式下的高可用切换问题；</p>\n<p>很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求；</p>\n<p>可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。</p>\n<p><strong>缺点</strong>：</p>\n<p>部署相对 Redis 主从模式要复杂一些，原理理解更繁琐；</p>\n<p>资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供服务；</p>\n<p>Redis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。</p>\n<p>不能解决读写分离问题，实现起来相对复杂。</p>\n<p><strong>建议</strong>：</p>\n<p>如果监控同一业务，可以选择一套 Sentinel 集群监控多组 Redis 数据节点的方案，反之选择一套 Sentinel 监控一组 Redis 数据节点的方案。</p>\n<p>sentinel monitor配置中的建议设置成 Sentinel 节点的一半加 1，当 Sentinel 部署在多个 IDC 的时候，单个 IDC 部署的 Sentinel 数量不建议超过（Sentinel 数量 – quorum）。</p>\n<p>合理设置参数，防止误切，控制切换灵敏度控制：</p>\n<p>a. quorum</p>\n<p>b. down-after-milliseconds 30000</p>\n<p>c. failover-timeout 180000</p>\n<p>d. maxclient</p>\n<p>e. timeout</p>\n<p>部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱。</p>\n<p>Redis 建议使用 pipeline 和 multi-keys 操作，减少 RTT 次数，提高请求效率。</p>\n<p>自行搞定配置中心（zookeeper），方便客户端对实例的链接访问。</p>\n<h4 id=\"Redis-Cluster\"><a href=\"#Redis-Cluster\" class=\"headerlink\" title=\"Redis Cluster\"></a>Redis Cluster</h4><p>Redis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。</p>\n<p>Redis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p>\n<p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。<br><img src=\"/images/redis5.jpg\" alt=\"redis\"><br><strong>优点</strong>：</p>\n<p>无中心架构；</p>\n<p>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；</p>\n<p>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</p>\n<p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；</p>\n<p>降低运维成本，提高系统的扩展性和可用性。</p>\n<p><strong>缺点</strong>：</p>\n<p>Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p>\n<p>节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。</p>\n<p>数据通过异步复制，不保证数据的强一致性。</p>\n<p>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p>\n<p>Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。</p>\n<p>Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。</p>\n<p>Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。</p>\n<p>Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。</p>\n<p>不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</p>\n<p>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p>\n<p>避免产生 hot-key，导致主库节点成为系统的短板。</p>\n<p>避免产生 big-key，导致网卡撑爆、慢查询等。</p>\n<p>重试时间应该大于 cluster-node-time 时间。</p>\n<p>Redis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。</p>\n<h4 id=\"Redis-自研\"><a href=\"#Redis-自研\" class=\"headerlink\" title=\"Redis 自研\"></a>Redis 自研</h4><p>Redis 自研的高可用解决方案，主要体现在配置中心、故障探测和 failover 的处理机制上，通常需要根据企业业务的实际线上环境来定制化。<br><img src=\"/images/redis6.jpg\" alt=\"redis\"><br><img src=\"/images/redis7.jpg\" alt=\"redis\"><br>优点：</p>\n<p>高可靠性、高可用性；</p>\n<p>自主可控性高；</p>\n<p>贴切业务实际需求，可缩性好，兼容性好。</p>\n<p>缺点：</p>\n<p>实现复杂，开发成本高；</p>\n<p>需要建立配套的周边设施，如监控，域名服务，存储元数据信息的数据库等；</p>\n<p>维护成本高。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/redis-logo.png\" alt=\"redis\"><br>本文主要针对 Redis 常见的几种使用方式及其优缺点展开分析。</p>\n<h3 id=\"常见使用方式\"><a href=\"#常见使用方式\" class=\"headerlink\" title=\"常见使用方式\"></a>常见使用方式</h3><p>Redis 的几种常见使用方式包括：</p>\n<ul>\n<li><p>Redis 单副本；</p>\n</li>\n<li><p>Redis 多副本（主从）；</p>\n</li>\n<li><p>Redis Sentinel（哨兵）；</p>\n</li>\n<li><p>Redis Cluster；</p>\n</li>\n<li><p>Redis 自研。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"各种使用方式的优缺点\"><a href=\"#各种使用方式的优缺点\" class=\"headerlink\" title=\"各种使用方式的优缺点\"></a>各种使用方式的优缺点</h3><h4 id=\"Redis-单副本\"><a href=\"#Redis-单副本\" class=\"headerlink\" title=\"Redis 单副本\"></a>Redis 单副本</h4><p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。<br><img src=\"/images/redis1.jpg\" alt=\"redis\"><br><strong>优点</strong>：</p>\n<p>架构简单，部署方便；</p>\n<p>高性价比：缓存使用时无需备用节点（单实例可用性可以用 supervisor 或 crontab 保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；</p>\n<p>高性能。</p>\n<p><strong>缺点</strong>：</p>\n<p>不保证数据的可靠性；</p>\n<p>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；</p>\n<p>高性能受限于单核 CPU 的处理能力（Redis 是单线程机制），CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代。</p>\n<h4 id=\"Redis-多副本（主从）\"><a href=\"#Redis-多副本（主从）\" class=\"headerlink\" title=\"Redis 多副本（主从）\"></a>Redis 多副本（主从）</h4><p>Redis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。<br><img src=\"/images/redis2.jpg\" alt=\"redis\"></p>\n<p><strong>优点</strong>：</p>\n<p>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；</p>\n<p>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</p>\n<p><strong>缺点</strong>：</p>\n<p>故障恢复复杂，如果没有 RedisHA 系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；</p>\n<p>主库的写能力受到单机的限制，可以考虑分片；</p>\n<p>主库的存储能力受到单机的限制，可以考虑 Pika；</p>\n<p>原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘 IO 和 CPU（压缩）资源消耗；发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</p>\n<h4 id=\"Redis-多副本（主从）-1\"><a href=\"#Redis-多副本（主从）-1\" class=\"headerlink\" title=\"Redis 多副本（主从）\"></a>Redis 多副本（主从）</h4><p>Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。</p>\n<p>其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1（n&gt;=1）的奇数个。<br><img src=\"/images/redis3.jpg\" alt=\"redis\"><br><img src=\"/images/redis4.jpg\" alt=\"redis\"><br><strong>优点</strong>：</p>\n<p>Redis Sentinel 集群部署简单；</p>\n<p>能够解决 Redis 主从模式下的高可用切换问题；</p>\n<p>很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求；</p>\n<p>可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。</p>\n<p><strong>缺点</strong>：</p>\n<p>部署相对 Redis 主从模式要复杂一些，原理理解更繁琐；</p>\n<p>资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供服务；</p>\n<p>Redis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。</p>\n<p>不能解决读写分离问题，实现起来相对复杂。</p>\n<p><strong>建议</strong>：</p>\n<p>如果监控同一业务，可以选择一套 Sentinel 集群监控多组 Redis 数据节点的方案，反之选择一套 Sentinel 监控一组 Redis 数据节点的方案。</p>\n<p>sentinel monitor配置中的建议设置成 Sentinel 节点的一半加 1，当 Sentinel 部署在多个 IDC 的时候，单个 IDC 部署的 Sentinel 数量不建议超过（Sentinel 数量 – quorum）。</p>\n<p>合理设置参数，防止误切，控制切换灵敏度控制：</p>\n<p>a. quorum</p>\n<p>b. down-after-milliseconds 30000</p>\n<p>c. failover-timeout 180000</p>\n<p>d. maxclient</p>\n<p>e. timeout</p>\n<p>部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱。</p>\n<p>Redis 建议使用 pipeline 和 multi-keys 操作，减少 RTT 次数，提高请求效率。</p>\n<p>自行搞定配置中心（zookeeper），方便客户端对实例的链接访问。</p>\n<h4 id=\"Redis-Cluster\"><a href=\"#Redis-Cluster\" class=\"headerlink\" title=\"Redis Cluster\"></a>Redis Cluster</h4><p>Redis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。</p>\n<p>Redis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p>\n<p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。<br><img src=\"/images/redis5.jpg\" alt=\"redis\"><br><strong>优点</strong>：</p>\n<p>无中心架构；</p>\n<p>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；</p>\n<p>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</p>\n<p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；</p>\n<p>降低运维成本，提高系统的扩展性和可用性。</p>\n<p><strong>缺点</strong>：</p>\n<p>Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p>\n<p>节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。</p>\n<p>数据通过异步复制，不保证数据的强一致性。</p>\n<p>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p>\n<p>Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。</p>\n<p>Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。</p>\n<p>Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。</p>\n<p>Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。</p>\n<p>不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</p>\n<p>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p>\n<p>避免产生 hot-key，导致主库节点成为系统的短板。</p>\n<p>避免产生 big-key，导致网卡撑爆、慢查询等。</p>\n<p>重试时间应该大于 cluster-node-time 时间。</p>\n<p>Redis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。</p>\n<h4 id=\"Redis-自研\"><a href=\"#Redis-自研\" class=\"headerlink\" title=\"Redis 自研\"></a>Redis 自研</h4><p>Redis 自研的高可用解决方案，主要体现在配置中心、故障探测和 failover 的处理机制上，通常需要根据企业业务的实际线上环境来定制化。<br><img src=\"/images/redis6.jpg\" alt=\"redis\"><br><img src=\"/images/redis7.jpg\" alt=\"redis\"><br>优点：</p>\n<p>高可靠性、高可用性；</p>\n<p>自主可控性高；</p>\n<p>贴切业务实际需求，可缩性好，兼容性好。</p>\n<p>缺点：</p>\n<p>实现复杂，开发成本高；</p>\n<p>需要建立配套的周边设施，如监控，域名服务，存储元数据信息的数据库等；</p>\n<p>维护成本高。</p>\n"},{"title":"Linux常用命令","date":"2018-12-13T16:00:00.000Z","_content":"![linux](/images/linux-logo.jpg)\n\n---\n\n### 基本命令\n#### 关机和重启\n```bash\n$ shutdown -h now        立刻关机\n$ shutdown -h 5        5分钟后关机\n$ poweroff            立刻关机\n```\n#### 帮助命令\n```bash\n--help命令\n$ shutdown --help：\n$ ifconfig  --help：查看网卡信息\n \n--man命令（命令说明书） \n$ man shutdown\n--注意：man shutdown打开命令说明书之后，使用按键q退出\n```\n\n---\n\n### 目录操作命令\n#### 目录切换 cd\n```bash\n--命令：cd 目录\n$ cd /        切换到根目录\n$ cd /usr        切换到根目录下的usr目录\n$ cd ../        切换到上一级目录 或者  cd ..\n$ cd ~        切换到home目录\n$ cd -        切换到上次访问的目录\n```\n#### 目录查看 ls [-al]\n```bash\n--命令：ls [-al]\n$ ls                查看当前目录下的所有目录和文件\n$ ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）\n$ ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）\n$ ls /dir            查看指定目录下的所有目录和文件   如：ls /usr\n```\n#### 目录操作 [增删改查]\n##### 创建目录 [增] mkdir\n```bash\n--命令：mkdir 目录\n$ mkdir xxx           在当前目录下创建一个名为xxx的目录\n$ mkdir /usr/xxx   在指定目录下创建一个名为xxx的目录\n```\n##### 删除目录或文件 [删] rm\n```bash\n--命令：rm [-rf] 目录\n\n删除文件：\n$ rm 文件        删除当前目录下的文件\n$ rm -f 文件    删除当前目录的的文件（不询问）\n\n删除目录：\n$ rm -r xxx  递归删除当前目录下的xxx目录\n$ rm -rf xxx  递归删除当前目录下的xxx目录（不询问）\n\n全部删除：\n$ rm -rf *    将当前目录下的所有目录和文件全部删除\n$ rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除\n\n注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包\n```\n##### 目录修改 [改] mv和cp\n```bash\n一、重命名目录\n    命令：mv 当前目录  新目录\n    例如：mv xxx coder    将目录xxx改为coder\n    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作\n\n二、剪切目录\n    命令：mv 目录名称 目录的新位置\n    示例：将/usr/tmp目录下的xxx目录剪切到 /usr目录下面     mv /usr/tmp/xxx /usr\n    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作\n\n三、拷贝目录\n    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归\n    示例：将/usr/tmp目录下的xxx目录复制到 /usr目录下面     cp /usr/tmp/xxx  /usr\n    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用写-r递归\n```\n##### 搜索目录 [查] find\n```bash\n$ find 目录 参数 文件名称\n示例：find /usr/tmp -name 'a*'  查找/usr/tmp目录下的所有以a开头的目录或文件\n```\n\n---\n\n### 文件操作命令\n#### 文件操作 [增删改查]\n##### 新建文件 [增] touch\n```bash\n$ touch 文件名\n示例：在当前目录创建一个名为aa.txt的文件 touch xxx.txt\n```\n##### 删除文件 [删] rm\n```bash\n$ rm -rf 文件名\n```\n##### 修改文件 [改] vi/vim\n**[vi编辑器的3种模式]**\n基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：\n- 命令行模式command mode）\n控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。\n\t命令行模式下的常用命令：\n       - 控制光标移动：↑，↓，j\n       - 删除当前行：dd \n       - 查找：/字符\n       - 进入编辑模式：i o a\n       - 进入底行模式：:\n      \n- 编辑模式（Insert mode）\n\t只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。\n    编辑模式下常用命令：\n       - ESC 退出编辑模式到命令行模式；\n      \n- 底行模式（last line mode）\n    将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。\n    底行模式下常用命令：\n       - 退出编辑：   :q\n       - 强制退出：   :q!\n       - 保存并退出：  :wq\n\n**打开文件**\n```bash\n$ vi 文件名\n示例：打开当前目录下的xxx.txt文件  vi xxx.txt 或者 vim xxx.txt\n注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。\n```\n\n**编辑文件**\n\n使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。\ni:在光标所在字符前开始插入\na:在光标所在字符后开始插入\no:在光标所在行的下面另起一新行插入\n\n**保存或者取消编辑**\n\n保存文件：\n第一步：ESC  进入命令行模式\n第二步：:     进入底行模式\n第三步：wq     保存并退出编辑\n取消编辑：\n\n第一步：ESC  进入命令行模式\n第二步：:     进入底行模式\n第三步：q!     撤销本次修改并退出编辑\n##### 文件的查看 [查]\n文件的查看命令：cat/more/less/tail\n**cat：看最后一屏**\n```bash\n示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容\n$ cat sudo.conf\n```\n**more：百分比显示**\n```bash\n示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看\n$ more sudo.conf\n```\n**less：翻页查看**\n```bash\n示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看\n$ less sudo.conf\n```\n**tail：指定行数或者动态查看**\n```bash\n示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束  \n$ tail -10 sudo.conf\n```\n#### 权限修改\nrwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。\n\n示例：给xxx.txt文件权限改为可执行文件权限，xxx.txt文件的权限是-rw --- ---\n\n第一位：-就代表是文件，d代表是文件夹\n第一段（3位）：代表拥有者的权限\n第二段（3位）：代表拥有者所在的组，组员的权限\n第三段（最后3位）：代表的是其他用户的权限\n\n421  421  421\nrw-  ---  ---\n```bash\n$ chmod +x xxx.txt\n或者采用8421法\n$ chmod 100 xxx.txt\n```\n\n---\n\n### 压缩文件操作\n#### 打包和压缩\nWindows的压缩文件的扩展名  .zip/.rar\nlinux中的打包文件：xxx.tar      \nlinux中的压缩文件：xxx.gz    \nlinux中打包并压缩的文件：.tar.gz\n\nLinux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。\n而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。\n```bash\n命令：tar -zcvf 打包压缩后的文件名 要打包的文件\n其中：z：调用gzip压缩命令进行压缩\n  c：打包文件\n  v：显示运行过程\n  f：指定文件名\n示例：打包并压缩/usr/tmp下的所有文件压缩后的压缩包指定名称为xxx.tar\n$ tar -zcvf xxx.tar xx.txt xxx.txt \n或\n$ tar -zcvf xx.tar *\n```\n#### 解压\n```bash\n命令：tar [-zxvf] 压缩文件    \n其中：x：代表解压\n示例：将/usr/tmp下的xxx.tar解压到当前目录下\n$ tar -zxvf xxx.tar\n```\n```bash\n示例：将/usr/tmp 下的xx.tar解压到根目录/usr下\n$ tar -zxvf xx.tar -C /usr -C代表指定解压的位置\n```\n\n---\n\n### 查找命令\n#### grep\ngrep命令是一种强大的文本搜索工具\n使用实例：\n```bash\n$ ps -ef | grep sshd  查找指定ssh服务进程 \n$ ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除grep本身 \n$ ps -ef | grep sshd -c 查找指定进程个数 \n```\n#### find\nfind命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 \nfind 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\n使用实例：\n```bash\n$ find . -name \"*.log\" -ls  在当前目录查找以.log结尾的文件，并显示详细信息。 \n$ find /root/ -perm 600   查找/root/目录下权限为600的文件 \n$ find . -type f -name \"*.log\"  查找当目录，以.log结尾的普通文件 \n$ find . -type d | sort   查找当前所有目录并排序 \n$ find . -size +100M  查找当前目录大于100M的文件\n```\n#### locate\nlocate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，<font style=\"color: red\">先使用updatedb命令</font>，手动更新数据库。如果数据库中没有查询的数据，则会报出<font style=\"color: red\">locate: can not stat () '/var/lib/mlocate/mlocate.db': No such file or directory</font>该错误！updatedb即可！\n\n**<code>yum -y install mlocate</code>如果是精简版CentOS系统需要安装locate命令**\n使用实例：\n```bash\nupdatedb\n$ locate /etc/sh 搜索etc目录下所有以sh开头的文件 \n$ locate pwd 查找和pwd相关的所有文件\n```\n#### whereis\nwhereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。\n使用实例：\n```bash\n$ whereis ls    将和ls文件相关的文件都查找出来\n```\n#### which\nwhich命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。\n使用实例：\n```bash\n$ which pwd  查找pwd命令所在路径 \n$ which java  查找path中java的路径 \n```\n\n---\n\n### su/sudo\n#### su\nsu用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。\n```bash\n$ su test:切换到test用户，但是路径还是/root目录\n$ su - test : 切换到test用户，路径变成了/home/test\n$ su : 切换到root用户，但是路径还是原来的路径\n$ su - : 切换到root用户，并且路径是/root\n```\nsu不足：如果某个用户需要使用root权限、则必须要把root密码告诉此用户。\n退出返回之前的用户：exit\n\n#### sudo\nsudo是为所有想使用root权限的普通用户设计的。可以让普通用户具有临时使用root权限的权利。只需输入自己账户的密码即可。\n进入sudo配置文件命令：\n```bash\nvi /etc/sudoer或者visudo\n```\n```bash\n案例：\n允许hadoop用户以root身份执行各种应用命令，需要输入hadoop用户的密码。\n$ hadoop  ALL=(ALL)   ALL \n \n案例：\n只允许hadoop用户以root身份执行ls 、cat命令，并且执行时候免输入密码。 \n配置文件中： \n$ hadoop  ALL=NOPASSWD:  /bin/ls, /bin/cat \n\n```\n\n---\n\n### 系统服务\n```bash\n$ service iptables status  --查看iptables服务的状态\n$ service iptables start  --开启iptables服务\n$ service iptables stop  --停止iptables服务\n$ service iptables restart  --重启iptables服务\n$ chkconfig iptables off  --关闭iptables服务的开机自启动\n$ chkconfig iptables on  --开启iptables服务的开机自启动\n```\n\n---\n\n### 网络管理\n#### 主机名配置\n```bash\n[root@loonycoder ~]# vi /etc/sysconfig/network\nNETWORKING=yes\nHOSTNAME=loonycoder\n```\n#### IP 地址配置\n```bash\n[root@loonycoder ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0\n```\n#### 域名映射\n/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用。所以，你想访问一个什么样的主机名，就需要把这个主机名和它对应的ip地址。\n```bash\n[root@loonycoder ~]# vi /etc/hosts\n#### 在最后加上\n192.168.0.1  node1\n192.168.0.2  node2\n192.168.0.3  node3\n```\n\n---\n\n### 定时任务指令crontab 配置\ncrontab是Unix和Linux用于设置定时任务的指令。通过crontab命令，可以在固定间隔时间,执行指定的系统指令或shell脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。\ncrontab安装：\n```bash\n$ yum install crontabs\n```\n服务操作说明：\n```bash\n$ service crond start   ## 启动服务 \n$ service crond stop    ## 关闭服务 \n$ service crond restart ## 重启服务\n```\n#### 命令格式\n```bash\n$ crontab [-u user] file\n$ crontab [-u user] [ -e | -l | -r ]\n```\n参数说明：\n**-u user**：用来设定某个用户的crontab服务  \n\n**file**：file是命令文件的名字,表示将file做为crontab的任务列表文件\n并载入crontab。\n\n**-e**：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前\n用户的crontab文件。\n\n**-l**：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前\n用户的crontab文件内容。\n\n**-r**：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab\n文件，如果不指定用户，则默认删除当前用户的crontab文件。\n\n命令示例：\n```bash\n$ crontab file [-u user] ## 用指定的文件替代目前的crontab\n$ crontab -l [-u user]  ## 列出用户目前的crontab\n$ crontab -e [-u user]  ## 编辑用户目前的crontab\n```\n#### 配置说明、实例\n命令：*   *    *   *   *   command  \n\n解释：分  时  日  月  周  命令\n\n第1列表示分钟1～59 每分钟用\\*或者 \\*/1表示    \n\n第2列表示小时0～23（0表示0点）\n\n第3列表示日期1～31  \n\n第4列表示月份1～12  \n\n第5列标识号星期0～6（0表示星期天）  \n\n第6列要运行的命令\n\n配置实例：\n```bash\n#先打开定时任务所在的文件：\n$ crontab -e\n \n#每分钟执行一次date命令 \n$ */1 * * * * date >> /root/date.txt\n \n#每晚的21:30重启apache。 \n$ 30 21 * * * service httpd restart\n \n#每月1、10、22日的4 : 45重启apache。  \n$ 45 4 1,10,22 * * service httpd restart\n \n#每周六、周日的1 : 10重启apache。 \n$ 10 1 * * 6,0 service httpd restart\n \n#每天18 : 00至23 : 00之间每隔30分钟重启apache。\n$ 0,30   18-23    *   *   *   service httpd restart\n\n#晚上11点到早上7点之间，每隔一小时重启apache\n$ *  23-7/1    *   *   *   service httpd restart\n```\n\n---\n\n### 其他命令\n#### 查看当前目录：pwd\n```bash\n$ pwd     #查看当前目录路径\n```\n#### 查看进程：ps -ef\n```bash\n$ ps -ef  #查看所有正在运行的进程\n```\n#### 结束进程：kill\n```bash\n$ kill pid 或者 kill -9 pid #(强制杀死进程)           #pid:进程号\n```\n#### 网络通信命令：\n```bash\n# ifconfig：查看网卡信息\n\n$ ifconfig 或 ifconfig | more\n\n# ping：查看与某台机器的连接情况\n\n$ ping ip\n\n$ netstat -an：查看当前系统端口\n\n$ netstat -an\n\n# 搜索指定端口\n\n$ netstat -an | grep 8080\n```\n#### 配置网络\n```bash\n$ setup\n```\n#### 重启网络\n```bash\n$ service network restart\n```\n#### 切换用户\n```bash\n$ su -用户名\n```\n#### 关闭防火墙\n```bash\n$ chkconfig iptables off\n或\n$ iptables -L;\n$ iptables -F;\n$ service iptables stop\n```\n#### 修改文件权限\n```bash\n$ chmod 777\n```\n#### 清屏\n```bash\n$ clear\n或者\n$ ctrl + l\n```\n#### vi模式下快捷键\n```bash\nesc后:\n保存并退出快捷键：shift+z+z\n光标跳到最后一行快捷键：shift+g\n删除一行：dd\n复制一行内容：y+y\n粘贴复制的内容：p\n```\n\n\n\n","source":"_posts/linux-1.md","raw":"---\ntitle: Linux常用命令\ncategories:\n    - Linux\n    \ndate: 2018-12-14\ntags:\n\t- Linux\n    - 服务器\n---\n![linux](/images/linux-logo.jpg)\n\n---\n\n### 基本命令\n#### 关机和重启\n```bash\n$ shutdown -h now        立刻关机\n$ shutdown -h 5        5分钟后关机\n$ poweroff            立刻关机\n```\n#### 帮助命令\n```bash\n--help命令\n$ shutdown --help：\n$ ifconfig  --help：查看网卡信息\n \n--man命令（命令说明书） \n$ man shutdown\n--注意：man shutdown打开命令说明书之后，使用按键q退出\n```\n\n---\n\n### 目录操作命令\n#### 目录切换 cd\n```bash\n--命令：cd 目录\n$ cd /        切换到根目录\n$ cd /usr        切换到根目录下的usr目录\n$ cd ../        切换到上一级目录 或者  cd ..\n$ cd ~        切换到home目录\n$ cd -        切换到上次访问的目录\n```\n#### 目录查看 ls [-al]\n```bash\n--命令：ls [-al]\n$ ls                查看当前目录下的所有目录和文件\n$ ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）\n$ ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）\n$ ls /dir            查看指定目录下的所有目录和文件   如：ls /usr\n```\n#### 目录操作 [增删改查]\n##### 创建目录 [增] mkdir\n```bash\n--命令：mkdir 目录\n$ mkdir xxx           在当前目录下创建一个名为xxx的目录\n$ mkdir /usr/xxx   在指定目录下创建一个名为xxx的目录\n```\n##### 删除目录或文件 [删] rm\n```bash\n--命令：rm [-rf] 目录\n\n删除文件：\n$ rm 文件        删除当前目录下的文件\n$ rm -f 文件    删除当前目录的的文件（不询问）\n\n删除目录：\n$ rm -r xxx  递归删除当前目录下的xxx目录\n$ rm -rf xxx  递归删除当前目录下的xxx目录（不询问）\n\n全部删除：\n$ rm -rf *    将当前目录下的所有目录和文件全部删除\n$ rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除\n\n注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包\n```\n##### 目录修改 [改] mv和cp\n```bash\n一、重命名目录\n    命令：mv 当前目录  新目录\n    例如：mv xxx coder    将目录xxx改为coder\n    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作\n\n二、剪切目录\n    命令：mv 目录名称 目录的新位置\n    示例：将/usr/tmp目录下的xxx目录剪切到 /usr目录下面     mv /usr/tmp/xxx /usr\n    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作\n\n三、拷贝目录\n    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归\n    示例：将/usr/tmp目录下的xxx目录复制到 /usr目录下面     cp /usr/tmp/xxx  /usr\n    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用写-r递归\n```\n##### 搜索目录 [查] find\n```bash\n$ find 目录 参数 文件名称\n示例：find /usr/tmp -name 'a*'  查找/usr/tmp目录下的所有以a开头的目录或文件\n```\n\n---\n\n### 文件操作命令\n#### 文件操作 [增删改查]\n##### 新建文件 [增] touch\n```bash\n$ touch 文件名\n示例：在当前目录创建一个名为aa.txt的文件 touch xxx.txt\n```\n##### 删除文件 [删] rm\n```bash\n$ rm -rf 文件名\n```\n##### 修改文件 [改] vi/vim\n**[vi编辑器的3种模式]**\n基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：\n- 命令行模式command mode）\n控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。\n\t命令行模式下的常用命令：\n       - 控制光标移动：↑，↓，j\n       - 删除当前行：dd \n       - 查找：/字符\n       - 进入编辑模式：i o a\n       - 进入底行模式：:\n      \n- 编辑模式（Insert mode）\n\t只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。\n    编辑模式下常用命令：\n       - ESC 退出编辑模式到命令行模式；\n      \n- 底行模式（last line mode）\n    将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。\n    底行模式下常用命令：\n       - 退出编辑：   :q\n       - 强制退出：   :q!\n       - 保存并退出：  :wq\n\n**打开文件**\n```bash\n$ vi 文件名\n示例：打开当前目录下的xxx.txt文件  vi xxx.txt 或者 vim xxx.txt\n注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。\n```\n\n**编辑文件**\n\n使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。\ni:在光标所在字符前开始插入\na:在光标所在字符后开始插入\no:在光标所在行的下面另起一新行插入\n\n**保存或者取消编辑**\n\n保存文件：\n第一步：ESC  进入命令行模式\n第二步：:     进入底行模式\n第三步：wq     保存并退出编辑\n取消编辑：\n\n第一步：ESC  进入命令行模式\n第二步：:     进入底行模式\n第三步：q!     撤销本次修改并退出编辑\n##### 文件的查看 [查]\n文件的查看命令：cat/more/less/tail\n**cat：看最后一屏**\n```bash\n示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容\n$ cat sudo.conf\n```\n**more：百分比显示**\n```bash\n示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看\n$ more sudo.conf\n```\n**less：翻页查看**\n```bash\n示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看\n$ less sudo.conf\n```\n**tail：指定行数或者动态查看**\n```bash\n示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束  \n$ tail -10 sudo.conf\n```\n#### 权限修改\nrwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。\n\n示例：给xxx.txt文件权限改为可执行文件权限，xxx.txt文件的权限是-rw --- ---\n\n第一位：-就代表是文件，d代表是文件夹\n第一段（3位）：代表拥有者的权限\n第二段（3位）：代表拥有者所在的组，组员的权限\n第三段（最后3位）：代表的是其他用户的权限\n\n421  421  421\nrw-  ---  ---\n```bash\n$ chmod +x xxx.txt\n或者采用8421法\n$ chmod 100 xxx.txt\n```\n\n---\n\n### 压缩文件操作\n#### 打包和压缩\nWindows的压缩文件的扩展名  .zip/.rar\nlinux中的打包文件：xxx.tar      \nlinux中的压缩文件：xxx.gz    \nlinux中打包并压缩的文件：.tar.gz\n\nLinux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。\n而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。\n```bash\n命令：tar -zcvf 打包压缩后的文件名 要打包的文件\n其中：z：调用gzip压缩命令进行压缩\n  c：打包文件\n  v：显示运行过程\n  f：指定文件名\n示例：打包并压缩/usr/tmp下的所有文件压缩后的压缩包指定名称为xxx.tar\n$ tar -zcvf xxx.tar xx.txt xxx.txt \n或\n$ tar -zcvf xx.tar *\n```\n#### 解压\n```bash\n命令：tar [-zxvf] 压缩文件    \n其中：x：代表解压\n示例：将/usr/tmp下的xxx.tar解压到当前目录下\n$ tar -zxvf xxx.tar\n```\n```bash\n示例：将/usr/tmp 下的xx.tar解压到根目录/usr下\n$ tar -zxvf xx.tar -C /usr -C代表指定解压的位置\n```\n\n---\n\n### 查找命令\n#### grep\ngrep命令是一种强大的文本搜索工具\n使用实例：\n```bash\n$ ps -ef | grep sshd  查找指定ssh服务进程 \n$ ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除grep本身 \n$ ps -ef | grep sshd -c 查找指定进程个数 \n```\n#### find\nfind命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 \nfind 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\n使用实例：\n```bash\n$ find . -name \"*.log\" -ls  在当前目录查找以.log结尾的文件，并显示详细信息。 \n$ find /root/ -perm 600   查找/root/目录下权限为600的文件 \n$ find . -type f -name \"*.log\"  查找当目录，以.log结尾的普通文件 \n$ find . -type d | sort   查找当前所有目录并排序 \n$ find . -size +100M  查找当前目录大于100M的文件\n```\n#### locate\nlocate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，<font style=\"color: red\">先使用updatedb命令</font>，手动更新数据库。如果数据库中没有查询的数据，则会报出<font style=\"color: red\">locate: can not stat () '/var/lib/mlocate/mlocate.db': No such file or directory</font>该错误！updatedb即可！\n\n**<code>yum -y install mlocate</code>如果是精简版CentOS系统需要安装locate命令**\n使用实例：\n```bash\nupdatedb\n$ locate /etc/sh 搜索etc目录下所有以sh开头的文件 \n$ locate pwd 查找和pwd相关的所有文件\n```\n#### whereis\nwhereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。\n使用实例：\n```bash\n$ whereis ls    将和ls文件相关的文件都查找出来\n```\n#### which\nwhich命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。\n使用实例：\n```bash\n$ which pwd  查找pwd命令所在路径 \n$ which java  查找path中java的路径 \n```\n\n---\n\n### su/sudo\n#### su\nsu用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。\n```bash\n$ su test:切换到test用户，但是路径还是/root目录\n$ su - test : 切换到test用户，路径变成了/home/test\n$ su : 切换到root用户，但是路径还是原来的路径\n$ su - : 切换到root用户，并且路径是/root\n```\nsu不足：如果某个用户需要使用root权限、则必须要把root密码告诉此用户。\n退出返回之前的用户：exit\n\n#### sudo\nsudo是为所有想使用root权限的普通用户设计的。可以让普通用户具有临时使用root权限的权利。只需输入自己账户的密码即可。\n进入sudo配置文件命令：\n```bash\nvi /etc/sudoer或者visudo\n```\n```bash\n案例：\n允许hadoop用户以root身份执行各种应用命令，需要输入hadoop用户的密码。\n$ hadoop  ALL=(ALL)   ALL \n \n案例：\n只允许hadoop用户以root身份执行ls 、cat命令，并且执行时候免输入密码。 \n配置文件中： \n$ hadoop  ALL=NOPASSWD:  /bin/ls, /bin/cat \n\n```\n\n---\n\n### 系统服务\n```bash\n$ service iptables status  --查看iptables服务的状态\n$ service iptables start  --开启iptables服务\n$ service iptables stop  --停止iptables服务\n$ service iptables restart  --重启iptables服务\n$ chkconfig iptables off  --关闭iptables服务的开机自启动\n$ chkconfig iptables on  --开启iptables服务的开机自启动\n```\n\n---\n\n### 网络管理\n#### 主机名配置\n```bash\n[root@loonycoder ~]# vi /etc/sysconfig/network\nNETWORKING=yes\nHOSTNAME=loonycoder\n```\n#### IP 地址配置\n```bash\n[root@loonycoder ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0\n```\n#### 域名映射\n/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用。所以，你想访问一个什么样的主机名，就需要把这个主机名和它对应的ip地址。\n```bash\n[root@loonycoder ~]# vi /etc/hosts\n#### 在最后加上\n192.168.0.1  node1\n192.168.0.2  node2\n192.168.0.3  node3\n```\n\n---\n\n### 定时任务指令crontab 配置\ncrontab是Unix和Linux用于设置定时任务的指令。通过crontab命令，可以在固定间隔时间,执行指定的系统指令或shell脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。\ncrontab安装：\n```bash\n$ yum install crontabs\n```\n服务操作说明：\n```bash\n$ service crond start   ## 启动服务 \n$ service crond stop    ## 关闭服务 \n$ service crond restart ## 重启服务\n```\n#### 命令格式\n```bash\n$ crontab [-u user] file\n$ crontab [-u user] [ -e | -l | -r ]\n```\n参数说明：\n**-u user**：用来设定某个用户的crontab服务  \n\n**file**：file是命令文件的名字,表示将file做为crontab的任务列表文件\n并载入crontab。\n\n**-e**：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前\n用户的crontab文件。\n\n**-l**：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前\n用户的crontab文件内容。\n\n**-r**：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab\n文件，如果不指定用户，则默认删除当前用户的crontab文件。\n\n命令示例：\n```bash\n$ crontab file [-u user] ## 用指定的文件替代目前的crontab\n$ crontab -l [-u user]  ## 列出用户目前的crontab\n$ crontab -e [-u user]  ## 编辑用户目前的crontab\n```\n#### 配置说明、实例\n命令：*   *    *   *   *   command  \n\n解释：分  时  日  月  周  命令\n\n第1列表示分钟1～59 每分钟用\\*或者 \\*/1表示    \n\n第2列表示小时0～23（0表示0点）\n\n第3列表示日期1～31  \n\n第4列表示月份1～12  \n\n第5列标识号星期0～6（0表示星期天）  \n\n第6列要运行的命令\n\n配置实例：\n```bash\n#先打开定时任务所在的文件：\n$ crontab -e\n \n#每分钟执行一次date命令 \n$ */1 * * * * date >> /root/date.txt\n \n#每晚的21:30重启apache。 \n$ 30 21 * * * service httpd restart\n \n#每月1、10、22日的4 : 45重启apache。  \n$ 45 4 1,10,22 * * service httpd restart\n \n#每周六、周日的1 : 10重启apache。 \n$ 10 1 * * 6,0 service httpd restart\n \n#每天18 : 00至23 : 00之间每隔30分钟重启apache。\n$ 0,30   18-23    *   *   *   service httpd restart\n\n#晚上11点到早上7点之间，每隔一小时重启apache\n$ *  23-7/1    *   *   *   service httpd restart\n```\n\n---\n\n### 其他命令\n#### 查看当前目录：pwd\n```bash\n$ pwd     #查看当前目录路径\n```\n#### 查看进程：ps -ef\n```bash\n$ ps -ef  #查看所有正在运行的进程\n```\n#### 结束进程：kill\n```bash\n$ kill pid 或者 kill -9 pid #(强制杀死进程)           #pid:进程号\n```\n#### 网络通信命令：\n```bash\n# ifconfig：查看网卡信息\n\n$ ifconfig 或 ifconfig | more\n\n# ping：查看与某台机器的连接情况\n\n$ ping ip\n\n$ netstat -an：查看当前系统端口\n\n$ netstat -an\n\n# 搜索指定端口\n\n$ netstat -an | grep 8080\n```\n#### 配置网络\n```bash\n$ setup\n```\n#### 重启网络\n```bash\n$ service network restart\n```\n#### 切换用户\n```bash\n$ su -用户名\n```\n#### 关闭防火墙\n```bash\n$ chkconfig iptables off\n或\n$ iptables -L;\n$ iptables -F;\n$ service iptables stop\n```\n#### 修改文件权限\n```bash\n$ chmod 777\n```\n#### 清屏\n```bash\n$ clear\n或者\n$ ctrl + l\n```\n#### vi模式下快捷键\n```bash\nesc后:\n保存并退出快捷键：shift+z+z\n光标跳到最后一行快捷键：shift+g\n删除一行：dd\n复制一行内容：y+y\n粘贴复制的内容：p\n```\n\n\n\n","slug":"linux-1","published":1,"updated":"2020-02-22T10:30:21.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiz6001bv9s63msj8bl3","content":"<p><img src=\"/images/linux-logo.jpg\" alt=\"linux\"></p>\n<hr>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><h4 id=\"关机和重启\"><a href=\"#关机和重启\" class=\"headerlink\" title=\"关机和重启\"></a>关机和重启</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ shutdown -h now        立刻关机</span><br><span class=\"line\">$ shutdown -h 5        5分钟后关机</span><br><span class=\"line\">$ poweroff            立刻关机</span><br></pre></td></tr></table></figure>\n<h4 id=\"帮助命令\"><a href=\"#帮助命令\" class=\"headerlink\" title=\"帮助命令\"></a>帮助命令</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--<span class=\"built_in\">help</span>命令</span><br><span class=\"line\">$ shutdown --<span class=\"built_in\">help</span>：</span><br><span class=\"line\">$ ifconfig  --<span class=\"built_in\">help</span>：查看网卡信息</span><br><span class=\"line\"> </span><br><span class=\"line\">--man命令（命令说明书） </span><br><span class=\"line\">$ man shutdown</span><br><span class=\"line\">--注意：man shutdown打开命令说明书之后，使用按键q退出</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"目录操作命令\"><a href=\"#目录操作命令\" class=\"headerlink\" title=\"目录操作命令\"></a>目录操作命令</h3><h4 id=\"目录切换-cd\"><a href=\"#目录切换-cd\" class=\"headerlink\" title=\"目录切换 cd\"></a>目录切换 cd</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--命令：<span class=\"built_in\">cd</span> 目录</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /        切换到根目录</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr        切换到根目录下的usr目录</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> ../        切换到上一级目录 或者  <span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> ~        切换到home目录</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> -        切换到上次访问的目录</span><br></pre></td></tr></table></figure>\n<h4 id=\"目录查看-ls-al\"><a href=\"#目录查看-ls-al\" class=\"headerlink\" title=\"目录查看 ls [-al]\"></a>目录查看 ls [-al]</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--命令：ls [-al]</span><br><span class=\"line\">$ ls                查看当前目录下的所有目录和文件</span><br><span class=\"line\">$ ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）</span><br><span class=\"line\">$ ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）</span><br><span class=\"line\">$ ls /dir            查看指定目录下的所有目录和文件   如：ls /usr</span><br></pre></td></tr></table></figure>\n<h4 id=\"目录操作-增删改查\"><a href=\"#目录操作-增删改查\" class=\"headerlink\" title=\"目录操作 [增删改查]\"></a>目录操作 [增删改查]</h4><h5 id=\"创建目录-增-mkdir\"><a href=\"#创建目录-增-mkdir\" class=\"headerlink\" title=\"创建目录 [增] mkdir\"></a>创建目录 [增] mkdir</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--命令：mkdir 目录</span><br><span class=\"line\">$ mkdir xxx           在当前目录下创建一个名为xxx的目录</span><br><span class=\"line\">$ mkdir /usr/xxx   在指定目录下创建一个名为xxx的目录</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除目录或文件-删-rm\"><a href=\"#删除目录或文件-删-rm\" class=\"headerlink\" title=\"删除目录或文件 [删] rm\"></a>删除目录或文件 [删] rm</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--命令：rm [-rf] 目录</span><br><span class=\"line\"></span><br><span class=\"line\">删除文件：</span><br><span class=\"line\">$ rm 文件        删除当前目录下的文件</span><br><span class=\"line\">$ rm -f 文件    删除当前目录的的文件（不询问）</span><br><span class=\"line\"></span><br><span class=\"line\">删除目录：</span><br><span class=\"line\">$ rm -r xxx  递归删除当前目录下的xxx目录</span><br><span class=\"line\">$ rm -rf xxx  递归删除当前目录下的xxx目录（不询问）</span><br><span class=\"line\"></span><br><span class=\"line\">全部删除：</span><br><span class=\"line\">$ rm -rf *    将当前目录下的所有目录和文件全部删除</span><br><span class=\"line\">$ rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</span><br><span class=\"line\"></span><br><span class=\"line\">注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</span><br></pre></td></tr></table></figure>\n<h5 id=\"目录修改-改-mv和cp\"><a href=\"#目录修改-改-mv和cp\" class=\"headerlink\" title=\"目录修改 [改] mv和cp\"></a>目录修改 [改] mv和cp</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一、重命名目录</span><br><span class=\"line\">    命令：mv 当前目录  新目录</span><br><span class=\"line\">    例如：mv xxx coder    将目录xxx改为coder</span><br><span class=\"line\">    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作</span><br><span class=\"line\"></span><br><span class=\"line\">二、剪切目录</span><br><span class=\"line\">    命令：mv 目录名称 目录的新位置</span><br><span class=\"line\">    示例：将/usr/tmp目录下的xxx目录剪切到 /usr目录下面     mv /usr/tmp/xxx /usr</span><br><span class=\"line\">    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</span><br><span class=\"line\"></span><br><span class=\"line\">三、拷贝目录</span><br><span class=\"line\">    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归</span><br><span class=\"line\">    示例：将/usr/tmp目录下的xxx目录复制到 /usr目录下面     cp /usr/tmp/xxx  /usr</span><br><span class=\"line\">    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用写-r递归</span><br></pre></td></tr></table></figure>\n<h5 id=\"搜索目录-查-find\"><a href=\"#搜索目录-查-find\" class=\"headerlink\" title=\"搜索目录 [查] find\"></a>搜索目录 [查] find</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find 目录 参数 文件名称</span><br><span class=\"line\">示例：find /usr/tmp -name <span class=\"string\">'a*'</span>  查找/usr/tmp目录下的所有以a开头的目录或文件</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"文件操作命令\"><a href=\"#文件操作命令\" class=\"headerlink\" title=\"文件操作命令\"></a>文件操作命令</h3><h4 id=\"文件操作-增删改查\"><a href=\"#文件操作-增删改查\" class=\"headerlink\" title=\"文件操作 [增删改查]\"></a>文件操作 [增删改查]</h4><h5 id=\"新建文件-增-touch\"><a href=\"#新建文件-增-touch\" class=\"headerlink\" title=\"新建文件 [增] touch\"></a>新建文件 [增] touch</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch 文件名</span><br><span class=\"line\">示例：在当前目录创建一个名为aa.txt的文件 touch xxx.txt</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除文件-删-rm\"><a href=\"#删除文件-删-rm\" class=\"headerlink\" title=\"删除文件 [删] rm\"></a>删除文件 [删] rm</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -rf 文件名</span><br></pre></td></tr></table></figure>\n<h5 id=\"修改文件-改-vi-vim\"><a href=\"#修改文件-改-vi-vim\" class=\"headerlink\" title=\"修改文件 [改] vi/vim\"></a>修改文件 [改] vi/vim</h5><p><strong>[vi编辑器的3种模式]</strong><br>基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p>\n<ul>\n<li><p>命令行模式command mode）<br>控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>  命令行模式下的常用命令：</p>\n<pre><code>- 控制光标移动：↑，↓，j\n- 删除当前行：dd \n- 查找：/字符\n- 进入编辑模式：i o a\n- 进入底行模式：:</code></pre></li>\n<li><p>编辑模式（Insert mode）<br>  只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>  编辑模式下常用命令：</p>\n<pre><code>- ESC 退出编辑模式到命令行模式；</code></pre></li>\n<li><p>底行模式（last line mode）<br>  将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>  底行模式下常用命令：</p>\n<pre><code>- 退出编辑：   :q\n- 强制退出：   :q!\n- 保存并退出：  :wq</code></pre></li>\n</ul>\n<p><strong>打开文件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vi 文件名</span><br><span class=\"line\">示例：打开当前目录下的xxx.txt文件  vi xxx.txt 或者 vim xxx.txt</span><br><span class=\"line\">注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。</span><br></pre></td></tr></table></figure>\n\n<p><strong>编辑文件</strong></p>\n<p>使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。<br>i:在光标所在字符前开始插入<br>a:在光标所在字符后开始插入<br>o:在光标所在行的下面另起一新行插入</p>\n<p><strong>保存或者取消编辑</strong></p>\n<p>保存文件：<br>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：wq     保存并退出编辑<br>取消编辑：</p>\n<p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：q!     撤销本次修改并退出编辑</p>\n<h5 id=\"文件的查看-查\"><a href=\"#文件的查看-查\" class=\"headerlink\" title=\"文件的查看 [查]\"></a>文件的查看 [查]</h5><p>文件的查看命令：cat/more/less/tail<br><strong>cat：看最后一屏</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容</span><br><span class=\"line\">$ cat sudo.conf</span><br></pre></td></tr></table></figure>\n<p><strong>more：百分比显示</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看</span><br><span class=\"line\">$ more sudo.conf</span><br></pre></td></tr></table></figure>\n<p><strong>less：翻页查看</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看</span><br><span class=\"line\">$ less sudo.conf</span><br></pre></td></tr></table></figure>\n<p><strong>tail：指定行数或者动态查看</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束  </span><br><span class=\"line\">$ tail -10 sudo.conf</span><br></pre></td></tr></table></figure>\n<h4 id=\"权限修改\"><a href=\"#权限修改\" class=\"headerlink\" title=\"权限修改\"></a>权限修改</h4><p>rwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。</p>\n<p>示例：给xxx.txt文件权限改为可执行文件权限，xxx.txt文件的权限是-rw — —</p>\n<p>第一位：-就代表是文件，d代表是文件夹<br>第一段（3位）：代表拥有者的权限<br>第二段（3位）：代表拥有者所在的组，组员的权限<br>第三段（最后3位）：代表的是其他用户的权限</p>\n<p>421  421  421<br>rw-  —  —</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chmod +x xxx.txt</span><br><span class=\"line\">或者采用8421法</span><br><span class=\"line\">$ chmod 100 xxx.txt</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"压缩文件操作\"><a href=\"#压缩文件操作\" class=\"headerlink\" title=\"压缩文件操作\"></a>压缩文件操作</h3><h4 id=\"打包和压缩\"><a href=\"#打包和压缩\" class=\"headerlink\" title=\"打包和压缩\"></a>打包和压缩</h4><p>Windows的压缩文件的扩展名  .zip/.rar<br>linux中的打包文件：xxx.tar<br>linux中的压缩文件：xxx.gz<br>linux中打包并压缩的文件：.tar.gz</p>\n<p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令：tar -zcvf 打包压缩后的文件名 要打包的文件</span><br><span class=\"line\">其中：z：调用gzip压缩命令进行压缩</span><br><span class=\"line\">  c：打包文件</span><br><span class=\"line\">  v：显示运行过程</span><br><span class=\"line\">  f：指定文件名</span><br><span class=\"line\">示例：打包并压缩/usr/tmp下的所有文件压缩后的压缩包指定名称为xxx.tar</span><br><span class=\"line\">$ tar -zcvf xxx.tar xx.txt xxx.txt </span><br><span class=\"line\">或</span><br><span class=\"line\">$ tar -zcvf xx.tar *</span><br></pre></td></tr></table></figure>\n<h4 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令：tar [-zxvf] 压缩文件    </span><br><span class=\"line\">其中：x：代表解压</span><br><span class=\"line\">示例：将/usr/tmp下的xxx.tar解压到当前目录下</span><br><span class=\"line\">$ tar -zxvf xxx.tar</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：将/usr/tmp 下的xx.tar解压到根目录/usr下</span><br><span class=\"line\">$ tar -zxvf xx.tar -C /usr -C代表指定解压的位置</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"查找命令\"><a href=\"#查找命令\" class=\"headerlink\" title=\"查找命令\"></a>查找命令</h3><h4 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h4><p>grep命令是一种强大的文本搜索工具<br>使用实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -ef | grep sshd  查找指定ssh服务进程 </span><br><span class=\"line\">$ ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除grep本身 </span><br><span class=\"line\">$ ps -ef | grep sshd -c 查找指定进程个数</span><br></pre></td></tr></table></figure>\n<h4 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h4><p>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。<br>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。<br>使用实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find . -name <span class=\"string\">\"*.log\"</span> -ls  在当前目录查找以.<span class=\"built_in\">log</span>结尾的文件，并显示详细信息。 </span><br><span class=\"line\">$ find /root/ -perm 600   查找/root/目录下权限为600的文件 </span><br><span class=\"line\">$ find . -<span class=\"built_in\">type</span> f -name <span class=\"string\">\"*.log\"</span>  查找当目录，以.<span class=\"built_in\">log</span>结尾的普通文件 </span><br><span class=\"line\">$ find . -<span class=\"built_in\">type</span> d | sort   查找当前所有目录并排序 </span><br><span class=\"line\">$ find . -size +100M  查找当前目录大于100M的文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"locate\"><a href=\"#locate\" class=\"headerlink\" title=\"locate\"></a>locate</h4><p>locate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，<font style=\"color: red\">先使用updatedb命令</font>，手动更新数据库。如果数据库中没有查询的数据，则会报出<font style=\"color: red\">locate: can not stat () ‘/var/lib/mlocate/mlocate.db’: No such file or directory</font>该错误！updatedb即可！</p>\n<p><strong><code>yum -y install mlocate</code>如果是精简版CentOS系统需要安装locate命令</strong><br>使用实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">updatedb</span><br><span class=\"line\">$ locate /etc/sh 搜索etc目录下所有以sh开头的文件 </span><br><span class=\"line\">$ locate <span class=\"built_in\">pwd</span> 查找和<span class=\"built_in\">pwd</span>相关的所有文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h4><p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。<br>使用实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ whereis ls    将和ls文件相关的文件都查找出来</span><br></pre></td></tr></table></figure>\n<h4 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h4><p>which命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。<br>使用实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">which</span> <span class=\"built_in\">pwd</span>  查找<span class=\"built_in\">pwd</span>命令所在路径 </span><br><span class=\"line\">$ <span class=\"built_in\">which</span> java  查找path中java的路径</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"su-sudo\"><a href=\"#su-sudo\" class=\"headerlink\" title=\"su/sudo\"></a>su/sudo</h3><h4 id=\"su\"><a href=\"#su\" class=\"headerlink\" title=\"su\"></a>su</h4><p>su用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ su <span class=\"built_in\">test</span>:切换到<span class=\"built_in\">test</span>用户，但是路径还是/root目录</span><br><span class=\"line\">$ su - <span class=\"built_in\">test</span> : 切换到<span class=\"built_in\">test</span>用户，路径变成了/home/<span class=\"built_in\">test</span></span><br><span class=\"line\">$ su : 切换到root用户，但是路径还是原来的路径</span><br><span class=\"line\">$ su - : 切换到root用户，并且路径是/root</span><br></pre></td></tr></table></figure>\n<p>su不足：如果某个用户需要使用root权限、则必须要把root密码告诉此用户。<br>退出返回之前的用户：exit</p>\n<h4 id=\"sudo\"><a href=\"#sudo\" class=\"headerlink\" title=\"sudo\"></a>sudo</h4><p>sudo是为所有想使用root权限的普通用户设计的。可以让普通用户具有临时使用root权限的权利。只需输入自己账户的密码即可。<br>进入sudo配置文件命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/sudoer或者visudo</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：</span><br><span class=\"line\">允许hadoop用户以root身份执行各种应用命令，需要输入hadoop用户的密码。</span><br><span class=\"line\">$ hadoop  ALL=(ALL)   ALL </span><br><span class=\"line\"> </span><br><span class=\"line\">案例：</span><br><span class=\"line\">只允许hadoop用户以root身份执行ls 、cat命令，并且执行时候免输入密码。 </span><br><span class=\"line\">配置文件中： </span><br><span class=\"line\">$ hadoop  ALL=NOPASSWD:  /bin/ls, /bin/cat</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"系统服务\"><a href=\"#系统服务\" class=\"headerlink\" title=\"系统服务\"></a>系统服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ service iptables status  --查看iptables服务的状态</span><br><span class=\"line\">$ service iptables start  --开启iptables服务</span><br><span class=\"line\">$ service iptables stop  --停止iptables服务</span><br><span class=\"line\">$ service iptables restart  --重启iptables服务</span><br><span class=\"line\">$ chkconfig iptables off  --关闭iptables服务的开机自启动</span><br><span class=\"line\">$ chkconfig iptables on  --开启iptables服务的开机自启动</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"网络管理\"><a href=\"#网络管理\" class=\"headerlink\" title=\"网络管理\"></a>网络管理</h3><h4 id=\"主机名配置\"><a href=\"#主机名配置\" class=\"headerlink\" title=\"主机名配置\"></a>主机名配置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@loonycoder ~]<span class=\"comment\"># vi /etc/sysconfig/network</span></span><br><span class=\"line\">NETWORKING=yes</span><br><span class=\"line\">HOSTNAME=loonycoder</span><br></pre></td></tr></table></figure>\n<h4 id=\"IP-地址配置\"><a href=\"#IP-地址配置\" class=\"headerlink\" title=\"IP 地址配置\"></a>IP 地址配置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@loonycoder ~]<span class=\"comment\"># vi /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"域名映射\"><a href=\"#域名映射\" class=\"headerlink\" title=\"域名映射\"></a>域名映射</h4><p>/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用。所以，你想访问一个什么样的主机名，就需要把这个主机名和它对应的ip地址。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@loonycoder ~]<span class=\"comment\"># vi /etc/hosts</span></span><br><span class=\"line\"><span class=\"comment\">#### 在最后加上</span></span><br><span class=\"line\">192.168.0.1  node1</span><br><span class=\"line\">192.168.0.2  node2</span><br><span class=\"line\">192.168.0.3  node3</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"定时任务指令crontab-配置\"><a href=\"#定时任务指令crontab-配置\" class=\"headerlink\" title=\"定时任务指令crontab 配置\"></a>定时任务指令crontab 配置</h3><p>crontab是Unix和Linux用于设置定时任务的指令。通过crontab命令，可以在固定间隔时间,执行指定的系统指令或shell脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。<br>crontab安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install crontabs</span><br></pre></td></tr></table></figure>\n<p>服务操作说明：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ service crond start   <span class=\"comment\">## 启动服务 </span></span><br><span class=\"line\">$ service crond stop    <span class=\"comment\">## 关闭服务 </span></span><br><span class=\"line\">$ service crond restart <span class=\"comment\">## 重启服务</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"命令格式\"><a href=\"#命令格式\" class=\"headerlink\" title=\"命令格式\"></a>命令格式</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ crontab [-u user] file</span><br><span class=\"line\">$ crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>\n<p>参数说明：<br><strong>-u user</strong>：用来设定某个用户的crontab服务  </p>\n<p><strong>file</strong>：file是命令文件的名字,表示将file做为crontab的任务列表文件<br>并载入crontab。</p>\n<p><strong>-e</strong>：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前<br>用户的crontab文件。</p>\n<p><strong>-l</strong>：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前<br>用户的crontab文件内容。</p>\n<p><strong>-r</strong>：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab<br>文件，如果不指定用户，则默认删除当前用户的crontab文件。</p>\n<p>命令示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ crontab file [-u user] <span class=\"comment\">## 用指定的文件替代目前的crontab</span></span><br><span class=\"line\">$ crontab -l [-u user]  <span class=\"comment\">## 列出用户目前的crontab</span></span><br><span class=\"line\">$ crontab -e [-u user]  <span class=\"comment\">## 编辑用户目前的crontab</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"配置说明、实例\"><a href=\"#配置说明、实例\" class=\"headerlink\" title=\"配置说明、实例\"></a>配置说明、实例</h4><p>命令：*   *    *   *   *   command  </p>\n<p>解释：分  时  日  月  周  命令</p>\n<p>第1列表示分钟1～59 每分钟用*或者 */1表示    </p>\n<p>第2列表示小时0～23（0表示0点）</p>\n<p>第3列表示日期1～31  </p>\n<p>第4列表示月份1～12  </p>\n<p>第5列标识号星期0～6（0表示星期天）  </p>\n<p>第6列要运行的命令</p>\n<p>配置实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#先打开定时任务所在的文件：</span></span><br><span class=\"line\">$ crontab -e</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#每分钟执行一次date命令 </span></span><br><span class=\"line\">$ */1 * * * * date &gt;&gt; /root/date.txt</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#每晚的21:30重启apache。 </span></span><br><span class=\"line\">$ 30 21 * * * service httpd restart</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#每月1、10、22日的4 : 45重启apache。  </span></span><br><span class=\"line\">$ 45 4 1,10,22 * * service httpd restart</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#每周六、周日的1 : 10重启apache。 </span></span><br><span class=\"line\">$ 10 1 * * 6,0 service httpd restart</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#每天18 : 00至23 : 00之间每隔30分钟重启apache。</span></span><br><span class=\"line\">$ 0,30   18-23    *   *   *   service httpd restart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#晚上11点到早上7点之间，每隔一小时重启apache</span></span><br><span class=\"line\">$ *  23-7/1    *   *   *   service httpd restart</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h3><h4 id=\"查看当前目录：pwd\"><a href=\"#查看当前目录：pwd\" class=\"headerlink\" title=\"查看当前目录：pwd\"></a>查看当前目录：pwd</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">pwd</span>     <span class=\"comment\">#查看当前目录路径</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"查看进程：ps-ef\"><a href=\"#查看进程：ps-ef\" class=\"headerlink\" title=\"查看进程：ps -ef\"></a>查看进程：ps -ef</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -ef  <span class=\"comment\">#查看所有正在运行的进程</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"结束进程：kill\"><a href=\"#结束进程：kill\" class=\"headerlink\" title=\"结束进程：kill\"></a>结束进程：kill</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">kill</span> pid 或者 <span class=\"built_in\">kill</span> -9 pid <span class=\"comment\">#(强制杀死进程)           #pid:进程号</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"网络通信命令：\"><a href=\"#网络通信命令：\" class=\"headerlink\" title=\"网络通信命令：\"></a>网络通信命令：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ifconfig：查看网卡信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ifconfig 或 ifconfig | more</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ping：查看与某台机器的连接情况</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ping ip</span><br><span class=\"line\"></span><br><span class=\"line\">$ netstat -an：查看当前系统端口</span><br><span class=\"line\"></span><br><span class=\"line\">$ netstat -an</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索指定端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ netstat -an | grep 8080</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置网络\"><a href=\"#配置网络\" class=\"headerlink\" title=\"配置网络\"></a>配置网络</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ setup</span><br></pre></td></tr></table></figure>\n<h4 id=\"重启网络\"><a href=\"#重启网络\" class=\"headerlink\" title=\"重启网络\"></a>重启网络</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ service network restart</span><br></pre></td></tr></table></figure>\n<h4 id=\"切换用户\"><a href=\"#切换用户\" class=\"headerlink\" title=\"切换用户\"></a>切换用户</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ su -用户名</span><br></pre></td></tr></table></figure>\n<h4 id=\"关闭防火墙\"><a href=\"#关闭防火墙\" class=\"headerlink\" title=\"关闭防火墙\"></a>关闭防火墙</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chkconfig iptables off</span><br><span class=\"line\">或</span><br><span class=\"line\">$ iptables -L;</span><br><span class=\"line\">$ iptables -F;</span><br><span class=\"line\">$ service iptables stop</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改文件权限\"><a href=\"#修改文件权限\" class=\"headerlink\" title=\"修改文件权限\"></a>修改文件权限</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chmod 777</span><br></pre></td></tr></table></figure>\n<h4 id=\"清屏\"><a href=\"#清屏\" class=\"headerlink\" title=\"清屏\"></a>清屏</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ clear</span><br><span class=\"line\">或者</span><br><span class=\"line\">$ ctrl + l</span><br></pre></td></tr></table></figure>\n<h4 id=\"vi模式下快捷键\"><a href=\"#vi模式下快捷键\" class=\"headerlink\" title=\"vi模式下快捷键\"></a>vi模式下快捷键</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">esc后:</span><br><span class=\"line\">保存并退出快捷键：<span class=\"built_in\">shift</span>+z+z</span><br><span class=\"line\">光标跳到最后一行快捷键：<span class=\"built_in\">shift</span>+g</span><br><span class=\"line\">删除一行：dd</span><br><span class=\"line\">复制一行内容：y+y</span><br><span class=\"line\">粘贴复制的内容：p</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/linux-logo.jpg\" alt=\"linux\"></p>\n<hr>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><h4 id=\"关机和重启\"><a href=\"#关机和重启\" class=\"headerlink\" title=\"关机和重启\"></a>关机和重启</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ shutdown -h now        立刻关机</span><br><span class=\"line\">$ shutdown -h 5        5分钟后关机</span><br><span class=\"line\">$ poweroff            立刻关机</span><br></pre></td></tr></table></figure>\n<h4 id=\"帮助命令\"><a href=\"#帮助命令\" class=\"headerlink\" title=\"帮助命令\"></a>帮助命令</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--<span class=\"built_in\">help</span>命令</span><br><span class=\"line\">$ shutdown --<span class=\"built_in\">help</span>：</span><br><span class=\"line\">$ ifconfig  --<span class=\"built_in\">help</span>：查看网卡信息</span><br><span class=\"line\"> </span><br><span class=\"line\">--man命令（命令说明书） </span><br><span class=\"line\">$ man shutdown</span><br><span class=\"line\">--注意：man shutdown打开命令说明书之后，使用按键q退出</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"目录操作命令\"><a href=\"#目录操作命令\" class=\"headerlink\" title=\"目录操作命令\"></a>目录操作命令</h3><h4 id=\"目录切换-cd\"><a href=\"#目录切换-cd\" class=\"headerlink\" title=\"目录切换 cd\"></a>目录切换 cd</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--命令：<span class=\"built_in\">cd</span> 目录</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /        切换到根目录</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr        切换到根目录下的usr目录</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> ../        切换到上一级目录 或者  <span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> ~        切换到home目录</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> -        切换到上次访问的目录</span><br></pre></td></tr></table></figure>\n<h4 id=\"目录查看-ls-al\"><a href=\"#目录查看-ls-al\" class=\"headerlink\" title=\"目录查看 ls [-al]\"></a>目录查看 ls [-al]</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--命令：ls [-al]</span><br><span class=\"line\">$ ls                查看当前目录下的所有目录和文件</span><br><span class=\"line\">$ ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）</span><br><span class=\"line\">$ ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）</span><br><span class=\"line\">$ ls /dir            查看指定目录下的所有目录和文件   如：ls /usr</span><br></pre></td></tr></table></figure>\n<h4 id=\"目录操作-增删改查\"><a href=\"#目录操作-增删改查\" class=\"headerlink\" title=\"目录操作 [增删改查]\"></a>目录操作 [增删改查]</h4><h5 id=\"创建目录-增-mkdir\"><a href=\"#创建目录-增-mkdir\" class=\"headerlink\" title=\"创建目录 [增] mkdir\"></a>创建目录 [增] mkdir</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--命令：mkdir 目录</span><br><span class=\"line\">$ mkdir xxx           在当前目录下创建一个名为xxx的目录</span><br><span class=\"line\">$ mkdir /usr/xxx   在指定目录下创建一个名为xxx的目录</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除目录或文件-删-rm\"><a href=\"#删除目录或文件-删-rm\" class=\"headerlink\" title=\"删除目录或文件 [删] rm\"></a>删除目录或文件 [删] rm</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--命令：rm [-rf] 目录</span><br><span class=\"line\"></span><br><span class=\"line\">删除文件：</span><br><span class=\"line\">$ rm 文件        删除当前目录下的文件</span><br><span class=\"line\">$ rm -f 文件    删除当前目录的的文件（不询问）</span><br><span class=\"line\"></span><br><span class=\"line\">删除目录：</span><br><span class=\"line\">$ rm -r xxx  递归删除当前目录下的xxx目录</span><br><span class=\"line\">$ rm -rf xxx  递归删除当前目录下的xxx目录（不询问）</span><br><span class=\"line\"></span><br><span class=\"line\">全部删除：</span><br><span class=\"line\">$ rm -rf *    将当前目录下的所有目录和文件全部删除</span><br><span class=\"line\">$ rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</span><br><span class=\"line\"></span><br><span class=\"line\">注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</span><br></pre></td></tr></table></figure>\n<h5 id=\"目录修改-改-mv和cp\"><a href=\"#目录修改-改-mv和cp\" class=\"headerlink\" title=\"目录修改 [改] mv和cp\"></a>目录修改 [改] mv和cp</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一、重命名目录</span><br><span class=\"line\">    命令：mv 当前目录  新目录</span><br><span class=\"line\">    例如：mv xxx coder    将目录xxx改为coder</span><br><span class=\"line\">    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作</span><br><span class=\"line\"></span><br><span class=\"line\">二、剪切目录</span><br><span class=\"line\">    命令：mv 目录名称 目录的新位置</span><br><span class=\"line\">    示例：将/usr/tmp目录下的xxx目录剪切到 /usr目录下面     mv /usr/tmp/xxx /usr</span><br><span class=\"line\">    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</span><br><span class=\"line\"></span><br><span class=\"line\">三、拷贝目录</span><br><span class=\"line\">    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归</span><br><span class=\"line\">    示例：将/usr/tmp目录下的xxx目录复制到 /usr目录下面     cp /usr/tmp/xxx  /usr</span><br><span class=\"line\">    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用写-r递归</span><br></pre></td></tr></table></figure>\n<h5 id=\"搜索目录-查-find\"><a href=\"#搜索目录-查-find\" class=\"headerlink\" title=\"搜索目录 [查] find\"></a>搜索目录 [查] find</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find 目录 参数 文件名称</span><br><span class=\"line\">示例：find /usr/tmp -name <span class=\"string\">'a*'</span>  查找/usr/tmp目录下的所有以a开头的目录或文件</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"文件操作命令\"><a href=\"#文件操作命令\" class=\"headerlink\" title=\"文件操作命令\"></a>文件操作命令</h3><h4 id=\"文件操作-增删改查\"><a href=\"#文件操作-增删改查\" class=\"headerlink\" title=\"文件操作 [增删改查]\"></a>文件操作 [增删改查]</h4><h5 id=\"新建文件-增-touch\"><a href=\"#新建文件-增-touch\" class=\"headerlink\" title=\"新建文件 [增] touch\"></a>新建文件 [增] touch</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch 文件名</span><br><span class=\"line\">示例：在当前目录创建一个名为aa.txt的文件 touch xxx.txt</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除文件-删-rm\"><a href=\"#删除文件-删-rm\" class=\"headerlink\" title=\"删除文件 [删] rm\"></a>删除文件 [删] rm</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -rf 文件名</span><br></pre></td></tr></table></figure>\n<h5 id=\"修改文件-改-vi-vim\"><a href=\"#修改文件-改-vi-vim\" class=\"headerlink\" title=\"修改文件 [改] vi/vim\"></a>修改文件 [改] vi/vim</h5><p><strong>[vi编辑器的3种模式]</strong><br>基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p>\n<ul>\n<li><p>命令行模式command mode）<br>控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>  命令行模式下的常用命令：</p>\n<pre><code>- 控制光标移动：↑，↓，j\n- 删除当前行：dd \n- 查找：/字符\n- 进入编辑模式：i o a\n- 进入底行模式：:</code></pre></li>\n<li><p>编辑模式（Insert mode）<br>  只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>  编辑模式下常用命令：</p>\n<pre><code>- ESC 退出编辑模式到命令行模式；</code></pre></li>\n<li><p>底行模式（last line mode）<br>  将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>  底行模式下常用命令：</p>\n<pre><code>- 退出编辑：   :q\n- 强制退出：   :q!\n- 保存并退出：  :wq</code></pre></li>\n</ul>\n<p><strong>打开文件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vi 文件名</span><br><span class=\"line\">示例：打开当前目录下的xxx.txt文件  vi xxx.txt 或者 vim xxx.txt</span><br><span class=\"line\">注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。</span><br></pre></td></tr></table></figure>\n\n<p><strong>编辑文件</strong></p>\n<p>使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。<br>i:在光标所在字符前开始插入<br>a:在光标所在字符后开始插入<br>o:在光标所在行的下面另起一新行插入</p>\n<p><strong>保存或者取消编辑</strong></p>\n<p>保存文件：<br>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：wq     保存并退出编辑<br>取消编辑：</p>\n<p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：q!     撤销本次修改并退出编辑</p>\n<h5 id=\"文件的查看-查\"><a href=\"#文件的查看-查\" class=\"headerlink\" title=\"文件的查看 [查]\"></a>文件的查看 [查]</h5><p>文件的查看命令：cat/more/less/tail<br><strong>cat：看最后一屏</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容</span><br><span class=\"line\">$ cat sudo.conf</span><br></pre></td></tr></table></figure>\n<p><strong>more：百分比显示</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看</span><br><span class=\"line\">$ more sudo.conf</span><br></pre></td></tr></table></figure>\n<p><strong>less：翻页查看</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看</span><br><span class=\"line\">$ less sudo.conf</span><br></pre></td></tr></table></figure>\n<p><strong>tail：指定行数或者动态查看</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束  </span><br><span class=\"line\">$ tail -10 sudo.conf</span><br></pre></td></tr></table></figure>\n<h4 id=\"权限修改\"><a href=\"#权限修改\" class=\"headerlink\" title=\"权限修改\"></a>权限修改</h4><p>rwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。</p>\n<p>示例：给xxx.txt文件权限改为可执行文件权限，xxx.txt文件的权限是-rw — —</p>\n<p>第一位：-就代表是文件，d代表是文件夹<br>第一段（3位）：代表拥有者的权限<br>第二段（3位）：代表拥有者所在的组，组员的权限<br>第三段（最后3位）：代表的是其他用户的权限</p>\n<p>421  421  421<br>rw-  —  —</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chmod +x xxx.txt</span><br><span class=\"line\">或者采用8421法</span><br><span class=\"line\">$ chmod 100 xxx.txt</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"压缩文件操作\"><a href=\"#压缩文件操作\" class=\"headerlink\" title=\"压缩文件操作\"></a>压缩文件操作</h3><h4 id=\"打包和压缩\"><a href=\"#打包和压缩\" class=\"headerlink\" title=\"打包和压缩\"></a>打包和压缩</h4><p>Windows的压缩文件的扩展名  .zip/.rar<br>linux中的打包文件：xxx.tar<br>linux中的压缩文件：xxx.gz<br>linux中打包并压缩的文件：.tar.gz</p>\n<p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令：tar -zcvf 打包压缩后的文件名 要打包的文件</span><br><span class=\"line\">其中：z：调用gzip压缩命令进行压缩</span><br><span class=\"line\">  c：打包文件</span><br><span class=\"line\">  v：显示运行过程</span><br><span class=\"line\">  f：指定文件名</span><br><span class=\"line\">示例：打包并压缩/usr/tmp下的所有文件压缩后的压缩包指定名称为xxx.tar</span><br><span class=\"line\">$ tar -zcvf xxx.tar xx.txt xxx.txt </span><br><span class=\"line\">或</span><br><span class=\"line\">$ tar -zcvf xx.tar *</span><br></pre></td></tr></table></figure>\n<h4 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令：tar [-zxvf] 压缩文件    </span><br><span class=\"line\">其中：x：代表解压</span><br><span class=\"line\">示例：将/usr/tmp下的xxx.tar解压到当前目录下</span><br><span class=\"line\">$ tar -zxvf xxx.tar</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：将/usr/tmp 下的xx.tar解压到根目录/usr下</span><br><span class=\"line\">$ tar -zxvf xx.tar -C /usr -C代表指定解压的位置</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"查找命令\"><a href=\"#查找命令\" class=\"headerlink\" title=\"查找命令\"></a>查找命令</h3><h4 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h4><p>grep命令是一种强大的文本搜索工具<br>使用实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -ef | grep sshd  查找指定ssh服务进程 </span><br><span class=\"line\">$ ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除grep本身 </span><br><span class=\"line\">$ ps -ef | grep sshd -c 查找指定进程个数</span><br></pre></td></tr></table></figure>\n<h4 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h4><p>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。<br>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。<br>使用实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find . -name <span class=\"string\">\"*.log\"</span> -ls  在当前目录查找以.<span class=\"built_in\">log</span>结尾的文件，并显示详细信息。 </span><br><span class=\"line\">$ find /root/ -perm 600   查找/root/目录下权限为600的文件 </span><br><span class=\"line\">$ find . -<span class=\"built_in\">type</span> f -name <span class=\"string\">\"*.log\"</span>  查找当目录，以.<span class=\"built_in\">log</span>结尾的普通文件 </span><br><span class=\"line\">$ find . -<span class=\"built_in\">type</span> d | sort   查找当前所有目录并排序 </span><br><span class=\"line\">$ find . -size +100M  查找当前目录大于100M的文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"locate\"><a href=\"#locate\" class=\"headerlink\" title=\"locate\"></a>locate</h4><p>locate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，<font style=\"color: red\">先使用updatedb命令</font>，手动更新数据库。如果数据库中没有查询的数据，则会报出<font style=\"color: red\">locate: can not stat () ‘/var/lib/mlocate/mlocate.db’: No such file or directory</font>该错误！updatedb即可！</p>\n<p><strong><code>yum -y install mlocate</code>如果是精简版CentOS系统需要安装locate命令</strong><br>使用实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">updatedb</span><br><span class=\"line\">$ locate /etc/sh 搜索etc目录下所有以sh开头的文件 </span><br><span class=\"line\">$ locate <span class=\"built_in\">pwd</span> 查找和<span class=\"built_in\">pwd</span>相关的所有文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h4><p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。<br>使用实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ whereis ls    将和ls文件相关的文件都查找出来</span><br></pre></td></tr></table></figure>\n<h4 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h4><p>which命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。<br>使用实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">which</span> <span class=\"built_in\">pwd</span>  查找<span class=\"built_in\">pwd</span>命令所在路径 </span><br><span class=\"line\">$ <span class=\"built_in\">which</span> java  查找path中java的路径</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"su-sudo\"><a href=\"#su-sudo\" class=\"headerlink\" title=\"su/sudo\"></a>su/sudo</h3><h4 id=\"su\"><a href=\"#su\" class=\"headerlink\" title=\"su\"></a>su</h4><p>su用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ su <span class=\"built_in\">test</span>:切换到<span class=\"built_in\">test</span>用户，但是路径还是/root目录</span><br><span class=\"line\">$ su - <span class=\"built_in\">test</span> : 切换到<span class=\"built_in\">test</span>用户，路径变成了/home/<span class=\"built_in\">test</span></span><br><span class=\"line\">$ su : 切换到root用户，但是路径还是原来的路径</span><br><span class=\"line\">$ su - : 切换到root用户，并且路径是/root</span><br></pre></td></tr></table></figure>\n<p>su不足：如果某个用户需要使用root权限、则必须要把root密码告诉此用户。<br>退出返回之前的用户：exit</p>\n<h4 id=\"sudo\"><a href=\"#sudo\" class=\"headerlink\" title=\"sudo\"></a>sudo</h4><p>sudo是为所有想使用root权限的普通用户设计的。可以让普通用户具有临时使用root权限的权利。只需输入自己账户的密码即可。<br>进入sudo配置文件命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/sudoer或者visudo</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：</span><br><span class=\"line\">允许hadoop用户以root身份执行各种应用命令，需要输入hadoop用户的密码。</span><br><span class=\"line\">$ hadoop  ALL=(ALL)   ALL </span><br><span class=\"line\"> </span><br><span class=\"line\">案例：</span><br><span class=\"line\">只允许hadoop用户以root身份执行ls 、cat命令，并且执行时候免输入密码。 </span><br><span class=\"line\">配置文件中： </span><br><span class=\"line\">$ hadoop  ALL=NOPASSWD:  /bin/ls, /bin/cat</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"系统服务\"><a href=\"#系统服务\" class=\"headerlink\" title=\"系统服务\"></a>系统服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ service iptables status  --查看iptables服务的状态</span><br><span class=\"line\">$ service iptables start  --开启iptables服务</span><br><span class=\"line\">$ service iptables stop  --停止iptables服务</span><br><span class=\"line\">$ service iptables restart  --重启iptables服务</span><br><span class=\"line\">$ chkconfig iptables off  --关闭iptables服务的开机自启动</span><br><span class=\"line\">$ chkconfig iptables on  --开启iptables服务的开机自启动</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"网络管理\"><a href=\"#网络管理\" class=\"headerlink\" title=\"网络管理\"></a>网络管理</h3><h4 id=\"主机名配置\"><a href=\"#主机名配置\" class=\"headerlink\" title=\"主机名配置\"></a>主机名配置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@loonycoder ~]<span class=\"comment\"># vi /etc/sysconfig/network</span></span><br><span class=\"line\">NETWORKING=yes</span><br><span class=\"line\">HOSTNAME=loonycoder</span><br></pre></td></tr></table></figure>\n<h4 id=\"IP-地址配置\"><a href=\"#IP-地址配置\" class=\"headerlink\" title=\"IP 地址配置\"></a>IP 地址配置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@loonycoder ~]<span class=\"comment\"># vi /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"域名映射\"><a href=\"#域名映射\" class=\"headerlink\" title=\"域名映射\"></a>域名映射</h4><p>/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用。所以，你想访问一个什么样的主机名，就需要把这个主机名和它对应的ip地址。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@loonycoder ~]<span class=\"comment\"># vi /etc/hosts</span></span><br><span class=\"line\"><span class=\"comment\">#### 在最后加上</span></span><br><span class=\"line\">192.168.0.1  node1</span><br><span class=\"line\">192.168.0.2  node2</span><br><span class=\"line\">192.168.0.3  node3</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"定时任务指令crontab-配置\"><a href=\"#定时任务指令crontab-配置\" class=\"headerlink\" title=\"定时任务指令crontab 配置\"></a>定时任务指令crontab 配置</h3><p>crontab是Unix和Linux用于设置定时任务的指令。通过crontab命令，可以在固定间隔时间,执行指定的系统指令或shell脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。<br>crontab安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install crontabs</span><br></pre></td></tr></table></figure>\n<p>服务操作说明：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ service crond start   <span class=\"comment\">## 启动服务 </span></span><br><span class=\"line\">$ service crond stop    <span class=\"comment\">## 关闭服务 </span></span><br><span class=\"line\">$ service crond restart <span class=\"comment\">## 重启服务</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"命令格式\"><a href=\"#命令格式\" class=\"headerlink\" title=\"命令格式\"></a>命令格式</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ crontab [-u user] file</span><br><span class=\"line\">$ crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>\n<p>参数说明：<br><strong>-u user</strong>：用来设定某个用户的crontab服务  </p>\n<p><strong>file</strong>：file是命令文件的名字,表示将file做为crontab的任务列表文件<br>并载入crontab。</p>\n<p><strong>-e</strong>：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前<br>用户的crontab文件。</p>\n<p><strong>-l</strong>：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前<br>用户的crontab文件内容。</p>\n<p><strong>-r</strong>：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab<br>文件，如果不指定用户，则默认删除当前用户的crontab文件。</p>\n<p>命令示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ crontab file [-u user] <span class=\"comment\">## 用指定的文件替代目前的crontab</span></span><br><span class=\"line\">$ crontab -l [-u user]  <span class=\"comment\">## 列出用户目前的crontab</span></span><br><span class=\"line\">$ crontab -e [-u user]  <span class=\"comment\">## 编辑用户目前的crontab</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"配置说明、实例\"><a href=\"#配置说明、实例\" class=\"headerlink\" title=\"配置说明、实例\"></a>配置说明、实例</h4><p>命令：*   *    *   *   *   command  </p>\n<p>解释：分  时  日  月  周  命令</p>\n<p>第1列表示分钟1～59 每分钟用*或者 */1表示    </p>\n<p>第2列表示小时0～23（0表示0点）</p>\n<p>第3列表示日期1～31  </p>\n<p>第4列表示月份1～12  </p>\n<p>第5列标识号星期0～6（0表示星期天）  </p>\n<p>第6列要运行的命令</p>\n<p>配置实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#先打开定时任务所在的文件：</span></span><br><span class=\"line\">$ crontab -e</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#每分钟执行一次date命令 </span></span><br><span class=\"line\">$ */1 * * * * date &gt;&gt; /root/date.txt</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#每晚的21:30重启apache。 </span></span><br><span class=\"line\">$ 30 21 * * * service httpd restart</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#每月1、10、22日的4 : 45重启apache。  </span></span><br><span class=\"line\">$ 45 4 1,10,22 * * service httpd restart</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#每周六、周日的1 : 10重启apache。 </span></span><br><span class=\"line\">$ 10 1 * * 6,0 service httpd restart</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#每天18 : 00至23 : 00之间每隔30分钟重启apache。</span></span><br><span class=\"line\">$ 0,30   18-23    *   *   *   service httpd restart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#晚上11点到早上7点之间，每隔一小时重启apache</span></span><br><span class=\"line\">$ *  23-7/1    *   *   *   service httpd restart</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h3><h4 id=\"查看当前目录：pwd\"><a href=\"#查看当前目录：pwd\" class=\"headerlink\" title=\"查看当前目录：pwd\"></a>查看当前目录：pwd</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">pwd</span>     <span class=\"comment\">#查看当前目录路径</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"查看进程：ps-ef\"><a href=\"#查看进程：ps-ef\" class=\"headerlink\" title=\"查看进程：ps -ef\"></a>查看进程：ps -ef</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -ef  <span class=\"comment\">#查看所有正在运行的进程</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"结束进程：kill\"><a href=\"#结束进程：kill\" class=\"headerlink\" title=\"结束进程：kill\"></a>结束进程：kill</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">kill</span> pid 或者 <span class=\"built_in\">kill</span> -9 pid <span class=\"comment\">#(强制杀死进程)           #pid:进程号</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"网络通信命令：\"><a href=\"#网络通信命令：\" class=\"headerlink\" title=\"网络通信命令：\"></a>网络通信命令：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ifconfig：查看网卡信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ifconfig 或 ifconfig | more</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ping：查看与某台机器的连接情况</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ping ip</span><br><span class=\"line\"></span><br><span class=\"line\">$ netstat -an：查看当前系统端口</span><br><span class=\"line\"></span><br><span class=\"line\">$ netstat -an</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索指定端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ netstat -an | grep 8080</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置网络\"><a href=\"#配置网络\" class=\"headerlink\" title=\"配置网络\"></a>配置网络</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ setup</span><br></pre></td></tr></table></figure>\n<h4 id=\"重启网络\"><a href=\"#重启网络\" class=\"headerlink\" title=\"重启网络\"></a>重启网络</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ service network restart</span><br></pre></td></tr></table></figure>\n<h4 id=\"切换用户\"><a href=\"#切换用户\" class=\"headerlink\" title=\"切换用户\"></a>切换用户</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ su -用户名</span><br></pre></td></tr></table></figure>\n<h4 id=\"关闭防火墙\"><a href=\"#关闭防火墙\" class=\"headerlink\" title=\"关闭防火墙\"></a>关闭防火墙</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chkconfig iptables off</span><br><span class=\"line\">或</span><br><span class=\"line\">$ iptables -L;</span><br><span class=\"line\">$ iptables -F;</span><br><span class=\"line\">$ service iptables stop</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改文件权限\"><a href=\"#修改文件权限\" class=\"headerlink\" title=\"修改文件权限\"></a>修改文件权限</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chmod 777</span><br></pre></td></tr></table></figure>\n<h4 id=\"清屏\"><a href=\"#清屏\" class=\"headerlink\" title=\"清屏\"></a>清屏</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ clear</span><br><span class=\"line\">或者</span><br><span class=\"line\">$ ctrl + l</span><br></pre></td></tr></table></figure>\n<h4 id=\"vi模式下快捷键\"><a href=\"#vi模式下快捷键\" class=\"headerlink\" title=\"vi模式下快捷键\"></a>vi模式下快捷键</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">esc后:</span><br><span class=\"line\">保存并退出快捷键：<span class=\"built_in\">shift</span>+z+z</span><br><span class=\"line\">光标跳到最后一行快捷键：<span class=\"built_in\">shift</span>+g</span><br><span class=\"line\">删除一行：dd</span><br><span class=\"line\">复制一行内容：y+y</span><br><span class=\"line\">粘贴复制的内容：p</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"Redis入门","date":"2018-11-27T16:00:00.000Z","_content":"![redis](/images/redis-logo.png)\n\n### Redis 概述\n在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。\n\n---\n\n### NoSQL 技术\n为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种**基于内存的数据库**，并且提供一定的持久化功能。\n\n**Redis**和**MongoDB**是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以**支持每秒十几万此的读/写操作**，其性能远超数据库，并且还**支持集群、分布式、主从同步等**配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还**支持一定的事务能力**，这保证了高并发的场景下数据的安全和一致性。\n\n---\n\n### Redis 在 Java Web 中的应用\nRedis 在 Java Web 主要有两个应用场景：\n\n- 存储 **缓存** 用的数据；\n- 需要高速读/写的场合**使用它快速读/写**；\n\n#### 缓存\n在日常对数据库的访问中，读操作的次数远超写操作，比例大概在 **1:9** 到 **3:7**，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会**去磁盘把对应的数据索引取回来**，这是一个相对较慢的过程。\n\n如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端**直接去读取内存中的数据**，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们**只是使用 Redis 存储一些常用和主要的数据**，比如用户登录的信息等。\n\n一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：\n\n- **业务数据常用吗？命中率如何？**如果命中率很低，就没有必要写入缓存；\n- **该业务数据是读操作多，还是写操作多？**如果写操作多，频繁需要写入数据库，也没有必要使用缓存；\n- **业务数据大小如何？**如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；\n在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！使用 Redis 作为缓存的读取逻辑如下图所示：\n![redis](/images/redis8.png)\n从上图我们可以知道以下两点：\n\n1. 当**第一次读取数据的时候**，读取 Redis 的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入 Redis 中；\n2. 当**第二次以及以后需要读取数据时**，就会直接读取 Redis，读到数据后就结束了流程，这样速度就大大提高了。\n从上面的分析可以知道，读操作的可能性是远大于写操作的，所以使用 Redis 来处理日常中需要经常读取的数据，速度提升是显而易见的，同时也降低了对数据库的依赖，使得数据库的压力大大减少。\n\n分析了读操作的逻辑，下面我们来看看**写操作的流程**：\n![redis](/images/redis9.png)\n从流程可以看出，更新或者写入的操作，需要多个 Redis 的操作，如果业务数据写次数远大于读次数那么就没有必要使用 Redis。\n> 关于使用内存存储数据，我知道谷歌好像就是**把所有互联网的数据都存储在内存条**的，所以才会有如此高质量、高效的搜索，但它毕竟是谷歌...\n\n#### 高速读/写的场合\n在如今的互联网中，越来越多的存在高并发的情况，比如天猫双11、抢红包、抢演唱会门票等，这些场合都是在某一个瞬间或者是某一个短暂的时刻有**成千上万的请求**到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，**轻则造成用户体验极差用户量流失，重则数据库瘫痪，服务宕机**，而这样的场合都是不允许的！\n\n所以我们需要使用 Redis 来应对这样的高并发需求的场合，我们先来看看一次**请求操作的流程图**：\n![redis](/images/redis10.png)\n我们来进一步阐述这个过程：\n\n1. 当一个请求到达服务器时，只是把业务数据在 Redis 上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足**高速响应的需求**；\n2. 但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完 Redis 的读/写之后，会去**判断该高速读/写的业务是否结束**，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将 Redis 的缓存的数据以批量的形式**一次性写入数据库**，从而完成持久化的工作。\n\n---\n\n### Redis 的安装\n\n> 操作系统：CentOS 7\n> redis版本：5.0\n\n#### 下载安装包\n```bash\n$ wget http://download.redis.io/releases/redis-5.0.0.tar.gz\n```\n![redis](/images/redis11.png)\n#### 解压安装包\n```bash\n$ tar -zxvf redis-5.0.0.tar.gz\n```\n![redis](/images/redis12.png)\n没有报错就代表解压成功！\n#### yum安装gcc依赖\n```bash\n$ yum install gcc\n```\n遇到选择，输入y即可\n#### 编译&安装\n```bash\n$ cd redis-5.0.0/\n$ make\n$ make install\n```\n#### 测试是否安装成功\n先切换到redis src目录下\n```bash\n$ cd src/\n```\n#### 直接启动redis\n```bash\n$ ./redis-server\n```\n![redis](/images/redis13.png)\n如上图：redis启动成功，但是这种启动方式需要一直打开窗口，不能进行其他操作，不太方便。\n按 ctrl + c可以关闭窗口。\n#### 以后台进程方式启动redis\n##### 第一步：修改redis.conf文件\nredis.conf文件就在redis目录下\n```bash\n$ cd redis-5.0.0/\n$ vim redis.conf\n```\n将**daemonize no**修改为**daemonize yes**\n![redis](/images/redis14.png)\n配置允许所有ip都可以访问redis，将bind 127.0.0.1注释掉:\n![redis](/images/redis15.png)\n并且将protected-mode改为no\n![redis](/images/redis16.png)\n##### 第二步：指定redis.conf文件启动\n```bash\n$ ./redis-server ~/redis-5.0.0/redis.conf \n```\n![redis](/images/redis17.png)\n##### 第三步：关闭redis进程\n首先使用<code>ps -aux&brvbar;grep redis</code>查看redis进程\n```bash\n$ ps -aux | grep redis\n```\n![redis](/images/redis18.png)\n使用kill命令杀死进程,并检查是否成功关闭\n```bash\n$ kill -9 2751\n```\n##### 第四步：检查是否开启了所有ip访问：\n```bash\n$ ps -ef |grep redis\n```\n如果端口号前面显示的是\\*则说明客户端可以访问了，如果是127.0.0.1，则需要重新配置了。\n\n#### 设置redis开机自启动\n##### 在/etc目录下新建redis目录\n```bash\n$ cd /etc\n$ mkdir redis\n```\n##### 将/root/redis-5.0.0/redis.conf文件复制一份到/etc/redis目录下，并命名为6379.conf\n```bash\n$ cp /root/redis-5.0.0/redis.conf /etc/redis/6379.conf\n```\n##### 将redis的启动脚本复制一份放到/etc/init.d目录下\n```bash\n$ cp /root/redis-5.0.0/utils/redis_init_script /etc/init.d/redisd\n```\n##### 设置redis开机自启动\n先切换到/etc/init.d目录下，然后执行自启命令\n```bash\n$ chkconfig redisd on\n```\n如果redisd不支持chkconfig，使用vim编辑redisd文件，在第一行加入如下两行注释，保存退出\n```bash\n# chkconfig:   2345 90 10\n# description:  Redis is a persistent key-value database\n```\n注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。\n再次执行开机自启命令，成功。\n```bash\n$ chkconfig redisd on\n```\n\n#### 以服务的形式启动和关闭redis\n##### 启动\n```bash\n$ service redisd start\n```\n##### 关闭\n```bash\n$ service redisd stop\n```\n![redis](/images/redis19.png)\n\n---\n\n### 在 Java 中使用 Redis\n#### 第一步：添加 Jedis 依赖\n想要在 Java 中使用 Redis 缓存，需要添加相关的Jar包依赖，打开Maven仓库的网站：<https://mvnrepository.com/> ，搜索Jedis：\n![redis](/images/redis20.png)\n```bash\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.1.0</version>\n</dependency>\n```\n写个简单的性能测试：\n```bash\n@Test\npublic void redisTester() {\n    Jedis jedis = new Jedis(\"localhost\", 6379, 100000);\n    int i = 0;\n    try {\n        long start = System.currentTimeMillis();// 开始毫秒数\n        while (true) {\n            long end = System.currentTimeMillis();\n            if (end - start >= 1000) {// 当大于等于1000毫秒（相当于1秒）时，结束操作\n                break;\n            }\n            i++;\n            jedis.set(\"test\" + i, i + \"\");\n        }\n    } finally {// 关闭连接\n        jedis.close();\n    }\n    // 打印1秒内对Redis的操作次数\n    System.out.println(\"redis每秒操作：\" + i + \"次\");\n}\n-----------测试结果-----------\nredis每秒操作：99776次\n```\n#### 第二步：使用 Redis 连接池\n跟数据库连接池相同，Java Redis也同样提供了类<code>redis.clients.jedis.JedisPool</code>来管理我们的Reids连接池对象，并且我们可以使用<code>redis.clients.jedis.JedisPoolConfig</code>来对连接池进行配置，代码如下：\n```bash\nJedisPoolConfig poolConfig = new JedisPoolConfig();\n// 最大空闲数\npoolConfig.setMaxIdle(50);\n// 最大连接数\npoolConfig.setMaxTotal(100);\n// 最大等待毫秒数\npoolConfig.setMaxWaitMillis(20000);\n// 使用配置创建连接池\nJedisPool pool = new JedisPool(poolConfig, \"localhost\");\n// 从连接池中获取单个连接\nJedis jedis = pool.getResource();\n// 如果需要密码\n//jedis.auth(\"password\");\n```\nRedis 只能支持六种数据类型（string/hash/list/set/zset/hyperloglog）的操作，但在 Java 中我们却通常以类对象为主，所以在需要 Redis 存储的五中数据类型与 Java 对象之间进行转换，如果自己编写一些工具类，比如一个角色对象的转换，还是比较容易的，但是涉及到许多对象的时候，这其中无论工作量还是工作难度都是很大的，所以总体来说，**就操作对象而言，使用 Redis 还是挺难的**，好在 Spring 对这些进行了封装和支持。\n\n#### 第三步：在 Spring 中使用 Redis\n上面说到了 Redis 无法操作对象的问题，无法在那些基础类型和 Java 对象之间方便的转换，但是在 Spring 中，这些问题都可以**通过使用RedisTemplate**得到解决！\n\n想要达到这样的效果，除了 Jedis 包以外还需要在 Spring 引入 spring-data-redis 包：<https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis>\n![redis](/images/redis21.png)\n```bash\n<dependency>\n    <groupId>org.springframework.data</groupId>\n    <artifactId>spring-data-redis</artifactId>\n    <version>2.2.0.RELEASE</version>\n</dependency>\n```\n**(1) 第一步：使用Spring配置JedisPoolConfig对象**\n大部分的情况下，我们还是会用到连接池的，于是先用 Spring 配置一个 JedisPoolConfig 对象：\n```bash\n<bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\">\n    <!--最大空闲数-->\n    <property name=\"maxIdle\" value=\"50\"/>\n    <!--最大连接数-->\n    <property name=\"maxTotal\" value=\"100\"/>\n    <!--最大等待时间-->\n    <property name=\"maxWaitMillis\" value=\"20000\"/>\n</bean>\n```\n**(2) 第二步：为连接池配置工厂模型**\n好了，我们现在配置好了连接池的相关属性，那么具体使用哪种工厂实现呢？在Spring Data Redis中有四种可供我们选择的工厂模型，它们分别是：\n- JredisConnectionFactory\n- JedisConnectionFactory\n- LettuceConnectionFactory\n- SrpConnectionFactory\n我们这里就简单配置成JedisConnectionFactory：\n```bash\n<bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\n    <!--Redis服务地址-->\n    <property name=\"hostName\" value=\"localhost\"/>\n    <!--端口号-->\n    <property name=\"port\" value=\"6379\"/>\n    <!--如果有密码则需要配置密码-->\n    <!--<property name=\"password\" value=\"password\"/>-->\n    <!--连接池配置-->\n    <property name=\"poolConfig\" ref=\"poolConfig\"/>\n</bean>\n```\n**(3) 第三步：配置RedisTemplate**\n普通的连接根本没有办法直接将对象直接存入 Redis 内存中，我们需要替代的方案：将对象序列化（可以简单的理解为继承Serializable接口）。我们可以把对象序列化之后存入Redis缓存中，然后在取出的时候又通过转换器，将序列化之后的对象反序列化回对象，这样就完成了我们的要求：\n![redis](/images/redis22.png)\nRedisTemplate可以帮助我们完成这份工作，它会找到对应的序列化器去转换Redis的键值：\n```bash\n<bean id=\"redisTemplate\"\n      class=\"org.springframework.data.redis.core.RedisTemplate\"\n      p:connection-factory-ref=\"connectionFactory\"/>\n```\n\n> 我从《JavaEE互联网轻量级框架整合开发》中了解到，这一步需要配置单独的序列化器去支撑这一步的工作，但是自己在测试当中，发现只要我们的Pojo类实现了Serializable接口，就不会出现问题，所以我直接省略掉了配置序列化器这一步。\n**(4) 第四步：编写测试**\n```bash\n/**\n * @author: @loonycoder\n * @create: 2018-11-28 下午 18:22:06\n */\npublic class Student implements Serializable{\n\n    private String name;\n    private int age;\n\n    /**\n     * 给该类一个服务类用于测试\n     */\n    public void service() {\n        System.out.println(\"学生名字为：\" + name);\n        System.out.println(\"学生年龄为：\" + age);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n然后编写测试类：\n```bash\n@Test\npublic void test() {\n    ApplicationContext context =\n            new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    RedisTemplate redisTemplate = context.getBean(RedisTemplate.class);\n    Student student = new Student();\n    student.setName(\"loonycoder\");\n    student.setAge(24);\n    redisTemplate.opsForValue().set(\"student_1\", student);\n    Student student1 = (Student) redisTemplate.opsForValue().get(\"student_1\");\n    student1.service();\n}\n```\n![redis](/images/redis23.png)\n\n#### 第四步：在 SpringBoot 中使用 Redis\n**(1)在SpringBoot中添加Redis依赖：**\n```bash\n<!-- Radis -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n**(2)添加配置文件：**\n在SpringBoot中使用<code>.properties</code>或者<code>.yml</code>都可以，这里给出<code>.properties</code>的例子，因为自己的<code>.yml</code>文件看上去感觉乱糟糟的：\n```bash\n# REDIS (RedisProperties)\n# Redis数据库索引（默认为0）\nspring.redis.database=0\n# Redis服务器地址\nspring.redis.host=localhost\n# Redis服务器连接端口\nspring.redis.port=6379\n# Redis服务器连接密码（默认为空）\nspring.redis.password=\n# 连接池最大连接数（使用负值表示没有限制）\nspring.redis.pool.max-active=8\n# 连接池最大阻塞等待时间（使用负值表示没有限制）\nspring.redis.pool.max-wait=-1\n# 连接池中的最大空闲连接\nspring.redis.pool.max-idle=8\n# 连接池中的最小空闲连接\nspring.redis.pool.min-idle=0\n# 连接超时时间（毫秒）\nspring.redis.timeout=0\n```\n**(3)测试访问：**\n```bash\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest()\npublic class ApplicationTests {\n\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Test\n    public void test() throws Exception {\n\n        // 保存字符串\n        stringRedisTemplate.opsForValue().set(\"loonycoder\", \"24\");\n        Assert.assertEquals(\"24\", stringRedisTemplate.opsForValue().get(\"loonycoder\"));\n\n    }\n}\n```\n通过上面这段极为简单的测试案例演示了如何通过自动配置的**StringRedisTemplate**对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。原本是RedisTemplate<K, V>接口，StringRedisTemplate就相当于RedisTemplate<String, String>的实现。\n**(4)存储对象：**\n这一步跟上面使用Spring一样，只需要将Pojo类实现Serializable接口就可以了，这里直接贴测试代码：\n```bash\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest()\npublic class ApplicationTests {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Test\n    public void test() throws Exception {\n\n        User user = new User();\n        user.setName(\"loonycoder\");\n        user.setAge(24);\n\n        redisTemplate.opsForValue().set(\"user_1\", user);\n        User user1 = (User) redisTemplate.opsForValue().get(\"user_1\");\n\n        System.out.println(user1.getName());\n    }\n}\n```\n\n> 参考文章：\n> <https://www.cnblogs.com/ityouknow/p/5748830.html>\n> <http://blog.didispace.com/springbootredis/>\n\n---\n\n### 在Redis中操作集合\n\n> 引用文章：<https://www.jianshu.com/p/29aaac3172b5>\n\n直接贴上两段简单的示例代码：\n\n#### 在Redis中操作List\n```bash\n// list数据类型适合于消息队列的场景:比如12306并发量太高，而同一时间段内只能处理指定数量的数据！必须满足先进先出的原则，其余数据处于等待\n@Test\npublic void listPushResitTest() {\n    // leftPush依次由右边添加\n    stringRedisTemplate.opsForList().rightPush(\"myList\", \"1\");\n    stringRedisTemplate.opsForList().rightPush(\"myList\", \"2\");\n    stringRedisTemplate.opsForList().rightPush(\"myList\", \"A\");\n    stringRedisTemplate.opsForList().rightPush(\"myList\", \"B\");\n    // leftPush依次由左边添加\n    stringRedisTemplate.opsForList().leftPush(\"myList\", \"0\");\n}\n\n@Test\npublic void listGetListResitTest() {\n    // 查询类别所有元素\n    List<String> listAll = stringRedisTemplate.opsForList().range(\"myList\", 0, -1);\n    logger.info(\"list all {}\", listAll);\n    // 查询前3个元素\n    List<String> list = stringRedisTemplate.opsForList().range(\"myList\", 0, 3);\n    logger.info(\"list limit {}\", list);\n}\n\n@Test\npublic void listRemoveOneResitTest() {\n    // 删除先进入的B元素\n    stringRedisTemplate.opsForList().remove(\"myList\", 1, \"B\");\n}\n\n@Test\npublic void listRemoveAllResitTest() {\n    // 删除所有A元素\n    stringRedisTemplate.opsForList().remove(\"myList\", 0, \"A\");\n}\n```\n#### 在Redis中操作Hash\n```bash\n@Test\npublic void hashPutResitTest() {\n    // map的key值相同，后添加的覆盖原有的\n    stringRedisTemplate.opsForHash().put(\"banks:12600000\", \"a\", \"b\");\n}\n\n@Test\npublic void hashGetEntiresResitTest() {\n    // 获取map对象\n    Map<Object, Object> map = stringRedisTemplate.opsForHash().entries(\"banks:12600000\");\n    logger.info(\"objects:{}\", map);\n}\n\n@Test\npublic void hashGeDeleteResitTest() {\n    // 根据map的key删除这个元素\n    stringRedisTemplate.opsForHash().delete(\"banks:12600000\", \"c\");\n}\n\n@Test\npublic void hashGetKeysResitTest() {\n    // 获得map的key集合\n    Set<Object> objects = stringRedisTemplate.opsForHash().keys(\"banks:12600000\");\n    logger.info(\"objects:{}\", objects);\n}\n\n@Test\npublic void hashGetValueListResitTest() {\n    // 获得map的value列表\n    List<Object> objects = stringRedisTemplate.opsForHash().values(\"banks:12600000\");\n    logger.info(\"objects:{}\", objects);\n}\n\n@Test\npublic void hashSize() { // 获取map对象大小\n    long size = stringRedisTemplate.opsForHash().size(\"banks:12600000\");\n    logger.info(\"size:{}\", size);\n}\n```\n\n---\n\n### 总结\n在网上看到了关于MySQL的性能测试，读写操作大概就**每秒1000以下**的样子，而且这还和引擎相关，所以可以看出Redis确实能在性能方面帮助许多。\n\n","source":"_posts/redis-1.md","raw":"---\ntitle: Redis入门\ncategories:\n    - 数据库\n    \ndate: 2018-11-28\ntags:\n\t- 数据库\n    - Redis\n---\n![redis](/images/redis-logo.png)\n\n### Redis 概述\n在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。\n\n---\n\n### NoSQL 技术\n为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种**基于内存的数据库**，并且提供一定的持久化功能。\n\n**Redis**和**MongoDB**是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以**支持每秒十几万此的读/写操作**，其性能远超数据库，并且还**支持集群、分布式、主从同步等**配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还**支持一定的事务能力**，这保证了高并发的场景下数据的安全和一致性。\n\n---\n\n### Redis 在 Java Web 中的应用\nRedis 在 Java Web 主要有两个应用场景：\n\n- 存储 **缓存** 用的数据；\n- 需要高速读/写的场合**使用它快速读/写**；\n\n#### 缓存\n在日常对数据库的访问中，读操作的次数远超写操作，比例大概在 **1:9** 到 **3:7**，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会**去磁盘把对应的数据索引取回来**，这是一个相对较慢的过程。\n\n如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端**直接去读取内存中的数据**，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们**只是使用 Redis 存储一些常用和主要的数据**，比如用户登录的信息等。\n\n一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：\n\n- **业务数据常用吗？命中率如何？**如果命中率很低，就没有必要写入缓存；\n- **该业务数据是读操作多，还是写操作多？**如果写操作多，频繁需要写入数据库，也没有必要使用缓存；\n- **业务数据大小如何？**如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；\n在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！使用 Redis 作为缓存的读取逻辑如下图所示：\n![redis](/images/redis8.png)\n从上图我们可以知道以下两点：\n\n1. 当**第一次读取数据的时候**，读取 Redis 的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入 Redis 中；\n2. 当**第二次以及以后需要读取数据时**，就会直接读取 Redis，读到数据后就结束了流程，这样速度就大大提高了。\n从上面的分析可以知道，读操作的可能性是远大于写操作的，所以使用 Redis 来处理日常中需要经常读取的数据，速度提升是显而易见的，同时也降低了对数据库的依赖，使得数据库的压力大大减少。\n\n分析了读操作的逻辑，下面我们来看看**写操作的流程**：\n![redis](/images/redis9.png)\n从流程可以看出，更新或者写入的操作，需要多个 Redis 的操作，如果业务数据写次数远大于读次数那么就没有必要使用 Redis。\n> 关于使用内存存储数据，我知道谷歌好像就是**把所有互联网的数据都存储在内存条**的，所以才会有如此高质量、高效的搜索，但它毕竟是谷歌...\n\n#### 高速读/写的场合\n在如今的互联网中，越来越多的存在高并发的情况，比如天猫双11、抢红包、抢演唱会门票等，这些场合都是在某一个瞬间或者是某一个短暂的时刻有**成千上万的请求**到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，**轻则造成用户体验极差用户量流失，重则数据库瘫痪，服务宕机**，而这样的场合都是不允许的！\n\n所以我们需要使用 Redis 来应对这样的高并发需求的场合，我们先来看看一次**请求操作的流程图**：\n![redis](/images/redis10.png)\n我们来进一步阐述这个过程：\n\n1. 当一个请求到达服务器时，只是把业务数据在 Redis 上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足**高速响应的需求**；\n2. 但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完 Redis 的读/写之后，会去**判断该高速读/写的业务是否结束**，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将 Redis 的缓存的数据以批量的形式**一次性写入数据库**，从而完成持久化的工作。\n\n---\n\n### Redis 的安装\n\n> 操作系统：CentOS 7\n> redis版本：5.0\n\n#### 下载安装包\n```bash\n$ wget http://download.redis.io/releases/redis-5.0.0.tar.gz\n```\n![redis](/images/redis11.png)\n#### 解压安装包\n```bash\n$ tar -zxvf redis-5.0.0.tar.gz\n```\n![redis](/images/redis12.png)\n没有报错就代表解压成功！\n#### yum安装gcc依赖\n```bash\n$ yum install gcc\n```\n遇到选择，输入y即可\n#### 编译&安装\n```bash\n$ cd redis-5.0.0/\n$ make\n$ make install\n```\n#### 测试是否安装成功\n先切换到redis src目录下\n```bash\n$ cd src/\n```\n#### 直接启动redis\n```bash\n$ ./redis-server\n```\n![redis](/images/redis13.png)\n如上图：redis启动成功，但是这种启动方式需要一直打开窗口，不能进行其他操作，不太方便。\n按 ctrl + c可以关闭窗口。\n#### 以后台进程方式启动redis\n##### 第一步：修改redis.conf文件\nredis.conf文件就在redis目录下\n```bash\n$ cd redis-5.0.0/\n$ vim redis.conf\n```\n将**daemonize no**修改为**daemonize yes**\n![redis](/images/redis14.png)\n配置允许所有ip都可以访问redis，将bind 127.0.0.1注释掉:\n![redis](/images/redis15.png)\n并且将protected-mode改为no\n![redis](/images/redis16.png)\n##### 第二步：指定redis.conf文件启动\n```bash\n$ ./redis-server ~/redis-5.0.0/redis.conf \n```\n![redis](/images/redis17.png)\n##### 第三步：关闭redis进程\n首先使用<code>ps -aux&brvbar;grep redis</code>查看redis进程\n```bash\n$ ps -aux | grep redis\n```\n![redis](/images/redis18.png)\n使用kill命令杀死进程,并检查是否成功关闭\n```bash\n$ kill -9 2751\n```\n##### 第四步：检查是否开启了所有ip访问：\n```bash\n$ ps -ef |grep redis\n```\n如果端口号前面显示的是\\*则说明客户端可以访问了，如果是127.0.0.1，则需要重新配置了。\n\n#### 设置redis开机自启动\n##### 在/etc目录下新建redis目录\n```bash\n$ cd /etc\n$ mkdir redis\n```\n##### 将/root/redis-5.0.0/redis.conf文件复制一份到/etc/redis目录下，并命名为6379.conf\n```bash\n$ cp /root/redis-5.0.0/redis.conf /etc/redis/6379.conf\n```\n##### 将redis的启动脚本复制一份放到/etc/init.d目录下\n```bash\n$ cp /root/redis-5.0.0/utils/redis_init_script /etc/init.d/redisd\n```\n##### 设置redis开机自启动\n先切换到/etc/init.d目录下，然后执行自启命令\n```bash\n$ chkconfig redisd on\n```\n如果redisd不支持chkconfig，使用vim编辑redisd文件，在第一行加入如下两行注释，保存退出\n```bash\n# chkconfig:   2345 90 10\n# description:  Redis is a persistent key-value database\n```\n注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。\n再次执行开机自启命令，成功。\n```bash\n$ chkconfig redisd on\n```\n\n#### 以服务的形式启动和关闭redis\n##### 启动\n```bash\n$ service redisd start\n```\n##### 关闭\n```bash\n$ service redisd stop\n```\n![redis](/images/redis19.png)\n\n---\n\n### 在 Java 中使用 Redis\n#### 第一步：添加 Jedis 依赖\n想要在 Java 中使用 Redis 缓存，需要添加相关的Jar包依赖，打开Maven仓库的网站：<https://mvnrepository.com/> ，搜索Jedis：\n![redis](/images/redis20.png)\n```bash\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.1.0</version>\n</dependency>\n```\n写个简单的性能测试：\n```bash\n@Test\npublic void redisTester() {\n    Jedis jedis = new Jedis(\"localhost\", 6379, 100000);\n    int i = 0;\n    try {\n        long start = System.currentTimeMillis();// 开始毫秒数\n        while (true) {\n            long end = System.currentTimeMillis();\n            if (end - start >= 1000) {// 当大于等于1000毫秒（相当于1秒）时，结束操作\n                break;\n            }\n            i++;\n            jedis.set(\"test\" + i, i + \"\");\n        }\n    } finally {// 关闭连接\n        jedis.close();\n    }\n    // 打印1秒内对Redis的操作次数\n    System.out.println(\"redis每秒操作：\" + i + \"次\");\n}\n-----------测试结果-----------\nredis每秒操作：99776次\n```\n#### 第二步：使用 Redis 连接池\n跟数据库连接池相同，Java Redis也同样提供了类<code>redis.clients.jedis.JedisPool</code>来管理我们的Reids连接池对象，并且我们可以使用<code>redis.clients.jedis.JedisPoolConfig</code>来对连接池进行配置，代码如下：\n```bash\nJedisPoolConfig poolConfig = new JedisPoolConfig();\n// 最大空闲数\npoolConfig.setMaxIdle(50);\n// 最大连接数\npoolConfig.setMaxTotal(100);\n// 最大等待毫秒数\npoolConfig.setMaxWaitMillis(20000);\n// 使用配置创建连接池\nJedisPool pool = new JedisPool(poolConfig, \"localhost\");\n// 从连接池中获取单个连接\nJedis jedis = pool.getResource();\n// 如果需要密码\n//jedis.auth(\"password\");\n```\nRedis 只能支持六种数据类型（string/hash/list/set/zset/hyperloglog）的操作，但在 Java 中我们却通常以类对象为主，所以在需要 Redis 存储的五中数据类型与 Java 对象之间进行转换，如果自己编写一些工具类，比如一个角色对象的转换，还是比较容易的，但是涉及到许多对象的时候，这其中无论工作量还是工作难度都是很大的，所以总体来说，**就操作对象而言，使用 Redis 还是挺难的**，好在 Spring 对这些进行了封装和支持。\n\n#### 第三步：在 Spring 中使用 Redis\n上面说到了 Redis 无法操作对象的问题，无法在那些基础类型和 Java 对象之间方便的转换，但是在 Spring 中，这些问题都可以**通过使用RedisTemplate**得到解决！\n\n想要达到这样的效果，除了 Jedis 包以外还需要在 Spring 引入 spring-data-redis 包：<https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis>\n![redis](/images/redis21.png)\n```bash\n<dependency>\n    <groupId>org.springframework.data</groupId>\n    <artifactId>spring-data-redis</artifactId>\n    <version>2.2.0.RELEASE</version>\n</dependency>\n```\n**(1) 第一步：使用Spring配置JedisPoolConfig对象**\n大部分的情况下，我们还是会用到连接池的，于是先用 Spring 配置一个 JedisPoolConfig 对象：\n```bash\n<bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\">\n    <!--最大空闲数-->\n    <property name=\"maxIdle\" value=\"50\"/>\n    <!--最大连接数-->\n    <property name=\"maxTotal\" value=\"100\"/>\n    <!--最大等待时间-->\n    <property name=\"maxWaitMillis\" value=\"20000\"/>\n</bean>\n```\n**(2) 第二步：为连接池配置工厂模型**\n好了，我们现在配置好了连接池的相关属性，那么具体使用哪种工厂实现呢？在Spring Data Redis中有四种可供我们选择的工厂模型，它们分别是：\n- JredisConnectionFactory\n- JedisConnectionFactory\n- LettuceConnectionFactory\n- SrpConnectionFactory\n我们这里就简单配置成JedisConnectionFactory：\n```bash\n<bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\n    <!--Redis服务地址-->\n    <property name=\"hostName\" value=\"localhost\"/>\n    <!--端口号-->\n    <property name=\"port\" value=\"6379\"/>\n    <!--如果有密码则需要配置密码-->\n    <!--<property name=\"password\" value=\"password\"/>-->\n    <!--连接池配置-->\n    <property name=\"poolConfig\" ref=\"poolConfig\"/>\n</bean>\n```\n**(3) 第三步：配置RedisTemplate**\n普通的连接根本没有办法直接将对象直接存入 Redis 内存中，我们需要替代的方案：将对象序列化（可以简单的理解为继承Serializable接口）。我们可以把对象序列化之后存入Redis缓存中，然后在取出的时候又通过转换器，将序列化之后的对象反序列化回对象，这样就完成了我们的要求：\n![redis](/images/redis22.png)\nRedisTemplate可以帮助我们完成这份工作，它会找到对应的序列化器去转换Redis的键值：\n```bash\n<bean id=\"redisTemplate\"\n      class=\"org.springframework.data.redis.core.RedisTemplate\"\n      p:connection-factory-ref=\"connectionFactory\"/>\n```\n\n> 我从《JavaEE互联网轻量级框架整合开发》中了解到，这一步需要配置单独的序列化器去支撑这一步的工作，但是自己在测试当中，发现只要我们的Pojo类实现了Serializable接口，就不会出现问题，所以我直接省略掉了配置序列化器这一步。\n**(4) 第四步：编写测试**\n```bash\n/**\n * @author: @loonycoder\n * @create: 2018-11-28 下午 18:22:06\n */\npublic class Student implements Serializable{\n\n    private String name;\n    private int age;\n\n    /**\n     * 给该类一个服务类用于测试\n     */\n    public void service() {\n        System.out.println(\"学生名字为：\" + name);\n        System.out.println(\"学生年龄为：\" + age);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n然后编写测试类：\n```bash\n@Test\npublic void test() {\n    ApplicationContext context =\n            new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    RedisTemplate redisTemplate = context.getBean(RedisTemplate.class);\n    Student student = new Student();\n    student.setName(\"loonycoder\");\n    student.setAge(24);\n    redisTemplate.opsForValue().set(\"student_1\", student);\n    Student student1 = (Student) redisTemplate.opsForValue().get(\"student_1\");\n    student1.service();\n}\n```\n![redis](/images/redis23.png)\n\n#### 第四步：在 SpringBoot 中使用 Redis\n**(1)在SpringBoot中添加Redis依赖：**\n```bash\n<!-- Radis -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n**(2)添加配置文件：**\n在SpringBoot中使用<code>.properties</code>或者<code>.yml</code>都可以，这里给出<code>.properties</code>的例子，因为自己的<code>.yml</code>文件看上去感觉乱糟糟的：\n```bash\n# REDIS (RedisProperties)\n# Redis数据库索引（默认为0）\nspring.redis.database=0\n# Redis服务器地址\nspring.redis.host=localhost\n# Redis服务器连接端口\nspring.redis.port=6379\n# Redis服务器连接密码（默认为空）\nspring.redis.password=\n# 连接池最大连接数（使用负值表示没有限制）\nspring.redis.pool.max-active=8\n# 连接池最大阻塞等待时间（使用负值表示没有限制）\nspring.redis.pool.max-wait=-1\n# 连接池中的最大空闲连接\nspring.redis.pool.max-idle=8\n# 连接池中的最小空闲连接\nspring.redis.pool.min-idle=0\n# 连接超时时间（毫秒）\nspring.redis.timeout=0\n```\n**(3)测试访问：**\n```bash\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest()\npublic class ApplicationTests {\n\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Test\n    public void test() throws Exception {\n\n        // 保存字符串\n        stringRedisTemplate.opsForValue().set(\"loonycoder\", \"24\");\n        Assert.assertEquals(\"24\", stringRedisTemplate.opsForValue().get(\"loonycoder\"));\n\n    }\n}\n```\n通过上面这段极为简单的测试案例演示了如何通过自动配置的**StringRedisTemplate**对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。原本是RedisTemplate<K, V>接口，StringRedisTemplate就相当于RedisTemplate<String, String>的实现。\n**(4)存储对象：**\n这一步跟上面使用Spring一样，只需要将Pojo类实现Serializable接口就可以了，这里直接贴测试代码：\n```bash\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest()\npublic class ApplicationTests {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Test\n    public void test() throws Exception {\n\n        User user = new User();\n        user.setName(\"loonycoder\");\n        user.setAge(24);\n\n        redisTemplate.opsForValue().set(\"user_1\", user);\n        User user1 = (User) redisTemplate.opsForValue().get(\"user_1\");\n\n        System.out.println(user1.getName());\n    }\n}\n```\n\n> 参考文章：\n> <https://www.cnblogs.com/ityouknow/p/5748830.html>\n> <http://blog.didispace.com/springbootredis/>\n\n---\n\n### 在Redis中操作集合\n\n> 引用文章：<https://www.jianshu.com/p/29aaac3172b5>\n\n直接贴上两段简单的示例代码：\n\n#### 在Redis中操作List\n```bash\n// list数据类型适合于消息队列的场景:比如12306并发量太高，而同一时间段内只能处理指定数量的数据！必须满足先进先出的原则，其余数据处于等待\n@Test\npublic void listPushResitTest() {\n    // leftPush依次由右边添加\n    stringRedisTemplate.opsForList().rightPush(\"myList\", \"1\");\n    stringRedisTemplate.opsForList().rightPush(\"myList\", \"2\");\n    stringRedisTemplate.opsForList().rightPush(\"myList\", \"A\");\n    stringRedisTemplate.opsForList().rightPush(\"myList\", \"B\");\n    // leftPush依次由左边添加\n    stringRedisTemplate.opsForList().leftPush(\"myList\", \"0\");\n}\n\n@Test\npublic void listGetListResitTest() {\n    // 查询类别所有元素\n    List<String> listAll = stringRedisTemplate.opsForList().range(\"myList\", 0, -1);\n    logger.info(\"list all {}\", listAll);\n    // 查询前3个元素\n    List<String> list = stringRedisTemplate.opsForList().range(\"myList\", 0, 3);\n    logger.info(\"list limit {}\", list);\n}\n\n@Test\npublic void listRemoveOneResitTest() {\n    // 删除先进入的B元素\n    stringRedisTemplate.opsForList().remove(\"myList\", 1, \"B\");\n}\n\n@Test\npublic void listRemoveAllResitTest() {\n    // 删除所有A元素\n    stringRedisTemplate.opsForList().remove(\"myList\", 0, \"A\");\n}\n```\n#### 在Redis中操作Hash\n```bash\n@Test\npublic void hashPutResitTest() {\n    // map的key值相同，后添加的覆盖原有的\n    stringRedisTemplate.opsForHash().put(\"banks:12600000\", \"a\", \"b\");\n}\n\n@Test\npublic void hashGetEntiresResitTest() {\n    // 获取map对象\n    Map<Object, Object> map = stringRedisTemplate.opsForHash().entries(\"banks:12600000\");\n    logger.info(\"objects:{}\", map);\n}\n\n@Test\npublic void hashGeDeleteResitTest() {\n    // 根据map的key删除这个元素\n    stringRedisTemplate.opsForHash().delete(\"banks:12600000\", \"c\");\n}\n\n@Test\npublic void hashGetKeysResitTest() {\n    // 获得map的key集合\n    Set<Object> objects = stringRedisTemplate.opsForHash().keys(\"banks:12600000\");\n    logger.info(\"objects:{}\", objects);\n}\n\n@Test\npublic void hashGetValueListResitTest() {\n    // 获得map的value列表\n    List<Object> objects = stringRedisTemplate.opsForHash().values(\"banks:12600000\");\n    logger.info(\"objects:{}\", objects);\n}\n\n@Test\npublic void hashSize() { // 获取map对象大小\n    long size = stringRedisTemplate.opsForHash().size(\"banks:12600000\");\n    logger.info(\"size:{}\", size);\n}\n```\n\n---\n\n### 总结\n在网上看到了关于MySQL的性能测试，读写操作大概就**每秒1000以下**的样子，而且这还和引擎相关，所以可以看出Redis确实能在性能方面帮助许多。\n\n","slug":"redis-1","published":1,"updated":"2020-02-21T18:35:58.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmiz7001dv9s6ez0xdctd","content":"<p><img src=\"/images/redis-logo.png\" alt=\"redis\"></p>\n<h3 id=\"Redis-概述\"><a href=\"#Redis-概述\" class=\"headerlink\" title=\"Redis 概述\"></a>Redis 概述</h3><p>在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p>\n<hr>\n<h3 id=\"NoSQL-技术\"><a href=\"#NoSQL-技术\" class=\"headerlink\" title=\"NoSQL 技术\"></a>NoSQL 技术</h3><p>为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种<strong>基于内存的数据库</strong>，并且提供一定的持久化功能。</p>\n<p><strong>Redis</strong>和<strong>MongoDB</strong>是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以<strong>支持每秒十几万此的读/写操作</strong>，其性能远超数据库，并且还<strong>支持集群、分布式、主从同步等</strong>配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还<strong>支持一定的事务能力</strong>，这保证了高并发的场景下数据的安全和一致性。</p>\n<hr>\n<h3 id=\"Redis-在-Java-Web-中的应用\"><a href=\"#Redis-在-Java-Web-中的应用\" class=\"headerlink\" title=\"Redis 在 Java Web 中的应用\"></a>Redis 在 Java Web 中的应用</h3><p>Redis 在 Java Web 主要有两个应用场景：</p>\n<ul>\n<li>存储 <strong>缓存</strong> 用的数据；</li>\n<li>需要高速读/写的场合<strong>使用它快速读/写</strong>；</li>\n</ul>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><p>在日常对数据库的访问中，读操作的次数远超写操作，比例大概在 <strong>1:9</strong> 到 <strong>3:7</strong>，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会<strong>去磁盘把对应的数据索引取回来</strong>，这是一个相对较慢的过程。</p>\n<p>如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端<strong>直接去读取内存中的数据</strong>，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们<strong>只是使用 Redis 存储一些常用和主要的数据</strong>，比如用户登录的信息等。</p>\n<p>一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：</p>\n<ul>\n<li><strong>业务数据常用吗？命中率如何？</strong>如果命中率很低，就没有必要写入缓存；</li>\n<li><strong>该业务数据是读操作多，还是写操作多？</strong>如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li>\n<li><strong>业务数据大小如何？</strong>如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；<br>在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！使用 Redis 作为缓存的读取逻辑如下图所示：<br><img src=\"/images/redis8.png\" alt=\"redis\"><br>从上图我们可以知道以下两点：</li>\n</ul>\n<ol>\n<li>当<strong>第一次读取数据的时候</strong>，读取 Redis 的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入 Redis 中；</li>\n<li>当<strong>第二次以及以后需要读取数据时</strong>，就会直接读取 Redis，读到数据后就结束了流程，这样速度就大大提高了。<br>从上面的分析可以知道，读操作的可能性是远大于写操作的，所以使用 Redis 来处理日常中需要经常读取的数据，速度提升是显而易见的，同时也降低了对数据库的依赖，使得数据库的压力大大减少。</li>\n</ol>\n<p>分析了读操作的逻辑，下面我们来看看<strong>写操作的流程</strong>：<br><img src=\"/images/redis9.png\" alt=\"redis\"><br>从流程可以看出，更新或者写入的操作，需要多个 Redis 的操作，如果业务数据写次数远大于读次数那么就没有必要使用 Redis。</p>\n<blockquote>\n<p>关于使用内存存储数据，我知道谷歌好像就是<strong>把所有互联网的数据都存储在内存条</strong>的，所以才会有如此高质量、高效的搜索，但它毕竟是谷歌…</p>\n</blockquote>\n<h4 id=\"高速读-写的场合\"><a href=\"#高速读-写的场合\" class=\"headerlink\" title=\"高速读/写的场合\"></a>高速读/写的场合</h4><p>在如今的互联网中，越来越多的存在高并发的情况，比如天猫双11、抢红包、抢演唱会门票等，这些场合都是在某一个瞬间或者是某一个短暂的时刻有<strong>成千上万的请求</strong>到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，<strong>轻则造成用户体验极差用户量流失，重则数据库瘫痪，服务宕机</strong>，而这样的场合都是不允许的！</p>\n<p>所以我们需要使用 Redis 来应对这样的高并发需求的场合，我们先来看看一次<strong>请求操作的流程图</strong>：<br><img src=\"/images/redis10.png\" alt=\"redis\"><br>我们来进一步阐述这个过程：</p>\n<ol>\n<li>当一个请求到达服务器时，只是把业务数据在 Redis 上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足<strong>高速响应的需求</strong>；</li>\n<li>但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完 Redis 的读/写之后，会去<strong>判断该高速读/写的业务是否结束</strong>，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将 Redis 的缓存的数据以批量的形式<strong>一次性写入数据库</strong>，从而完成持久化的工作。</li>\n</ol>\n<hr>\n<h3 id=\"Redis-的安装\"><a href=\"#Redis-的安装\" class=\"headerlink\" title=\"Redis 的安装\"></a>Redis 的安装</h3><blockquote>\n<p>操作系统：CentOS 7<br>redis版本：5.0</p>\n</blockquote>\n<h4 id=\"下载安装包\"><a href=\"#下载安装包\" class=\"headerlink\" title=\"下载安装包\"></a>下载安装包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget http://download.redis.io/releases/redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis11.png\" alt=\"redis\"></p>\n<h4 id=\"解压安装包\"><a href=\"#解压安装包\" class=\"headerlink\" title=\"解压安装包\"></a>解压安装包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar -zxvf redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis12.png\" alt=\"redis\"><br>没有报错就代表解压成功！</p>\n<h4 id=\"yum安装gcc依赖\"><a href=\"#yum安装gcc依赖\" class=\"headerlink\" title=\"yum安装gcc依赖\"></a>yum安装gcc依赖</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install gcc</span><br></pre></td></tr></table></figure>\n<p>遇到选择，输入y即可</p>\n<h4 id=\"编译-amp-安装\"><a href=\"#编译-amp-安装\" class=\"headerlink\" title=\"编译&amp;安装\"></a>编译&amp;安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> redis-5.0.0/</span><br><span class=\"line\">$ make</span><br><span class=\"line\">$ make install</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试是否安装成功\"><a href=\"#测试是否安装成功\" class=\"headerlink\" title=\"测试是否安装成功\"></a>测试是否安装成功</h4><p>先切换到redis src目录下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> src/</span><br></pre></td></tr></table></figure>\n<h4 id=\"直接启动redis\"><a href=\"#直接启动redis\" class=\"headerlink\" title=\"直接启动redis\"></a>直接启动redis</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./redis-server</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis13.png\" alt=\"redis\"><br>如上图：redis启动成功，但是这种启动方式需要一直打开窗口，不能进行其他操作，不太方便。<br>按 ctrl + c可以关闭窗口。</p>\n<h4 id=\"以后台进程方式启动redis\"><a href=\"#以后台进程方式启动redis\" class=\"headerlink\" title=\"以后台进程方式启动redis\"></a>以后台进程方式启动redis</h4><h5 id=\"第一步：修改redis-conf文件\"><a href=\"#第一步：修改redis-conf文件\" class=\"headerlink\" title=\"第一步：修改redis.conf文件\"></a>第一步：修改redis.conf文件</h5><p>redis.conf文件就在redis目录下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> redis-5.0.0/</span><br><span class=\"line\">$ vim redis.conf</span><br></pre></td></tr></table></figure>\n<p>将<strong>daemonize no</strong>修改为<strong>daemonize yes</strong><br><img src=\"/images/redis14.png\" alt=\"redis\"><br>配置允许所有ip都可以访问redis，将bind 127.0.0.1注释掉:<br><img src=\"/images/redis15.png\" alt=\"redis\"><br>并且将protected-mode改为no<br><img src=\"/images/redis16.png\" alt=\"redis\"></p>\n<h5 id=\"第二步：指定redis-conf文件启动\"><a href=\"#第二步：指定redis-conf文件启动\" class=\"headerlink\" title=\"第二步：指定redis.conf文件启动\"></a>第二步：指定redis.conf文件启动</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./redis-server ~/redis-5.0.0/redis.conf</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis17.png\" alt=\"redis\"></p>\n<h5 id=\"第三步：关闭redis进程\"><a href=\"#第三步：关闭redis进程\" class=\"headerlink\" title=\"第三步：关闭redis进程\"></a>第三步：关闭redis进程</h5><p>首先使用<code>ps -aux&brvbar;grep redis</code>查看redis进程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -aux | grep redis</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis18.png\" alt=\"redis\"><br>使用kill命令杀死进程,并检查是否成功关闭</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">kill</span> -9 2751</span><br></pre></td></tr></table></figure>\n<h5 id=\"第四步：检查是否开启了所有ip访问：\"><a href=\"#第四步：检查是否开启了所有ip访问：\" class=\"headerlink\" title=\"第四步：检查是否开启了所有ip访问：\"></a>第四步：检查是否开启了所有ip访问：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -ef |grep redis</span><br></pre></td></tr></table></figure>\n<p>如果端口号前面显示的是*则说明客户端可以访问了，如果是127.0.0.1，则需要重新配置了。</p>\n<h4 id=\"设置redis开机自启动\"><a href=\"#设置redis开机自启动\" class=\"headerlink\" title=\"设置redis开机自启动\"></a>设置redis开机自启动</h4><h5 id=\"在-etc目录下新建redis目录\"><a href=\"#在-etc目录下新建redis目录\" class=\"headerlink\" title=\"在/etc目录下新建redis目录\"></a>在/etc目录下新建redis目录</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /etc</span><br><span class=\"line\">$ mkdir redis</span><br></pre></td></tr></table></figure>\n<h5 id=\"将-root-redis-5-0-0-redis-conf文件复制一份到-etc-redis目录下，并命名为6379-conf\"><a href=\"#将-root-redis-5-0-0-redis-conf文件复制一份到-etc-redis目录下，并命名为6379-conf\" class=\"headerlink\" title=\"将/root/redis-5.0.0/redis.conf文件复制一份到/etc/redis目录下，并命名为6379.conf\"></a>将/root/redis-5.0.0/redis.conf文件复制一份到/etc/redis目录下，并命名为6379.conf</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cp /root/redis-5.0.0/redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure>\n<h5 id=\"将redis的启动脚本复制一份放到-etc-init-d目录下\"><a href=\"#将redis的启动脚本复制一份放到-etc-init-d目录下\" class=\"headerlink\" title=\"将redis的启动脚本复制一份放到/etc/init.d目录下\"></a>将redis的启动脚本复制一份放到/etc/init.d目录下</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cp /root/redis-5.0.0/utils/redis_init_script /etc/init.d/redisd</span><br></pre></td></tr></table></figure>\n<h5 id=\"设置redis开机自启动-1\"><a href=\"#设置redis开机自启动-1\" class=\"headerlink\" title=\"设置redis开机自启动\"></a>设置redis开机自启动</h5><p>先切换到/etc/init.d目录下，然后执行自启命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chkconfig redisd on</span><br></pre></td></tr></table></figure>\n<p>如果redisd不支持chkconfig，使用vim编辑redisd文件，在第一行加入如下两行注释，保存退出</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># chkconfig:   2345 90 10</span></span><br><span class=\"line\"><span class=\"comment\"># description:  Redis is a persistent key-value database</span></span><br></pre></td></tr></table></figure>\n<p>注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。<br>再次执行开机自启命令，成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chkconfig redisd on</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"以服务的形式启动和关闭redis\"><a href=\"#以服务的形式启动和关闭redis\" class=\"headerlink\" title=\"以服务的形式启动和关闭redis\"></a>以服务的形式启动和关闭redis</h4><h5 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ service redisd start</span><br></pre></td></tr></table></figure>\n<h5 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ service redisd stop</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis19.png\" alt=\"redis\"></p>\n<hr>\n<h3 id=\"在-Java-中使用-Redis\"><a href=\"#在-Java-中使用-Redis\" class=\"headerlink\" title=\"在 Java 中使用 Redis\"></a>在 Java 中使用 Redis</h3><h4 id=\"第一步：添加-Jedis-依赖\"><a href=\"#第一步：添加-Jedis-依赖\" class=\"headerlink\" title=\"第一步：添加 Jedis 依赖\"></a>第一步：添加 Jedis 依赖</h4><p>想要在 Java 中使用 Redis 缓存，需要添加相关的Jar包依赖，打开Maven仓库的网站：<a href=\"https://mvnrepository.com/\" target=\"_blank\" rel=\"noopener\">https://mvnrepository.com/</a> ，搜索Jedis：<br><img src=\"/images/redis20.png\" alt=\"redis\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>写个简单的性能测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">redisTester</span></span>() &#123;</span><br><span class=\"line\">    Jedis jedis = new Jedis(<span class=\"string\">\"localhost\"</span>, 6379, 100000);</span><br><span class=\"line\">    int i = 0;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        long start = System.currentTimeMillis();// 开始毫秒数</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            long end = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (end - start &gt;= 1000) &#123;// 当大于等于1000毫秒（相当于1秒）时，结束操作</span><br><span class=\"line\">                <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            jedis.set(<span class=\"string\">\"test\"</span> + i, i + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;// 关闭连接</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 打印1秒内对Redis的操作次数</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"redis每秒操作：\"</span> + i + <span class=\"string\">\"次\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-----------测试结果-----------</span><br><span class=\"line\">redis每秒操作：99776次</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：使用-Redis-连接池\"><a href=\"#第二步：使用-Redis-连接池\" class=\"headerlink\" title=\"第二步：使用 Redis 连接池\"></a>第二步：使用 Redis 连接池</h4><p>跟数据库连接池相同，Java Redis也同样提供了类<code>redis.clients.jedis.JedisPool</code>来管理我们的Reids连接池对象，并且我们可以使用<code>redis.clients.jedis.JedisPoolConfig</code>来对连接池进行配置，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class=\"line\">// 最大空闲数</span><br><span class=\"line\">poolConfig.setMaxIdle(50);</span><br><span class=\"line\">// 最大连接数</span><br><span class=\"line\">poolConfig.setMaxTotal(100);</span><br><span class=\"line\">// 最大等待毫秒数</span><br><span class=\"line\">poolConfig.setMaxWaitMillis(20000);</span><br><span class=\"line\">// 使用配置创建连接池</span><br><span class=\"line\">JedisPool pool = new JedisPool(poolConfig, <span class=\"string\">\"localhost\"</span>);</span><br><span class=\"line\">// 从连接池中获取单个连接</span><br><span class=\"line\">Jedis jedis = pool.getResource();</span><br><span class=\"line\">// 如果需要密码</span><br><span class=\"line\">//jedis.auth(<span class=\"string\">\"password\"</span>);</span><br></pre></td></tr></table></figure>\n<p>Redis 只能支持六种数据类型（string/hash/list/set/zset/hyperloglog）的操作，但在 Java 中我们却通常以类对象为主，所以在需要 Redis 存储的五中数据类型与 Java 对象之间进行转换，如果自己编写一些工具类，比如一个角色对象的转换，还是比较容易的，但是涉及到许多对象的时候，这其中无论工作量还是工作难度都是很大的，所以总体来说，<strong>就操作对象而言，使用 Redis 还是挺难的</strong>，好在 Spring 对这些进行了封装和支持。</p>\n<h4 id=\"第三步：在-Spring-中使用-Redis\"><a href=\"#第三步：在-Spring-中使用-Redis\" class=\"headerlink\" title=\"第三步：在 Spring 中使用 Redis\"></a>第三步：在 Spring 中使用 Redis</h4><p>上面说到了 Redis 无法操作对象的问题，无法在那些基础类型和 Java 对象之间方便的转换，但是在 Spring 中，这些问题都可以<strong>通过使用RedisTemplate</strong>得到解决！</p>\n<p>想要达到这样的效果，除了 Jedis 包以外还需要在 Spring 引入 spring-data-redis 包：<a href=\"https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis\" target=\"_blank\" rel=\"noopener\">https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis</a><br><img src=\"/images/redis21.png\" alt=\"redis\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>(1) 第一步：使用Spring配置JedisPoolConfig对象</strong><br>大部分的情况下，我们还是会用到连接池的，于是先用 Spring 配置一个 JedisPoolConfig 对象：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"poolConfig\"</span> class=<span class=\"string\">\"redis.clients.jedis.JedisPoolConfig\"</span>&gt;</span><br><span class=\"line\">    &lt;!--最大空闲数--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"maxIdle\"</span> value=<span class=\"string\">\"50\"</span>/&gt;</span><br><span class=\"line\">    &lt;!--最大连接数--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"maxTotal\"</span> value=<span class=\"string\">\"100\"</span>/&gt;</span><br><span class=\"line\">    &lt;!--最大等待时间--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"maxWaitMillis\"</span> value=<span class=\"string\">\"20000\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>(2) 第二步：为连接池配置工厂模型</strong><br>好了，我们现在配置好了连接池的相关属性，那么具体使用哪种工厂实现呢？在Spring Data Redis中有四种可供我们选择的工厂模型，它们分别是：</p>\n<ul>\n<li>JredisConnectionFactory</li>\n<li>JedisConnectionFactory</li>\n<li>LettuceConnectionFactory</li>\n<li>SrpConnectionFactory<br>我们这里就简单配置成JedisConnectionFactory：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"connectionFactory\"</span> class=<span class=\"string\">\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"</span>&gt;</span><br><span class=\"line\">    &lt;!--Redis服务地址--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"hostName\"</span> value=<span class=\"string\">\"localhost\"</span>/&gt;</span><br><span class=\"line\">    &lt;!--端口号--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"port\"</span> value=<span class=\"string\">\"6379\"</span>/&gt;</span><br><span class=\"line\">    &lt;!--如果有密码则需要配置密码--&gt;</span><br><span class=\"line\">    &lt;!--&lt;property name=<span class=\"string\">\"password\"</span> value=<span class=\"string\">\"password\"</span>/&gt;--&gt;</span><br><span class=\"line\">    &lt;!--连接池配置--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"poolConfig\"</span> ref=<span class=\"string\">\"poolConfig\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>(3) 第三步：配置RedisTemplate</strong><br>普通的连接根本没有办法直接将对象直接存入 Redis 内存中，我们需要替代的方案：将对象序列化（可以简单的理解为继承Serializable接口）。我们可以把对象序列化之后存入Redis缓存中，然后在取出的时候又通过转换器，将序列化之后的对象反序列化回对象，这样就完成了我们的要求：<br><img src=\"/images/redis22.png\" alt=\"redis\"><br>RedisTemplate可以帮助我们完成这份工作，它会找到对应的序列化器去转换Redis的键值：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"redisTemplate\"</span></span><br><span class=\"line\">      class=<span class=\"string\">\"org.springframework.data.redis.core.RedisTemplate\"</span></span><br><span class=\"line\">      p:connection-factory-ref=<span class=\"string\">\"connectionFactory\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>我从《JavaEE互联网轻量级框架整合开发》中了解到，这一步需要配置单独的序列化器去支撑这一步的工作，但是自己在测试当中，发现只要我们的Pojo类实现了Serializable接口，就不会出现问题，所以我直接省略掉了配置序列化器这一步。<br><strong>(4) 第四步：编写测试</strong></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @author: @loonycoder</span><br><span class=\"line\"> * @create: 2018-11-28 下午 18:22:06</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Student implements Serializable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 给该类一个服务类用于测试</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">service</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"学生名字为：\"</span> + name);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"学生年龄为：\"</span> + age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getName</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int <span class=\"function\"><span class=\"title\">getAge</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后编写测试类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">test</span></span>() &#123;</span><br><span class=\"line\">    ApplicationContext context =</span><br><span class=\"line\">            new ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">    RedisTemplate redisTemplate = context.getBean(RedisTemplate.class);</span><br><span class=\"line\">    Student student = new Student();</span><br><span class=\"line\">    student.setName(<span class=\"string\">\"loonycoder\"</span>);</span><br><span class=\"line\">    student.setAge(24);</span><br><span class=\"line\">    redisTemplate.opsForValue().<span class=\"built_in\">set</span>(<span class=\"string\">\"student_1\"</span>, student);</span><br><span class=\"line\">    Student student1 = (Student) redisTemplate.opsForValue().get(<span class=\"string\">\"student_1\"</span>);</span><br><span class=\"line\">    student1.service();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis23.png\" alt=\"redis\"></p>\n<h4 id=\"第四步：在-SpringBoot-中使用-Redis\"><a href=\"#第四步：在-SpringBoot-中使用-Redis\" class=\"headerlink\" title=\"第四步：在 SpringBoot 中使用 Redis\"></a>第四步：在 SpringBoot 中使用 Redis</h4><p><strong>(1)在SpringBoot中添加Redis依赖：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Radis --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>(2)添加配置文件：</strong><br>在SpringBoot中使用<code>.properties</code>或者<code>.yml</code>都可以，这里给出<code>.properties</code>的例子，因为自己的<code>.yml</code>文件看上去感觉乱糟糟的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># REDIS (RedisProperties)</span></span><br><span class=\"line\"><span class=\"comment\"># Redis数据库索引（默认为0）</span></span><br><span class=\"line\">spring.redis.database=0</span><br><span class=\"line\"><span class=\"comment\"># Redis服务器地址</span></span><br><span class=\"line\">spring.redis.host=localhost</span><br><span class=\"line\"><span class=\"comment\"># Redis服务器连接端口</span></span><br><span class=\"line\">spring.redis.port=6379</span><br><span class=\"line\"><span class=\"comment\"># Redis服务器连接密码（默认为空）</span></span><br><span class=\"line\">spring.redis.password=</span><br><span class=\"line\"><span class=\"comment\"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class=\"line\">spring.redis.pool.max-active=8</span><br><span class=\"line\"><span class=\"comment\"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class=\"line\">spring.redis.pool.max-wait=-1</span><br><span class=\"line\"><span class=\"comment\"># 连接池中的最大空闲连接</span></span><br><span class=\"line\">spring.redis.pool.max-idle=8</span><br><span class=\"line\"><span class=\"comment\"># 连接池中的最小空闲连接</span></span><br><span class=\"line\">spring.redis.pool.min-idle=0</span><br><span class=\"line\"><span class=\"comment\"># 连接超时时间（毫秒）</span></span><br><span class=\"line\">spring.redis.timeout=0</span><br></pre></td></tr></table></figure>\n<p><strong>(3)测试访问：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\">@SpringBootTest()</span><br><span class=\"line\">public class ApplicationTests &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private StringRedisTemplate stringRedisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void <span class=\"built_in\">test</span>() throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 保存字符串</span><br><span class=\"line\">        stringRedisTemplate.opsForValue().<span class=\"built_in\">set</span>(<span class=\"string\">\"loonycoder\"</span>, <span class=\"string\">\"24\"</span>);</span><br><span class=\"line\">        Assert.assertEquals(<span class=\"string\">\"24\"</span>, stringRedisTemplate.opsForValue().get(<span class=\"string\">\"loonycoder\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面这段极为简单的测试案例演示了如何通过自动配置的<strong>StringRedisTemplate</strong>对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。原本是RedisTemplate&lt;K, V&gt;接口，StringRedisTemplate就相当于RedisTemplate&lt;String, String&gt;的实现。<br><strong>(4)存储对象：</strong><br>这一步跟上面使用Spring一样，只需要将Pojo类实现Serializable接口就可以了，这里直接贴测试代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\">@SpringBootTest()</span><br><span class=\"line\">public class ApplicationTests &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void <span class=\"built_in\">test</span>() throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        User user = new User();</span><br><span class=\"line\">        user.setName(<span class=\"string\">\"loonycoder\"</span>);</span><br><span class=\"line\">        user.setAge(24);</span><br><span class=\"line\"></span><br><span class=\"line\">        redisTemplate.opsForValue().<span class=\"built_in\">set</span>(<span class=\"string\">\"user_1\"</span>, user);</span><br><span class=\"line\">        User user1 = (User) redisTemplate.opsForValue().get(<span class=\"string\">\"user_1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(user1.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参考文章：<br><a href=\"https://www.cnblogs.com/ityouknow/p/5748830.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ityouknow/p/5748830.html</a><br><a href=\"http://blog.didispace.com/springbootredis/\" target=\"_blank\" rel=\"noopener\">http://blog.didispace.com/springbootredis/</a></p>\n</blockquote>\n<hr>\n<h3 id=\"在Redis中操作集合\"><a href=\"#在Redis中操作集合\" class=\"headerlink\" title=\"在Redis中操作集合\"></a>在Redis中操作集合</h3><blockquote>\n<p>引用文章：<a href=\"https://www.jianshu.com/p/29aaac3172b5\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/29aaac3172b5</a></p>\n</blockquote>\n<p>直接贴上两段简单的示例代码：</p>\n<h4 id=\"在Redis中操作List\"><a href=\"#在Redis中操作List\" class=\"headerlink\" title=\"在Redis中操作List\"></a>在Redis中操作List</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// list数据类型适合于消息队列的场景:比如12306并发量太高，而同一时间段内只能处理指定数量的数据！必须满足先进先出的原则，其余数据处于等待</span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">listPushResitTest</span></span>() &#123;</span><br><span class=\"line\">    // leftPush依次由右边添加</span><br><span class=\"line\">    stringRedisTemplate.opsForList().rightPush(<span class=\"string\">\"myList\"</span>, <span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">    stringRedisTemplate.opsForList().rightPush(<span class=\"string\">\"myList\"</span>, <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">    stringRedisTemplate.opsForList().rightPush(<span class=\"string\">\"myList\"</span>, <span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    stringRedisTemplate.opsForList().rightPush(<span class=\"string\">\"myList\"</span>, <span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    // leftPush依次由左边添加</span><br><span class=\"line\">    stringRedisTemplate.opsForList().leftPush(<span class=\"string\">\"myList\"</span>, <span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">listGetListResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 查询类别所有元素</span><br><span class=\"line\">    List&lt;String&gt; listAll = stringRedisTemplate.opsForList().range(<span class=\"string\">\"myList\"</span>, 0, -1);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"list all &#123;&#125;\"</span>, listAll);</span><br><span class=\"line\">    // 查询前3个元素</span><br><span class=\"line\">    List&lt;String&gt; list = stringRedisTemplate.opsForList().range(<span class=\"string\">\"myList\"</span>, 0, 3);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"list limit &#123;&#125;\"</span>, list);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">listRemoveOneResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 删除先进入的B元素</span><br><span class=\"line\">    stringRedisTemplate.opsForList().remove(<span class=\"string\">\"myList\"</span>, 1, <span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">listRemoveAllResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 删除所有A元素</span><br><span class=\"line\">    stringRedisTemplate.opsForList().remove(<span class=\"string\">\"myList\"</span>, 0, <span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在Redis中操作Hash\"><a href=\"#在Redis中操作Hash\" class=\"headerlink\" title=\"在Redis中操作Hash\"></a>在Redis中操作Hash</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashPutResitTest</span></span>() &#123;</span><br><span class=\"line\">    // map的key值相同，后添加的覆盖原有的</span><br><span class=\"line\">    stringRedisTemplate.opsForHash().put(<span class=\"string\">\"banks:12600000\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashGetEntiresResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 获取map对象</span><br><span class=\"line\">    Map&lt;Object, Object&gt; map = stringRedisTemplate.opsForHash().entries(<span class=\"string\">\"banks:12600000\"</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"objects:&#123;&#125;\"</span>, map);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashGeDeleteResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 根据map的key删除这个元素</span><br><span class=\"line\">    stringRedisTemplate.opsForHash().delete(<span class=\"string\">\"banks:12600000\"</span>, <span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashGetKeysResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 获得map的key集合</span><br><span class=\"line\">    Set&lt;Object&gt; objects = stringRedisTemplate.opsForHash().keys(<span class=\"string\">\"banks:12600000\"</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"objects:&#123;&#125;\"</span>, objects);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashGetValueListResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 获得map的value列表</span><br><span class=\"line\">    List&lt;Object&gt; objects = stringRedisTemplate.opsForHash().values(<span class=\"string\">\"banks:12600000\"</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"objects:&#123;&#125;\"</span>, objects);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashSize</span></span>() &#123; // 获取map对象大小</span><br><span class=\"line\">    long size = stringRedisTemplate.opsForHash().size(<span class=\"string\">\"banks:12600000\"</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"size:&#123;&#125;\"</span>, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在网上看到了关于MySQL的性能测试，读写操作大概就<strong>每秒1000以下</strong>的样子，而且这还和引擎相关，所以可以看出Redis确实能在性能方面帮助许多。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/redis-logo.png\" alt=\"redis\"></p>\n<h3 id=\"Redis-概述\"><a href=\"#Redis-概述\" class=\"headerlink\" title=\"Redis 概述\"></a>Redis 概述</h3><p>在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p>\n<hr>\n<h3 id=\"NoSQL-技术\"><a href=\"#NoSQL-技术\" class=\"headerlink\" title=\"NoSQL 技术\"></a>NoSQL 技术</h3><p>为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种<strong>基于内存的数据库</strong>，并且提供一定的持久化功能。</p>\n<p><strong>Redis</strong>和<strong>MongoDB</strong>是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以<strong>支持每秒十几万此的读/写操作</strong>，其性能远超数据库，并且还<strong>支持集群、分布式、主从同步等</strong>配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还<strong>支持一定的事务能力</strong>，这保证了高并发的场景下数据的安全和一致性。</p>\n<hr>\n<h3 id=\"Redis-在-Java-Web-中的应用\"><a href=\"#Redis-在-Java-Web-中的应用\" class=\"headerlink\" title=\"Redis 在 Java Web 中的应用\"></a>Redis 在 Java Web 中的应用</h3><p>Redis 在 Java Web 主要有两个应用场景：</p>\n<ul>\n<li>存储 <strong>缓存</strong> 用的数据；</li>\n<li>需要高速读/写的场合<strong>使用它快速读/写</strong>；</li>\n</ul>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><p>在日常对数据库的访问中，读操作的次数远超写操作，比例大概在 <strong>1:9</strong> 到 <strong>3:7</strong>，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会<strong>去磁盘把对应的数据索引取回来</strong>，这是一个相对较慢的过程。</p>\n<p>如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端<strong>直接去读取内存中的数据</strong>，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们<strong>只是使用 Redis 存储一些常用和主要的数据</strong>，比如用户登录的信息等。</p>\n<p>一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：</p>\n<ul>\n<li><strong>业务数据常用吗？命中率如何？</strong>如果命中率很低，就没有必要写入缓存；</li>\n<li><strong>该业务数据是读操作多，还是写操作多？</strong>如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li>\n<li><strong>业务数据大小如何？</strong>如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；<br>在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！使用 Redis 作为缓存的读取逻辑如下图所示：<br><img src=\"/images/redis8.png\" alt=\"redis\"><br>从上图我们可以知道以下两点：</li>\n</ul>\n<ol>\n<li>当<strong>第一次读取数据的时候</strong>，读取 Redis 的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入 Redis 中；</li>\n<li>当<strong>第二次以及以后需要读取数据时</strong>，就会直接读取 Redis，读到数据后就结束了流程，这样速度就大大提高了。<br>从上面的分析可以知道，读操作的可能性是远大于写操作的，所以使用 Redis 来处理日常中需要经常读取的数据，速度提升是显而易见的，同时也降低了对数据库的依赖，使得数据库的压力大大减少。</li>\n</ol>\n<p>分析了读操作的逻辑，下面我们来看看<strong>写操作的流程</strong>：<br><img src=\"/images/redis9.png\" alt=\"redis\"><br>从流程可以看出，更新或者写入的操作，需要多个 Redis 的操作，如果业务数据写次数远大于读次数那么就没有必要使用 Redis。</p>\n<blockquote>\n<p>关于使用内存存储数据，我知道谷歌好像就是<strong>把所有互联网的数据都存储在内存条</strong>的，所以才会有如此高质量、高效的搜索，但它毕竟是谷歌…</p>\n</blockquote>\n<h4 id=\"高速读-写的场合\"><a href=\"#高速读-写的场合\" class=\"headerlink\" title=\"高速读/写的场合\"></a>高速读/写的场合</h4><p>在如今的互联网中，越来越多的存在高并发的情况，比如天猫双11、抢红包、抢演唱会门票等，这些场合都是在某一个瞬间或者是某一个短暂的时刻有<strong>成千上万的请求</strong>到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，<strong>轻则造成用户体验极差用户量流失，重则数据库瘫痪，服务宕机</strong>，而这样的场合都是不允许的！</p>\n<p>所以我们需要使用 Redis 来应对这样的高并发需求的场合，我们先来看看一次<strong>请求操作的流程图</strong>：<br><img src=\"/images/redis10.png\" alt=\"redis\"><br>我们来进一步阐述这个过程：</p>\n<ol>\n<li>当一个请求到达服务器时，只是把业务数据在 Redis 上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足<strong>高速响应的需求</strong>；</li>\n<li>但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完 Redis 的读/写之后，会去<strong>判断该高速读/写的业务是否结束</strong>，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将 Redis 的缓存的数据以批量的形式<strong>一次性写入数据库</strong>，从而完成持久化的工作。</li>\n</ol>\n<hr>\n<h3 id=\"Redis-的安装\"><a href=\"#Redis-的安装\" class=\"headerlink\" title=\"Redis 的安装\"></a>Redis 的安装</h3><blockquote>\n<p>操作系统：CentOS 7<br>redis版本：5.0</p>\n</blockquote>\n<h4 id=\"下载安装包\"><a href=\"#下载安装包\" class=\"headerlink\" title=\"下载安装包\"></a>下载安装包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget http://download.redis.io/releases/redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis11.png\" alt=\"redis\"></p>\n<h4 id=\"解压安装包\"><a href=\"#解压安装包\" class=\"headerlink\" title=\"解压安装包\"></a>解压安装包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar -zxvf redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis12.png\" alt=\"redis\"><br>没有报错就代表解压成功！</p>\n<h4 id=\"yum安装gcc依赖\"><a href=\"#yum安装gcc依赖\" class=\"headerlink\" title=\"yum安装gcc依赖\"></a>yum安装gcc依赖</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install gcc</span><br></pre></td></tr></table></figure>\n<p>遇到选择，输入y即可</p>\n<h4 id=\"编译-amp-安装\"><a href=\"#编译-amp-安装\" class=\"headerlink\" title=\"编译&amp;安装\"></a>编译&amp;安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> redis-5.0.0/</span><br><span class=\"line\">$ make</span><br><span class=\"line\">$ make install</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试是否安装成功\"><a href=\"#测试是否安装成功\" class=\"headerlink\" title=\"测试是否安装成功\"></a>测试是否安装成功</h4><p>先切换到redis src目录下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> src/</span><br></pre></td></tr></table></figure>\n<h4 id=\"直接启动redis\"><a href=\"#直接启动redis\" class=\"headerlink\" title=\"直接启动redis\"></a>直接启动redis</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./redis-server</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis13.png\" alt=\"redis\"><br>如上图：redis启动成功，但是这种启动方式需要一直打开窗口，不能进行其他操作，不太方便。<br>按 ctrl + c可以关闭窗口。</p>\n<h4 id=\"以后台进程方式启动redis\"><a href=\"#以后台进程方式启动redis\" class=\"headerlink\" title=\"以后台进程方式启动redis\"></a>以后台进程方式启动redis</h4><h5 id=\"第一步：修改redis-conf文件\"><a href=\"#第一步：修改redis-conf文件\" class=\"headerlink\" title=\"第一步：修改redis.conf文件\"></a>第一步：修改redis.conf文件</h5><p>redis.conf文件就在redis目录下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> redis-5.0.0/</span><br><span class=\"line\">$ vim redis.conf</span><br></pre></td></tr></table></figure>\n<p>将<strong>daemonize no</strong>修改为<strong>daemonize yes</strong><br><img src=\"/images/redis14.png\" alt=\"redis\"><br>配置允许所有ip都可以访问redis，将bind 127.0.0.1注释掉:<br><img src=\"/images/redis15.png\" alt=\"redis\"><br>并且将protected-mode改为no<br><img src=\"/images/redis16.png\" alt=\"redis\"></p>\n<h5 id=\"第二步：指定redis-conf文件启动\"><a href=\"#第二步：指定redis-conf文件启动\" class=\"headerlink\" title=\"第二步：指定redis.conf文件启动\"></a>第二步：指定redis.conf文件启动</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./redis-server ~/redis-5.0.0/redis.conf</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis17.png\" alt=\"redis\"></p>\n<h5 id=\"第三步：关闭redis进程\"><a href=\"#第三步：关闭redis进程\" class=\"headerlink\" title=\"第三步：关闭redis进程\"></a>第三步：关闭redis进程</h5><p>首先使用<code>ps -aux&brvbar;grep redis</code>查看redis进程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -aux | grep redis</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis18.png\" alt=\"redis\"><br>使用kill命令杀死进程,并检查是否成功关闭</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">kill</span> -9 2751</span><br></pre></td></tr></table></figure>\n<h5 id=\"第四步：检查是否开启了所有ip访问：\"><a href=\"#第四步：检查是否开启了所有ip访问：\" class=\"headerlink\" title=\"第四步：检查是否开启了所有ip访问：\"></a>第四步：检查是否开启了所有ip访问：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps -ef |grep redis</span><br></pre></td></tr></table></figure>\n<p>如果端口号前面显示的是*则说明客户端可以访问了，如果是127.0.0.1，则需要重新配置了。</p>\n<h4 id=\"设置redis开机自启动\"><a href=\"#设置redis开机自启动\" class=\"headerlink\" title=\"设置redis开机自启动\"></a>设置redis开机自启动</h4><h5 id=\"在-etc目录下新建redis目录\"><a href=\"#在-etc目录下新建redis目录\" class=\"headerlink\" title=\"在/etc目录下新建redis目录\"></a>在/etc目录下新建redis目录</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /etc</span><br><span class=\"line\">$ mkdir redis</span><br></pre></td></tr></table></figure>\n<h5 id=\"将-root-redis-5-0-0-redis-conf文件复制一份到-etc-redis目录下，并命名为6379-conf\"><a href=\"#将-root-redis-5-0-0-redis-conf文件复制一份到-etc-redis目录下，并命名为6379-conf\" class=\"headerlink\" title=\"将/root/redis-5.0.0/redis.conf文件复制一份到/etc/redis目录下，并命名为6379.conf\"></a>将/root/redis-5.0.0/redis.conf文件复制一份到/etc/redis目录下，并命名为6379.conf</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cp /root/redis-5.0.0/redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure>\n<h5 id=\"将redis的启动脚本复制一份放到-etc-init-d目录下\"><a href=\"#将redis的启动脚本复制一份放到-etc-init-d目录下\" class=\"headerlink\" title=\"将redis的启动脚本复制一份放到/etc/init.d目录下\"></a>将redis的启动脚本复制一份放到/etc/init.d目录下</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cp /root/redis-5.0.0/utils/redis_init_script /etc/init.d/redisd</span><br></pre></td></tr></table></figure>\n<h5 id=\"设置redis开机自启动-1\"><a href=\"#设置redis开机自启动-1\" class=\"headerlink\" title=\"设置redis开机自启动\"></a>设置redis开机自启动</h5><p>先切换到/etc/init.d目录下，然后执行自启命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chkconfig redisd on</span><br></pre></td></tr></table></figure>\n<p>如果redisd不支持chkconfig，使用vim编辑redisd文件，在第一行加入如下两行注释，保存退出</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># chkconfig:   2345 90 10</span></span><br><span class=\"line\"><span class=\"comment\"># description:  Redis is a persistent key-value database</span></span><br></pre></td></tr></table></figure>\n<p>注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。<br>再次执行开机自启命令，成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chkconfig redisd on</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"以服务的形式启动和关闭redis\"><a href=\"#以服务的形式启动和关闭redis\" class=\"headerlink\" title=\"以服务的形式启动和关闭redis\"></a>以服务的形式启动和关闭redis</h4><h5 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ service redisd start</span><br></pre></td></tr></table></figure>\n<h5 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ service redisd stop</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis19.png\" alt=\"redis\"></p>\n<hr>\n<h3 id=\"在-Java-中使用-Redis\"><a href=\"#在-Java-中使用-Redis\" class=\"headerlink\" title=\"在 Java 中使用 Redis\"></a>在 Java 中使用 Redis</h3><h4 id=\"第一步：添加-Jedis-依赖\"><a href=\"#第一步：添加-Jedis-依赖\" class=\"headerlink\" title=\"第一步：添加 Jedis 依赖\"></a>第一步：添加 Jedis 依赖</h4><p>想要在 Java 中使用 Redis 缓存，需要添加相关的Jar包依赖，打开Maven仓库的网站：<a href=\"https://mvnrepository.com/\" target=\"_blank\" rel=\"noopener\">https://mvnrepository.com/</a> ，搜索Jedis：<br><img src=\"/images/redis20.png\" alt=\"redis\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>写个简单的性能测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">redisTester</span></span>() &#123;</span><br><span class=\"line\">    Jedis jedis = new Jedis(<span class=\"string\">\"localhost\"</span>, 6379, 100000);</span><br><span class=\"line\">    int i = 0;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        long start = System.currentTimeMillis();// 开始毫秒数</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            long end = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (end - start &gt;= 1000) &#123;// 当大于等于1000毫秒（相当于1秒）时，结束操作</span><br><span class=\"line\">                <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            jedis.set(<span class=\"string\">\"test\"</span> + i, i + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;// 关闭连接</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 打印1秒内对Redis的操作次数</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"redis每秒操作：\"</span> + i + <span class=\"string\">\"次\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-----------测试结果-----------</span><br><span class=\"line\">redis每秒操作：99776次</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：使用-Redis-连接池\"><a href=\"#第二步：使用-Redis-连接池\" class=\"headerlink\" title=\"第二步：使用 Redis 连接池\"></a>第二步：使用 Redis 连接池</h4><p>跟数据库连接池相同，Java Redis也同样提供了类<code>redis.clients.jedis.JedisPool</code>来管理我们的Reids连接池对象，并且我们可以使用<code>redis.clients.jedis.JedisPoolConfig</code>来对连接池进行配置，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class=\"line\">// 最大空闲数</span><br><span class=\"line\">poolConfig.setMaxIdle(50);</span><br><span class=\"line\">// 最大连接数</span><br><span class=\"line\">poolConfig.setMaxTotal(100);</span><br><span class=\"line\">// 最大等待毫秒数</span><br><span class=\"line\">poolConfig.setMaxWaitMillis(20000);</span><br><span class=\"line\">// 使用配置创建连接池</span><br><span class=\"line\">JedisPool pool = new JedisPool(poolConfig, <span class=\"string\">\"localhost\"</span>);</span><br><span class=\"line\">// 从连接池中获取单个连接</span><br><span class=\"line\">Jedis jedis = pool.getResource();</span><br><span class=\"line\">// 如果需要密码</span><br><span class=\"line\">//jedis.auth(<span class=\"string\">\"password\"</span>);</span><br></pre></td></tr></table></figure>\n<p>Redis 只能支持六种数据类型（string/hash/list/set/zset/hyperloglog）的操作，但在 Java 中我们却通常以类对象为主，所以在需要 Redis 存储的五中数据类型与 Java 对象之间进行转换，如果自己编写一些工具类，比如一个角色对象的转换，还是比较容易的，但是涉及到许多对象的时候，这其中无论工作量还是工作难度都是很大的，所以总体来说，<strong>就操作对象而言，使用 Redis 还是挺难的</strong>，好在 Spring 对这些进行了封装和支持。</p>\n<h4 id=\"第三步：在-Spring-中使用-Redis\"><a href=\"#第三步：在-Spring-中使用-Redis\" class=\"headerlink\" title=\"第三步：在 Spring 中使用 Redis\"></a>第三步：在 Spring 中使用 Redis</h4><p>上面说到了 Redis 无法操作对象的问题，无法在那些基础类型和 Java 对象之间方便的转换，但是在 Spring 中，这些问题都可以<strong>通过使用RedisTemplate</strong>得到解决！</p>\n<p>想要达到这样的效果，除了 Jedis 包以外还需要在 Spring 引入 spring-data-redis 包：<a href=\"https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis\" target=\"_blank\" rel=\"noopener\">https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis</a><br><img src=\"/images/redis21.png\" alt=\"redis\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>(1) 第一步：使用Spring配置JedisPoolConfig对象</strong><br>大部分的情况下，我们还是会用到连接池的，于是先用 Spring 配置一个 JedisPoolConfig 对象：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"poolConfig\"</span> class=<span class=\"string\">\"redis.clients.jedis.JedisPoolConfig\"</span>&gt;</span><br><span class=\"line\">    &lt;!--最大空闲数--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"maxIdle\"</span> value=<span class=\"string\">\"50\"</span>/&gt;</span><br><span class=\"line\">    &lt;!--最大连接数--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"maxTotal\"</span> value=<span class=\"string\">\"100\"</span>/&gt;</span><br><span class=\"line\">    &lt;!--最大等待时间--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"maxWaitMillis\"</span> value=<span class=\"string\">\"20000\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>(2) 第二步：为连接池配置工厂模型</strong><br>好了，我们现在配置好了连接池的相关属性，那么具体使用哪种工厂实现呢？在Spring Data Redis中有四种可供我们选择的工厂模型，它们分别是：</p>\n<ul>\n<li>JredisConnectionFactory</li>\n<li>JedisConnectionFactory</li>\n<li>LettuceConnectionFactory</li>\n<li>SrpConnectionFactory<br>我们这里就简单配置成JedisConnectionFactory：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"connectionFactory\"</span> class=<span class=\"string\">\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"</span>&gt;</span><br><span class=\"line\">    &lt;!--Redis服务地址--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"hostName\"</span> value=<span class=\"string\">\"localhost\"</span>/&gt;</span><br><span class=\"line\">    &lt;!--端口号--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"port\"</span> value=<span class=\"string\">\"6379\"</span>/&gt;</span><br><span class=\"line\">    &lt;!--如果有密码则需要配置密码--&gt;</span><br><span class=\"line\">    &lt;!--&lt;property name=<span class=\"string\">\"password\"</span> value=<span class=\"string\">\"password\"</span>/&gt;--&gt;</span><br><span class=\"line\">    &lt;!--连接池配置--&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"poolConfig\"</span> ref=<span class=\"string\">\"poolConfig\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>(3) 第三步：配置RedisTemplate</strong><br>普通的连接根本没有办法直接将对象直接存入 Redis 内存中，我们需要替代的方案：将对象序列化（可以简单的理解为继承Serializable接口）。我们可以把对象序列化之后存入Redis缓存中，然后在取出的时候又通过转换器，将序列化之后的对象反序列化回对象，这样就完成了我们的要求：<br><img src=\"/images/redis22.png\" alt=\"redis\"><br>RedisTemplate可以帮助我们完成这份工作，它会找到对应的序列化器去转换Redis的键值：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"redisTemplate\"</span></span><br><span class=\"line\">      class=<span class=\"string\">\"org.springframework.data.redis.core.RedisTemplate\"</span></span><br><span class=\"line\">      p:connection-factory-ref=<span class=\"string\">\"connectionFactory\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>我从《JavaEE互联网轻量级框架整合开发》中了解到，这一步需要配置单独的序列化器去支撑这一步的工作，但是自己在测试当中，发现只要我们的Pojo类实现了Serializable接口，就不会出现问题，所以我直接省略掉了配置序列化器这一步。<br><strong>(4) 第四步：编写测试</strong></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @author: @loonycoder</span><br><span class=\"line\"> * @create: 2018-11-28 下午 18:22:06</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Student implements Serializable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 给该类一个服务类用于测试</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">service</span></span>() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"学生名字为：\"</span> + name);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"学生年龄为：\"</span> + age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getName</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int <span class=\"function\"><span class=\"title\">getAge</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后编写测试类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">test</span></span>() &#123;</span><br><span class=\"line\">    ApplicationContext context =</span><br><span class=\"line\">            new ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">    RedisTemplate redisTemplate = context.getBean(RedisTemplate.class);</span><br><span class=\"line\">    Student student = new Student();</span><br><span class=\"line\">    student.setName(<span class=\"string\">\"loonycoder\"</span>);</span><br><span class=\"line\">    student.setAge(24);</span><br><span class=\"line\">    redisTemplate.opsForValue().<span class=\"built_in\">set</span>(<span class=\"string\">\"student_1\"</span>, student);</span><br><span class=\"line\">    Student student1 = (Student) redisTemplate.opsForValue().get(<span class=\"string\">\"student_1\"</span>);</span><br><span class=\"line\">    student1.service();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/redis23.png\" alt=\"redis\"></p>\n<h4 id=\"第四步：在-SpringBoot-中使用-Redis\"><a href=\"#第四步：在-SpringBoot-中使用-Redis\" class=\"headerlink\" title=\"第四步：在 SpringBoot 中使用 Redis\"></a>第四步：在 SpringBoot 中使用 Redis</h4><p><strong>(1)在SpringBoot中添加Redis依赖：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Radis --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>(2)添加配置文件：</strong><br>在SpringBoot中使用<code>.properties</code>或者<code>.yml</code>都可以，这里给出<code>.properties</code>的例子，因为自己的<code>.yml</code>文件看上去感觉乱糟糟的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># REDIS (RedisProperties)</span></span><br><span class=\"line\"><span class=\"comment\"># Redis数据库索引（默认为0）</span></span><br><span class=\"line\">spring.redis.database=0</span><br><span class=\"line\"><span class=\"comment\"># Redis服务器地址</span></span><br><span class=\"line\">spring.redis.host=localhost</span><br><span class=\"line\"><span class=\"comment\"># Redis服务器连接端口</span></span><br><span class=\"line\">spring.redis.port=6379</span><br><span class=\"line\"><span class=\"comment\"># Redis服务器连接密码（默认为空）</span></span><br><span class=\"line\">spring.redis.password=</span><br><span class=\"line\"><span class=\"comment\"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class=\"line\">spring.redis.pool.max-active=8</span><br><span class=\"line\"><span class=\"comment\"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class=\"line\">spring.redis.pool.max-wait=-1</span><br><span class=\"line\"><span class=\"comment\"># 连接池中的最大空闲连接</span></span><br><span class=\"line\">spring.redis.pool.max-idle=8</span><br><span class=\"line\"><span class=\"comment\"># 连接池中的最小空闲连接</span></span><br><span class=\"line\">spring.redis.pool.min-idle=0</span><br><span class=\"line\"><span class=\"comment\"># 连接超时时间（毫秒）</span></span><br><span class=\"line\">spring.redis.timeout=0</span><br></pre></td></tr></table></figure>\n<p><strong>(3)测试访问：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\">@SpringBootTest()</span><br><span class=\"line\">public class ApplicationTests &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private StringRedisTemplate stringRedisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void <span class=\"built_in\">test</span>() throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 保存字符串</span><br><span class=\"line\">        stringRedisTemplate.opsForValue().<span class=\"built_in\">set</span>(<span class=\"string\">\"loonycoder\"</span>, <span class=\"string\">\"24\"</span>);</span><br><span class=\"line\">        Assert.assertEquals(<span class=\"string\">\"24\"</span>, stringRedisTemplate.opsForValue().get(<span class=\"string\">\"loonycoder\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面这段极为简单的测试案例演示了如何通过自动配置的<strong>StringRedisTemplate</strong>对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。原本是RedisTemplate&lt;K, V&gt;接口，StringRedisTemplate就相当于RedisTemplate&lt;String, String&gt;的实现。<br><strong>(4)存储对象：</strong><br>这一步跟上面使用Spring一样，只需要将Pojo类实现Serializable接口就可以了，这里直接贴测试代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\">@SpringBootTest()</span><br><span class=\"line\">public class ApplicationTests &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void <span class=\"built_in\">test</span>() throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        User user = new User();</span><br><span class=\"line\">        user.setName(<span class=\"string\">\"loonycoder\"</span>);</span><br><span class=\"line\">        user.setAge(24);</span><br><span class=\"line\"></span><br><span class=\"line\">        redisTemplate.opsForValue().<span class=\"built_in\">set</span>(<span class=\"string\">\"user_1\"</span>, user);</span><br><span class=\"line\">        User user1 = (User) redisTemplate.opsForValue().get(<span class=\"string\">\"user_1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(user1.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参考文章：<br><a href=\"https://www.cnblogs.com/ityouknow/p/5748830.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ityouknow/p/5748830.html</a><br><a href=\"http://blog.didispace.com/springbootredis/\" target=\"_blank\" rel=\"noopener\">http://blog.didispace.com/springbootredis/</a></p>\n</blockquote>\n<hr>\n<h3 id=\"在Redis中操作集合\"><a href=\"#在Redis中操作集合\" class=\"headerlink\" title=\"在Redis中操作集合\"></a>在Redis中操作集合</h3><blockquote>\n<p>引用文章：<a href=\"https://www.jianshu.com/p/29aaac3172b5\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/29aaac3172b5</a></p>\n</blockquote>\n<p>直接贴上两段简单的示例代码：</p>\n<h4 id=\"在Redis中操作List\"><a href=\"#在Redis中操作List\" class=\"headerlink\" title=\"在Redis中操作List\"></a>在Redis中操作List</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// list数据类型适合于消息队列的场景:比如12306并发量太高，而同一时间段内只能处理指定数量的数据！必须满足先进先出的原则，其余数据处于等待</span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">listPushResitTest</span></span>() &#123;</span><br><span class=\"line\">    // leftPush依次由右边添加</span><br><span class=\"line\">    stringRedisTemplate.opsForList().rightPush(<span class=\"string\">\"myList\"</span>, <span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">    stringRedisTemplate.opsForList().rightPush(<span class=\"string\">\"myList\"</span>, <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">    stringRedisTemplate.opsForList().rightPush(<span class=\"string\">\"myList\"</span>, <span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    stringRedisTemplate.opsForList().rightPush(<span class=\"string\">\"myList\"</span>, <span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    // leftPush依次由左边添加</span><br><span class=\"line\">    stringRedisTemplate.opsForList().leftPush(<span class=\"string\">\"myList\"</span>, <span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">listGetListResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 查询类别所有元素</span><br><span class=\"line\">    List&lt;String&gt; listAll = stringRedisTemplate.opsForList().range(<span class=\"string\">\"myList\"</span>, 0, -1);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"list all &#123;&#125;\"</span>, listAll);</span><br><span class=\"line\">    // 查询前3个元素</span><br><span class=\"line\">    List&lt;String&gt; list = stringRedisTemplate.opsForList().range(<span class=\"string\">\"myList\"</span>, 0, 3);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"list limit &#123;&#125;\"</span>, list);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">listRemoveOneResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 删除先进入的B元素</span><br><span class=\"line\">    stringRedisTemplate.opsForList().remove(<span class=\"string\">\"myList\"</span>, 1, <span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">listRemoveAllResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 删除所有A元素</span><br><span class=\"line\">    stringRedisTemplate.opsForList().remove(<span class=\"string\">\"myList\"</span>, 0, <span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在Redis中操作Hash\"><a href=\"#在Redis中操作Hash\" class=\"headerlink\" title=\"在Redis中操作Hash\"></a>在Redis中操作Hash</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashPutResitTest</span></span>() &#123;</span><br><span class=\"line\">    // map的key值相同，后添加的覆盖原有的</span><br><span class=\"line\">    stringRedisTemplate.opsForHash().put(<span class=\"string\">\"banks:12600000\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashGetEntiresResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 获取map对象</span><br><span class=\"line\">    Map&lt;Object, Object&gt; map = stringRedisTemplate.opsForHash().entries(<span class=\"string\">\"banks:12600000\"</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"objects:&#123;&#125;\"</span>, map);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashGeDeleteResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 根据map的key删除这个元素</span><br><span class=\"line\">    stringRedisTemplate.opsForHash().delete(<span class=\"string\">\"banks:12600000\"</span>, <span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashGetKeysResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 获得map的key集合</span><br><span class=\"line\">    Set&lt;Object&gt; objects = stringRedisTemplate.opsForHash().keys(<span class=\"string\">\"banks:12600000\"</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"objects:&#123;&#125;\"</span>, objects);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashGetValueListResitTest</span></span>() &#123;</span><br><span class=\"line\">    // 获得map的value列表</span><br><span class=\"line\">    List&lt;Object&gt; objects = stringRedisTemplate.opsForHash().values(<span class=\"string\">\"banks:12600000\"</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"objects:&#123;&#125;\"</span>, objects);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">hashSize</span></span>() &#123; // 获取map对象大小</span><br><span class=\"line\">    long size = stringRedisTemplate.opsForHash().size(<span class=\"string\">\"banks:12600000\"</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"size:&#123;&#125;\"</span>, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在网上看到了关于MySQL的性能测试，读写操作大概就<strong>每秒1000以下</strong>的样子，而且这还和引擎相关，所以可以看出Redis确实能在性能方面帮助许多。</p>\n"},{"title":"Spring框架——深入剖析核心IoC源码","date":"2018-10-29T16:00:00.000Z","_content":"\n![Spring](/images/spring_logo.jpg)\n\n原文转自：<https://javadoop.com/post/spring-ioc>\n\n因为有幸看到这篇让我读了约三个半小时的文章，简直价值千金，所以稍作修改，以此记录。\n为了保持文章的严谨性，如有错误，望及时指出，十分希望听到读者的声音。\n\n---\n\n### 引言\n先看下最基本的启动 Spring 容器的例子：\n```bash\npublic static void main(String[] args) {\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:Application.xml\");\n}\n```\n以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。\n```bash\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-context</artifactId>\n  <version>4.3.11.RELEASE</version>\n</dependency>\n```\n> spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。\n\n多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。\n废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code>其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext 。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：\n![spring](/images/spring-ioc1.png)\n> 读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。\n当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。\n\n我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 \n**FileSystemXmlApplicationContext**和**AnnotationConfigApplicationContext**这两个类。\n\n1. **FileSystemXmlApplicationContext**的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。\n\n2. **AnnotationConfigApplicationContext**是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。\n\n不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。\n\n我们先来一个简单的例子来看看怎么实例化 ApplicationContext。\n\n首先，定义一个接口：\n```bash\npublic interface MessageService {\n    String getMessage();\n}\n```\n定义接口实现类：\n```bash\npublic class MessageServiceImpl implements MessageService {\n    public String getMessage() {\n        return \"hello world\";\n    }\n}\n```\n\n接下来，我们在 **resources** 目录新建一个配置文件，文件名随意，通常叫 Application.xml 或 Application-xxx.xml 就可以了：\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\">\n    <bean id=\"messageService\" class=\"com.loonycoder.service.MessageServiceImpl\"/>\n</beans>\n```\n这样，我们就可以跑起来了：\n```bash\npublic class App {\n    public static void main(String[] args) {\n        // 用我们的配置文件来启动一个 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:Application.xml\");\n\n        System.out.println(\"context 启动成功\");\n\n        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式\n        MessageService messageService = context.getBean(MessageService.class);\n        // 这句将输出: hello world\n        System.out.println(messageService.getMessage());\n    }\n}\n```\n以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。\n\n---\n\n### BeanFactory 简介\nBeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。\n\n初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：\n![spring](/images/spring-ioc2.png)\n我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。\n\n- ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。\n- ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。\n- AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。\n- ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。\n- 请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。\n然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。\n\n---\n\n### 启动过程分析\n下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。\n\n第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。\n\n```bash\npublic class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {\n  private Resource[] configResources;\n\n  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法\n  public ClassPathXmlApplicationContext(ApplicationContext parent) {\n    super(parent);\n  }\n  ...\n  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)\n      throws BeansException {\n\n    super(parent);\n    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)\n    setConfigLocations(configLocations);\n    if (refresh) {\n      refresh(); // 核心方法\n    }\n  }\n    ...\n}\n```\n\n接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。\n\n往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。\n```bash\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n\n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n\n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset 'active' flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring's core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n\n下面，我们开始一步步来肢解这个 refresh() 方法。\n\n---\n\n#### 创建 Bean 容器，加载并注册 Bean\n我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。\n\n注意，**这个方法是全文最重要的部分之一**，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。\n\n当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。\n\n// AbstractApplicationContext.java\n```bash\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等\n   refreshBeanFactory();\n\n   // 返回刚刚创建的 BeanFactory\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n   }\n   return beanFactory;\n}\n```\n// AbstractRefreshableApplicationContext.java 120\n```bash\n@Override\nprotected final void refreshBeanFactory() throws BeansException {\n   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory\n   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前\n   // ApplicationContext 是否有 BeanFactory\n   if (hasBeanFactory()) {\n      destroyBeans();\n      closeBeanFactory();\n   }\n   try {\n      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。\n      DefaultListableBeanFactory beanFactory = createBeanFactory();\n      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到\n      beanFactory.setSerializationId(getId());\n\n      // 下面这两个方法很重要，别跟丢了，具体细节之后说\n      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用\n      customizeBeanFactory(beanFactory);\n\n      // 加载 Bean 到 BeanFactory 中\n      loadBeanDefinitions(beanFactory);\n      synchronized (this.beanFactoryMonitor) {\n         this.beanFactory = beanFactory;\n      }\n   }\n   catch (IOException ex) {\n      throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex);\n   }\n}\n```\n\n> 看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。\n\n我们说说为什么选择实例化 **DefaultListableBeanFactory** ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：\n![spring](/images/spring-ioc2.png)\n\n我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。\n\n> 如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？\n之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。\n那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。\n\n在继续往下之前，我们需要先了解 BeanDefinition。**我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？**\n\n这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。\n\n所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。\n> BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。\n\n**BeanDefinition 接口定义**\n我们来看下 BeanDefinition 的接口定义：\n```bash\npublic interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {\n\n   // 我们可以看到，默认只提供 sington 和 prototype 两种，\n   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，\n   // 不过，它们属于基于 web 的扩展。\n   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;\n   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;\n\n   // 比较不重要，直接跳过吧\n   int ROLE_APPLICATION = 0;\n   int ROLE_SUPPORT = 1;\n   int ROLE_INFRASTRUCTURE = 2;\n\n   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍\n   // 一句话就是：继承父 Bean 的配置信息而已\n   void setParentName(String parentName);\n\n   // 获取父 Bean\n   String getParentName();\n\n   // 设置 Bean 的类名称，将来是要通过反射来生成实例的\n   void setBeanClassName(String beanClassName);\n\n   // 获取 Bean 的类名称\n   String getBeanClassName();\n\n\n   // 设置 bean 的 scope\n   void setScope(String scope);\n\n   String getScope();\n\n   // 设置是否懒加载\n   void setLazyInit(boolean lazyInit);\n\n   boolean isLazyInit();\n\n   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，\n   // 是 depends-on=\"\" 属性设置的值。\n   void setDependsOn(String... dependsOn);\n\n   // 返回该 Bean 的所有依赖\n   String[] getDependsOn();\n\n   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，\n   // 如果根据名称注入，即使这边设置了 false，也是可以的\n   void setAutowireCandidate(boolean autowireCandidate);\n\n   // 该 Bean 是否可以注入到其他 Bean 中\n   boolean isAutowireCandidate();\n\n   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean\n   void setPrimary(boolean primary);\n\n   // 是否是 primary 的\n   boolean isPrimary();\n\n   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录\n   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的\n   void setFactoryBeanName(String factoryBeanName);\n   // 获取工厂名称\n   String getFactoryBeanName();\n   // 指定工厂类中的 工厂方法名称\n   void setFactoryMethodName(String factoryMethodName);\n   // 获取工厂类中的 工厂方法名称\n   String getFactoryMethodName();\n\n   // 构造器参数\n   ConstructorArgumentValues getConstructorArgumentValues();\n\n   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到\n   MutablePropertyValues getPropertyValues();\n\n   // 是否 singleton\n   boolean isSingleton();\n\n   // 是否 prototype\n   boolean isPrototype();\n\n   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，\n   // 常用于作为 父bean 用于继承，其实也很少用......\n   boolean isAbstract();\n\n   int getRole();\n   String getDescription();\n   String getResourceDescription();\n   BeanDefinition getOriginatingBeanDefinition();\n}\n```\n\n> 这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。\n这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。\n\n有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：\n```bash\ncustomizeBeanFactory(beanFactory);\nloadBeanDefinitions(beanFactory);\n```\n\n虽然只有两个方法，但路还很长啊。。。\n\n**customizeBeanFactory**\n\ncustomizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。\n```bash\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n   if (this.allowBeanDefinitionOverriding != null) {\n      // 是否允许 Bean 定义覆盖\n      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n   }\n   if (this.allowCircularReferences != null) {\n      // 是否允许 Bean 间的循环依赖\n      beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n   }\n}\n```\nBeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\n循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。\n\n默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。\n\n至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。\n\n之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。\n\n**加载Bean:loadBeanDefinitions**\n\n接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。\n\n读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。\n\n// AbstractXmlApplicationContext.java 80\n```bash\n/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/\n@Override\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader\n   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\n   // Configure the bean definition reader with this context's\n   // resource loading environment.\n   beanDefinitionReader.setEnvironment(this.getEnvironment());\n   beanDefinitionReader.setResourceLoader(this);\n   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，\n   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧\n   initBeanDefinitionReader(beanDefinitionReader);\n   // 重点来了，继续往下\n   loadBeanDefinitions(beanDefinitionReader);\n}\n```\n现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。\n\n// AbstractXmlApplicationContext.java 120\n```bash\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n   Resource[] configResources = getConfigResources();\n   if (configResources != null) {\n      // 往下看\n      reader.loadBeanDefinitions(configResources);\n   }\n   String[] configLocations = getConfigLocations();\n   if (configLocations != null) {\n      // 2\n      reader.loadBeanDefinitions(configLocations);\n   }\n}\n\n// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里\n@Override\npublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {\n   Assert.notNull(resources, \"Resource array must not be null\");\n   int counter = 0;\n   // 注意这里是个 for 循环，也就是每个文件是一个 resource\n   for (Resource resource : resources) {\n      // 继续往下看\n      counter += loadBeanDefinitions(resource);\n   }\n   // 最后返回 counter，表示总共加载了多少的 BeanDefinition\n   return counter;\n}\n\n// XmlBeanDefinitionReader 303\n@Override\npublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n   return loadBeanDefinitions(new EncodedResource(resource));\n}\n\n// XmlBeanDefinitionReader 314\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n   Assert.notNull(encodedResource, \"EncodedResource must not be null\");\n   if (logger.isInfoEnabled()) {\n      logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource());\n   }\n   // 用一个 ThreadLocal 来存放配置文件资源\n   Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();\n   if (currentResources == null) {\n      currentResources = new HashSet<EncodedResource>(4);\n      this.resourcesCurrentlyBeingLoaded.set(currentResources);\n   }\n   if (!currentResources.add(encodedResource)) {\n      throw new BeanDefinitionStoreException(\n            \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\");\n   }\n   try {\n      InputStream inputStream = encodedResource.getResource().getInputStream();\n      try {\n         InputSource inputSource = new InputSource(inputStream);\n         if (encodedResource.getEncoding() != null) {\n            inputSource.setEncoding(encodedResource.getEncoding());\n         }\n         // 核心部分是这里，往下面看\n         return doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n      }\n      finally {\n         inputStream.close();\n      }\n   }\n   catch (IOException ex) {\n      throw new BeanDefinitionStoreException(\n            \"IOException parsing XML document from \" + encodedResource.getResource(), ex);\n   }\n   finally {\n      currentResources.remove(encodedResource);\n      if (currentResources.isEmpty()) {\n         this.resourcesCurrentlyBeingLoaded.remove();\n      }\n   }\n}\n\n// 还在这个文件中，第 388 行\nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n      throws BeanDefinitionStoreException {\n   try {\n      // 这里就不看了，将 xml 文件转换为 Document 对象\n      Document doc = doLoadDocument(inputSource, resource);\n      // 继续\n      return registerBeanDefinitions(doc, resource);\n   }\n   catch (...\n}\n// 还在这个文件中，第 505 行\n// 返回值：返回从当前配置文件加载了多少数量的 Bean\npublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n   int countBefore = getRegistry().getBeanDefinitionCount();\n   // 这里\n   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n   return getRegistry().getBeanDefinitionCount() - countBefore;\n}\n// DefaultBeanDefinitionDocumentReader 90\n@Override\npublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n   this.readerContext = readerContext;\n   logger.debug(\"Loading bean definitions\");\n   Element root = doc.getDocumentElement();\n   // 从 xml 根节点开始解析文件\n   doRegisterBeanDefinitions(root);\n}  \n```\n\n经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：\n\n**doRegisterBeanDefinitions：**\n```bash\n// DefaultBeanDefinitionDocumentReader 116\nprotected void doRegisterBeanDefinitions(Element root) {\n   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，\n   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，\n   // 因为 <beans /> 内部是可以定义 <beans /> 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 <beans /> 节点，从源码分析的角度，我们当做根节点就好了\n   BeanDefinitionParserDelegate parent = this.delegate;\n   this.delegate = createDelegate(getReaderContext(), root, parent);\n\n   if (this.delegate.isDefaultNamespace(root)) {\n      // 这块说的是根节点 <beans ... profile=\"dev\" /> 中的 profile 是否是当前环境需要的，\n      // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 <beans /> 解析\n      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区\n      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n      if (StringUtils.hasText(profileSpec)) {\n         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n         if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n            if (logger.isInfoEnabled()) {\n               logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec +\n                     \"] not matching: \" + getReaderContext().getResource());\n            }\n            return;\n         }\n      }\n   }\n\n   preProcessXml(root); // 钩子\n   // 往下看\n   parseBeanDefinitions(root, this.delegate);\n   postProcessXml(root); // 钩子\n\n   this.delegate = parent;\n}\n```\n\npreProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。\n\n这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。\n\n接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :\n\n```bash\n// default namespace 涉及到的就四个标签 <import />、<alias />、<bean /> 和 <beans />，\n// 其他的属于 custom 的\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n   if (delegate.isDefaultNamespace(root)) {\n      NodeList nl = root.getChildNodes();\n      for (int i = 0; i < nl.getLength(); i++) {\n         Node node = nl.item(i);\n         if (node instanceof Element) {\n            Element ele = (Element) node;\n            if (delegate.isDefaultNamespace(ele)) {\n               // 解析 default namespace 下面的几个元素\n               parseDefaultElement(ele, delegate);\n            }\n            else {\n               // 解析其他 namespace 的元素\n               delegate.parseCustomElement(ele);\n            }\n         }\n      }\n   }\n   else {\n      delegate.parseCustomElement(root);\n   }\n}\n```\n\n从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。\n\nparseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt;、&lt;beans /&gt;</code>这几个。\n\n> 这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的：\n>```bash\nhttp://www.springframework.org/schema/beans\n```\n> 又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 xmlns 就是咯。\n> ```bash\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"\n            http://www.springframework.org/schema/beans\n          http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-autowire=\"byName\">\n```\n> 而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code> &lt;mvc /&gt;、&lt;task /&gt;、&lt;context /&gt;、&lt;aop /&gt;</code>等。\n这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。\n> 假如读者想分析 <code>&lt;context:property-placeholder location=\"classpath:xx.properties\" /&gt;</code>的实现原理，就应该到 ContextNamespaceHandler 中找答案。\n> ```bash\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:context=\"http://www.springframework.org/schema/context\"\n      xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n      xsi:schemaLocation=\"\n           http://www.springframework.org/schema/beans \n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/context\n           http://www.springframework.org/schema/context/spring-context.xsd\n           http://www.springframework.org/schema/mvc   \n           http://www.springframework.org/schema/mvc/spring-mvc.xsd  \n       \"\n      default-autowire=\"byName\">\n    </bean>\n```\n同理，以后你要是碰到 <code>&lt;<dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。\n回过神来，看看处理 default 标签的方法：\n```bash\nprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n      // 处理 <import /> 标签\n      importBeanDefinitionResource(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n      // 处理 <alias /> 标签定义\n      // <alias name=\"fromName\" alias=\"toName\"/>\n      processAliasRegistration(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n      // 处理 <bean /> 标签定义，这也算是我们的重点吧\n      processBeanDefinition(ele, delegate);\n   }\n   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n      // 如果碰到的是嵌套的 <beans /> 标签，需要递归\n      doRegisterBeanDefinitions(ele);\n   }\n}\n```\n如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <bean /> 标签出来说。\n\n**processBeanDefinition 解析 bean 标签**\n下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：\n\n// DefaultBeanDefinitionDocumentReader 298\n```bash\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 <bean /> 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\n   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的\n\n   if (bdHolder != null) {\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // Register the final decorated instance.\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(\"Failed to register bean definition with name '\" +\n               bdHolder.getBeanName() + \"'\", ele, ex);\n      }\n      // Send registration event.\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}\n```\n继续往下看怎么解析之前，我们先看下 <code>&lt;bean /&gt;</code> 标签中可以定义哪些属性：\n\nProperty||\n:-:|:-:|\nclass|类的全限定名\nname|可指定 id、name(用逗号、分号、空格分隔)\nscope|作用域\nconstructor arguments|指定构造参数\nproperties|设置属性的值\nautowiring mode|no(默认值)、byName、byType、 constructor\nlazy-initialization mode|是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)\ninitialization method|bean 属性设置完成后，会调用这个方法\ndestruction method|bean 销毁后的回调方法 \n\n\n上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。\n\n简单地说就是像下面这样子：\n```bash\n<bean id=\"exampleBean\" name=\"name1, name2, name3\" class=\"com.loonycoder.ExampleBean\"\n      scope=\"singleton\" lazy-init=\"true\" init-method=\"init\" destroy-method=\"cleanup\">\n\n    <!-- 可以用下面三种形式指定构造参数 -->\n    <constructor-arg type=\"int\" value=\"7500000\"/>\n    <constructor-arg name=\"years\" value=\"7500000\"/>\n    <constructor-arg index=\"0\" value=\"7500000\"/>\n\n    <!-- property 的几种情况 -->\n    <property name=\"beanOne\">\n        <ref bean=\"anotherExampleBean\"/>\n    </property>\n    <property name=\"beanTwo\" ref=\"yetAnotherBean\"/>\n    <property name=\"integerProperty\" value=\"1\"/>\n</bean>\n```\n当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;、&lt;replaced-method /&gt;、&lt;meta /&gt;、&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。\n\n有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。\n\n// BeanDefinitionParserDelegate 428\n```bash\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {\n    return parseBeanDefinitionElement(ele, null);\n}\n\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {\n   String id = ele.getAttribute(ID_ATTRIBUTE);\n   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n   List<String> aliases = new ArrayList<String>();\n\n   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，\n   // 当然，如果你不定义 name 属性的话，就是空的了\n   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了\n   if (StringUtils.hasLength(nameAttr)) {\n      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n      aliases.addAll(Arrays.asList(nameArr));\n   }\n\n   String beanName = id;\n   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName\n   if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n      beanName = aliases.remove(0);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"No XML 'id' specified - using '\" + beanName +\n               \"' as bean name and \" + aliases + \" as aliases\");\n      }\n   }\n\n   if (containingBean == null) {\n      checkNameUniqueness(beanName, aliases, ele);\n   }\n\n   // 根据 <bean ...>...</bean> 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,\n   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。\n   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n\n   // 到这里，整个 <bean /> 标签就算解析结束了，一个 BeanDefinition 就形成了。\n   if (beanDefinition != null) {\n      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生\n      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要\n      if (!StringUtils.hasText(beanName)) {\n         try {\n            if (containingBean != null) {// 按照我们的思路，这里 containingBean 是 null 的\n               beanName = BeanDefinitionReaderUtils.generateBeanName(\n                     beanDefinition, this.readerContext.getRegistry(), true);\n            }\n            else {\n               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：\n               //   1. beanName 为：com.loonycoder.service.MessageServiceImpl#0\n               //   2. beanClassName 为：com.loonycoder.service.MessageServiceImpl\n\n               beanName = this.readerContext.generateBeanName(beanDefinition);\n\n               String beanClassName = beanDefinition.getBeanClassName();\n               if (beanClassName != null &&\n                     beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&\n                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n                  // 把 beanClassName 设置为 Bean 的别名\n                  aliases.add(beanClassName);\n               }\n            }\n            if (logger.isDebugEnabled()) {\n               logger.debug(\"Neither XML 'id' nor 'name' specified - \" +\n                     \"using generated bean name [\" + beanName + \"]\");\n            }\n         }\n         catch (Exception ex) {\n            error(ex.getMessage(), ele);\n            return null;\n         }\n      }\n      String[] aliasesArray = StringUtils.toStringArray(aliases);\n      // 返回 BeanDefinitionHolder\n      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n   }\n\n   return null;\n}\n```\n然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：\n```bash\npublic AbstractBeanDefinition parseBeanDefinitionElement(\n      Element ele, String beanName, BeanDefinition containingBean) {\n\n   this.parseState.push(new BeanEntry(beanName));\n\n   String className = null;\n   if (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n   }\n\n   try {\n      String parent = null;\n      if (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n         parent = ele.getAttribute(PARENT_ATTRIBUTE);\n      }\n      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了\n      AbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中\n      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n      /**\n       * 下面的一堆是解析 <bean>......</bean> 内部的子元素，\n       * 解析出来以后的信息都放到 bd 的属性中\n       */\n\n      // 解析 <meta />\n      parseMetaElements(ele, bd);\n      // 解析 <lookup-method />\n      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n      // 解析 <replaced-method />\n      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n    // 解析 <constructor-arg />\n      parseConstructorArgElements(ele, bd);\n      // 解析 <property />\n      parsePropertyElements(ele, bd);\n      // 解析 <qualifier />\n      parseQualifierElements(ele, bd);\n\n      bd.setResource(this.readerContext.getResource());\n      bd.setSource(extractSource(ele));\n\n      return bd;\n   }\n   catch (ClassNotFoundException ex) {\n      error(\"Bean class [\" + className + \"] not found\", ele, ex);\n   }\n   catch (NoClassDefFoundError err) {\n      error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n   }\n   catch (Throwable ex) {\n      error(\"Unexpected failure during bean definition parsing\", ele, ex);\n   }\n   finally {\n      this.parseState.pop();\n   }\n\n   return null;\n}\n```\n到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。\n\n我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:\n```bash\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 <bean /> 节点转换为 BeanDefinitionHolder，就是上面说的一堆\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n   if (bdHolder != null) {\n      // 如果有自定义属性的话，进行相应的解析，先忽略\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // 我们把这步叫做 注册Bean 吧\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(\"Failed to register bean definition with name '\" +\n               bdHolder.getBeanName() + \"'\", ele, ex);\n      }\n      // 注册完成后，发送事件，本文不展开说这个\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}\n```\n大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：\n```bash\npublic class BeanDefinitionHolder implements BeanMetadataElement {\n\n  private final BeanDefinition beanDefinition;\n\n  private final String beanName;\n\n  private final String[] aliases;\n...\n```\n然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。\n\n下面，我们开始说说注册 Bean 吧。\n\n**注册 Bean**\n// BeanDefinitionReaderUtils 143\n```bash\npublic static void registerBeanDefinition(\n      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n      throws BeanDefinitionStoreException {\n\n   String beanName = definitionHolder.getBeanName();\n   // 注册这个 Bean\n   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n\n   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了\n   String[] aliases = definitionHolder.getAliases();\n   if (aliases != null) {\n      for (String alias : aliases) {\n         // alias -> beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，\n         // 获取的时候，会先将 alias 转换为 beanName，然后再查找\n         registry.registerAlias(beanName, alias);\n      }\n   }\n}\n```\n别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。\n\n// DefaultListableBeanFactory 793\n```bash\n@Override\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n      throws BeanDefinitionStoreException {\n\n   Assert.hasText(beanName, \"Bean name must not be empty\");\n   Assert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n   if (beanDefinition instanceof AbstractBeanDefinition) {\n      try {\n         ((AbstractBeanDefinition) beanDefinition).validate();\n      }\n      catch (BeanDefinitionValidationException ex) {\n         throw new BeanDefinitionStoreException(...);\n      }\n   }\n\n   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding\n   BeanDefinition oldBeanDefinition;\n\n   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中\n   oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n\n   // 处理重复名称的 Bean 定义的情况\n   if (oldBeanDefinition != null) {\n      if (!isAllowBeanDefinitionOverriding()) {\n         // 如果不允许覆盖的话，抛异常\n         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...\n      }\n      else if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {\n         // log...用框架定义的 Bean 覆盖用户自定义的 Bean \n      }\n      else if (!beanDefinition.equals(oldBeanDefinition)) {\n         // log...用新的 Bean 覆盖旧的 Bean\n      }\n      else {\n         // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean\n      }\n      // 覆盖\n      this.beanDefinitionMap.put(beanName, beanDefinition);\n   }\n   else {\n      // 判断是否已经有其他的 Bean 开始初始化了.\n      // 注意，\"注册Bean\" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，\n      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans\n      if (hasBeanCreationStarted()) {\n         // Cannot modify startup-time collection elements anymore (for stable iteration)\n         synchronized (this.beanDefinitionMap) {\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n            List<String> updatedDefinitions = new ArrayList<String>(this.beanDefinitionNames.size() + 1);\n            updatedDefinitions.addAll(this.beanDefinitionNames);\n            updatedDefinitions.add(beanName);\n            this.beanDefinitionNames = updatedDefinitions;\n            if (this.manualSingletonNames.contains(beanName)) {\n               Set<String> updatedSingletons = new LinkedHashSet<String>(this.manualSingletonNames);\n               updatedSingletons.remove(beanName);\n               this.manualSingletonNames = updatedSingletons;\n            }\n         }\n      }\n      else {\n         // 最正常的应该是进到这个分支。\n\n         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition\n         this.beanDefinitionMap.put(beanName, beanDefinition);\n         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字\n         this.beanDefinitionNames.add(beanName);\n         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，\n         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的\n         // 手动指的是通过调用以下方法注册的 bean ：\n         //     registerSingleton(String beanName, Object singletonObject)\n         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面\"手动\"注册一些 Bean，\n         // 如 \"environment\"、\"systemProperties\" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的\n         this.manualSingletonNames.remove(beanName);\n      }\n      // 这个不重要，在预初始化的时候会用到，不必管它。\n      this.frozenBeanDefinitionNames = null;\n   }\n\n   if (oldBeanDefinition != null || containsSingleton(beanName)) {\n      resetBeanDefinition(beanName);\n   }\n}\n```\n总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。\n\n--------- 分割线 ---------\n\n到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。\n\n#### Bean 容器实例化完成后\n说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。\n\n考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。\n\n```bash\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n\n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n\n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法\n         invokeBeanFactoryPostProcessors(beanFactory);          \n\n\n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成，不展开\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset 'active' flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring's core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n\n#### 准备 Bean 容器: prepareBeanFactory\n之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会\"手动\"注册一些特殊的 bean。\n\n这里简单介绍下 prepareBeanFactory(factory) 方法：\n```bash\n/**\n * Configure the factory's standard context characteristics,\n * such as the context's ClassLoader and post-processors.\n * @param beanFactory the BeanFactory to configure\n */\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，\n   // 这里设置为加载当前 ApplicationContext 类的类加载器\n   beanFactory.setBeanClassLoader(getClassLoader());\n\n   // 设置 BeanExpressionResolver\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n   // \n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // 添加一个 BeanPostProcessor，这个 processor 比较简单：\n   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，\n   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware\n   // 注意：它不仅仅回调 ApplicationContextAware，\n   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\n   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，\n   // Spring 会通过其他方式来处理这些依赖。\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   /**\n    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，\n    * 之前我们说过，\"当前 ApplicationContext 持有一个 BeanFactory\"，这里解释了第一行。\n    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource\n    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext\n    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean\n    */\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，\n   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器\n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它\n   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，\n   \n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   /**\n    * 从下面几行代码我们可以知道，Spring 往往很 \"智能\" 就是因为它会帮我们默认注册一些有用的 bean，\n    * 我们也可以选择覆盖\n    */\n\n   // 如果没有定义 \"environment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n   // 如果没有定义 \"systemProperties\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n   // 如果没有定义 \"systemEnvironment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}\n```\n\n在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。\n\n#### 初始化所有的 singleton beans\n我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。\n\n注意，后面的描述中，我都会使用**初始化**或**预初始化**来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。\n\n我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。\n\n剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。\n// AbstractApplicationContext.java 834\n```bash\n// 初始化剩余的 singleton beans\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n\n   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了\n   // 什么，看代码这里没有初始化 Bean 啊！\n   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧\n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n\n   // Register a default embedded value resolver if no bean post-processor\n   // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n   // at this point, primarily for resolution in annotation attribute values.\n   if (!beanFactory.hasEmbeddedValueResolver()) {\n      beanFactory.addEmbeddedValueResolver(new StringValueResolver() {\n         @Override\n         public String resolveStringValue(String strVal) {\n            return getEnvironment().resolvePlaceholders(strVal);\n         }\n      });\n   }\n\n   // 先初始化 LoadTimeWeaverAware 类型的 Bean\n   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧\n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n   for (String weaverAwareName : weaverAwareNames) {\n      getBean(weaverAwareName);\n   }\n\n   // Stop using the temporary ClassLoader for type matching.\n   beanFactory.setTempClassLoader(null);\n\n   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，\n   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。\n   beanFactory.freezeConfiguration();\n\n   // 开始初始化\n   beanFactory.preInstantiateSingletons();\n}\n```\n从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。\n\n**preInstantiateSingletons**\n// DefaultListableBeanFactory 728\n```bash\n@Override\npublic void preInstantiateSingletons() throws BeansException {\n   if (this.logger.isDebugEnabled()) {\n      this.logger.debug(\"Pre-instantiating singletons in \" + this);\n   }\n   // this.beanDefinitionNames 保存了所有的 beanNames\n   List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);\n\n   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作\n   for (String beanName : beanNames) {\n\n      // 合并父 Bean 中的配置，注意 <bean id=\"\" class=\"\" parent=\"\" /> 中的 parent，用的不多吧，\n      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 \"Bean 继承\"，不了解的请到附录中看一下\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\n      // 非抽象、非懒加载的 singletons。如果配置了 'abstract = true'，那是不需要初始化的\n      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)\n         if (isFactoryBean(beanName)) {\n            // FactoryBean 的话，在 beanName 前面加上 ‘&’ 符号。再调用 getBean，getBean 方法别急\n            final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);\n            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过\n            boolean isEagerInit;\n            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n               isEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n                  @Override\n                  public Boolean run() {\n                     return ((SmartFactoryBean<?>) factory).isEagerInit();\n                  }\n               }, getAccessControlContext());\n            }\n            else {\n               isEagerInit = (factory instanceof SmartFactoryBean &&\n                     ((SmartFactoryBean<?>) factory).isEagerInit());\n            }\n            if (isEagerInit) {\n\n               getBean(beanName);\n            }\n         }\n         else {\n            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了\n            getBean(beanName);\n         }\n      }\n   }\n\n   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化\n   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略\n   for (String beanName : beanNames) {\n      Object singletonInstance = getSingleton(beanName);\n      if (singletonInstance instanceof SmartInitializingSingleton) {\n         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n         if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged(new PrivilegedAction<Object>() {\n               @Override\n               public Object run() {\n                  smartSingleton.afterSingletonsInstantiated();\n                  return null;\n               }\n            }, getAccessControlContext());\n         }\n         else {\n            smartSingleton.afterSingletonsInstantiated();\n         }\n      }\n   }\n}\n```\n接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。\n\n**getBean**\n在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。\n\n// AbstractBeanFactory 196\n```bash\n@Override\npublic Object getBean(String name) throws BeansException {\n   return doGetBean(name, null, null, false);\n}\n\n// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，\n// 已经初始化过了就从容器中直接返回，否则就先初始化再返回\n@SuppressWarnings(\"unchecked\")\nprotected <T> T doGetBean(\n      final String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly)\n      throws BeansException {\n   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&’)，\n   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的\n   final String beanName = transformedBeanName(name);\n\n   // 注意跟着这个，这个是返回值\n   Object bean; \n\n   // 检查下是不是已经创建过了\n   Object sharedInstance = getSingleton(beanName);\n\n   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，\n   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean\n   if (sharedInstance != null && args == null) {\n      if (logger.isDebugEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.debug(\"...\");\n         }\n         else {\n            logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n         }\n      }\n      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，\n      // 如果是 FactoryBean 的话，返回它创建的那个实例对象\n      // (FactoryBean 知识，读者若不清楚请移步附录)\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   }\n\n   else {\n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，\n         // 往往是因为陷入了循环引用\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // 检查一下这个 BeanDefinition 在容器中是否存在\n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有\n         String nameToLookup = originalBeanName(name);\n         if (args != null) {\n            // 返回父容器的查询结果\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         }\n         else {\n            // No args -> delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         }\n      }\n\n      if (!typeCheckOnly) {\n         // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。\n         markBeanAsCreated(beanName);\n      }\n\n      /*\n       * 稍稍总结一下：\n       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；\n       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。\n       */\n      try {\n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n         checkMergedBeanDefinition(mbd, beanName, args);\n\n         // 先初始化依赖的所有 Bean，这个很好理解。\n         // 注意，这里的依赖指的是 depends-on 中定义的依赖\n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"'Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n               }\n               // 注册一下依赖关系\n               registerDependentBean(dep, beanName);\n               // 先初始化被依赖项\n               getBean(dep);\n            }\n         }\n\n         // 如果是 singleton scope 的，创建 singleton 的实例\n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {\n               @Override\n               public Object getObject() throws BeansException {\n                  try {\n                     // 执行创建 Bean，详情后面再说\n                     return createBean(beanName, mbd, args);\n                  }\n                  catch (BeansException ex) {\n                     destroySingleton(beanName);\n                     throw ex;\n                  }\n               }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         }\n\n         // 如果是 prototype scope 的，创建 prototype 的实例\n         else if (mbd.isPrototype()) {\n            // It’s a prototype -> create a new instance.\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               // 执行创建 Bean\n               prototypeInstance = createBean(beanName, mbd, args);\n            }\n            finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         }\n\n         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理\n         else {\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n            }\n            try {\n               Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n                  @Override\n                  public Object getObject() throws BeansException {\n                     beforePrototypeCreation(beanName);\n                     try {\n                        // 执行创建 Bean\n                        return createBean(beanName, mbd, args);\n                     }\n                     finally {\n                        afterPrototypeCreation(beanName);\n                     }\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            }\n            catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" +\n                     \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n                     ex);\n            }\n         }\n      }\n      catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n\n   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了\n   if (requiredType != null && bean != null && !requiredType.isInstance(bean)) {\n      try {\n         return getTypeConverter().convertIfNecessary(bean, requiredType);\n      }\n      catch (TypeMismatchException ex) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" +\n                  ClassUtils.getQualifiedName(requiredType) + \"'\", ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n      }\n   }\n   return (T) bean;\n}\n```\n大家应该也猜到了，接下来当然是分析 createBean 方法：\n```bash\nprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;\n```\n第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。\n\n这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。\n\n主要是为了以下场景，采用 @Autowired 注解注入属性值：\n```bash\npublic class MessageServiceImpl implements MessageService {\n    @Autowired\n    private UserService userService;\n\n    public String getMessage() {\n        return userService.getMessage();\n    }\n}\n```\n```bash\n<bean id=\"messageService\" class=\"com.loonycoder.service.MessageServiceImpl\" />\n```\n以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。\n\n好了，读者要知道这么回事就可以了，继续向前。\n\n// AbstractAutowireCapableBeanFactory 447\n```bash\n/**\n * Central method of this class: creates a bean instance,\n * populates the bean instance, applies post-processors, etc.\n * @see #doCreateBean\n */\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating instance of bean '\" + beanName + \"'\");\n   }\n   RootBeanDefinition mbdToUse = mbd;\n\n   // 确保 BeanDefinition 中的 Class 被加载\n   Class<?> resolvedClass = resolveBeanClass(mbd, beanName);\n   if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n      mbdToUse = new RootBeanDefinition(mbd);\n      mbdToUse.setBeanClass(resolvedClass);\n   }\n\n   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 <lookup-method /> \n   // 和 <replaced-method />，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。\n   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看\n   try {\n      mbdToUse.prepareMethodOverrides();\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n            beanName, \"Validation of method overrides failed\", ex);\n   }\n\n   try {\n      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，\n      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过\n      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n      if (bean != null) {\n         return bean; \n      }\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n            \"BeanPostProcessor before instantiation of bean failed\", ex);\n   }\n   // 重头戏，创建 bean\n   Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\");\n   }\n   return beanInstance;\n}\n```\n\n**创建Bean**\n我们继续往里看 doCreateBean 这个方法：\n```bash\n/**\n * Actually create the specified bean. Pre-creation processing has already happened\n * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n * <p>Differentiates between default bean instantiation, use of a\n * factory method, and autowiring a constructor.\n * @param beanName the name of the bean\n * @param mbd the merged bean definition for the bean\n * @param args explicit arguments to use for constructor or factory method invocation\n * @return a new instance of the bean\n * @throws BeanCreationException if the bean could not be created\n * @see #instantiateBean\n * @see #instantiateUsingFactoryMethod\n * @see #autowireConstructor\n */\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)\n      throws BeanCreationException {\n\n   // Instantiate the bean.\n   BeanWrapper instanceWrapper = null;\n   if (mbd.isSingleton()) {\n      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n   }\n   if (instanceWrapper == null) {\n      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说\n      instanceWrapper = createBeanInstance(beanName, mbd, args);\n   }\n   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 \"bean 实例\"\n   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);\n   // 类型\n   Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);\n   mbd.resolvedTargetType = beanType;\n\n   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor\n   synchronized (mbd.postProcessingLock) {\n      if (!mbd.postProcessed) {\n         try {\n            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的\n            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n         }\n         catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                  \"Post-processing of merged bean definition failed\", ex);\n         }\n         mbd.postProcessed = true;\n      }\n   }\n\n   // Eagerly cache singletons to be able to resolve circular references\n   // even when triggered by lifecycle interfaces like BeanFactoryAware.\n   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧\n   boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n         isSingletonCurrentlyInCreation(beanName));\n   if (earlySingletonExposure) {\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Eagerly caching bean '\" + beanName +\n               \"' to allow for resolving potential circular references\");\n      }\n      addSingletonFactory(beanName, new ObjectFactory<Object>() {\n         @Override\n         public Object getObject() throws BeansException {\n            return getEarlyBeanReference(beanName, mbd, bean);\n         }\n      });\n   }\n\n   // Initialize the bean instance.\n   Object exposedObject = bean;\n   try {\n      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值\n      populateBean(beanName, mbd, instanceWrapper);\n      if (exposedObject != null) {\n         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？\n         // 这里就是处理 bean 初始化完成后的各种回调\n         exposedObject = initializeBean(beanName, exposedObject, mbd);\n      }\n   }\n   catch (Throwable ex) {\n      if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n         throw (BeanCreationException) ex;\n      }\n      else {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n      }\n   }\n\n   if (earlySingletonExposure) {\n      // \n      Object earlySingletonReference = getSingleton(beanName, false);\n      if (earlySingletonReference != null) {\n         if (exposedObject == bean) {\n            exposedObject = earlySingletonReference;\n         }\n         else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n            String[] dependentBeans = getDependentBeans(beanName);\n            Set<String> actualDependentBeans = new LinkedHashSet<String>(dependentBeans.length);\n            for (String dependentBean : dependentBeans) {\n               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                  actualDependentBeans.add(dependentBean);\n               }\n            }\n            if (!actualDependentBeans.isEmpty()) {\n               throw new BeanCurrentlyInCreationException(beanName,\n                     \"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                     \"] in its raw version as part of a circular reference, but has eventually been \" +\n                     \"wrapped. This means that said other beans do not use the final version of the \" +\n                     \"bean. This is often the result of over-eager type matching - consider using \" +\n                     \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\");\n            }\n         }\n      }\n   }\n\n   // Register bean as disposable.\n   try {\n      registerDisposableBeanIfNecessary(beanName, bean, mbd);\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n   }\n\n   return exposedObject;\n}\n```\n到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。\n\n接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 \n\n注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。\n\n**创建 Bean 实例**\n我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。\n```bash\nprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {\n   // 确保已经加载了此 class\n   Class<?> beanClass = resolveBeanClass(mbd, beanName);\n\n   // 校验一下这个类的访问权限\n   if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {\n      throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n            \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName());\n   }\n\n   if (mbd.getFactoryMethodName() != null)  {\n      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean\n      return instantiateUsingFactoryMethod(beanName, mbd, args);\n   }\n\n   // 如果不是第一次创建，比如第二次创建 prototype bean。\n   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化\n   boolean resolved = false;\n   boolean autowireNecessary = false;\n   if (args == null) {\n      synchronized (mbd.constructorArgumentLock) {\n         if (mbd.resolvedConstructorOrFactoryMethod != null) {\n            resolved = true;\n            autowireNecessary = mbd.constructorArgumentsResolved;\n         }\n      }\n   }\n   if (resolved) {\n      if (autowireNecessary) {\n         // 构造函数依赖注入\n         return autowireConstructor(beanName, mbd, null, null);\n      }\n      else {\n         // 无参构造函数\n         return instantiateBean(beanName, mbd);\n      }\n   }\n\n   // 判断是否采用有参构造函数\n   Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n   if (ctors != null ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n      // 构造函数依赖注入\n      return autowireConstructor(beanName, mbd, ctors, args);\n   }\n\n   // 调用无参构造函数\n   return instantiateBean(beanName, mbd);\n}\n```\n\n挑个简单的**无参构造函数**构造实例来看看：\n```bash\nprotected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n   try {\n      Object beanInstance;\n      final BeanFactory parent = this;\n      if (System.getSecurityManager() != null) {\n         beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n\n               return getInstantiationStrategy().instantiate(mbd, beanName, parent);\n            }\n         }, getAccessControlContext());\n      }\n      else {\n         // 实例化\n         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);\n      }\n      // 包装一下，返回\n      BeanWrapper bw = new BeanWrapperImpl(beanInstance);\n      initBeanWrapper(bw);\n      return bw;\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n   }\n}\n```\n我们可以看到，关键的地方在于：\n```bash\nbeanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);\n```\n这里会进行实际的实例化过程，我们进去看看:\n\n// SimpleInstantiationStrategy 59\n```bash\n@Override\npublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {\n\n   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,\n   // 方法覆写 请参见附录\"方法注入\"中对 lookup-method 和 replaced-method 的介绍\n   if (bd.getMethodOverrides().isEmpty()) {\n      Constructor<?> constructorToUse;\n      synchronized (bd.constructorArgumentLock) {\n         constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;\n         if (constructorToUse == null) {\n            final Class<?> clazz = bd.getBeanClass();\n            if (clazz.isInterface()) {\n               throw new BeanInstantiationException(clazz, \"Specified class is an interface\");\n            }\n            try {\n               if (System.getSecurityManager() != null) {\n                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction<Constructor<?>>() {\n                     @Override\n                     public Constructor<?> run() throws Exception {\n                        return clazz.getDeclaredConstructor((Class[]) null);\n                     }\n                  });\n               }\n               else {\n                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);\n               }\n               bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n            }\n            catch (Throwable ex) {\n               throw new BeanInstantiationException(clazz, \"No default constructor found\", ex);\n            }\n         }\n      }\n      // 利用构造方法进行实例化\n      return BeanUtils.instantiateClass(constructorToUse);\n   }\n   else {\n      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。\n      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持\n      return instantiateWithMethodInjection(bd, beanName, owner);\n   }\n}\n```\n\n**bean 属性注入**\n看完了 createBeanInstance(...) 方法，我们来看看 populateBean(...) 方法，该方法负责进行属性设值，处理依赖。\n\n// AbstractAutowireCapableBeanFactory 1203\n```bash\nprotected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {\n   // bean 实例的所有属性都在这里了\n   PropertyValues pvs = mbd.getPropertyValues();\n\n   if (bw == null) {\n      if (!pvs.isEmpty()) {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n      }\n      else {\n         // Skip property population phase for null instance.\n         return;\n      }\n   }\n\n   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，\n   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，\n   // 我也没找到有实际的使用，所以我们暂且忽略这块吧\n   boolean continueWithPropertyPopulation = true;\n   if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n      for (BeanPostProcessor bp : getBeanPostProcessors()) {\n         if (bp instanceof InstantiationAwareBeanPostProcessor) {\n            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n            // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理\n            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n               continueWithPropertyPopulation = false;\n               break;\n            }\n         }\n      }\n   }\n\n   if (!continueWithPropertyPopulation) {\n      return;\n   }\n\n   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n         autowireByName(beanName, mbd, bw, newPvs);\n      }\n\n      // 通过类型装配。复杂一些\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n         autowireByType(beanName, mbd, bw, newPvs);\n      }\n\n      pvs = newPvs;\n   }\n\n   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n   if (hasInstAwareBpps || needsDepCheck) {\n      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n      if (hasInstAwareBpps) {\n         for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor\n               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究\n               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n               if (pvs == null) {\n                  return;\n               }\n            }\n         }\n      }\n      if (needsDepCheck) {\n         checkDependencies(beanName, mbd, filteredPds, pvs);\n      }\n   }\n   // 设置 bean 实例的属性值\n   applyPropertyValues(beanName, mbd, bw, pvs);\n}\n```\n\n**initializeBean**\n属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。\n```bash\nprotected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n   if (System.getSecurityManager() != null) {\n      AccessController.doPrivileged(new PrivilegedAction<Object>() {\n         @Override\n         public Object run() {\n            invokeAwareMethods(beanName, bean);\n            return null;\n         }\n      }, getAccessControlContext());\n   }\n   else {\n      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调\n      invokeAwareMethods(beanName, bean);\n   }\n\n   Object wrappedBean = bean;\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessBeforeInitialization 回调\n      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n   }\n\n   try {\n      // 处理 bean 中定义的 init-method，\n      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法\n      invokeInitMethods(beanName, wrappedBean, mbd);\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            (mbd != null ? mbd.getResourceDescription() : null),\n            beanName, \"Invocation of init method failed\", ex);\n   }\n\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessAfterInitialization 回调\n      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n   }\n   return wrappedBean;\n}\n```\n大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？\n\n---\n\n### 附录\n\n#### id和name\n每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。\n\n我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。\n```bash\nbeanFactory.getBean(\"beanName or alias\");\n```\n在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。\n```bash\n<bean id=\"messageService\" name=\"m1, m2, m3\" class=\"com.loonycoder.service.MessageServiceImpl\">\n```\n以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。\n```bash\n<bean name=\"m1, m2, m3\" class=\"com.loonycoder.service.MessageServiceImpl\" />\n```\n以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。\n```bash\n<bean class=\"com.loonycoder.service.MessageServiceImpl\">\n```\nbeanName 为：com.loonycoder.service.MessageServiceImpl#0，\n\n别名 1 个，为： com.loonycoder.service.MessageServiceImpl\n```bash\n<bean id=\"messageService\" class=\"com.loonycoder.service.MessageServiceImpl\">\n```\n以上配置的结果就是：beanName 为 messageService，没有别名。\n\n#### 配置是否允许 Bean 覆盖、是否允许循环依赖\n我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\n可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。\n\n循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。\n\n它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。\n\n添加这两个属性的作者 Juergen Hoeller 在这个 jira 的讨论中说明了怎么配置这两个属性。\n```bash\npublic class NoBeanOverridingContextLoader extends ContextLoader {\n\n  @Override\n  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) {\n    super.customizeContext(servletContext, applicationContext);\n    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;\n    arac.setAllowBeanDefinitionOverriding(false);\n  }\n}\n```\n```bash\npublic class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener {\n\n  @Override\n  protected ContextLoader createContextLoader() {\n    return new NoBeanOverridingContextLoader();\n  }\n\n}\n```\n```bash\n<listener>\n    <listener-class>com.loonycoder.MyContextLoaderListener</listener-class>  \n</listener>\n```\n\n#### profile\n我们可以把不同环境的配置分别配置到单独的文件中，举个例子：\n```bash\n<beans profile=\"development\"\n    xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n    xsi:schemaLocation=\"...\">\n\n    <jdbc:embedded-database id=\"dataSource\">\n        <jdbc:script location=\"classpath:com/loonycoder/config/sql/schema.sql\"/>\n        <jdbc:script location=\"classpath:com/oonycoder/config/sql/test-data.sql\"/>\n    </jdbc:embedded-database>\n</beans>\n```\n```bash\n<beans profile=\"production\"\n    xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xsi:schemaLocation=\"...\">\n\n    <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n</beans>\n```\n应该不必做过多解释了吧，看每个文件第一行的 profile=\"\"。\n\n当然，我们也可以在一个配置文件中使用：\n```bash\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xsi:schemaLocation=\"...\">\n\n    <beans profile=\"development\">\n        <jdbc:embedded-database id=\"dataSource\">\n            <jdbc:script location=\"classpath:com/loonycoder/config/sql/schema.sql\"/>\n            <jdbc:script location=\"classpath:com/loonycoder/config/sql/test-data.sql\"/>\n        </jdbc:embedded-database>\n    </beans>\n\n    <beans profile=\"production\">\n        <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n    </beans>\n</beans>\n```\n理解起来也很简单吧。\n\n接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？\n\nSpring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。\n\n最简单的方式莫过于在程序启动的时候指定：\n```bash\n-Dspring.profiles.active=\"profile1,profile2\"\n```\n> profile 可以激活多个\n\n当然，我们也可以通过代码的形式从 Environment 中设置 profile：\n```bash\nAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles(\"development\");\nctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\nctx.refresh(); // 重启\n```\n如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：\n```bash\njava -Dspring.profiles.active=prod -jar JavaDoop.jar\n```\n\n#### 工厂模式生成 Bean\n请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。\n\n设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。\n\n静态工厂：\n```bash\n<bean id=\"clientService\"\n    class=\"examples.ClientService\"\n    factory-method=\"createInstance\"/>\n```\n```bash\npublic class ClientService {\n    private static ClientService clientService = new ClientService();\n    private ClientService() {}\n\n    // 静态方法\n    public static ClientService createInstance() {\n        return clientService;\n    }\n}\n```\n实例工厂：\n```bash\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n    <!-- inject any dependencies required by this locator bean -->\n</bean>\n\n<bean id=\"clientService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createClientServiceInstance\"/>\n\n<bean id=\"accountService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createAccountServiceInstance\"/>\n```\n```bash\npublic class DefaultServiceLocator {\n\n    private static ClientService clientService = new ClientServiceImpl();\n\n    private static AccountService accountService = new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() {\n        return clientService;\n    }\n\n    public AccountService createAccountServiceInstance() {\n        return accountService;\n    }\n}\n```\n\n#### FactoryBean\nFactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。\n```bash\npublic interface FactoryBean<T> {\n    T getObject() throws Exception;\n    Class<T> getObjectType();\n    boolean isSingleton();\n}\n```\n```bash\npublic class Person { \n    private Car car ;\n    private void setCar(Car car){ this.car = car;  }  \n}\n```\n我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：\n```bash\npublic class MyCarFactoryBean implements FactoryBean<Car>{\n    private String make; \n    private int year ;\n\n    public void setMake(String m){ this.make =m ; }\n\n    public void setYear(int y){ this.year = y; }\n\n    public Car getObject(){ \n      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种\n      CarBuilder cb = CarBuilder.car();\n\n      if(year!=0) cb.setYear(this.year);\n      if(StringUtils.hasText(this.make)) cb.setMake( this.make ); \n      return cb.factory(); \n    }\n\n    public Class<Car> getObjectType() { return Car.class ; } \n\n    public boolean isSingleton() { return false; }\n}\n```\n我们看看装配的时候是怎么配置的：\n```bash\n<bean class = \"com.loonycoder.MyCarFactoryBean\" id = \"car\">\n  <property name = \"make\" value =\"Honda\"/>\n  <property name = \"year\" value =\"1994\"/>\n</bean>\n<bean class = \"com.loonycoder.Person\" id = \"josh\">\n  <property name = \"car\" ref = \"car\"/>\n</bean>\n```\n看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。\n\n说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？\n```bash\n@Configuration \npublic class CarConfiguration { \n\n    @Bean \n    public MyCarFactoryBean carFactoryBean(){ \n      MyCarFactoryBean cfb = new MyCarFactoryBean();\n      cfb.setMake(\"Honda\");\n      cfb.setYear(1994);\n      return cfb;\n    }\n\n    @Bean\n    public Person aPerson(){ \n    Person person = new Person();\n      // 注意这里的不同\n    person.setCar(carFactoryBean().getObject());\n    return person; \n    } \n}\n```\n这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。\n\n#### 初始化 Bean 的回调\n有以下四种方案：\n```bash\n<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/>\n```\n```bash\npublic class AnotherExampleBean implements InitializingBean {\n\n    public void afterPropertiesSet() {\n        // do some initialization work\n    }\n}\n```\n```bash\n@Bean(initMethod = \"init\")\npublic Foo foo() {\n    return new Foo();\n}\n```\n```bash\n@PostConstruct\npublic void init() {\n\n}\n```\n\n#### 销毁 Bean 的回调\n```bash\n<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/>\n```\n```bash\npublic class AnotherExampleBean implements DisposableBean {\n\n    public void destroy() {\n        // do some destruction work (like releasing pooled connections)\n    }\n}\n```\n```bash\n@Bean(destroyMethod = \"cleanup\")\npublic Bar bar() {\n    return new Bar();\n}\n```\n```bash\n@PreDestroy\npublic void cleanup() {\n\n}\n```\n\n#### ConversionService\n既然文中说到了这个，顺便提一下好了。\n\n最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。\n\n像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。\n```bash\n<bean id=\"conversionService\"\n  class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n  <property name=\"converters\">\n    <list>\n      <bean class=\"com.loonycoder.learning.utils.StringToEnumConverterFactory\"/>\n    </list>\n  </property>\n</bean>\n```\nConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。\n\n下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。\n\n来看一个很简单的例子，这样比什么都管用。\n```bash\npublic class StringToDateConverter implements Converter<String, Date> {\n\n    @Override\n    public Date convert(String source) {\n        try {\n            return DateUtils.parseDate(source, \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"HH:mm:ss\", \"HH:mm\");\n        } catch (ParseException e) {\n            return null;\n        }\n    }\n}\n```\n只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。\n\n#### Bean 继承\n在初始化 Bean 的地方，我们说过了这个：\n```bash\nRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n```\n这里涉及到的就是 <code>&lt;bean parent=\"\" /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。\n\n首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。\n\nSpring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。\n\n看如下一个例子:\n```bash\n<bean id=\"inheritedTestBean\" abstract=\"true\" class=\"org.springframework.beans.TestBean\">\n    <property name=\"name\" value=\"parent\"/>\n    <property name=\"age\" value=\"1\"/>\n</bean>\n\n<bean id=\"inheritsWithDifferentClass\" class=\"org.springframework.beans.DerivedTestBean\"\n        parent=\"inheritedTestBean\" init-method=\"initialize\">\n\n    <property name=\"name\" value=\"override\"/>\n</bean>\n```\nparent bean 设置了 <code>abstract=\"true\"</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。\n\nchild bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。\n\n当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。\n\n比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。\n```bash\n<bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\">\n    <property name=\"name\" value=\"parent\"/>\n    <property name=\"age\" value=\"1\"/>\n</bean>\n```\n\n#### 方法注入\n一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。\n\n但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。\n\n一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。\n\n另一种解决方案就是这里要介绍的通过使用 Lookup method。\n\n**lookup-method**\n我们来看一下 Spring Reference 中提供的一个例子：\n```bash\npackage fiona.apple;\n\n// no more Spring imports!\n\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        // grab a new instance of the appropriate Command interface\n        Command command = createCommand();\n        // set the state on the (hopefully brand new) Command instance\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    // okay... but where is the implementation of this method?\n    protected abstract Command createCommand();\n}\n```\nxml 配置 <code>&lt;lookup-method /&gt;</code>：\n```bash\n<!-- a stateful bean deployed as a prototype (non-singleton) -->\n<bean id=\"myCommand\" class=\"fiona.apple.AsyncCommand\" scope=\"prototype\">\n    <!-- inject dependencies here as required -->\n</bean>\n\n<!-- commandProcessor uses statefulCommandHelper -->\n<bean id=\"commandManager\" class=\"fiona.apple.CommandManager\">\n    <lookup-method name=\"createCommand\" bean=\"myCommand\"/>\n</bean>\n```\nSpring 采用 **CGLIB** 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。\n\nlookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：\n```bash\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup(\"myCommand\")\n    protected abstract Command createCommand();\n}\n```\n> 注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=\"com.loonycoder\" /&gt;</code>\n\n甚至，我们可以像下面这样：\n```bash\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup\n    protected abstract MyCommand createCommand();\n}\n```\n> 上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。\n\n**replaced-method**\n记住它的功能，就是替换掉 bean 中的一些方法。\n```bash\npublic class MyValueCalculator {\n\n    public String computeValue(String input) {\n        // some real code...\n    }\n\n    // some other methods...\n}\n```\n方法覆写，注意要实现 MethodReplacer 接口：\n```bash\npublic class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer {\n\n    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {\n        // get the input value, work with it, and return a computed result\n        String input = (String) args[0];\n        ...\n        return ...;\n    }\n}\n```\n配置也很简单：\n```bash\n<bean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\">\n    <!-- 定义 computeValue 这个方法要被替换掉 -->\n    <replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\">\n        <arg-type>String</arg-type>\n    </replaced-method>\n</bean>\n\n<bean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/>\n```\n> arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。\n\n#### BeanPostProcessor\n应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：\n```bash\npublic interface BeanPostProcessor {\n\n   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\n   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n\n}\n```\n看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。\n\n首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。\n\n我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。\n\n那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。\n\n最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？\n\n如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。\n\n首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。\n\n---\n\n### 总结\n按理说，总结应该写在附录前面，我就不讲究了。\n\n在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。\n\n本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。\n\n（全文完）\n","source":"_posts/Spring-2.md","raw":"---\ntitle: Spring框架——深入剖析核心IoC源码\ncategories:\n    - Java框架\n    \ndate: 2018-10-30\ntags:\n\t- 框架\n    - Spring\n---\n\n![Spring](/images/spring_logo.jpg)\n\n原文转自：<https://javadoop.com/post/spring-ioc>\n\n因为有幸看到这篇让我读了约三个半小时的文章，简直价值千金，所以稍作修改，以此记录。\n为了保持文章的严谨性，如有错误，望及时指出，十分希望听到读者的声音。\n\n---\n\n### 引言\n先看下最基本的启动 Spring 容器的例子：\n```bash\npublic static void main(String[] args) {\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:Application.xml\");\n}\n```\n以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。\n```bash\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-context</artifactId>\n  <version>4.3.11.RELEASE</version>\n</dependency>\n```\n> spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。\n\n多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。\n废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code>其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext 。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：\n![spring](/images/spring-ioc1.png)\n> 读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。\n当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。\n\n我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 \n**FileSystemXmlApplicationContext**和**AnnotationConfigApplicationContext**这两个类。\n\n1. **FileSystemXmlApplicationContext**的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。\n\n2. **AnnotationConfigApplicationContext**是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。\n\n不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。\n\n我们先来一个简单的例子来看看怎么实例化 ApplicationContext。\n\n首先，定义一个接口：\n```bash\npublic interface MessageService {\n    String getMessage();\n}\n```\n定义接口实现类：\n```bash\npublic class MessageServiceImpl implements MessageService {\n    public String getMessage() {\n        return \"hello world\";\n    }\n}\n```\n\n接下来，我们在 **resources** 目录新建一个配置文件，文件名随意，通常叫 Application.xml 或 Application-xxx.xml 就可以了：\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\">\n    <bean id=\"messageService\" class=\"com.loonycoder.service.MessageServiceImpl\"/>\n</beans>\n```\n这样，我们就可以跑起来了：\n```bash\npublic class App {\n    public static void main(String[] args) {\n        // 用我们的配置文件来启动一个 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:Application.xml\");\n\n        System.out.println(\"context 启动成功\");\n\n        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式\n        MessageService messageService = context.getBean(MessageService.class);\n        // 这句将输出: hello world\n        System.out.println(messageService.getMessage());\n    }\n}\n```\n以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。\n\n---\n\n### BeanFactory 简介\nBeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。\n\n初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：\n![spring](/images/spring-ioc2.png)\n我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。\n\n- ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。\n- ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。\n- AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。\n- ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。\n- 请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。\n然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。\n\n---\n\n### 启动过程分析\n下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。\n\n第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。\n\n```bash\npublic class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {\n  private Resource[] configResources;\n\n  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法\n  public ClassPathXmlApplicationContext(ApplicationContext parent) {\n    super(parent);\n  }\n  ...\n  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)\n      throws BeansException {\n\n    super(parent);\n    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)\n    setConfigLocations(configLocations);\n    if (refresh) {\n      refresh(); // 核心方法\n    }\n  }\n    ...\n}\n```\n\n接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。\n\n往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。\n```bash\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n\n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n\n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset 'active' flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring's core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n\n下面，我们开始一步步来肢解这个 refresh() 方法。\n\n---\n\n#### 创建 Bean 容器，加载并注册 Bean\n我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。\n\n注意，**这个方法是全文最重要的部分之一**，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。\n\n当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。\n\n// AbstractApplicationContext.java\n```bash\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等\n   refreshBeanFactory();\n\n   // 返回刚刚创建的 BeanFactory\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n   }\n   return beanFactory;\n}\n```\n// AbstractRefreshableApplicationContext.java 120\n```bash\n@Override\nprotected final void refreshBeanFactory() throws BeansException {\n   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory\n   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前\n   // ApplicationContext 是否有 BeanFactory\n   if (hasBeanFactory()) {\n      destroyBeans();\n      closeBeanFactory();\n   }\n   try {\n      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。\n      DefaultListableBeanFactory beanFactory = createBeanFactory();\n      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到\n      beanFactory.setSerializationId(getId());\n\n      // 下面这两个方法很重要，别跟丢了，具体细节之后说\n      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用\n      customizeBeanFactory(beanFactory);\n\n      // 加载 Bean 到 BeanFactory 中\n      loadBeanDefinitions(beanFactory);\n      synchronized (this.beanFactoryMonitor) {\n         this.beanFactory = beanFactory;\n      }\n   }\n   catch (IOException ex) {\n      throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex);\n   }\n}\n```\n\n> 看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。\n\n我们说说为什么选择实例化 **DefaultListableBeanFactory** ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：\n![spring](/images/spring-ioc2.png)\n\n我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。\n\n> 如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？\n之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。\n那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。\n\n在继续往下之前，我们需要先了解 BeanDefinition。**我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？**\n\n这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。\n\n所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。\n> BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。\n\n**BeanDefinition 接口定义**\n我们来看下 BeanDefinition 的接口定义：\n```bash\npublic interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {\n\n   // 我们可以看到，默认只提供 sington 和 prototype 两种，\n   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，\n   // 不过，它们属于基于 web 的扩展。\n   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;\n   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;\n\n   // 比较不重要，直接跳过吧\n   int ROLE_APPLICATION = 0;\n   int ROLE_SUPPORT = 1;\n   int ROLE_INFRASTRUCTURE = 2;\n\n   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍\n   // 一句话就是：继承父 Bean 的配置信息而已\n   void setParentName(String parentName);\n\n   // 获取父 Bean\n   String getParentName();\n\n   // 设置 Bean 的类名称，将来是要通过反射来生成实例的\n   void setBeanClassName(String beanClassName);\n\n   // 获取 Bean 的类名称\n   String getBeanClassName();\n\n\n   // 设置 bean 的 scope\n   void setScope(String scope);\n\n   String getScope();\n\n   // 设置是否懒加载\n   void setLazyInit(boolean lazyInit);\n\n   boolean isLazyInit();\n\n   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，\n   // 是 depends-on=\"\" 属性设置的值。\n   void setDependsOn(String... dependsOn);\n\n   // 返回该 Bean 的所有依赖\n   String[] getDependsOn();\n\n   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，\n   // 如果根据名称注入，即使这边设置了 false，也是可以的\n   void setAutowireCandidate(boolean autowireCandidate);\n\n   // 该 Bean 是否可以注入到其他 Bean 中\n   boolean isAutowireCandidate();\n\n   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean\n   void setPrimary(boolean primary);\n\n   // 是否是 primary 的\n   boolean isPrimary();\n\n   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录\n   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的\n   void setFactoryBeanName(String factoryBeanName);\n   // 获取工厂名称\n   String getFactoryBeanName();\n   // 指定工厂类中的 工厂方法名称\n   void setFactoryMethodName(String factoryMethodName);\n   // 获取工厂类中的 工厂方法名称\n   String getFactoryMethodName();\n\n   // 构造器参数\n   ConstructorArgumentValues getConstructorArgumentValues();\n\n   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到\n   MutablePropertyValues getPropertyValues();\n\n   // 是否 singleton\n   boolean isSingleton();\n\n   // 是否 prototype\n   boolean isPrototype();\n\n   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，\n   // 常用于作为 父bean 用于继承，其实也很少用......\n   boolean isAbstract();\n\n   int getRole();\n   String getDescription();\n   String getResourceDescription();\n   BeanDefinition getOriginatingBeanDefinition();\n}\n```\n\n> 这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。\n这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。\n\n有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：\n```bash\ncustomizeBeanFactory(beanFactory);\nloadBeanDefinitions(beanFactory);\n```\n\n虽然只有两个方法，但路还很长啊。。。\n\n**customizeBeanFactory**\n\ncustomizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。\n```bash\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n   if (this.allowBeanDefinitionOverriding != null) {\n      // 是否允许 Bean 定义覆盖\n      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n   }\n   if (this.allowCircularReferences != null) {\n      // 是否允许 Bean 间的循环依赖\n      beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n   }\n}\n```\nBeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\n循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。\n\n默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。\n\n至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。\n\n之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。\n\n**加载Bean:loadBeanDefinitions**\n\n接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。\n\n读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。\n\n// AbstractXmlApplicationContext.java 80\n```bash\n/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/\n@Override\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader\n   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\n   // Configure the bean definition reader with this context's\n   // resource loading environment.\n   beanDefinitionReader.setEnvironment(this.getEnvironment());\n   beanDefinitionReader.setResourceLoader(this);\n   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，\n   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧\n   initBeanDefinitionReader(beanDefinitionReader);\n   // 重点来了，继续往下\n   loadBeanDefinitions(beanDefinitionReader);\n}\n```\n现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。\n\n// AbstractXmlApplicationContext.java 120\n```bash\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n   Resource[] configResources = getConfigResources();\n   if (configResources != null) {\n      // 往下看\n      reader.loadBeanDefinitions(configResources);\n   }\n   String[] configLocations = getConfigLocations();\n   if (configLocations != null) {\n      // 2\n      reader.loadBeanDefinitions(configLocations);\n   }\n}\n\n// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里\n@Override\npublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {\n   Assert.notNull(resources, \"Resource array must not be null\");\n   int counter = 0;\n   // 注意这里是个 for 循环，也就是每个文件是一个 resource\n   for (Resource resource : resources) {\n      // 继续往下看\n      counter += loadBeanDefinitions(resource);\n   }\n   // 最后返回 counter，表示总共加载了多少的 BeanDefinition\n   return counter;\n}\n\n// XmlBeanDefinitionReader 303\n@Override\npublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n   return loadBeanDefinitions(new EncodedResource(resource));\n}\n\n// XmlBeanDefinitionReader 314\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n   Assert.notNull(encodedResource, \"EncodedResource must not be null\");\n   if (logger.isInfoEnabled()) {\n      logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource());\n   }\n   // 用一个 ThreadLocal 来存放配置文件资源\n   Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();\n   if (currentResources == null) {\n      currentResources = new HashSet<EncodedResource>(4);\n      this.resourcesCurrentlyBeingLoaded.set(currentResources);\n   }\n   if (!currentResources.add(encodedResource)) {\n      throw new BeanDefinitionStoreException(\n            \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\");\n   }\n   try {\n      InputStream inputStream = encodedResource.getResource().getInputStream();\n      try {\n         InputSource inputSource = new InputSource(inputStream);\n         if (encodedResource.getEncoding() != null) {\n            inputSource.setEncoding(encodedResource.getEncoding());\n         }\n         // 核心部分是这里，往下面看\n         return doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n      }\n      finally {\n         inputStream.close();\n      }\n   }\n   catch (IOException ex) {\n      throw new BeanDefinitionStoreException(\n            \"IOException parsing XML document from \" + encodedResource.getResource(), ex);\n   }\n   finally {\n      currentResources.remove(encodedResource);\n      if (currentResources.isEmpty()) {\n         this.resourcesCurrentlyBeingLoaded.remove();\n      }\n   }\n}\n\n// 还在这个文件中，第 388 行\nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n      throws BeanDefinitionStoreException {\n   try {\n      // 这里就不看了，将 xml 文件转换为 Document 对象\n      Document doc = doLoadDocument(inputSource, resource);\n      // 继续\n      return registerBeanDefinitions(doc, resource);\n   }\n   catch (...\n}\n// 还在这个文件中，第 505 行\n// 返回值：返回从当前配置文件加载了多少数量的 Bean\npublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n   int countBefore = getRegistry().getBeanDefinitionCount();\n   // 这里\n   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n   return getRegistry().getBeanDefinitionCount() - countBefore;\n}\n// DefaultBeanDefinitionDocumentReader 90\n@Override\npublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n   this.readerContext = readerContext;\n   logger.debug(\"Loading bean definitions\");\n   Element root = doc.getDocumentElement();\n   // 从 xml 根节点开始解析文件\n   doRegisterBeanDefinitions(root);\n}  \n```\n\n经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：\n\n**doRegisterBeanDefinitions：**\n```bash\n// DefaultBeanDefinitionDocumentReader 116\nprotected void doRegisterBeanDefinitions(Element root) {\n   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，\n   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，\n   // 因为 <beans /> 内部是可以定义 <beans /> 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 <beans /> 节点，从源码分析的角度，我们当做根节点就好了\n   BeanDefinitionParserDelegate parent = this.delegate;\n   this.delegate = createDelegate(getReaderContext(), root, parent);\n\n   if (this.delegate.isDefaultNamespace(root)) {\n      // 这块说的是根节点 <beans ... profile=\"dev\" /> 中的 profile 是否是当前环境需要的，\n      // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 <beans /> 解析\n      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区\n      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n      if (StringUtils.hasText(profileSpec)) {\n         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n         if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n            if (logger.isInfoEnabled()) {\n               logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec +\n                     \"] not matching: \" + getReaderContext().getResource());\n            }\n            return;\n         }\n      }\n   }\n\n   preProcessXml(root); // 钩子\n   // 往下看\n   parseBeanDefinitions(root, this.delegate);\n   postProcessXml(root); // 钩子\n\n   this.delegate = parent;\n}\n```\n\npreProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。\n\n这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。\n\n接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :\n\n```bash\n// default namespace 涉及到的就四个标签 <import />、<alias />、<bean /> 和 <beans />，\n// 其他的属于 custom 的\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n   if (delegate.isDefaultNamespace(root)) {\n      NodeList nl = root.getChildNodes();\n      for (int i = 0; i < nl.getLength(); i++) {\n         Node node = nl.item(i);\n         if (node instanceof Element) {\n            Element ele = (Element) node;\n            if (delegate.isDefaultNamespace(ele)) {\n               // 解析 default namespace 下面的几个元素\n               parseDefaultElement(ele, delegate);\n            }\n            else {\n               // 解析其他 namespace 的元素\n               delegate.parseCustomElement(ele);\n            }\n         }\n      }\n   }\n   else {\n      delegate.parseCustomElement(root);\n   }\n}\n```\n\n从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。\n\nparseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt;、&lt;beans /&gt;</code>这几个。\n\n> 这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的：\n>```bash\nhttp://www.springframework.org/schema/beans\n```\n> 又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 xmlns 就是咯。\n> ```bash\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"\n            http://www.springframework.org/schema/beans\n          http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-autowire=\"byName\">\n```\n> 而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code> &lt;mvc /&gt;、&lt;task /&gt;、&lt;context /&gt;、&lt;aop /&gt;</code>等。\n这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。\n> 假如读者想分析 <code>&lt;context:property-placeholder location=\"classpath:xx.properties\" /&gt;</code>的实现原理，就应该到 ContextNamespaceHandler 中找答案。\n> ```bash\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:context=\"http://www.springframework.org/schema/context\"\n      xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n      xsi:schemaLocation=\"\n           http://www.springframework.org/schema/beans \n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/context\n           http://www.springframework.org/schema/context/spring-context.xsd\n           http://www.springframework.org/schema/mvc   \n           http://www.springframework.org/schema/mvc/spring-mvc.xsd  \n       \"\n      default-autowire=\"byName\">\n    </bean>\n```\n同理，以后你要是碰到 <code>&lt;<dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。\n回过神来，看看处理 default 标签的方法：\n```bash\nprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n      // 处理 <import /> 标签\n      importBeanDefinitionResource(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n      // 处理 <alias /> 标签定义\n      // <alias name=\"fromName\" alias=\"toName\"/>\n      processAliasRegistration(ele);\n   }\n   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n      // 处理 <bean /> 标签定义，这也算是我们的重点吧\n      processBeanDefinition(ele, delegate);\n   }\n   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n      // 如果碰到的是嵌套的 <beans /> 标签，需要递归\n      doRegisterBeanDefinitions(ele);\n   }\n}\n```\n如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <bean /> 标签出来说。\n\n**processBeanDefinition 解析 bean 标签**\n下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：\n\n// DefaultBeanDefinitionDocumentReader 298\n```bash\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 <bean /> 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\n   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的\n\n   if (bdHolder != null) {\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // Register the final decorated instance.\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(\"Failed to register bean definition with name '\" +\n               bdHolder.getBeanName() + \"'\", ele, ex);\n      }\n      // Send registration event.\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}\n```\n继续往下看怎么解析之前，我们先看下 <code>&lt;bean /&gt;</code> 标签中可以定义哪些属性：\n\nProperty||\n:-:|:-:|\nclass|类的全限定名\nname|可指定 id、name(用逗号、分号、空格分隔)\nscope|作用域\nconstructor arguments|指定构造参数\nproperties|设置属性的值\nautowiring mode|no(默认值)、byName、byType、 constructor\nlazy-initialization mode|是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)\ninitialization method|bean 属性设置完成后，会调用这个方法\ndestruction method|bean 销毁后的回调方法 \n\n\n上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。\n\n简单地说就是像下面这样子：\n```bash\n<bean id=\"exampleBean\" name=\"name1, name2, name3\" class=\"com.loonycoder.ExampleBean\"\n      scope=\"singleton\" lazy-init=\"true\" init-method=\"init\" destroy-method=\"cleanup\">\n\n    <!-- 可以用下面三种形式指定构造参数 -->\n    <constructor-arg type=\"int\" value=\"7500000\"/>\n    <constructor-arg name=\"years\" value=\"7500000\"/>\n    <constructor-arg index=\"0\" value=\"7500000\"/>\n\n    <!-- property 的几种情况 -->\n    <property name=\"beanOne\">\n        <ref bean=\"anotherExampleBean\"/>\n    </property>\n    <property name=\"beanTwo\" ref=\"yetAnotherBean\"/>\n    <property name=\"integerProperty\" value=\"1\"/>\n</bean>\n```\n当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;、&lt;replaced-method /&gt;、&lt;meta /&gt;、&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。\n\n有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。\n\n// BeanDefinitionParserDelegate 428\n```bash\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {\n    return parseBeanDefinitionElement(ele, null);\n}\n\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {\n   String id = ele.getAttribute(ID_ATTRIBUTE);\n   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n   List<String> aliases = new ArrayList<String>();\n\n   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，\n   // 当然，如果你不定义 name 属性的话，就是空的了\n   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了\n   if (StringUtils.hasLength(nameAttr)) {\n      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n      aliases.addAll(Arrays.asList(nameArr));\n   }\n\n   String beanName = id;\n   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName\n   if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n      beanName = aliases.remove(0);\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"No XML 'id' specified - using '\" + beanName +\n               \"' as bean name and \" + aliases + \" as aliases\");\n      }\n   }\n\n   if (containingBean == null) {\n      checkNameUniqueness(beanName, aliases, ele);\n   }\n\n   // 根据 <bean ...>...</bean> 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,\n   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。\n   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n\n   // 到这里，整个 <bean /> 标签就算解析结束了，一个 BeanDefinition 就形成了。\n   if (beanDefinition != null) {\n      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生\n      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要\n      if (!StringUtils.hasText(beanName)) {\n         try {\n            if (containingBean != null) {// 按照我们的思路，这里 containingBean 是 null 的\n               beanName = BeanDefinitionReaderUtils.generateBeanName(\n                     beanDefinition, this.readerContext.getRegistry(), true);\n            }\n            else {\n               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：\n               //   1. beanName 为：com.loonycoder.service.MessageServiceImpl#0\n               //   2. beanClassName 为：com.loonycoder.service.MessageServiceImpl\n\n               beanName = this.readerContext.generateBeanName(beanDefinition);\n\n               String beanClassName = beanDefinition.getBeanClassName();\n               if (beanClassName != null &&\n                     beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&\n                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n                  // 把 beanClassName 设置为 Bean 的别名\n                  aliases.add(beanClassName);\n               }\n            }\n            if (logger.isDebugEnabled()) {\n               logger.debug(\"Neither XML 'id' nor 'name' specified - \" +\n                     \"using generated bean name [\" + beanName + \"]\");\n            }\n         }\n         catch (Exception ex) {\n            error(ex.getMessage(), ele);\n            return null;\n         }\n      }\n      String[] aliasesArray = StringUtils.toStringArray(aliases);\n      // 返回 BeanDefinitionHolder\n      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n   }\n\n   return null;\n}\n```\n然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：\n```bash\npublic AbstractBeanDefinition parseBeanDefinitionElement(\n      Element ele, String beanName, BeanDefinition containingBean) {\n\n   this.parseState.push(new BeanEntry(beanName));\n\n   String className = null;\n   if (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n   }\n\n   try {\n      String parent = null;\n      if (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n         parent = ele.getAttribute(PARENT_ATTRIBUTE);\n      }\n      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了\n      AbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中\n      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n      /**\n       * 下面的一堆是解析 <bean>......</bean> 内部的子元素，\n       * 解析出来以后的信息都放到 bd 的属性中\n       */\n\n      // 解析 <meta />\n      parseMetaElements(ele, bd);\n      // 解析 <lookup-method />\n      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n      // 解析 <replaced-method />\n      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n    // 解析 <constructor-arg />\n      parseConstructorArgElements(ele, bd);\n      // 解析 <property />\n      parsePropertyElements(ele, bd);\n      // 解析 <qualifier />\n      parseQualifierElements(ele, bd);\n\n      bd.setResource(this.readerContext.getResource());\n      bd.setSource(extractSource(ele));\n\n      return bd;\n   }\n   catch (ClassNotFoundException ex) {\n      error(\"Bean class [\" + className + \"] not found\", ele, ex);\n   }\n   catch (NoClassDefFoundError err) {\n      error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n   }\n   catch (Throwable ex) {\n      error(\"Unexpected failure during bean definition parsing\", ele, ex);\n   }\n   finally {\n      this.parseState.pop();\n   }\n\n   return null;\n}\n```\n到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。\n\n我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:\n```bash\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   // 将 <bean /> 节点转换为 BeanDefinitionHolder，就是上面说的一堆\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n   if (bdHolder != null) {\n      // 如果有自定义属性的话，进行相应的解析，先忽略\n      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n      try {\n         // 我们把这步叫做 注册Bean 吧\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n      }\n      catch (BeanDefinitionStoreException ex) {\n         getReaderContext().error(\"Failed to register bean definition with name '\" +\n               bdHolder.getBeanName() + \"'\", ele, ex);\n      }\n      // 注册完成后，发送事件，本文不展开说这个\n      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n   }\n}\n```\n大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：\n```bash\npublic class BeanDefinitionHolder implements BeanMetadataElement {\n\n  private final BeanDefinition beanDefinition;\n\n  private final String beanName;\n\n  private final String[] aliases;\n...\n```\n然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。\n\n下面，我们开始说说注册 Bean 吧。\n\n**注册 Bean**\n// BeanDefinitionReaderUtils 143\n```bash\npublic static void registerBeanDefinition(\n      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n      throws BeanDefinitionStoreException {\n\n   String beanName = definitionHolder.getBeanName();\n   // 注册这个 Bean\n   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n\n   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了\n   String[] aliases = definitionHolder.getAliases();\n   if (aliases != null) {\n      for (String alias : aliases) {\n         // alias -> beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，\n         // 获取的时候，会先将 alias 转换为 beanName，然后再查找\n         registry.registerAlias(beanName, alias);\n      }\n   }\n}\n```\n别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。\n\n// DefaultListableBeanFactory 793\n```bash\n@Override\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n      throws BeanDefinitionStoreException {\n\n   Assert.hasText(beanName, \"Bean name must not be empty\");\n   Assert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n   if (beanDefinition instanceof AbstractBeanDefinition) {\n      try {\n         ((AbstractBeanDefinition) beanDefinition).validate();\n      }\n      catch (BeanDefinitionValidationException ex) {\n         throw new BeanDefinitionStoreException(...);\n      }\n   }\n\n   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding\n   BeanDefinition oldBeanDefinition;\n\n   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中\n   oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n\n   // 处理重复名称的 Bean 定义的情况\n   if (oldBeanDefinition != null) {\n      if (!isAllowBeanDefinitionOverriding()) {\n         // 如果不允许覆盖的话，抛异常\n         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...\n      }\n      else if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {\n         // log...用框架定义的 Bean 覆盖用户自定义的 Bean \n      }\n      else if (!beanDefinition.equals(oldBeanDefinition)) {\n         // log...用新的 Bean 覆盖旧的 Bean\n      }\n      else {\n         // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean\n      }\n      // 覆盖\n      this.beanDefinitionMap.put(beanName, beanDefinition);\n   }\n   else {\n      // 判断是否已经有其他的 Bean 开始初始化了.\n      // 注意，\"注册Bean\" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，\n      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans\n      if (hasBeanCreationStarted()) {\n         // Cannot modify startup-time collection elements anymore (for stable iteration)\n         synchronized (this.beanDefinitionMap) {\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n            List<String> updatedDefinitions = new ArrayList<String>(this.beanDefinitionNames.size() + 1);\n            updatedDefinitions.addAll(this.beanDefinitionNames);\n            updatedDefinitions.add(beanName);\n            this.beanDefinitionNames = updatedDefinitions;\n            if (this.manualSingletonNames.contains(beanName)) {\n               Set<String> updatedSingletons = new LinkedHashSet<String>(this.manualSingletonNames);\n               updatedSingletons.remove(beanName);\n               this.manualSingletonNames = updatedSingletons;\n            }\n         }\n      }\n      else {\n         // 最正常的应该是进到这个分支。\n\n         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition\n         this.beanDefinitionMap.put(beanName, beanDefinition);\n         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字\n         this.beanDefinitionNames.add(beanName);\n         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，\n         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的\n         // 手动指的是通过调用以下方法注册的 bean ：\n         //     registerSingleton(String beanName, Object singletonObject)\n         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面\"手动\"注册一些 Bean，\n         // 如 \"environment\"、\"systemProperties\" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的\n         this.manualSingletonNames.remove(beanName);\n      }\n      // 这个不重要，在预初始化的时候会用到，不必管它。\n      this.frozenBeanDefinitionNames = null;\n   }\n\n   if (oldBeanDefinition != null || containsSingleton(beanName)) {\n      resetBeanDefinition(beanName);\n   }\n}\n```\n总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。\n\n--------- 分割线 ---------\n\n到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。\n\n#### Bean 容器实例化完成后\n说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。\n\n考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。\n\n```bash\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛\n   synchronized (this.startupShutdownMonitor) {\n\n      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符\n      prepareRefresh();\n\n      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，\n      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，\n      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map)\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean\n      // 这块待会会展开说\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，\n         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】\n\n         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化\n         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事\n         postProcessBeanFactory(beanFactory);\n         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法\n         invokeBeanFactoryPostProcessors(beanFactory);          \n\n\n\n         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别\n         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization\n         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机\n         registerBeanPostProcessors(beanFactory);\n\n         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了\n         initMessageSource();\n\n         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了\n         initApplicationEventMulticaster();\n\n         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说\n         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）\n         onRefresh();\n\n         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过\n         registerListeners();\n\n         // 重点，重点，重点\n         // 初始化所有的 singleton beans\n         //（lazy-init 的除外）\n         finishBeanFactoryInitialization(beanFactory);\n\n         // 最后，广播事件，ApplicationContext 初始化完成，不展开\n         finishRefresh();\n      }\n\n      catch (BeansException ex) {\n         if (logger.isWarnEnabled()) {\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         }\n\n         // Destroy already created singletons to avoid dangling resources.\n         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n         destroyBeans();\n\n         // Reset 'active' flag.\n         cancelRefresh(ex);\n\n         // 把异常往外抛\n         throw ex;\n      }\n\n      finally {\n         // Reset common introspection caches in Spring's core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      }\n   }\n}\n```\n\n#### 准备 Bean 容器: prepareBeanFactory\n之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会\"手动\"注册一些特殊的 bean。\n\n这里简单介绍下 prepareBeanFactory(factory) 方法：\n```bash\n/**\n * Configure the factory's standard context characteristics,\n * such as the context's ClassLoader and post-processors.\n * @param beanFactory the BeanFactory to configure\n */\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，\n   // 这里设置为加载当前 ApplicationContext 类的类加载器\n   beanFactory.setBeanClassLoader(getClassLoader());\n\n   // 设置 BeanExpressionResolver\n   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n   // \n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n   // 添加一个 BeanPostProcessor，这个 processor 比较简单：\n   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，\n   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware\n   // 注意：它不仅仅回调 ApplicationContextAware，\n   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\n   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，\n   // Spring 会通过其他方式来处理这些依赖。\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\n   /**\n    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，\n    * 之前我们说过，\"当前 ApplicationContext 持有一个 BeanFactory\"，这里解释了第一行。\n    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource\n    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext\n    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean\n    */\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，\n   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器\n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它\n   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，\n   \n   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      // Set a temporary ClassLoader for type matching.\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   }\n\n   /**\n    * 从下面几行代码我们可以知道，Spring 往往很 \"智能\" 就是因为它会帮我们默认注册一些有用的 bean，\n    * 我们也可以选择覆盖\n    */\n\n   // 如果没有定义 \"environment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n   }\n   // 如果没有定义 \"systemProperties\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n   }\n   // 如果没有定义 \"systemEnvironment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个\n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n   }\n}\n```\n\n在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。\n\n#### 初始化所有的 singleton beans\n我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。\n\n注意，后面的描述中，我都会使用**初始化**或**预初始化**来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。\n\n我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。\n\n剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。\n// AbstractApplicationContext.java 834\n```bash\n// 初始化剩余的 singleton beans\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n\n   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了\n   // 什么，看代码这里没有初始化 Bean 啊！\n   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧\n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n      beanFactory.setConversionService(\n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n   }\n\n   // Register a default embedded value resolver if no bean post-processor\n   // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n   // at this point, primarily for resolution in annotation attribute values.\n   if (!beanFactory.hasEmbeddedValueResolver()) {\n      beanFactory.addEmbeddedValueResolver(new StringValueResolver() {\n         @Override\n         public String resolveStringValue(String strVal) {\n            return getEnvironment().resolvePlaceholders(strVal);\n         }\n      });\n   }\n\n   // 先初始化 LoadTimeWeaverAware 类型的 Bean\n   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧\n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n   for (String weaverAwareName : weaverAwareNames) {\n      getBean(weaverAwareName);\n   }\n\n   // Stop using the temporary ClassLoader for type matching.\n   beanFactory.setTempClassLoader(null);\n\n   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，\n   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。\n   beanFactory.freezeConfiguration();\n\n   // 开始初始化\n   beanFactory.preInstantiateSingletons();\n}\n```\n从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。\n\n**preInstantiateSingletons**\n// DefaultListableBeanFactory 728\n```bash\n@Override\npublic void preInstantiateSingletons() throws BeansException {\n   if (this.logger.isDebugEnabled()) {\n      this.logger.debug(\"Pre-instantiating singletons in \" + this);\n   }\n   // this.beanDefinitionNames 保存了所有的 beanNames\n   List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);\n\n   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作\n   for (String beanName : beanNames) {\n\n      // 合并父 Bean 中的配置，注意 <bean id=\"\" class=\"\" parent=\"\" /> 中的 parent，用的不多吧，\n      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 \"Bean 继承\"，不了解的请到附录中看一下\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\n      // 非抽象、非懒加载的 singletons。如果配置了 'abstract = true'，那是不需要初始化的\n      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)\n         if (isFactoryBean(beanName)) {\n            // FactoryBean 的话，在 beanName 前面加上 ‘&’ 符号。再调用 getBean，getBean 方法别急\n            final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);\n            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过\n            boolean isEagerInit;\n            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n               isEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n                  @Override\n                  public Boolean run() {\n                     return ((SmartFactoryBean<?>) factory).isEagerInit();\n                  }\n               }, getAccessControlContext());\n            }\n            else {\n               isEagerInit = (factory instanceof SmartFactoryBean &&\n                     ((SmartFactoryBean<?>) factory).isEagerInit());\n            }\n            if (isEagerInit) {\n\n               getBean(beanName);\n            }\n         }\n         else {\n            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了\n            getBean(beanName);\n         }\n      }\n   }\n\n   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化\n   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略\n   for (String beanName : beanNames) {\n      Object singletonInstance = getSingleton(beanName);\n      if (singletonInstance instanceof SmartInitializingSingleton) {\n         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n         if (System.getSecurityManager() != null) {\n            AccessController.doPrivileged(new PrivilegedAction<Object>() {\n               @Override\n               public Object run() {\n                  smartSingleton.afterSingletonsInstantiated();\n                  return null;\n               }\n            }, getAccessControlContext());\n         }\n         else {\n            smartSingleton.afterSingletonsInstantiated();\n         }\n      }\n   }\n}\n```\n接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。\n\n**getBean**\n在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。\n\n// AbstractBeanFactory 196\n```bash\n@Override\npublic Object getBean(String name) throws BeansException {\n   return doGetBean(name, null, null, false);\n}\n\n// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，\n// 已经初始化过了就从容器中直接返回，否则就先初始化再返回\n@SuppressWarnings(\"unchecked\")\nprotected <T> T doGetBean(\n      final String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly)\n      throws BeansException {\n   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&’)，\n   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的\n   final String beanName = transformedBeanName(name);\n\n   // 注意跟着这个，这个是返回值\n   Object bean; \n\n   // 检查下是不是已经创建过了\n   Object sharedInstance = getSingleton(beanName);\n\n   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，\n   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean\n   if (sharedInstance != null && args == null) {\n      if (logger.isDebugEnabled()) {\n         if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.debug(\"...\");\n         }\n         else {\n            logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n         }\n      }\n      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，\n      // 如果是 FactoryBean 的话，返回它创建的那个实例对象\n      // (FactoryBean 知识，读者若不清楚请移步附录)\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n   }\n\n   else {\n      if (isPrototypeCurrentlyInCreation(beanName)) {\n         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，\n         // 往往是因为陷入了循环引用\n         throw new BeanCurrentlyInCreationException(beanName);\n      }\n\n      // 检查一下这个 BeanDefinition 在容器中是否存在\n      BeanFactory parentBeanFactory = getParentBeanFactory();\n      if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有\n         String nameToLookup = originalBeanName(name);\n         if (args != null) {\n            // 返回父容器的查询结果\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n         }\n         else {\n            // No args -> delegate to standard getBean method.\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n         }\n      }\n\n      if (!typeCheckOnly) {\n         // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。\n         markBeanAsCreated(beanName);\n      }\n\n      /*\n       * 稍稍总结一下：\n       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；\n       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。\n       */\n      try {\n         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n         checkMergedBeanDefinition(mbd, beanName, args);\n\n         // 先初始化依赖的所有 Bean，这个很好理解。\n         // 注意，这里的依赖指的是 depends-on 中定义的依赖\n         String[] dependsOn = mbd.getDependsOn();\n         if (dependsOn != null) {\n            for (String dep : dependsOn) {\n               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了\n               if (isDependent(beanName, dep)) {\n                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"'Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n               }\n               // 注册一下依赖关系\n               registerDependentBean(dep, beanName);\n               // 先初始化被依赖项\n               getBean(dep);\n            }\n         }\n\n         // 如果是 singleton scope 的，创建 singleton 的实例\n         if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {\n               @Override\n               public Object getObject() throws BeansException {\n                  try {\n                     // 执行创建 Bean，详情后面再说\n                     return createBean(beanName, mbd, args);\n                  }\n                  catch (BeansException ex) {\n                     destroySingleton(beanName);\n                     throw ex;\n                  }\n               }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n         }\n\n         // 如果是 prototype scope 的，创建 prototype 的实例\n         else if (mbd.isPrototype()) {\n            // It’s a prototype -> create a new instance.\n            Object prototypeInstance = null;\n            try {\n               beforePrototypeCreation(beanName);\n               // 执行创建 Bean\n               prototypeInstance = createBean(beanName, mbd, args);\n            }\n            finally {\n               afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n         }\n\n         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理\n         else {\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n               throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n            }\n            try {\n               Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n                  @Override\n                  public Object getObject() throws BeansException {\n                     beforePrototypeCreation(beanName);\n                     try {\n                        // 执行创建 Bean\n                        return createBean(beanName, mbd, args);\n                     }\n                     finally {\n                        afterPrototypeCreation(beanName);\n                     }\n                  }\n               });\n               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            }\n            catch (IllegalStateException ex) {\n               throw new BeanCreationException(beanName,\n                     \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" +\n                     \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n                     ex);\n            }\n         }\n      }\n      catch (BeansException ex) {\n         cleanupAfterBeanCreationFailure(beanName);\n         throw ex;\n      }\n   }\n\n   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了\n   if (requiredType != null && bean != null && !requiredType.isInstance(bean)) {\n      try {\n         return getTypeConverter().convertIfNecessary(bean, requiredType);\n      }\n      catch (TypeMismatchException ex) {\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" +\n                  ClassUtils.getQualifiedName(requiredType) + \"'\", ex);\n         }\n         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n      }\n   }\n   return (T) bean;\n}\n```\n大家应该也猜到了，接下来当然是分析 createBean 方法：\n```bash\nprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;\n```\n第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。\n\n这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。\n\n主要是为了以下场景，采用 @Autowired 注解注入属性值：\n```bash\npublic class MessageServiceImpl implements MessageService {\n    @Autowired\n    private UserService userService;\n\n    public String getMessage() {\n        return userService.getMessage();\n    }\n}\n```\n```bash\n<bean id=\"messageService\" class=\"com.loonycoder.service.MessageServiceImpl\" />\n```\n以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。\n\n好了，读者要知道这么回事就可以了，继续向前。\n\n// AbstractAutowireCapableBeanFactory 447\n```bash\n/**\n * Central method of this class: creates a bean instance,\n * populates the bean instance, applies post-processors, etc.\n * @see #doCreateBean\n */\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating instance of bean '\" + beanName + \"'\");\n   }\n   RootBeanDefinition mbdToUse = mbd;\n\n   // 确保 BeanDefinition 中的 Class 被加载\n   Class<?> resolvedClass = resolveBeanClass(mbd, beanName);\n   if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n      mbdToUse = new RootBeanDefinition(mbd);\n      mbdToUse.setBeanClass(resolvedClass);\n   }\n\n   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 <lookup-method /> \n   // 和 <replaced-method />，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。\n   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看\n   try {\n      mbdToUse.prepareMethodOverrides();\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n            beanName, \"Validation of method overrides failed\", ex);\n   }\n\n   try {\n      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，\n      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过\n      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n      if (bean != null) {\n         return bean; \n      }\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n            \"BeanPostProcessor before instantiation of bean failed\", ex);\n   }\n   // 重头戏，创建 bean\n   Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n   if (logger.isDebugEnabled()) {\n      logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\");\n   }\n   return beanInstance;\n}\n```\n\n**创建Bean**\n我们继续往里看 doCreateBean 这个方法：\n```bash\n/**\n * Actually create the specified bean. Pre-creation processing has already happened\n * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n * <p>Differentiates between default bean instantiation, use of a\n * factory method, and autowiring a constructor.\n * @param beanName the name of the bean\n * @param mbd the merged bean definition for the bean\n * @param args explicit arguments to use for constructor or factory method invocation\n * @return a new instance of the bean\n * @throws BeanCreationException if the bean could not be created\n * @see #instantiateBean\n * @see #instantiateUsingFactoryMethod\n * @see #autowireConstructor\n */\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)\n      throws BeanCreationException {\n\n   // Instantiate the bean.\n   BeanWrapper instanceWrapper = null;\n   if (mbd.isSingleton()) {\n      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n   }\n   if (instanceWrapper == null) {\n      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说\n      instanceWrapper = createBeanInstance(beanName, mbd, args);\n   }\n   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 \"bean 实例\"\n   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);\n   // 类型\n   Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);\n   mbd.resolvedTargetType = beanType;\n\n   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor\n   synchronized (mbd.postProcessingLock) {\n      if (!mbd.postProcessed) {\n         try {\n            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的\n            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n         }\n         catch (Throwable ex) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                  \"Post-processing of merged bean definition failed\", ex);\n         }\n         mbd.postProcessed = true;\n      }\n   }\n\n   // Eagerly cache singletons to be able to resolve circular references\n   // even when triggered by lifecycle interfaces like BeanFactoryAware.\n   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧\n   boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n         isSingletonCurrentlyInCreation(beanName));\n   if (earlySingletonExposure) {\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Eagerly caching bean '\" + beanName +\n               \"' to allow for resolving potential circular references\");\n      }\n      addSingletonFactory(beanName, new ObjectFactory<Object>() {\n         @Override\n         public Object getObject() throws BeansException {\n            return getEarlyBeanReference(beanName, mbd, bean);\n         }\n      });\n   }\n\n   // Initialize the bean instance.\n   Object exposedObject = bean;\n   try {\n      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值\n      populateBean(beanName, mbd, instanceWrapper);\n      if (exposedObject != null) {\n         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？\n         // 这里就是处理 bean 初始化完成后的各种回调\n         exposedObject = initializeBean(beanName, exposedObject, mbd);\n      }\n   }\n   catch (Throwable ex) {\n      if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n         throw (BeanCreationException) ex;\n      }\n      else {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n      }\n   }\n\n   if (earlySingletonExposure) {\n      // \n      Object earlySingletonReference = getSingleton(beanName, false);\n      if (earlySingletonReference != null) {\n         if (exposedObject == bean) {\n            exposedObject = earlySingletonReference;\n         }\n         else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n            String[] dependentBeans = getDependentBeans(beanName);\n            Set<String> actualDependentBeans = new LinkedHashSet<String>(dependentBeans.length);\n            for (String dependentBean : dependentBeans) {\n               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                  actualDependentBeans.add(dependentBean);\n               }\n            }\n            if (!actualDependentBeans.isEmpty()) {\n               throw new BeanCurrentlyInCreationException(beanName,\n                     \"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                     \"] in its raw version as part of a circular reference, but has eventually been \" +\n                     \"wrapped. This means that said other beans do not use the final version of the \" +\n                     \"bean. This is often the result of over-eager type matching - consider using \" +\n                     \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\");\n            }\n         }\n      }\n   }\n\n   // Register bean as disposable.\n   try {\n      registerDisposableBeanIfNecessary(beanName, bean, mbd);\n   }\n   catch (BeanDefinitionValidationException ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n   }\n\n   return exposedObject;\n}\n```\n到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。\n\n接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 \n\n注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。\n\n**创建 Bean 实例**\n我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。\n```bash\nprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {\n   // 确保已经加载了此 class\n   Class<?> beanClass = resolveBeanClass(mbd, beanName);\n\n   // 校验一下这个类的访问权限\n   if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {\n      throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n            \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName());\n   }\n\n   if (mbd.getFactoryMethodName() != null)  {\n      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean\n      return instantiateUsingFactoryMethod(beanName, mbd, args);\n   }\n\n   // 如果不是第一次创建，比如第二次创建 prototype bean。\n   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化\n   boolean resolved = false;\n   boolean autowireNecessary = false;\n   if (args == null) {\n      synchronized (mbd.constructorArgumentLock) {\n         if (mbd.resolvedConstructorOrFactoryMethod != null) {\n            resolved = true;\n            autowireNecessary = mbd.constructorArgumentsResolved;\n         }\n      }\n   }\n   if (resolved) {\n      if (autowireNecessary) {\n         // 构造函数依赖注入\n         return autowireConstructor(beanName, mbd, null, null);\n      }\n      else {\n         // 无参构造函数\n         return instantiateBean(beanName, mbd);\n      }\n   }\n\n   // 判断是否采用有参构造函数\n   Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n   if (ctors != null ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n      // 构造函数依赖注入\n      return autowireConstructor(beanName, mbd, ctors, args);\n   }\n\n   // 调用无参构造函数\n   return instantiateBean(beanName, mbd);\n}\n```\n\n挑个简单的**无参构造函数**构造实例来看看：\n```bash\nprotected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n   try {\n      Object beanInstance;\n      final BeanFactory parent = this;\n      if (System.getSecurityManager() != null) {\n         beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n\n               return getInstantiationStrategy().instantiate(mbd, beanName, parent);\n            }\n         }, getAccessControlContext());\n      }\n      else {\n         // 实例化\n         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);\n      }\n      // 包装一下，返回\n      BeanWrapper bw = new BeanWrapperImpl(beanInstance);\n      initBeanWrapper(bw);\n      return bw;\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n   }\n}\n```\n我们可以看到，关键的地方在于：\n```bash\nbeanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);\n```\n这里会进行实际的实例化过程，我们进去看看:\n\n// SimpleInstantiationStrategy 59\n```bash\n@Override\npublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {\n\n   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,\n   // 方法覆写 请参见附录\"方法注入\"中对 lookup-method 和 replaced-method 的介绍\n   if (bd.getMethodOverrides().isEmpty()) {\n      Constructor<?> constructorToUse;\n      synchronized (bd.constructorArgumentLock) {\n         constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;\n         if (constructorToUse == null) {\n            final Class<?> clazz = bd.getBeanClass();\n            if (clazz.isInterface()) {\n               throw new BeanInstantiationException(clazz, \"Specified class is an interface\");\n            }\n            try {\n               if (System.getSecurityManager() != null) {\n                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction<Constructor<?>>() {\n                     @Override\n                     public Constructor<?> run() throws Exception {\n                        return clazz.getDeclaredConstructor((Class[]) null);\n                     }\n                  });\n               }\n               else {\n                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);\n               }\n               bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n            }\n            catch (Throwable ex) {\n               throw new BeanInstantiationException(clazz, \"No default constructor found\", ex);\n            }\n         }\n      }\n      // 利用构造方法进行实例化\n      return BeanUtils.instantiateClass(constructorToUse);\n   }\n   else {\n      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。\n      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持\n      return instantiateWithMethodInjection(bd, beanName, owner);\n   }\n}\n```\n\n**bean 属性注入**\n看完了 createBeanInstance(...) 方法，我们来看看 populateBean(...) 方法，该方法负责进行属性设值，处理依赖。\n\n// AbstractAutowireCapableBeanFactory 1203\n```bash\nprotected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {\n   // bean 实例的所有属性都在这里了\n   PropertyValues pvs = mbd.getPropertyValues();\n\n   if (bw == null) {\n      if (!pvs.isEmpty()) {\n         throw new BeanCreationException(\n               mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n      }\n      else {\n         // Skip property population phase for null instance.\n         return;\n      }\n   }\n\n   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，\n   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，\n   // 我也没找到有实际的使用，所以我们暂且忽略这块吧\n   boolean continueWithPropertyPopulation = true;\n   if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n      for (BeanPostProcessor bp : getBeanPostProcessors()) {\n         if (bp instanceof InstantiationAwareBeanPostProcessor) {\n            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n            // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理\n            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n               continueWithPropertyPopulation = false;\n               break;\n            }\n         }\n      }\n   }\n\n   if (!continueWithPropertyPopulation) {\n      return;\n   }\n\n   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n         autowireByName(beanName, mbd, bw, newPvs);\n      }\n\n      // 通过类型装配。复杂一些\n      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n         autowireByType(beanName, mbd, bw, newPvs);\n      }\n\n      pvs = newPvs;\n   }\n\n   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n   if (hasInstAwareBpps || needsDepCheck) {\n      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n      if (hasInstAwareBpps) {\n         for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor\n               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究\n               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n               if (pvs == null) {\n                  return;\n               }\n            }\n         }\n      }\n      if (needsDepCheck) {\n         checkDependencies(beanName, mbd, filteredPds, pvs);\n      }\n   }\n   // 设置 bean 实例的属性值\n   applyPropertyValues(beanName, mbd, bw, pvs);\n}\n```\n\n**initializeBean**\n属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。\n```bash\nprotected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n   if (System.getSecurityManager() != null) {\n      AccessController.doPrivileged(new PrivilegedAction<Object>() {\n         @Override\n         public Object run() {\n            invokeAwareMethods(beanName, bean);\n            return null;\n         }\n      }, getAccessControlContext());\n   }\n   else {\n      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调\n      invokeAwareMethods(beanName, bean);\n   }\n\n   Object wrappedBean = bean;\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessBeforeInitialization 回调\n      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n   }\n\n   try {\n      // 处理 bean 中定义的 init-method，\n      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法\n      invokeInitMethods(beanName, wrappedBean, mbd);\n   }\n   catch (Throwable ex) {\n      throw new BeanCreationException(\n            (mbd != null ? mbd.getResourceDescription() : null),\n            beanName, \"Invocation of init method failed\", ex);\n   }\n\n   if (mbd == null || !mbd.isSynthetic()) {\n      // BeanPostProcessor 的 postProcessAfterInitialization 回调\n      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n   }\n   return wrappedBean;\n}\n```\n大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？\n\n---\n\n### 附录\n\n#### id和name\n每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。\n\n我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。\n```bash\nbeanFactory.getBean(\"beanName or alias\");\n```\n在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。\n```bash\n<bean id=\"messageService\" name=\"m1, m2, m3\" class=\"com.loonycoder.service.MessageServiceImpl\">\n```\n以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。\n```bash\n<bean name=\"m1, m2, m3\" class=\"com.loonycoder.service.MessageServiceImpl\" />\n```\n以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。\n```bash\n<bean class=\"com.loonycoder.service.MessageServiceImpl\">\n```\nbeanName 为：com.loonycoder.service.MessageServiceImpl#0，\n\n别名 1 个，为： com.loonycoder.service.MessageServiceImpl\n```bash\n<bean id=\"messageService\" class=\"com.loonycoder.service.MessageServiceImpl\">\n```\n以上配置的结果就是：beanName 为 messageService，没有别名。\n\n#### 配置是否允许 Bean 覆盖、是否允许循环依赖\n我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\n可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。\n\n循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。\n\n它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。\n\n添加这两个属性的作者 Juergen Hoeller 在这个 jira 的讨论中说明了怎么配置这两个属性。\n```bash\npublic class NoBeanOverridingContextLoader extends ContextLoader {\n\n  @Override\n  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) {\n    super.customizeContext(servletContext, applicationContext);\n    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;\n    arac.setAllowBeanDefinitionOverriding(false);\n  }\n}\n```\n```bash\npublic class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener {\n\n  @Override\n  protected ContextLoader createContextLoader() {\n    return new NoBeanOverridingContextLoader();\n  }\n\n}\n```\n```bash\n<listener>\n    <listener-class>com.loonycoder.MyContextLoaderListener</listener-class>  \n</listener>\n```\n\n#### profile\n我们可以把不同环境的配置分别配置到单独的文件中，举个例子：\n```bash\n<beans profile=\"development\"\n    xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n    xsi:schemaLocation=\"...\">\n\n    <jdbc:embedded-database id=\"dataSource\">\n        <jdbc:script location=\"classpath:com/loonycoder/config/sql/schema.sql\"/>\n        <jdbc:script location=\"classpath:com/oonycoder/config/sql/test-data.sql\"/>\n    </jdbc:embedded-database>\n</beans>\n```\n```bash\n<beans profile=\"production\"\n    xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xsi:schemaLocation=\"...\">\n\n    <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n</beans>\n```\n应该不必做过多解释了吧，看每个文件第一行的 profile=\"\"。\n\n当然，我们也可以在一个配置文件中使用：\n```bash\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xsi:schemaLocation=\"...\">\n\n    <beans profile=\"development\">\n        <jdbc:embedded-database id=\"dataSource\">\n            <jdbc:script location=\"classpath:com/loonycoder/config/sql/schema.sql\"/>\n            <jdbc:script location=\"classpath:com/loonycoder/config/sql/test-data.sql\"/>\n        </jdbc:embedded-database>\n    </beans>\n\n    <beans profile=\"production\">\n        <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n    </beans>\n</beans>\n```\n理解起来也很简单吧。\n\n接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？\n\nSpring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。\n\n最简单的方式莫过于在程序启动的时候指定：\n```bash\n-Dspring.profiles.active=\"profile1,profile2\"\n```\n> profile 可以激活多个\n\n当然，我们也可以通过代码的形式从 Environment 中设置 profile：\n```bash\nAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles(\"development\");\nctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\nctx.refresh(); // 重启\n```\n如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：\n```bash\njava -Dspring.profiles.active=prod -jar JavaDoop.jar\n```\n\n#### 工厂模式生成 Bean\n请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。\n\n设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。\n\n静态工厂：\n```bash\n<bean id=\"clientService\"\n    class=\"examples.ClientService\"\n    factory-method=\"createInstance\"/>\n```\n```bash\npublic class ClientService {\n    private static ClientService clientService = new ClientService();\n    private ClientService() {}\n\n    // 静态方法\n    public static ClientService createInstance() {\n        return clientService;\n    }\n}\n```\n实例工厂：\n```bash\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n    <!-- inject any dependencies required by this locator bean -->\n</bean>\n\n<bean id=\"clientService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createClientServiceInstance\"/>\n\n<bean id=\"accountService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createAccountServiceInstance\"/>\n```\n```bash\npublic class DefaultServiceLocator {\n\n    private static ClientService clientService = new ClientServiceImpl();\n\n    private static AccountService accountService = new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() {\n        return clientService;\n    }\n\n    public AccountService createAccountServiceInstance() {\n        return accountService;\n    }\n}\n```\n\n#### FactoryBean\nFactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。\n```bash\npublic interface FactoryBean<T> {\n    T getObject() throws Exception;\n    Class<T> getObjectType();\n    boolean isSingleton();\n}\n```\n```bash\npublic class Person { \n    private Car car ;\n    private void setCar(Car car){ this.car = car;  }  \n}\n```\n我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：\n```bash\npublic class MyCarFactoryBean implements FactoryBean<Car>{\n    private String make; \n    private int year ;\n\n    public void setMake(String m){ this.make =m ; }\n\n    public void setYear(int y){ this.year = y; }\n\n    public Car getObject(){ \n      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种\n      CarBuilder cb = CarBuilder.car();\n\n      if(year!=0) cb.setYear(this.year);\n      if(StringUtils.hasText(this.make)) cb.setMake( this.make ); \n      return cb.factory(); \n    }\n\n    public Class<Car> getObjectType() { return Car.class ; } \n\n    public boolean isSingleton() { return false; }\n}\n```\n我们看看装配的时候是怎么配置的：\n```bash\n<bean class = \"com.loonycoder.MyCarFactoryBean\" id = \"car\">\n  <property name = \"make\" value =\"Honda\"/>\n  <property name = \"year\" value =\"1994\"/>\n</bean>\n<bean class = \"com.loonycoder.Person\" id = \"josh\">\n  <property name = \"car\" ref = \"car\"/>\n</bean>\n```\n看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。\n\n说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？\n```bash\n@Configuration \npublic class CarConfiguration { \n\n    @Bean \n    public MyCarFactoryBean carFactoryBean(){ \n      MyCarFactoryBean cfb = new MyCarFactoryBean();\n      cfb.setMake(\"Honda\");\n      cfb.setYear(1994);\n      return cfb;\n    }\n\n    @Bean\n    public Person aPerson(){ \n    Person person = new Person();\n      // 注意这里的不同\n    person.setCar(carFactoryBean().getObject());\n    return person; \n    } \n}\n```\n这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。\n\n#### 初始化 Bean 的回调\n有以下四种方案：\n```bash\n<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/>\n```\n```bash\npublic class AnotherExampleBean implements InitializingBean {\n\n    public void afterPropertiesSet() {\n        // do some initialization work\n    }\n}\n```\n```bash\n@Bean(initMethod = \"init\")\npublic Foo foo() {\n    return new Foo();\n}\n```\n```bash\n@PostConstruct\npublic void init() {\n\n}\n```\n\n#### 销毁 Bean 的回调\n```bash\n<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/>\n```\n```bash\npublic class AnotherExampleBean implements DisposableBean {\n\n    public void destroy() {\n        // do some destruction work (like releasing pooled connections)\n    }\n}\n```\n```bash\n@Bean(destroyMethod = \"cleanup\")\npublic Bar bar() {\n    return new Bar();\n}\n```\n```bash\n@PreDestroy\npublic void cleanup() {\n\n}\n```\n\n#### ConversionService\n既然文中说到了这个，顺便提一下好了。\n\n最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。\n\n像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。\n```bash\n<bean id=\"conversionService\"\n  class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n  <property name=\"converters\">\n    <list>\n      <bean class=\"com.loonycoder.learning.utils.StringToEnumConverterFactory\"/>\n    </list>\n  </property>\n</bean>\n```\nConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。\n\n下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。\n\n来看一个很简单的例子，这样比什么都管用。\n```bash\npublic class StringToDateConverter implements Converter<String, Date> {\n\n    @Override\n    public Date convert(String source) {\n        try {\n            return DateUtils.parseDate(source, \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"HH:mm:ss\", \"HH:mm\");\n        } catch (ParseException e) {\n            return null;\n        }\n    }\n}\n```\n只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。\n\n#### Bean 继承\n在初始化 Bean 的地方，我们说过了这个：\n```bash\nRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n```\n这里涉及到的就是 <code>&lt;bean parent=\"\" /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。\n\n首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。\n\nSpring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。\n\n看如下一个例子:\n```bash\n<bean id=\"inheritedTestBean\" abstract=\"true\" class=\"org.springframework.beans.TestBean\">\n    <property name=\"name\" value=\"parent\"/>\n    <property name=\"age\" value=\"1\"/>\n</bean>\n\n<bean id=\"inheritsWithDifferentClass\" class=\"org.springframework.beans.DerivedTestBean\"\n        parent=\"inheritedTestBean\" init-method=\"initialize\">\n\n    <property name=\"name\" value=\"override\"/>\n</bean>\n```\nparent bean 设置了 <code>abstract=\"true\"</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。\n\nchild bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。\n\n当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。\n\n比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。\n```bash\n<bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\">\n    <property name=\"name\" value=\"parent\"/>\n    <property name=\"age\" value=\"1\"/>\n</bean>\n```\n\n#### 方法注入\n一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。\n\n但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。\n\n一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。\n\n另一种解决方案就是这里要介绍的通过使用 Lookup method。\n\n**lookup-method**\n我们来看一下 Spring Reference 中提供的一个例子：\n```bash\npackage fiona.apple;\n\n// no more Spring imports!\n\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        // grab a new instance of the appropriate Command interface\n        Command command = createCommand();\n        // set the state on the (hopefully brand new) Command instance\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    // okay... but where is the implementation of this method?\n    protected abstract Command createCommand();\n}\n```\nxml 配置 <code>&lt;lookup-method /&gt;</code>：\n```bash\n<!-- a stateful bean deployed as a prototype (non-singleton) -->\n<bean id=\"myCommand\" class=\"fiona.apple.AsyncCommand\" scope=\"prototype\">\n    <!-- inject dependencies here as required -->\n</bean>\n\n<!-- commandProcessor uses statefulCommandHelper -->\n<bean id=\"commandManager\" class=\"fiona.apple.CommandManager\">\n    <lookup-method name=\"createCommand\" bean=\"myCommand\"/>\n</bean>\n```\nSpring 采用 **CGLIB** 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。\n\nlookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：\n```bash\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup(\"myCommand\")\n    protected abstract Command createCommand();\n}\n```\n> 注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=\"com.loonycoder\" /&gt;</code>\n\n甚至，我们可以像下面这样：\n```bash\npublic abstract class CommandManager {\n\n    public Object process(Object commandState) {\n        MyCommand command = createCommand();\n        command.setState(commandState);\n        return command.execute();\n    }\n\n    @Lookup\n    protected abstract MyCommand createCommand();\n}\n```\n> 上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。\n\n**replaced-method**\n记住它的功能，就是替换掉 bean 中的一些方法。\n```bash\npublic class MyValueCalculator {\n\n    public String computeValue(String input) {\n        // some real code...\n    }\n\n    // some other methods...\n}\n```\n方法覆写，注意要实现 MethodReplacer 接口：\n```bash\npublic class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer {\n\n    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {\n        // get the input value, work with it, and return a computed result\n        String input = (String) args[0];\n        ...\n        return ...;\n    }\n}\n```\n配置也很简单：\n```bash\n<bean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\">\n    <!-- 定义 computeValue 这个方法要被替换掉 -->\n    <replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\">\n        <arg-type>String</arg-type>\n    </replaced-method>\n</bean>\n\n<bean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/>\n```\n> arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。\n\n#### BeanPostProcessor\n应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：\n```bash\npublic interface BeanPostProcessor {\n\n   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\n   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n\n}\n```\n看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。\n\n首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。\n\n我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。\n\n那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。\n\n最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？\n\n如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。\n\n首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。\n\n---\n\n### 总结\n按理说，总结应该写在附录前面，我就不讲究了。\n\n在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。\n\n本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。\n\n（全文完）\n","slug":"Spring-2","published":1,"updated":"2020-02-21T15:31:39.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6xlmizy0031v9s685ai9o4e","content":"<p><img src=\"/images/spring_logo.jpg\" alt=\"Spring\"></p>\n<p>原文转自：<a href=\"https://javadoop.com/post/spring-ioc\" target=\"_blank\" rel=\"noopener\">https://javadoop.com/post/spring-ioc</a></p>\n<p>因为有幸看到这篇让我读了约三个半小时的文章，简直价值千金，所以稍作修改，以此记录。<br>为了保持文章的严谨性，如有错误，望及时指出，十分希望听到读者的声音。</p>\n<hr>\n<h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>先看下最基本的启动 Spring 容器的例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    ApplicationContext context = new ClassPathXmlApplicationContext(<span class=\"string\">\"classpath:Application.xml\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>\n</blockquote>\n<p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。<br>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code>其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext 。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：<br><img src=\"/images/spring-ioc1.png\" alt=\"spring\"></p>\n<blockquote>\n<p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。<br>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p>\n</blockquote>\n<p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的<br><strong>FileSystemXmlApplicationContext</strong>和<strong>AnnotationConfigApplicationContext</strong>这两个类。</p>\n<ol>\n<li><p><strong>FileSystemXmlApplicationContext</strong>的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p>\n</li>\n<li><p><strong>AnnotationConfigApplicationContext</strong>是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p>\n</li>\n</ol>\n<p>不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p>\n<p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p>\n<p>首先，定义一个接口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface MessageService &#123;</span><br><span class=\"line\">    String getMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义接口实现类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MessageServiceImpl implements MessageService &#123;</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getMessage</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"hello world\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 Application.xml 或 Application-xxx.xml 就可以了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span> ?&gt;</span><br><span class=\"line\">&lt;beans xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">       xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">       xsi:schemaLocation=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span> default-autowire=<span class=\"string\">\"byName\"</span>&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">\"messageService\"</span> class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span>/&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<p>这样，我们就可以跑起来了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class App &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 用我们的配置文件来启动一个 ApplicationContext</span><br><span class=\"line\">        ApplicationContext context = new ClassPathXmlApplicationContext(<span class=\"string\">\"classpath:Application.xml\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"context 启动成功\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span><br><span class=\"line\">        MessageService messageService = context.getBean(MessageService.class);</span><br><span class=\"line\">        // 这句将输出: hello world</span><br><span class=\"line\">        System.out.println(messageService.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p>\n<hr>\n<h3 id=\"BeanFactory-简介\"><a href=\"#BeanFactory-简介\" class=\"headerlink\" title=\"BeanFactory 简介\"></a>BeanFactory 简介</h3><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p>\n<p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：<br><img src=\"/images/spring-ioc2.png\" alt=\"spring\"><br>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p>\n<ul>\n<li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li>\n<li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li>\n<li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li>\n<li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li>\n<li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。<br>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</li>\n</ul>\n<hr>\n<h3 id=\"启动过程分析\"><a href=\"#启动过程分析\" class=\"headerlink\" title=\"启动过程分析\"></a>启动过程分析</h3><p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p>\n<p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123;</span><br><span class=\"line\">  private Resource[] configResources;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span><br><span class=\"line\">  public ClassPathXmlApplicationContext(ApplicationContext parent) &#123;</span><br><span class=\"line\">    super(parent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</span><br><span class=\"line\">      throws BeansException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    super(parent);</span><br><span class=\"line\">    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span><br><span class=\"line\">    setConfigLocations(configLocations);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (refresh) &#123;</span><br><span class=\"line\">      refresh(); // 核心方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p>\n<p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class=\"line\">   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span><br><span class=\"line\">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class=\"line\">      prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class=\"line\">      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class=\"line\">      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class=\"line\">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class=\"line\">      // 这块待会会展开说</span><br><span class=\"line\">      prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class=\"line\">         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class=\"line\"></span><br><span class=\"line\">         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class=\"line\">         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class=\"line\">         postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span><br><span class=\"line\">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class=\"line\">         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class=\"line\">         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span><br><span class=\"line\">         registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class=\"line\">         initMessageSource();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class=\"line\">         initApplicationEventMulticaster();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 从方法名就可以知道，典型的模板方法(钩子方法)，</span><br><span class=\"line\">         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class=\"line\">         onRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class=\"line\">         registerListeners();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 重点，重点，重点</span><br><span class=\"line\">         // 初始化所有的 singleton beans</span><br><span class=\"line\">         //（lazy-init 的除外）</span><br><span class=\"line\">         finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 最后，广播事件，ApplicationContext 初始化完成</span><br><span class=\"line\">         finishRefresh();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      catch (BeansException ex) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"Exception encountered during context initialization - \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"cancelling refresh attempt: \"</span> + ex);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         // Destroy already created singletons to avoid dangling resources.</span><br><span class=\"line\">         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class=\"line\">         destroyBeans();</span><br><span class=\"line\"></span><br><span class=\"line\">         // Reset <span class=\"string\">'active'</span> flag.</span><br><span class=\"line\">         cancelRefresh(ex);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 把异常往外抛</span><br><span class=\"line\">         throw ex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      finally &#123;</span><br><span class=\"line\">         // Reset common introspection caches <span class=\"keyword\">in</span> Spring<span class=\"string\">'s core, since we</span></span><br><span class=\"line\"><span class=\"string\">         // might not ever need metadata for singleton beans anymore...</span></span><br><span class=\"line\"><span class=\"string\">         resetCommonCaches();</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">   &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面，我们开始一步步来肢解这个 refresh() 方法。</p>\n<hr>\n<h4 id=\"创建-Bean-容器，加载并注册-Bean\"><a href=\"#创建-Bean-容器，加载并注册-Bean\" class=\"headerlink\" title=\"创建 Bean 容器，加载并注册 Bean\"></a>创建 Bean 容器，加载并注册 Bean</h4><p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p>\n<p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p>\n<p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p>\n<p>// AbstractApplicationContext.java</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected ConfigurableListableBeanFactory <span class=\"function\"><span class=\"title\">obtainFreshBeanFactory</span></span>() &#123;</span><br><span class=\"line\">   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span><br><span class=\"line\">   refreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 返回刚刚创建的 BeanFactory</span><br><span class=\"line\">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      logger.debug(<span class=\"string\">\"Bean factory for \"</span> + getDisplayName() + <span class=\"string\">\": \"</span> + beanFactory);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> beanFactory;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>// AbstractRefreshableApplicationContext.java 120</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class=\"line\">   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span><br><span class=\"line\">   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span><br><span class=\"line\">   // ApplicationContext 是否有 BeanFactory</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (hasBeanFactory()) &#123;</span><br><span class=\"line\">      destroyBeans();</span><br><span class=\"line\">      closeBeanFactory();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span><br><span class=\"line\">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class=\"line\">      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span><br><span class=\"line\">      beanFactory.setSerializationId(getId());</span><br><span class=\"line\"></span><br><span class=\"line\">      // 下面这两个方法很重要，别跟丢了，具体细节之后说</span><br><span class=\"line\">      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span><br><span class=\"line\">      customizeBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 加载 Bean 到 BeanFactory 中</span><br><span class=\"line\">      loadBeanDefinitions(beanFactory);</span><br><span class=\"line\">      synchronized (this.beanFactoryMonitor) &#123;</span><br><span class=\"line\">         this.beanFactory = beanFactory;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (IOException ex) &#123;</span><br><span class=\"line\">      throw new ApplicationContextException(<span class=\"string\">\"I/O error parsing bean definition source for \"</span> + getDisplayName(), ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>\n</blockquote>\n<p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：<br><img src=\"/images/spring-ioc2.png\" alt=\"spring\"></p>\n<p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p>\n<blockquote>\n<p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？<br>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。<br>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。</p>\n</blockquote>\n<p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p>\n<p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p>\n<p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p>\n<blockquote>\n<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>\n</blockquote>\n<p><strong>BeanDefinition 接口定义</strong><br>我们来看下 BeanDefinition 的接口定义：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 我们可以看到，默认只提供 sington 和 prototype 两种，</span><br><span class=\"line\">   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span><br><span class=\"line\">   // 不过，它们属于基于 web 的扩展。</span><br><span class=\"line\">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class=\"line\">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 比较不重要，直接跳过吧</span><br><span class=\"line\">   int ROLE_APPLICATION = 0;</span><br><span class=\"line\">   int ROLE_SUPPORT = 1;</span><br><span class=\"line\">   int ROLE_INFRASTRUCTURE = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span><br><span class=\"line\">   // 一句话就是：继承父 Bean 的配置信息而已</span><br><span class=\"line\">   void setParentName(String parentName);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 获取父 Bean</span><br><span class=\"line\">   String getParentName();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置 Bean 的类名称，将来是要通过反射来生成实例的</span><br><span class=\"line\">   void setBeanClassName(String beanClassName);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 获取 Bean 的类名称</span><br><span class=\"line\">   String getBeanClassName();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置 bean 的 scope</span><br><span class=\"line\">   void setScope(String scope);</span><br><span class=\"line\"></span><br><span class=\"line\">   String getScope();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置是否懒加载</span><br><span class=\"line\">   void setLazyInit(boolean lazyInit);</span><br><span class=\"line\"></span><br><span class=\"line\">   boolean isLazyInit();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span><br><span class=\"line\">   // 是 depends-on=<span class=\"string\">\"\"</span> 属性设置的值。</span><br><span class=\"line\">   void setDependsOn(String... dependsOn);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 返回该 Bean 的所有依赖</span><br><span class=\"line\">   String[] getDependsOn();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span><br><span class=\"line\">   // 如果根据名称注入，即使这边设置了 <span class=\"literal\">false</span>，也是可以的</span><br><span class=\"line\">   void setAutowireCandidate(boolean autowireCandidate);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 该 Bean 是否可以注入到其他 Bean 中</span><br><span class=\"line\">   boolean isAutowireCandidate();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 <span class=\"literal\">true</span> 的 bean</span><br><span class=\"line\">   void setPrimary(boolean primary);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 是否是 primary 的</span><br><span class=\"line\">   boolean isPrimary();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span><br><span class=\"line\">   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span><br><span class=\"line\">   void setFactoryBeanName(String factoryBeanName);</span><br><span class=\"line\">   // 获取工厂名称</span><br><span class=\"line\">   String getFactoryBeanName();</span><br><span class=\"line\">   // 指定工厂类中的 工厂方法名称</span><br><span class=\"line\">   void setFactoryMethodName(String factoryMethodName);</span><br><span class=\"line\">   // 获取工厂类中的 工厂方法名称</span><br><span class=\"line\">   String getFactoryMethodName();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 构造器参数</span><br><span class=\"line\">   ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class=\"line\"></span><br><span class=\"line\">   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span><br><span class=\"line\">   MutablePropertyValues getPropertyValues();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 是否 singleton</span><br><span class=\"line\">   boolean isSingleton();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 是否 prototype</span><br><span class=\"line\">   boolean isPrototype();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span><br><span class=\"line\">   // 常用于作为 父bean 用于继承，其实也很少用......</span><br><span class=\"line\">   boolean isAbstract();</span><br><span class=\"line\"></span><br><span class=\"line\">   int getRole();</span><br><span class=\"line\">   String getDescription();</span><br><span class=\"line\">   String getResourceDescription();</span><br><span class=\"line\">   BeanDefinition getOriginatingBeanDefinition();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。<br>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p>\n</blockquote>\n<p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">customizeBeanFactory(beanFactory);</span><br><span class=\"line\">loadBeanDefinitions(beanFactory);</span><br></pre></td></tr></table></figure>\n\n<p>虽然只有两个方法，但路还很长啊。。。</p>\n<p><strong>customizeBeanFactory</strong></p>\n<p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (this.allowBeanDefinitionOverriding != null) &#123;</span><br><span class=\"line\">      // 是否允许 Bean 定义覆盖</span><br><span class=\"line\">      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (this.allowCircularReferences != null) &#123;</span><br><span class=\"line\">      // 是否允许 Bean 间的循环依赖</span><br><span class=\"line\">      beanFactory.setAllowCircularReferences(this.allowCircularReferences);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>\n<p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>\n<p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p>\n<p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p>\n<p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p>\n<p><strong>加载Bean:loadBeanDefinitions</strong></p>\n<p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p>\n<p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p>\n<p>// AbstractXmlApplicationContext.java 80</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class=\"line\">   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span><br><span class=\"line\">   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">   // Configure the bean definition reader with this context<span class=\"string\">'s</span></span><br><span class=\"line\"><span class=\"string\">   // resource loading environment.</span></span><br><span class=\"line\"><span class=\"string\">   beanDefinitionReader.setEnvironment(this.getEnvironment());</span></span><br><span class=\"line\"><span class=\"string\">   beanDefinitionReader.setResourceLoader(this);</span></span><br><span class=\"line\"><span class=\"string\">   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span></span><br><span class=\"line\"><span class=\"string\">   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span></span><br><span class=\"line\"><span class=\"string\">   initBeanDefinitionReader(beanDefinitionReader);</span></span><br><span class=\"line\"><span class=\"string\">   // 重点来了，继续往下</span></span><br><span class=\"line\"><span class=\"string\">   loadBeanDefinitions(beanDefinitionReader);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p>\n<p>// AbstractXmlApplicationContext.java 120</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class=\"line\">   Resource[] configResources = getConfigResources();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (configResources != null) &#123;</span><br><span class=\"line\">      // 往下看</span><br><span class=\"line\">      reader.loadBeanDefinitions(configResources);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   String[] configLocations = getConfigLocations();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (configLocations != null) &#123;</span><br><span class=\"line\">      // 2</span><br><span class=\"line\">      reader.loadBeanDefinitions(configLocations);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\">   Assert.notNull(resources, <span class=\"string\">\"Resource array must not be null\"</span>);</span><br><span class=\"line\">   int counter = 0;</span><br><span class=\"line\">   // 注意这里是个 <span class=\"keyword\">for</span> 循环，也就是每个文件是一个 resource</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (Resource resource : resources) &#123;</span><br><span class=\"line\">      // 继续往下看</span><br><span class=\"line\">      counter += loadBeanDefinitions(resource);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 最后返回 counter，表示总共加载了多少的 BeanDefinition</span><br><span class=\"line\">   <span class=\"built_in\">return</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// XmlBeanDefinitionReader 303</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> loadBeanDefinitions(new EncodedResource(resource));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// XmlBeanDefinitionReader 314</span><br><span class=\"line\">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\">   Assert.notNull(encodedResource, <span class=\"string\">\"EncodedResource must not be null\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">      logger.info(<span class=\"string\">\"Loading XML bean definitions from \"</span> + encodedResource.getResource());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 用一个 ThreadLocal 来存放配置文件资源</span><br><span class=\"line\">   Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (currentResources == null) &#123;</span><br><span class=\"line\">      currentResources = new HashSet&lt;EncodedResource&gt;(4);</span><br><span class=\"line\">      this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class=\"line\">      throw new BeanDefinitionStoreException(</span><br><span class=\"line\">            <span class=\"string\">\"Detected cyclic loading of \"</span> + encodedResource + <span class=\"string\">\" - check your import definitions!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         InputSource inputSource = new InputSource(inputStream);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (encodedResource.getEncoding() != null) &#123;</span><br><span class=\"line\">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         // 核心部分是这里，往下面看</span><br><span class=\"line\">         <span class=\"built_in\">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      finally &#123;</span><br><span class=\"line\">         inputStream.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (IOException ex) &#123;</span><br><span class=\"line\">      throw new BeanDefinitionStoreException(</span><br><span class=\"line\">            <span class=\"string\">\"IOException parsing XML document from \"</span> + encodedResource.getResource(), ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   finally &#123;</span><br><span class=\"line\">      currentResources.remove(encodedResource);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentResources.isEmpty()) &#123;</span><br><span class=\"line\">         this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 还在这个文件中，第 388 行</span><br><span class=\"line\">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class=\"line\">      throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      // 这里就不看了，将 xml 文件转换为 Document 对象</span><br><span class=\"line\">      Document doc = doLoadDocument(inputSource, resource);</span><br><span class=\"line\">      // 继续</span><br><span class=\"line\">      <span class=\"built_in\">return</span> registerBeanDefinitions(doc, resource);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 还在这个文件中，第 505 行</span><br><span class=\"line\">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span><br><span class=\"line\">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\">   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class=\"line\">   int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class=\"line\">   // 这里</span><br><span class=\"line\">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class=\"line\">   <span class=\"built_in\">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// DefaultBeanDefinitionDocumentReader 90</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class=\"line\">   this.readerContext = readerContext;</span><br><span class=\"line\">   logger.debug(<span class=\"string\">\"Loading bean definitions\"</span>);</span><br><span class=\"line\">   Element root = doc.getDocumentElement();</span><br><span class=\"line\">   // 从 xml 根节点开始解析文件</span><br><span class=\"line\">   doRegisterBeanDefinitions(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p>\n<p><strong>doRegisterBeanDefinitions：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// DefaultBeanDefinitionDocumentReader 116</span><br><span class=\"line\">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class=\"line\">   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，</span><br><span class=\"line\">   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，</span><br><span class=\"line\">   // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了</span><br><span class=\"line\">   BeanDefinitionParserDelegate parent = this.delegate;</span><br><span class=\"line\">   this.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class=\"line\">      // 这块说的是根节点 &lt;beans ... profile=<span class=\"string\">\"dev\"</span> /&gt; 中的 profile 是否是当前环境需要的，</span><br><span class=\"line\">      // 如果当前环境配置的 profile 不包含此 profile，那就直接 <span class=\"built_in\">return</span> 了，不对此 &lt;beans /&gt; 解析</span><br><span class=\"line\">      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区</span><br><span class=\"line\">      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class=\"line\">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class=\"line\">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">               logger.info(<span class=\"string\">\"Skipped XML bean definition file due to specified profiles [\"</span> + profileSpec +</span><br><span class=\"line\">                     <span class=\"string\">\"] not matching: \"</span> + getReaderContext().getResource());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   preProcessXml(root); // 钩子</span><br><span class=\"line\">   // 往下看</span><br><span class=\"line\">   parseBeanDefinitions(root, this.delegate);</span><br><span class=\"line\">   postProcessXml(root); // 钩子</span><br><span class=\"line\"></span><br><span class=\"line\">   this.delegate = parent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p>\n<p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p>\n<p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;<span class=\"built_in\">alias</span> /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span><br><span class=\"line\">// 其他的属于 custom 的</span><br><span class=\"line\">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class=\"line\">      NodeList nl = root.getChildNodes();</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class=\"line\">         Node node = nl.item(i);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (node instanceof Element) &#123;</span><br><span class=\"line\">            Element ele = (Element) node;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class=\"line\">               // 解析 default namespace 下面的几个元素</span><br><span class=\"line\">               parseDefaultElement(ele, delegate);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               // 解析其他 namespace 的元素</span><br><span class=\"line\">               delegate.parseCustomElement(ele);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      delegate.parseCustomElement(root);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p>\n<p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt;、&lt;beans /&gt;</code>这几个。</p>\n<blockquote>\n<p>这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.springframework.org/schema/beans </span><br></pre></td></tr></table></figure>\n<p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 xmlns 就是咯。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">      xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">      xsi:schemaLocation=<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">           http://www.springframework.org/schema/beans</span></span><br><span class=\"line\"><span class=\"string\">         http://www.springframework.org/schema/beans/spring-beans.xsd\"</span></span><br><span class=\"line\">      default-autowire=<span class=\"string\">\"byName\"</span>&gt; </span><br></pre></td></tr></table></figure>\n<p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code> &lt;mvc /&gt;、&lt;task /&gt;、&lt;context /&gt;、&lt;aop /&gt;</code>等。<br>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。<br>假如读者想分析 <code>&lt;context:property-placeholder location=\"classpath:xx.properties\" /&gt;</code>的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">     xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">     xmlns:context=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></span><br><span class=\"line\">     xmlns:mvc=<span class=\"string\">\"http://www.springframework.org/schema/mvc\"</span></span><br><span class=\"line\">     xsi:schemaLocation=<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/beans </span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/context</span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/mvc   </span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span></span><br><span class=\"line\"><span class=\"string\">      \"</span></span><br><span class=\"line\">     default-autowire=<span class=\"string\">\"byName\"</span>&gt;</span><br><span class=\"line\">   &lt;/bean&gt; </span><br></pre></td></tr></table></figure>\n<p>同理，以后你要是碰到 <code>&lt;<dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。<br>回过神来，看看处理 default 标签的方法：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class=\"line\">      // 处理 &lt;import /&gt; 标签</span><br><span class=\"line\">      importBeanDefinitionResource(ele);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class=\"line\">      // 处理 &lt;<span class=\"built_in\">alias</span> /&gt; 标签定义</span><br><span class=\"line\">      // &lt;<span class=\"built_in\">alias</span> name=<span class=\"string\">\"fromName\"</span> <span class=\"built_in\">alias</span>=<span class=\"string\">\"toName\"</span>/&gt;</span><br><span class=\"line\">      processAliasRegistration(ele);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class=\"line\">      // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧</span><br><span class=\"line\">      processBeanDefinition(ele, delegate);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class=\"line\">      // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span><br><span class=\"line\">      doRegisterBeanDefinitions(ele);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <bean /> 标签出来说。</p>\n<p><strong>processBeanDefinition 解析 bean 标签</strong><br>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p>\n<p>// DefaultBeanDefinitionDocumentReader 298</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class=\"line\">   // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看</span><br><span class=\"line\">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (bdHolder != null) &#123;</span><br><span class=\"line\">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         // Register the final decorated instance.</span><br><span class=\"line\">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      catch (BeanDefinitionStoreException ex) &#123;</span><br><span class=\"line\">         getReaderContext().error(<span class=\"string\">\"Failed to register bean definition with name '\"</span> +</span><br><span class=\"line\">               bdHolder.getBeanName() + <span class=\"string\">\"'\"</span>, ele, ex);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // Send registration event.</span><br><span class=\"line\">      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续往下看怎么解析之前，我们先看下 <code>&lt;bean /&gt;</code> 标签中可以定义哪些属性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Property</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">class</td>\n<td align=\"center\">类的全限定名</td>\n</tr>\n<tr>\n<td align=\"center\">name</td>\n<td align=\"center\">可指定 id、name(用逗号、分号、空格分隔)</td>\n</tr>\n<tr>\n<td align=\"center\">scope</td>\n<td align=\"center\">作用域</td>\n</tr>\n<tr>\n<td align=\"center\">constructor arguments</td>\n<td align=\"center\">指定构造参数</td>\n</tr>\n<tr>\n<td align=\"center\">properties</td>\n<td align=\"center\">设置属性的值</td>\n</tr>\n<tr>\n<td align=\"center\">autowiring mode</td>\n<td align=\"center\">no(默认值)、byName、byType、 constructor</td>\n</tr>\n<tr>\n<td align=\"center\">lazy-initialization mode</td>\n<td align=\"center\">是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td>\n</tr>\n<tr>\n<td align=\"center\">initialization method</td>\n<td align=\"center\">bean 属性设置完成后，会调用这个方法</td>\n</tr>\n<tr>\n<td align=\"center\">destruction method</td>\n<td align=\"center\">bean 销毁后的回调方法</td>\n</tr>\n</tbody></table>\n<p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p>\n<p>简单地说就是像下面这样子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"exampleBean\"</span> name=<span class=\"string\">\"name1, name2, name3\"</span> class=<span class=\"string\">\"com.loonycoder.ExampleBean\"</span></span><br><span class=\"line\">      scope=<span class=\"string\">\"singleton\"</span> lazy-init=<span class=\"string\">\"true\"</span> init-method=<span class=\"string\">\"init\"</span> destroy-method=<span class=\"string\">\"cleanup\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 可以用下面三种形式指定构造参数 --&gt;</span><br><span class=\"line\">    &lt;constructor-arg <span class=\"built_in\">type</span>=<span class=\"string\">\"int\"</span> value=<span class=\"string\">\"7500000\"</span>/&gt;</span><br><span class=\"line\">    &lt;constructor-arg name=<span class=\"string\">\"years\"</span> value=<span class=\"string\">\"7500000\"</span>/&gt;</span><br><span class=\"line\">    &lt;constructor-arg index=<span class=\"string\">\"0\"</span> value=<span class=\"string\">\"7500000\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- property 的几种情况 --&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"beanOne\"</span>&gt;</span><br><span class=\"line\">        &lt;ref bean=<span class=\"string\">\"anotherExampleBean\"</span>/&gt;</span><br><span class=\"line\">    &lt;/property&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"beanTwo\"</span> ref=<span class=\"string\">\"yetAnotherBean\"</span>/&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"integerProperty\"</span> value=<span class=\"string\">\"1\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;、&lt;replaced-method /&gt;、&lt;meta /&gt;、&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p>\n<p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p>\n<p>// BeanDefinitionParserDelegate 428</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> parseBeanDefinitionElement(ele, null);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class=\"line\">   String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class=\"line\">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class=\"line\"></span><br><span class=\"line\">   List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span><br><span class=\"line\">   // 当然，如果你不定义 name 属性的话，就是空的了</span><br><span class=\"line\">   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class=\"line\">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class=\"line\">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   String beanName = id;</span><br><span class=\"line\">   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class=\"line\">      beanName = aliases.remove(0);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">         logger.debug(<span class=\"string\">\"No XML 'id' specified - using '\"</span> + beanName +</span><br><span class=\"line\">               <span class=\"string\">\"' as bean name and \"</span> + aliases + <span class=\"string\">\" as aliases\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (containingBean == null) &#123;</span><br><span class=\"line\">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span><br><span class=\"line\">   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。</span><br><span class=\"line\">   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanDefinition != null) &#123;</span><br><span class=\"line\">      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span><br><span class=\"line\">      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class=\"line\">         try &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (containingBean != null) &#123;// 按照我们的思路，这里 containingBean 是 null 的</span><br><span class=\"line\">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class=\"line\">                     beanDefinition, this.readerContext.getRegistry(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：</span><br><span class=\"line\">               //   1. beanName 为：com.loonycoder.service.MessageServiceImpl<span class=\"comment\">#0</span></span><br><span class=\"line\">               //   2. beanClassName 为：com.loonycoder.service.MessageServiceImpl</span><br><span class=\"line\"></span><br><span class=\"line\">               beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class=\"line\"></span><br><span class=\"line\">               String beanClassName = beanDefinition.getBeanClassName();</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (beanClassName != null &amp;&amp;</span><br><span class=\"line\">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class=\"line\">                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class=\"line\">                  // 把 beanClassName 设置为 Bean 的别名</span><br><span class=\"line\">                  aliases.add(beanClassName);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">               logger.debug(<span class=\"string\">\"Neither XML 'id' nor 'name' specified - \"</span> +</span><br><span class=\"line\">                     <span class=\"string\">\"using generated bean name [\"</span> + beanName + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         catch (Exception ex) &#123;</span><br><span class=\"line\">            error(ex.getMessage(), ele);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class=\"line\">      // 返回 BeanDefinitionHolder</span><br><span class=\"line\">      <span class=\"built_in\">return</span> new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class=\"line\">      Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   this.parseState.push(new BeanEntry(beanName));</span><br><span class=\"line\"></span><br><span class=\"line\">   String className = null;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class=\"line\">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      String parent = null;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class=\"line\">         parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span><br><span class=\"line\">      AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span><br><span class=\"line\">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class=\"line\">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class=\"line\"></span><br><span class=\"line\">      /**</span><br><span class=\"line\">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span><br><span class=\"line\">       * 解析出来以后的信息都放到 bd 的属性中</span><br><span class=\"line\">       */</span><br><span class=\"line\"></span><br><span class=\"line\">      // 解析 &lt;meta /&gt;</span><br><span class=\"line\">      parseMetaElements(ele, bd);</span><br><span class=\"line\">      // 解析 &lt;lookup-method /&gt;</span><br><span class=\"line\">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class=\"line\">      // 解析 &lt;replaced-method /&gt;</span><br><span class=\"line\">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class=\"line\">    // 解析 &lt;constructor-arg /&gt;</span><br><span class=\"line\">      parseConstructorArgElements(ele, bd);</span><br><span class=\"line\">      // 解析 &lt;property /&gt;</span><br><span class=\"line\">      parsePropertyElements(ele, bd);</span><br><span class=\"line\">      // 解析 &lt;qualifier /&gt;</span><br><span class=\"line\">      parseQualifierElements(ele, bd);</span><br><span class=\"line\"></span><br><span class=\"line\">      bd.setResource(this.readerContext.getResource());</span><br><span class=\"line\">      bd.setSource(extractSource(ele));</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">return</span> bd;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">      error(<span class=\"string\">\"Bean class [\"</span> + className + <span class=\"string\">\"] not found\"</span>, ele, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (NoClassDefFoundError err) &#123;</span><br><span class=\"line\">      error(<span class=\"string\">\"Class that bean class [\"</span> + className + <span class=\"string\">\"] depends on not found\"</span>, ele, err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (Throwable ex) &#123;</span><br><span class=\"line\">      error(<span class=\"string\">\"Unexpected failure during bean definition parsing\"</span>, ele, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   finally &#123;</span><br><span class=\"line\">      this.parseState.pop();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p>\n<p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class=\"line\">   // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span><br><span class=\"line\">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (bdHolder != null) &#123;</span><br><span class=\"line\">      // 如果有自定义属性的话，进行相应的解析，先忽略</span><br><span class=\"line\">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         // 我们把这步叫做 注册Bean 吧</span><br><span class=\"line\">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      catch (BeanDefinitionStoreException ex) &#123;</span><br><span class=\"line\">         getReaderContext().error(<span class=\"string\">\"Failed to register bean definition with name '\"</span> +</span><br><span class=\"line\">               bdHolder.getBeanName() + <span class=\"string\">\"'\"</span>, ele, ex);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 注册完成后，发送事件，本文不展开说这个</span><br><span class=\"line\">      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BeanDefinitionHolder implements BeanMetadataElement &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  private final BeanDefinition beanDefinition;</span><br><span class=\"line\"></span><br><span class=\"line\">  private final String beanName;</span><br><span class=\"line\"></span><br><span class=\"line\">  private final String[] aliases;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p>\n<p>下面，我们开始说说注册 Bean 吧。</p>\n<p><strong>注册 Bean</strong><br>// BeanDefinitionReaderUtils 143</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void registerBeanDefinition(</span><br><span class=\"line\">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class=\"line\">      throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   String beanName = definitionHolder.getBeanName();</span><br><span class=\"line\">   // 注册这个 Bean</span><br><span class=\"line\">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span><br><span class=\"line\">   String[] aliases = definitionHolder.getAliases();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (aliases != null) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (String <span class=\"built_in\">alias</span> : aliases) &#123;</span><br><span class=\"line\">         // <span class=\"built_in\">alias</span> -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span><br><span class=\"line\">         // 获取的时候，会先将 <span class=\"built_in\">alias</span> 转换为 beanName，然后再查找</span><br><span class=\"line\">         registry.registerAlias(beanName, <span class=\"built_in\">alias</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p>\n<p>// DefaultListableBeanFactory 793</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class=\"line\">      throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   Assert.hasText(beanName, <span class=\"string\">\"Bean name must not be empty\"</span>);</span><br><span class=\"line\">   Assert.notNull(beanDefinition, <span class=\"string\">\"BeanDefinition must not be null\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class=\"line\">         throw new BeanDefinitionStoreException(...);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span><br><span class=\"line\">   BeanDefinition oldBeanDefinition;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span><br><span class=\"line\">   oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 处理重复名称的 Bean 定义的情况</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (oldBeanDefinition != null) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class=\"line\">         // 如果不允许覆盖的话，抛异常</span><br><span class=\"line\">         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class=\"line\">         // <span class=\"built_in\">log</span>...用框架定义的 Bean 覆盖用户自定义的 Bean </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class=\"line\">         // <span class=\"built_in\">log</span>...用新的 Bean 覆盖旧的 Bean</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         // <span class=\"built_in\">log</span>...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 <span class=\"literal\">true</span> 的 Bean</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 覆盖</span><br><span class=\"line\">      this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      // 判断是否已经有其他的 Bean 开始初始化了.</span><br><span class=\"line\">      // 注意，<span class=\"string\">\"注册Bean\"</span> 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span><br><span class=\"line\">      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class=\"line\">         // Cannot modify startup-time collection elements anymore (<span class=\"keyword\">for</span> stable iteration)</span><br><span class=\"line\">         synchronized (this.beanDefinitionMap) &#123;</span><br><span class=\"line\">            this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class=\"line\">            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class=\"line\">            updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class=\"line\">            updatedDefinitions.add(beanName);</span><br><span class=\"line\">            this.beanDefinitionNames = updatedDefinitions;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class=\"line\">               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);</span><br><span class=\"line\">               updatedSingletons.remove(beanName);</span><br><span class=\"line\">               this.manualSingletonNames = updatedSingletons;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         // 最正常的应该是进到这个分支。</span><br><span class=\"line\"></span><br><span class=\"line\">         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span><br><span class=\"line\">         this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class=\"line\">         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span><br><span class=\"line\">         this.beanDefinitionNames.add(beanName);</span><br><span class=\"line\">         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span><br><span class=\"line\">         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span><br><span class=\"line\">         // 手动指的是通过调用以下方法注册的 bean ：</span><br><span class=\"line\">         //     registerSingleton(String beanName, Object singletonObject)</span><br><span class=\"line\">         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面<span class=\"string\">\"手动\"</span>注册一些 Bean，</span><br><span class=\"line\">         // 如 <span class=\"string\">\"environment\"</span>、<span class=\"string\">\"systemProperties\"</span> 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span><br><span class=\"line\">         this.manualSingletonNames.remove(beanName);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 这个不重要，在预初始化的时候会用到，不必管它。</span><br><span class=\"line\">      this.frozenBeanDefinitionNames = null;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (oldBeanDefinition != null || containsSingleton(beanName)) &#123;</span><br><span class=\"line\">      resetBeanDefinition(beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>\n<p>——— 分割线 ———</p>\n<p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p>\n<h4 id=\"Bean-容器实例化完成后\"><a href=\"#Bean-容器实例化完成后\" class=\"headerlink\" title=\"Bean 容器实例化完成后\"></a>Bean 容器实例化完成后</h4><p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p>\n<p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class=\"line\">   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span><br><span class=\"line\">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class=\"line\">      prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class=\"line\">      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class=\"line\">      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class=\"line\">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class=\"line\">      // 这块待会会展开说</span><br><span class=\"line\">      prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class=\"line\">         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class=\"line\"></span><br><span class=\"line\">         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class=\"line\">         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class=\"line\">         postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span><br><span class=\"line\">         invokeBeanFactoryPostProcessors(beanFactory);          </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class=\"line\">         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class=\"line\">         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span><br><span class=\"line\">         registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class=\"line\">         initMessageSource();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class=\"line\">         initApplicationEventMulticaster();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span><br><span class=\"line\">         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class=\"line\">         onRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class=\"line\">         registerListeners();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 重点，重点，重点</span><br><span class=\"line\">         // 初始化所有的 singleton beans</span><br><span class=\"line\">         //（lazy-init 的除外）</span><br><span class=\"line\">         finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 最后，广播事件，ApplicationContext 初始化完成，不展开</span><br><span class=\"line\">         finishRefresh();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      catch (BeansException ex) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"Exception encountered during context initialization - \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"cancelling refresh attempt: \"</span> + ex);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         // Destroy already created singletons to avoid dangling resources.</span><br><span class=\"line\">         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class=\"line\">         destroyBeans();</span><br><span class=\"line\"></span><br><span class=\"line\">         // Reset <span class=\"string\">'active'</span> flag.</span><br><span class=\"line\">         cancelRefresh(ex);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 把异常往外抛</span><br><span class=\"line\">         throw ex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      finally &#123;</span><br><span class=\"line\">         // Reset common introspection caches <span class=\"keyword\">in</span> Spring<span class=\"string\">'s core, since we</span></span><br><span class=\"line\"><span class=\"string\">         // might not ever need metadata for singleton beans anymore...</span></span><br><span class=\"line\"><span class=\"string\">         resetCommonCaches();</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">   &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"准备-Bean-容器-prepareBeanFactory\"><a href=\"#准备-Bean-容器-prepareBeanFactory\" class=\"headerlink\" title=\"准备 Bean 容器: prepareBeanFactory\"></a>准备 Bean 容器: prepareBeanFactory</h4><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p>\n<p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Configure the factory<span class=\"string\">'s standard context characteristics,</span></span><br><span class=\"line\"><span class=\"string\"> * such as the context'</span>s ClassLoader and post-processors.</span><br><span class=\"line\"> * @param beanFactory the BeanFactory to configure</span><br><span class=\"line\"> */</span><br><span class=\"line\">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class=\"line\">   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span><br><span class=\"line\">   // 这里设置为加载当前 ApplicationContext 类的类加载器</span><br><span class=\"line\">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置 BeanExpressionResolver</span><br><span class=\"line\">   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">   // </span><br><span class=\"line\">   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class=\"line\"></span><br><span class=\"line\">   // 添加一个 BeanPostProcessor，这个 processor 比较简单：</span><br><span class=\"line\">   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span><br><span class=\"line\">   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span><br><span class=\"line\">   // 注意：它不仅仅回调 ApplicationContextAware，</span><br><span class=\"line\">   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span><br><span class=\"line\">   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class=\"line\"></span><br><span class=\"line\">   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span><br><span class=\"line\">   // Spring 会通过其他方式来处理这些依赖。</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class=\"line\"></span><br><span class=\"line\">   /**</span><br><span class=\"line\">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span><br><span class=\"line\">    * 之前我们说过，<span class=\"string\">\"当前 ApplicationContext 持有一个 BeanFactory\"</span>，这里解释了第一行。</span><br><span class=\"line\">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span><br><span class=\"line\">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span><br><span class=\"line\">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span><br><span class=\"line\">    */</span><br><span class=\"line\">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class=\"line\">   beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class=\"line\">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class=\"line\">   beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span><br><span class=\"line\">   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span><br><span class=\"line\">   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class=\"line\"></span><br><span class=\"line\">   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span><br><span class=\"line\">   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class=\"line\">      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class=\"line\">      // Set a temporary ClassLoader <span class=\"keyword\">for</span> <span class=\"built_in\">type</span> matching.</span><br><span class=\"line\">      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   /**</span><br><span class=\"line\">    * 从下面几行代码我们可以知道，Spring 往往很 <span class=\"string\">\"智能\"</span> 就是因为它会帮我们默认注册一些有用的 bean，</span><br><span class=\"line\">    * 我们也可以选择覆盖</span><br><span class=\"line\">    */</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果没有定义 <span class=\"string\">\"environment\"</span> 这个 bean，那么 Spring 会 <span class=\"string\">\"手动\"</span> 注册一个</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 如果没有定义 <span class=\"string\">\"systemProperties\"</span> 这个 bean，那么 Spring 会 <span class=\"string\">\"手动\"</span> 注册一个</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class=\"line\">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 如果没有定义 <span class=\"string\">\"systemEnvironment\"</span> 这个 bean，那么 Spring 会 <span class=\"string\">\"手动\"</span> 注册一个</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p>\n<h4 id=\"初始化所有的-singleton-beans\"><a href=\"#初始化所有的-singleton-beans\" class=\"headerlink\" title=\"初始化所有的 singleton beans\"></a>初始化所有的 singleton beans</h4><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p>\n<p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p>\n<p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p>\n<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。<br>// AbstractApplicationContext.java 834</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 初始化剩余的 singleton beans</span><br><span class=\"line\">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span><br><span class=\"line\">   // 什么，看代码这里没有初始化 Bean 啊！</span><br><span class=\"line\">   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class=\"line\">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class=\"line\">      beanFactory.setConversionService(</span><br><span class=\"line\">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Register a default embedded value resolver <span class=\"keyword\">if</span> no bean post-processor</span><br><span class=\"line\">   // (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class=\"line\">   // at this point, primarily <span class=\"keyword\">for</span> resolution <span class=\"keyword\">in</span> annotation attribute values.</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class=\"line\">      beanFactory.addEmbeddedValueResolver(new <span class=\"function\"><span class=\"title\">StringValueResolver</span></span>() &#123;</span><br><span class=\"line\">         @Override</span><br><span class=\"line\">         public String resolveStringValue(String strVal) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 先初始化 LoadTimeWeaverAware 类型的 Bean</span><br><span class=\"line\">   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span><br><span class=\"line\">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class=\"line\">      getBean(weaverAwareName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Stop using the temporary ClassLoader <span class=\"keyword\">for</span> <span class=\"built_in\">type</span> matching.</span><br><span class=\"line\">   beanFactory.setTempClassLoader(null);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span><br><span class=\"line\">   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span><br><span class=\"line\">   beanFactory.freezeConfiguration();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 开始初始化</span><br><span class=\"line\">   beanFactory.preInstantiateSingletons();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p>\n<p><strong>preInstantiateSingletons</strong><br>// DefaultListableBeanFactory 728</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (this.logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      this.logger.debug(<span class=\"string\">\"Pre-instantiating singletons in \"</span> + this);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // this.beanDefinitionNames 保存了所有的 beanNames</span><br><span class=\"line\">   List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (String beanName : beanNames) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 合并父 Bean 中的配置，注意 &lt;bean id=<span class=\"string\">\"\"</span> class=<span class=\"string\">\"\"</span> parent=<span class=\"string\">\"\"</span> /&gt; 中的 parent，用的不多吧，</span><br><span class=\"line\">      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 <span class=\"string\">\"Bean 继承\"</span>，不了解的请到附录中看一下</span><br><span class=\"line\">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 非抽象、非懒加载的 singletons。如果配置了 <span class=\"string\">'abstract = true'</span>，那是不需要初始化的</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class=\"line\">         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class=\"line\">            // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span><br><span class=\"line\">            final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class=\"line\">            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span><br><span class=\"line\">            boolean isEagerInit;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class=\"line\">               isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class=\"line\">                  @Override</span><br><span class=\"line\">                  public Boolean <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">                     <span class=\"built_in\">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">               &#125;, getAccessControlContext());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class=\"line\">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isEagerInit) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">               getBean(beanName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span><br><span class=\"line\">            getBean(beanName);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span><br><span class=\"line\">   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (String beanName : beanNames) &#123;</span><br><span class=\"line\">      Object singletonInstance = getSingleton(beanName);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class=\"line\">         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class=\"line\">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class=\"line\">               @Override</span><br><span class=\"line\">               public Object <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class=\"line\">                  <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;, getAccessControlContext());</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            smartSingleton.afterSingletonsInstantiated();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p>\n<p><strong>getBean</strong><br>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p>\n<p>// AbstractBeanFactory 196</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Object getBean(String name) throws BeansException &#123;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> doGetBean(name, null, null, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span><br><span class=\"line\">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span><br><span class=\"line\">@SuppressWarnings(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">protected &lt;T&gt; T doGetBean(</span><br><span class=\"line\">      final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class=\"line\">      throws BeansException &#123;</span><br><span class=\"line\">   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span><br><span class=\"line\">   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span><br><span class=\"line\">   final String beanName = transformedBeanName(name);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 注意跟着这个，这个是返回值</span><br><span class=\"line\">   Object bean; </span><br><span class=\"line\"></span><br><span class=\"line\">   // 检查下是不是已经创建过了</span><br><span class=\"line\">   Object sharedInstance = getSingleton(beanName);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span><br><span class=\"line\">   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"...\"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"Returning cached instance of singleton bean '\"</span> + beanName + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span><br><span class=\"line\">      // 如果是 FactoryBean 的话，返回它创建的那个实例对象</span><br><span class=\"line\">      // (FactoryBean 知识，读者若不清楚请移步附录)</span><br><span class=\"line\">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span><br><span class=\"line\">         // 往往是因为陷入了循环引用</span><br><span class=\"line\">         throw new BeanCurrentlyInCreationException(beanName);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 检查一下这个 BeanDefinition 在容器中是否存在</span><br><span class=\"line\">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class=\"line\">         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span><br><span class=\"line\">         String nameToLookup = originalBeanName(name);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (args != null) &#123;</span><br><span class=\"line\">            // 返回父容器的查询结果</span><br><span class=\"line\">            <span class=\"built_in\">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // No args -&gt; delegate to standard getBean method.</span><br><span class=\"line\">            <span class=\"built_in\">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!typeCheckOnly) &#123;</span><br><span class=\"line\">         // typeCheckOnly 为 <span class=\"literal\">false</span>，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span><br><span class=\"line\">         markBeanAsCreated(beanName);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*</span><br><span class=\"line\">       * 稍稍总结一下：</span><br><span class=\"line\">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span><br><span class=\"line\">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span><br><span class=\"line\">       */</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class=\"line\">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 先初始化依赖的所有 Bean，这个很好理解。</span><br><span class=\"line\">         // 注意，这里的依赖指的是 depends-on 中定义的依赖</span><br><span class=\"line\">         String[] dependsOn = mbd.getDependsOn();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (dependsOn != null) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String dep : dependsOn) &#123;</span><br><span class=\"line\">               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class=\"line\">                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class=\"line\">                        <span class=\"string\">\"'Circular depends-on relationship between '\"</span> + beanName + <span class=\"string\">\"' and '\"</span> + dep + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               // 注册一下依赖关系</span><br><span class=\"line\">               registerDependentBean(dep, beanName);</span><br><span class=\"line\">               // 先初始化被依赖项</span><br><span class=\"line\">               getBean(dep);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         // 如果是 singleton scope 的，创建 singleton 的实例</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mbd.isSingleton()) &#123;</span><br><span class=\"line\">            sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class=\"line\">               @Override</span><br><span class=\"line\">               public Object getObject() throws BeansException &#123;</span><br><span class=\"line\">                  try &#123;</span><br><span class=\"line\">                     // 执行创建 Bean，详情后面再说</span><br><span class=\"line\">                     <span class=\"built_in\">return</span> createBean(beanName, mbd, args);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  catch (BeansException ex) &#123;</span><br><span class=\"line\">                     destroySingleton(beanName);</span><br><span class=\"line\">                     throw ex;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         // 如果是 prototype scope 的，创建 prototype 的实例</span><br><span class=\"line\">         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mbd.isPrototype()) &#123;</span><br><span class=\"line\">            // It’s a prototype -&gt; create a new instance.</span><br><span class=\"line\">            Object prototypeInstance = null;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">               beforePrototypeCreation(beanName);</span><br><span class=\"line\">               // 执行创建 Bean</span><br><span class=\"line\">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            finally &#123;</span><br><span class=\"line\">               afterPrototypeCreation(beanName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String scopeName = mbd.getScope();</span><br><span class=\"line\">            final Scope scope = this.scopes.get(scopeName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (scope == null) &#123;</span><br><span class=\"line\">               throw new IllegalStateException(<span class=\"string\">\"No Scope registered for scope name '\"</span> + scopeName + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">               Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class=\"line\">                  @Override</span><br><span class=\"line\">                  public Object getObject() throws BeansException &#123;</span><br><span class=\"line\">                     beforePrototypeCreation(beanName);</span><br><span class=\"line\">                     try &#123;</span><br><span class=\"line\">                        // 执行创建 Bean</span><br><span class=\"line\">                        <span class=\"built_in\">return</span> createBean(beanName, mbd, args);</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\">                     finally &#123;</span><br><span class=\"line\">                        afterPrototypeCreation(beanName);</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (IllegalStateException ex) &#123;</span><br><span class=\"line\">               throw new BeanCreationException(beanName,</span><br><span class=\"line\">                     <span class=\"string\">\"Scope '\"</span> + scopeName + <span class=\"string\">\"' is not active for the current thread; consider \"</span> +</span><br><span class=\"line\">                     <span class=\"string\">\"defining a scoped proxy for this bean if you intend to refer to it from a singleton\"</span>,</span><br><span class=\"line\">                     ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      catch (BeansException ex) &#123;</span><br><span class=\"line\">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class=\"line\">         throw ex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         <span class=\"built_in\">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      catch (TypeMismatchException ex) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"Failed to convert bean '\"</span> + name + <span class=\"string\">\"' to required type '\"</span> +</span><br><span class=\"line\">                  ClassUtils.getQualifiedName(requiredType) + <span class=\"string\">\"'\"</span>, ex);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> (T) bean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;</span><br></pre></td></tr></table></figure>\n<p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p>\n<p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p>\n<p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MessageServiceImpl implements MessageService &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getMessage</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> userService.getMessage();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"messageService\"</span> class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p>\n<p>好了，读者要知道这么回事就可以了，继续向前。</p>\n<p>// AbstractAutowireCapableBeanFactory 447</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Central method of this class: creates a bean instance,</span><br><span class=\"line\"> * populates the bean instance, applies post-processors, etc.</span><br><span class=\"line\"> * @see <span class=\"comment\">#doCreateBean</span></span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      logger.debug(<span class=\"string\">\"Creating instance of bean '\"</span> + beanName + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   RootBeanDefinition mbdToUse = mbd;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 确保 BeanDefinition 中的 Class 被加载</span><br><span class=\"line\">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class=\"line\">      mbdToUse = new RootBeanDefinition(mbd);</span><br><span class=\"line\">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; </span><br><span class=\"line\">   // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span><br><span class=\"line\">   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      mbdToUse.prepareMethodOverrides();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (BeanDefinitionValidationException ex) &#123;</span><br><span class=\"line\">      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class=\"line\">            beanName, <span class=\"string\">\"Validation of method overrides failed\"</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span><br><span class=\"line\">      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过</span><br><span class=\"line\">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (bean != null) &#123;</span><br><span class=\"line\">         <span class=\"built_in\">return</span> bean; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (Throwable ex) &#123;</span><br><span class=\"line\">      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class=\"line\">            <span class=\"string\">\"BeanPostProcessor before instantiation of bean failed\"</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 重头戏，创建 bean</span><br><span class=\"line\">   Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      logger.debug(<span class=\"string\">\"Finished creating instance of bean '\"</span> + beanName + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> beanInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建Bean</strong><br>我们继续往里看 doCreateBean 这个方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Actually create the specified bean. Pre-creation processing has already happened</span><br><span class=\"line\"> * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks.</span><br><span class=\"line\"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span><br><span class=\"line\"> * factory method, and autowiring a constructor.</span><br><span class=\"line\"> * @param beanName the name of the bean</span><br><span class=\"line\"> * @param mbd the merged bean definition <span class=\"keyword\">for</span> the bean</span><br><span class=\"line\"> * @param args explicit arguments to use <span class=\"keyword\">for</span> constructor or factory method invocation</span><br><span class=\"line\"> * @<span class=\"built_in\">return</span> a new instance of the bean</span><br><span class=\"line\"> * @throws BeanCreationException <span class=\"keyword\">if</span> the bean could not be created</span><br><span class=\"line\"> * @see <span class=\"comment\">#instantiateBean</span></span><br><span class=\"line\"> * @see <span class=\"comment\">#instantiateUsingFactoryMethod</span></span><br><span class=\"line\"> * @see <span class=\"comment\">#autowireConstructor</span></span><br><span class=\"line\"> */</span><br><span class=\"line\">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</span><br><span class=\"line\">      throws BeanCreationException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Instantiate the bean.</span><br><span class=\"line\">   BeanWrapper instanceWrapper = null;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (mbd.isSingleton()) &#123;</span><br><span class=\"line\">      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (instanceWrapper == null) &#123;</span><br><span class=\"line\">      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span><br><span class=\"line\">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 <span class=\"string\">\"bean 实例\"</span></span><br><span class=\"line\">   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class=\"line\">   // 类型</span><br><span class=\"line\">   Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</span><br><span class=\"line\">   mbd.resolvedTargetType = beanType;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span><br><span class=\"line\">   synchronized (mbd.postProcessingLock) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!mbd.postProcessed) &#123;</span><br><span class=\"line\">         try &#123;</span><br><span class=\"line\">            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span><br><span class=\"line\">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         catch (Throwable ex) &#123;</span><br><span class=\"line\">            throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class=\"line\">                  <span class=\"string\">\"Post-processing of merged bean definition failed\"</span>, ex);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         mbd.postProcessed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Eagerly cache singletons to be able to resolve circular references</span><br><span class=\"line\">   // even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class=\"line\">   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span><br><span class=\"line\">   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class=\"line\">         isSingletonCurrentlyInCreation(beanName));</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (earlySingletonExposure) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">         logger.debug(<span class=\"string\">\"Eagerly caching bean '\"</span> + beanName +</span><br><span class=\"line\">               <span class=\"string\">\"' to allow for resolving potential circular references\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class=\"line\">         @Override</span><br><span class=\"line\">         public Object getObject() throws BeansException &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Initialize the bean instance.</span><br><span class=\"line\">   Object exposedObject = bean;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span><br><span class=\"line\">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (exposedObject != null) &#123;</span><br><span class=\"line\">         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span><br><span class=\"line\">         // 这里就是处理 bean 初始化完成后的各种回调</span><br><span class=\"line\">         exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (Throwable ex) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class=\"line\">         throw (BeanCreationException) ex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         throw new BeanCreationException(</span><br><span class=\"line\">               mbd.getResourceDescription(), beanName, <span class=\"string\">\"Initialization of bean failed\"</span>, ex);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (earlySingletonExposure) &#123;</span><br><span class=\"line\">      // </span><br><span class=\"line\">      Object earlySingletonReference = getSingleton(beanName, <span class=\"literal\">false</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (earlySingletonReference != null) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (exposedObject == bean) &#123;</span><br><span class=\"line\">            exposedObject = earlySingletonReference;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class=\"line\">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class=\"line\">            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class=\"line\">                  actualDependentBeans.add(dependentBean);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class=\"line\">               throw new BeanCurrentlyInCreationException(beanName,</span><br><span class=\"line\">                     <span class=\"string\">\"Bean with name '\"</span> + beanName + <span class=\"string\">\"' has been injected into other beans [\"</span> +</span><br><span class=\"line\">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class=\"line\">                     <span class=\"string\">\"] in its raw version as part of a circular reference, but has eventually been \"</span> +</span><br><span class=\"line\">                     <span class=\"string\">\"wrapped. This means that said other beans do not use the final version of the \"</span> +</span><br><span class=\"line\">                     <span class=\"string\">\"bean. This is often the result of over-eager type matching - consider using \"</span> +</span><br><span class=\"line\">                     <span class=\"string\">\"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Register bean as disposable.</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (BeanDefinitionValidationException ex) &#123;</span><br><span class=\"line\">      throw new BeanCreationException(</span><br><span class=\"line\">            mbd.getResourceDescription(), beanName, <span class=\"string\">\"Invalid destruction signature\"</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">return</span> exposedObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p>\n<p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 </p>\n<p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p>\n<p><strong>创建 Bean 实例</strong><br>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123;</span><br><span class=\"line\">   // 确保已经加载了此 class</span><br><span class=\"line\">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 校验一下这个类的访问权限</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class=\"line\">      throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class=\"line\">            <span class=\"string\">\"Bean class isn't public, and non-public access not allowed: \"</span> + beanClass.getName());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (mbd.getFactoryMethodName() != null)  &#123;</span><br><span class=\"line\">      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean</span><br><span class=\"line\">      <span class=\"built_in\">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果不是第一次创建，比如第二次创建 prototype bean。</span><br><span class=\"line\">   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span><br><span class=\"line\">   boolean resolved = <span class=\"literal\">false</span>;</span><br><span class=\"line\">   boolean autowireNecessary = <span class=\"literal\">false</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (args == null) &#123;</span><br><span class=\"line\">      synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class=\"line\">            resolved = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (resolved) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (autowireNecessary) &#123;</span><br><span class=\"line\">         // 构造函数依赖注入</span><br><span class=\"line\">         <span class=\"built_in\">return</span> autowireConstructor(beanName, mbd, null, null);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         // 无参构造函数</span><br><span class=\"line\">         <span class=\"built_in\">return</span> instantiateBean(beanName, mbd);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 判断是否采用有参构造函数</span><br><span class=\"line\">   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (ctors != null ||</span><br><span class=\"line\">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class=\"line\">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class=\"line\">      // 构造函数依赖注入</span><br><span class=\"line\">      <span class=\"built_in\">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 调用无参构造函数</span><br><span class=\"line\">   <span class=\"built_in\">return</span> instantiateBean(beanName, mbd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      Object beanInstance;</span><br><span class=\"line\">      final BeanFactory parent = this;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class=\"line\">         beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Object <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"built_in\">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;, getAccessControlContext());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         // 实例化</span><br><span class=\"line\">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 包装一下，返回</span><br><span class=\"line\">      BeanWrapper bw = new BeanWrapperImpl(beanInstance);</span><br><span class=\"line\">      initBeanWrapper(bw);</span><br><span class=\"line\">      <span class=\"built_in\">return</span> bw;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (Throwable ex) &#123;</span><br><span class=\"line\">      throw new BeanCreationException(</span><br><span class=\"line\">            mbd.getResourceDescription(), beanName, <span class=\"string\">\"Instantiation of bean failed\"</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，关键的地方在于：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure>\n<p>这里会进行实际的实例化过程，我们进去看看:</p>\n<p>// SimpleInstantiationStrategy 59</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span><br><span class=\"line\">   // 方法覆写 请参见附录<span class=\"string\">\"方法注入\"</span>中对 lookup-method 和 replaced-method 的介绍</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class=\"line\">      Constructor&lt;?&gt; constructorToUse;</span><br><span class=\"line\">      synchronized (bd.constructorArgumentLock) &#123;</span><br><span class=\"line\">         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (constructorToUse == null) &#123;</span><br><span class=\"line\">            final Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (clazz.isInterface()) &#123;</span><br><span class=\"line\">               throw new BeanInstantiationException(clazz, <span class=\"string\">\"Specified class is an interface\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class=\"line\">                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">                     @Override</span><br><span class=\"line\">                     public Constructor&lt;?&gt; run() throws Exception &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">return</span> clazz.getDeclaredConstructor((Class[]) null);</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (Throwable ex) &#123;</span><br><span class=\"line\">               throw new BeanInstantiationException(clazz, <span class=\"string\">\"No default constructor found\"</span>, ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 利用构造方法进行实例化</span><br><span class=\"line\">      <span class=\"built_in\">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span><br><span class=\"line\">      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持</span><br><span class=\"line\">      <span class=\"built_in\">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>bean 属性注入</strong><br>看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。</p>\n<p>// AbstractAutowireCapableBeanFactory 1203</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class=\"line\">   // bean 实例的所有属性都在这里了</span><br><span class=\"line\">   PropertyValues pvs = mbd.getPropertyValues();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (bw == null) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!pvs.isEmpty()) &#123;</span><br><span class=\"line\">         throw new BeanCreationException(</span><br><span class=\"line\">               mbd.getResourceDescription(), beanName, <span class=\"string\">\"Cannot apply property values to null instance\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         // Skip property population phase <span class=\"keyword\">for</span> null instance.</span><br><span class=\"line\">         <span class=\"built_in\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span><br><span class=\"line\">   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span><br><span class=\"line\">   // 我也没找到有实际的使用，所以我们暂且忽略这块吧</span><br><span class=\"line\">   boolean continueWithPropertyPopulation = <span class=\"literal\">true</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class=\"line\">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class=\"line\">            // 如果返回 <span class=\"literal\">false</span>，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class=\"line\">               continueWithPropertyPopulation = <span class=\"literal\">false</span>;</span><br><span class=\"line\">               <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class=\"line\">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class=\"line\">      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class=\"line\">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 通过类型装配。复杂一些</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class=\"line\">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      pvs = newPvs;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class=\"line\">   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class=\"line\">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (hasInstAwareBpps) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class=\"line\">               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class=\"line\">               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span><br><span class=\"line\">               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span><br><span class=\"line\">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (pvs == null) &#123;</span><br><span class=\"line\">                  <span class=\"built_in\">return</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (needsDepCheck) &#123;</span><br><span class=\"line\">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 设置 bean 实例的属性值</span><br><span class=\"line\">   applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>initializeBean</strong><br>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class=\"line\">      AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class=\"line\">         @Override</span><br><span class=\"line\">         public Object <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">            invokeAwareMethods(beanName, bean);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;, getAccessControlContext());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span><br><span class=\"line\">      invokeAwareMethods(beanName, bean);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   Object wrappedBean = bean;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class=\"line\">      // BeanPostProcessor 的 postProcessBeforeInitialization 回调</span><br><span class=\"line\">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      // 处理 bean 中定义的 init-method，</span><br><span class=\"line\">      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span><br><span class=\"line\">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (Throwable ex) &#123;</span><br><span class=\"line\">      throw new BeanCreationException(</span><br><span class=\"line\">            (mbd != null ? mbd.getResourceDescription() : null),</span><br><span class=\"line\">            beanName, <span class=\"string\">\"Invocation of init method failed\"</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class=\"line\">      // BeanPostProcessor 的 postProcessAfterInitialization 回调</span><br><span class=\"line\">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> wrappedBean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p>\n<hr>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><h4 id=\"id和name\"><a href=\"#id和name\" class=\"headerlink\" title=\"id和name\"></a>id和name</h4><p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p>\n<p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beanFactory.getBean(<span class=\"string\">\"beanName or alias\"</span>);</span><br></pre></td></tr></table></figure>\n<p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"messageService\"</span> name=<span class=\"string\">\"m1, m2, m3\"</span> class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean name=<span class=\"string\">\"m1, m2, m3\"</span> class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>beanName 为：com.loonycoder.service.MessageServiceImpl#0，</p>\n<p>别名 1 个，为： com.loonycoder.service.MessageServiceImpl</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"messageService\"</span> class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>以上配置的结果就是：beanName 为 messageService，没有别名。</p>\n<h4 id=\"配置是否允许-Bean-覆盖、是否允许循环依赖\"><a href=\"#配置是否允许-Bean-覆盖、是否允许循环依赖\" class=\"headerlink\" title=\"配置是否允许 Bean 覆盖、是否允许循环依赖\"></a>配置是否允许 Bean 覆盖、是否允许循环依赖</h4><p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>\n<p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p>\n<p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p>\n<p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p>\n<p>添加这两个属性的作者 Juergen Hoeller 在这个 jira 的讨论中说明了怎么配置这两个属性。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NoBeanOverridingContextLoader extends ContextLoader &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) &#123;</span><br><span class=\"line\">    super.customizeContext(servletContext, applicationContext);</span><br><span class=\"line\">    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;</span><br><span class=\"line\">    arac.setAllowBeanDefinitionOverriding(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  protected ContextLoader <span class=\"function\"><span class=\"title\">createContextLoader</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new NoBeanOverridingContextLoader();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;listener&gt;</span><br><span class=\"line\">    &lt;listener-class&gt;com.loonycoder.MyContextLoaderListener&lt;/listener-class&gt;  </span><br><span class=\"line\">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"profile\"><a href=\"#profile\" class=\"headerlink\" title=\"profile\"></a>profile</h4><p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans profile=<span class=\"string\">\"development\"</span></span><br><span class=\"line\">    xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">    xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">    xmlns:jdbc=<span class=\"string\">\"http://www.springframework.org/schema/jdbc\"</span></span><br><span class=\"line\">    xsi:schemaLocation=<span class=\"string\">\"...\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;jdbc:embedded-database id=<span class=\"string\">\"dataSource\"</span>&gt;</span><br><span class=\"line\">        &lt;jdbc:script location=<span class=\"string\">\"classpath:com/loonycoder/config/sql/schema.sql\"</span>/&gt;</span><br><span class=\"line\">        &lt;jdbc:script location=<span class=\"string\">\"classpath:com/oonycoder/config/sql/test-data.sql\"</span>/&gt;</span><br><span class=\"line\">    &lt;/jdbc:embedded-database&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans profile=<span class=\"string\">\"production\"</span></span><br><span class=\"line\">    xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">    xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">    xmlns:jee=<span class=\"string\">\"http://www.springframework.org/schema/jee\"</span></span><br><span class=\"line\">    xsi:schemaLocation=<span class=\"string\">\"...\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;jee:jndi-lookup id=<span class=\"string\">\"dataSource\"</span> jndi-name=<span class=\"string\">\"java:comp/env/jdbc/datasource\"</span>/&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<p>应该不必做过多解释了吧，看每个文件第一行的 profile=””。</p>\n<p>当然，我们也可以在一个配置文件中使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">    xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">    xmlns:jdbc=<span class=\"string\">\"http://www.springframework.org/schema/jdbc\"</span></span><br><span class=\"line\">    xmlns:jee=<span class=\"string\">\"http://www.springframework.org/schema/jee\"</span></span><br><span class=\"line\">    xsi:schemaLocation=<span class=\"string\">\"...\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;beans profile=<span class=\"string\">\"development\"</span>&gt;</span><br><span class=\"line\">        &lt;jdbc:embedded-database id=<span class=\"string\">\"dataSource\"</span>&gt;</span><br><span class=\"line\">            &lt;jdbc:script location=<span class=\"string\">\"classpath:com/loonycoder/config/sql/schema.sql\"</span>/&gt;</span><br><span class=\"line\">            &lt;jdbc:script location=<span class=\"string\">\"classpath:com/loonycoder/config/sql/test-data.sql\"</span>/&gt;</span><br><span class=\"line\">        &lt;/jdbc:embedded-database&gt;</span><br><span class=\"line\">    &lt;/beans&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;beans profile=<span class=\"string\">\"production\"</span>&gt;</span><br><span class=\"line\">        &lt;jee:jndi-lookup id=<span class=\"string\">\"dataSource\"</span> jndi-name=<span class=\"string\">\"java:comp/env/jdbc/datasource\"</span>/&gt;</span><br><span class=\"line\">    &lt;/beans&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<p>理解起来也很简单吧。</p>\n<p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p>\n<p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p>\n<p>最简单的方式莫过于在程序启动的时候指定：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dspring.profiles.active=<span class=\"string\">\"profile1,profile2\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>profile 可以激活多个</p>\n</blockquote>\n<p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class=\"line\">ctx.getEnvironment().setActiveProfiles(<span class=\"string\">\"development\"</span>);</span><br><span class=\"line\">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class=\"line\">ctx.refresh(); // 重启</span><br></pre></td></tr></table></figure>\n<p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Dspring.profiles.active=prod -jar JavaDoop.jar</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"工厂模式生成-Bean\"><a href=\"#工厂模式生成-Bean\" class=\"headerlink\" title=\"工厂模式生成 Bean\"></a>工厂模式生成 Bean</h4><p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p>\n<p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p>\n<p>静态工厂：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"clientService\"</span></span><br><span class=\"line\">    class=<span class=\"string\">\"examples.ClientService\"</span></span><br><span class=\"line\">    factory-method=<span class=\"string\">\"createInstance\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ClientService &#123;</span><br><span class=\"line\">    private static ClientService clientService = new ClientService();</span><br><span class=\"line\">    private <span class=\"function\"><span class=\"title\">ClientService</span></span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 静态方法</span><br><span class=\"line\">    public static ClientService <span class=\"function\"><span class=\"title\">createInstance</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> clientService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实例工厂：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"serviceLocator\"</span> class=<span class=\"string\">\"examples.DefaultServiceLocator\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"clientService\"</span></span><br><span class=\"line\">    factory-bean=<span class=\"string\">\"serviceLocator\"</span></span><br><span class=\"line\">    factory-method=<span class=\"string\">\"createClientServiceInstance\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"accountService\"</span></span><br><span class=\"line\">    factory-bean=<span class=\"string\">\"serviceLocator\"</span></span><br><span class=\"line\">    factory-method=<span class=\"string\">\"createAccountServiceInstance\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DefaultServiceLocator &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class=\"line\"></span><br><span class=\"line\">    private static AccountService accountService = new AccountServiceImpl();</span><br><span class=\"line\"></span><br><span class=\"line\">    public ClientService <span class=\"function\"><span class=\"title\">createClientServiceInstance</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> clientService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public AccountService <span class=\"function\"><span class=\"title\">createAccountServiceInstance</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> accountService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"FactoryBean\"><a href=\"#FactoryBean\" class=\"headerlink\" title=\"FactoryBean\"></a>FactoryBean</h4><p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class=\"line\">    T getObject() throws Exception;</span><br><span class=\"line\">    Class&lt;T&gt; getObjectType();</span><br><span class=\"line\">    boolean isSingleton();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person &#123; </span><br><span class=\"line\">    private Car car ;</span><br><span class=\"line\">    private void setCar(Car car)&#123; this.car = car;  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;&#123;</span><br><span class=\"line\">    private String make; </span><br><span class=\"line\">    private int year ;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setMake(String m)&#123; this.make =m ; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setYear(int y)&#123; this.year = y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Car <span class=\"function\"><span class=\"title\">getObject</span></span>()&#123; </span><br><span class=\"line\">      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span><br><span class=\"line\">      CarBuilder cb = CarBuilder.car();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(year!=0) cb.setYear(this.year);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(StringUtils.hasText(this.make)) cb.setMake( this.make ); </span><br><span class=\"line\">      <span class=\"built_in\">return</span> cb.factory(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Class&lt;Car&gt; <span class=\"function\"><span class=\"title\">getObjectType</span></span>() &#123; <span class=\"built_in\">return</span> Car.class ; &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isSingleton</span></span>() &#123; <span class=\"built_in\">return</span> <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看看装配的时候是怎么配置的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean class = <span class=\"string\">\"com.loonycoder.MyCarFactoryBean\"</span> id = <span class=\"string\">\"car\"</span>&gt;</span><br><span class=\"line\">  &lt;property name = <span class=\"string\">\"make\"</span> value =<span class=\"string\">\"Honda\"</span>/&gt;</span><br><span class=\"line\">  &lt;property name = <span class=\"string\">\"year\"</span> value =<span class=\"string\">\"1994\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\">&lt;bean class = <span class=\"string\">\"com.loonycoder.Person\"</span> id = <span class=\"string\">\"josh\"</span>&gt;</span><br><span class=\"line\">  &lt;property name = <span class=\"string\">\"car\"</span> ref = <span class=\"string\">\"car\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p>\n<p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration </span><br><span class=\"line\">public class CarConfiguration &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean </span><br><span class=\"line\">    public MyCarFactoryBean <span class=\"function\"><span class=\"title\">carFactoryBean</span></span>()&#123; </span><br><span class=\"line\">      MyCarFactoryBean cfb = new MyCarFactoryBean();</span><br><span class=\"line\">      cfb.setMake(<span class=\"string\">\"Honda\"</span>);</span><br><span class=\"line\">      cfb.setYear(1994);</span><br><span class=\"line\">      <span class=\"built_in\">return</span> cfb;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Person <span class=\"function\"><span class=\"title\">aPerson</span></span>()&#123; </span><br><span class=\"line\">    Person person = new Person();</span><br><span class=\"line\">      // 注意这里的不同</span><br><span class=\"line\">    person.setCar(carFactoryBean().getObject());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> person; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p>\n<h4 id=\"初始化-Bean-的回调\"><a href=\"#初始化-Bean-的回调\" class=\"headerlink\" title=\"初始化 Bean 的回调\"></a>初始化 Bean 的回调</h4><p>有以下四种方案：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"exampleInitBean\"</span> class=<span class=\"string\">\"examples.ExampleBean\"</span> init-method=<span class=\"string\">\"init\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AnotherExampleBean implements InitializingBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">afterPropertiesSet</span></span>() &#123;</span><br><span class=\"line\">        // <span class=\"keyword\">do</span> some initialization work</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean(initMethod = <span class=\"string\">\"init\"</span>)</span><br><span class=\"line\">public Foo <span class=\"function\"><span class=\"title\">foo</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new Foo();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PostConstruct</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">init</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"销毁-Bean-的回调\"><a href=\"#销毁-Bean-的回调\" class=\"headerlink\" title=\"销毁 Bean 的回调\"></a>销毁 Bean 的回调</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"exampleInitBean\"</span> class=<span class=\"string\">\"examples.ExampleBean\"</span> destroy-method=<span class=\"string\">\"cleanup\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AnotherExampleBean implements DisposableBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">destroy</span></span>() &#123;</span><br><span class=\"line\">        // <span class=\"keyword\">do</span> some destruction work (like releasing pooled connections)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean(destroyMethod = <span class=\"string\">\"cleanup\"</span>)</span><br><span class=\"line\">public Bar <span class=\"function\"><span class=\"title\">bar</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new Bar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PreDestroy</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">cleanup</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ConversionService\"><a href=\"#ConversionService\" class=\"headerlink\" title=\"ConversionService\"></a>ConversionService</h4><p>既然文中说到了这个，顺便提一下好了。</p>\n<p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p>\n<p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"conversionService\"</span></span><br><span class=\"line\">  class=<span class=\"string\">\"org.springframework.context.support.ConversionServiceFactoryBean\"</span>&gt;</span><br><span class=\"line\">  &lt;property name=<span class=\"string\">\"converters\"</span>&gt;</span><br><span class=\"line\">    &lt;list&gt;</span><br><span class=\"line\">      &lt;bean class=<span class=\"string\">\"com.loonycoder.learning.utils.StringToEnumConverterFactory\"</span>/&gt;</span><br><span class=\"line\">    &lt;/list&gt;</span><br><span class=\"line\">  &lt;/property&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p>\n<p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p>\n<p>来看一个很简单的例子，这样比什么都管用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Date convert(String <span class=\"built_in\">source</span>) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> DateUtils.parseDate(<span class=\"built_in\">source</span>, <span class=\"string\">\"yyyy-MM-dd\"</span>, <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>, <span class=\"string\">\"yyyy-MM-dd HH:mm\"</span>, <span class=\"string\">\"HH:mm:ss\"</span>, <span class=\"string\">\"HH:mm\"</span>);</span><br><span class=\"line\">        &#125; catch (ParseException e) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p>\n<h4 id=\"Bean-继承\"><a href=\"#Bean-继承\" class=\"headerlink\" title=\"Bean 继承\"></a>Bean 继承</h4><p>在初始化 Bean 的地方，我们说过了这个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure>\n<p>这里涉及到的就是 <code>&lt;bean parent=\"\" /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p>\n<p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p>\n<p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p>\n<p>看如下一个例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"inheritedTestBean\"</span> abstract=<span class=\"string\">\"true\"</span> class=<span class=\"string\">\"org.springframework.beans.TestBean\"</span>&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"name\"</span> value=<span class=\"string\">\"parent\"</span>/&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"age\"</span> value=<span class=\"string\">\"1\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"inheritsWithDifferentClass\"</span> class=<span class=\"string\">\"org.springframework.beans.DerivedTestBean\"</span></span><br><span class=\"line\">        parent=<span class=\"string\">\"inheritedTestBean\"</span> init-method=<span class=\"string\">\"initialize\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"name\"</span> value=<span class=\"string\">\"override\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>parent bean 设置了 <code>abstract=\"true\"</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p>\n<p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p>\n<p>当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p>\n<p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"inheritedTestBeanWithoutClass\"</span> abstract=<span class=\"string\">\"true\"</span>&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"name\"</span> value=<span class=\"string\">\"parent\"</span>/&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"age\"</span> value=<span class=\"string\">\"1\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法注入\"><a href=\"#方法注入\" class=\"headerlink\" title=\"方法注入\"></a>方法注入</h4><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p>\n<p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p>\n<p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p>\n<p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p>\n<p><strong>lookup-method</strong><br>我们来看一下 Spring Reference 中提供的一个例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package fiona.apple;</span><br><span class=\"line\"></span><br><span class=\"line\">// no more Spring imports!</span><br><span class=\"line\"></span><br><span class=\"line\">public abstract class CommandManager &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object process(Object commandState) &#123;</span><br><span class=\"line\">        // grab a new instance of the appropriate Command interface</span><br><span class=\"line\">        Command <span class=\"built_in\">command</span> = createCommand();</span><br><span class=\"line\">        // <span class=\"built_in\">set</span> the state on the (hopefully brand new) Command instance</span><br><span class=\"line\">        command.setState(commandState);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> command.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // okay... but <span class=\"built_in\">where</span> is the implementation of this method?</span><br><span class=\"line\">    protected abstract Command createCommand();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"myCommand\"</span> class=<span class=\"string\">\"fiona.apple.AsyncCommand\"</span> scope=<span class=\"string\">\"prototype\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- inject dependencies here as required --&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"commandManager\"</span> class=<span class=\"string\">\"fiona.apple.CommandManager\"</span>&gt;</span><br><span class=\"line\">    &lt;lookup-method name=<span class=\"string\">\"createCommand\"</span> bean=<span class=\"string\">\"myCommand\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>Spring 采用 <strong>CGLIB</strong> 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p>\n<p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class CommandManager &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object process(Object commandState) &#123;</span><br><span class=\"line\">        MyCommand <span class=\"built_in\">command</span> = createCommand();</span><br><span class=\"line\">        command.setState(commandState);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> command.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Lookup(<span class=\"string\">\"myCommand\"</span>)</span><br><span class=\"line\">    protected abstract Command createCommand();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=\"com.loonycoder\" /&gt;</code></p>\n</blockquote>\n<p>甚至，我们可以像下面这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class CommandManager &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object process(Object commandState) &#123;</span><br><span class=\"line\">        MyCommand <span class=\"built_in\">command</span> = createCommand();</span><br><span class=\"line\">        command.setState(commandState);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> command.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Lookup</span><br><span class=\"line\">    protected abstract MyCommand createCommand();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p>\n</blockquote>\n<p><strong>replaced-method</strong><br>记住它的功能，就是替换掉 bean 中的一些方法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyValueCalculator &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String computeValue(String input) &#123;</span><br><span class=\"line\">        // some real code...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // some other methods...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法覆写，注意要实现 MethodReplacer 接口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123;</span><br><span class=\"line\">        // get the input value, work with it, and <span class=\"built_in\">return</span> a computed result</span><br><span class=\"line\">        String input = (String) args[0];</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ...;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置也很简单：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"myValueCalculator\"</span> class=<span class=\"string\">\"x.y.z.MyValueCalculator\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span><br><span class=\"line\">    &lt;replaced-method name=<span class=\"string\">\"computeValue\"</span> replacer=<span class=\"string\">\"replacementComputeValue\"</span>&gt;</span><br><span class=\"line\">        &lt;arg-type&gt;String&lt;/arg-type&gt;</span><br><span class=\"line\">    &lt;/replaced-method&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"replacementComputeValue\"</span> class=<span class=\"string\">\"a.b.c.ReplacementComputeValue\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p>\n</blockquote>\n<h4 id=\"BeanPostProcessor\"><a href=\"#BeanPostProcessor\" class=\"headerlink\" title=\"BeanPostProcessor\"></a>BeanPostProcessor</h4><p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BeanPostProcessor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p>\n<p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p>\n<p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p>\n<p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p>\n<p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p>\n<p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p>\n<p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>按理说，总结应该写在附录前面，我就不讲究了。</p>\n<p>在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。</p>\n<p>本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。</p>\n<p>（全文完）</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/spring_logo.jpg\" alt=\"Spring\"></p>\n<p>原文转自：<a href=\"https://javadoop.com/post/spring-ioc\" target=\"_blank\" rel=\"noopener\">https://javadoop.com/post/spring-ioc</a></p>\n<p>因为有幸看到这篇让我读了约三个半小时的文章，简直价值千金，所以稍作修改，以此记录。<br>为了保持文章的严谨性，如有错误，望及时指出，十分希望听到读者的声音。</p>\n<hr>\n<h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>先看下最基本的启动 Spring 容器的例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    ApplicationContext context = new ClassPathXmlApplicationContext(<span class=\"string\">\"classpath:Application.xml\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>\n</blockquote>\n<p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。<br>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code>其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext 。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：<br><img src=\"/images/spring-ioc1.png\" alt=\"spring\"></p>\n<blockquote>\n<p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。<br>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p>\n</blockquote>\n<p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的<br><strong>FileSystemXmlApplicationContext</strong>和<strong>AnnotationConfigApplicationContext</strong>这两个类。</p>\n<ol>\n<li><p><strong>FileSystemXmlApplicationContext</strong>的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p>\n</li>\n<li><p><strong>AnnotationConfigApplicationContext</strong>是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p>\n</li>\n</ol>\n<p>不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p>\n<p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p>\n<p>首先，定义一个接口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface MessageService &#123;</span><br><span class=\"line\">    String getMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义接口实现类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MessageServiceImpl implements MessageService &#123;</span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getMessage</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"string\">\"hello world\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 Application.xml 或 Application-xxx.xml 就可以了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span> ?&gt;</span><br><span class=\"line\">&lt;beans xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">       xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">       xsi:schemaLocation=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span> default-autowire=<span class=\"string\">\"byName\"</span>&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">\"messageService\"</span> class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span>/&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<p>这样，我们就可以跑起来了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class App &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 用我们的配置文件来启动一个 ApplicationContext</span><br><span class=\"line\">        ApplicationContext context = new ClassPathXmlApplicationContext(<span class=\"string\">\"classpath:Application.xml\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"context 启动成功\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span><br><span class=\"line\">        MessageService messageService = context.getBean(MessageService.class);</span><br><span class=\"line\">        // 这句将输出: hello world</span><br><span class=\"line\">        System.out.println(messageService.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p>\n<hr>\n<h3 id=\"BeanFactory-简介\"><a href=\"#BeanFactory-简介\" class=\"headerlink\" title=\"BeanFactory 简介\"></a>BeanFactory 简介</h3><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p>\n<p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：<br><img src=\"/images/spring-ioc2.png\" alt=\"spring\"><br>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p>\n<ul>\n<li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li>\n<li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li>\n<li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li>\n<li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li>\n<li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。<br>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</li>\n</ul>\n<hr>\n<h3 id=\"启动过程分析\"><a href=\"#启动过程分析\" class=\"headerlink\" title=\"启动过程分析\"></a>启动过程分析</h3><p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p>\n<p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123;</span><br><span class=\"line\">  private Resource[] configResources;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span><br><span class=\"line\">  public ClassPathXmlApplicationContext(ApplicationContext parent) &#123;</span><br><span class=\"line\">    super(parent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</span><br><span class=\"line\">      throws BeansException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    super(parent);</span><br><span class=\"line\">    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span><br><span class=\"line\">    setConfigLocations(configLocations);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (refresh) &#123;</span><br><span class=\"line\">      refresh(); // 核心方法</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p>\n<p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class=\"line\">   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span><br><span class=\"line\">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class=\"line\">      prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class=\"line\">      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class=\"line\">      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class=\"line\">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class=\"line\">      // 这块待会会展开说</span><br><span class=\"line\">      prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class=\"line\">         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class=\"line\"></span><br><span class=\"line\">         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class=\"line\">         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class=\"line\">         postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span><br><span class=\"line\">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class=\"line\">         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class=\"line\">         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span><br><span class=\"line\">         registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class=\"line\">         initMessageSource();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class=\"line\">         initApplicationEventMulticaster();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 从方法名就可以知道，典型的模板方法(钩子方法)，</span><br><span class=\"line\">         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class=\"line\">         onRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class=\"line\">         registerListeners();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 重点，重点，重点</span><br><span class=\"line\">         // 初始化所有的 singleton beans</span><br><span class=\"line\">         //（lazy-init 的除外）</span><br><span class=\"line\">         finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 最后，广播事件，ApplicationContext 初始化完成</span><br><span class=\"line\">         finishRefresh();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      catch (BeansException ex) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"Exception encountered during context initialization - \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"cancelling refresh attempt: \"</span> + ex);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         // Destroy already created singletons to avoid dangling resources.</span><br><span class=\"line\">         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class=\"line\">         destroyBeans();</span><br><span class=\"line\"></span><br><span class=\"line\">         // Reset <span class=\"string\">'active'</span> flag.</span><br><span class=\"line\">         cancelRefresh(ex);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 把异常往外抛</span><br><span class=\"line\">         throw ex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      finally &#123;</span><br><span class=\"line\">         // Reset common introspection caches <span class=\"keyword\">in</span> Spring<span class=\"string\">'s core, since we</span></span><br><span class=\"line\"><span class=\"string\">         // might not ever need metadata for singleton beans anymore...</span></span><br><span class=\"line\"><span class=\"string\">         resetCommonCaches();</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">   &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面，我们开始一步步来肢解这个 refresh() 方法。</p>\n<hr>\n<h4 id=\"创建-Bean-容器，加载并注册-Bean\"><a href=\"#创建-Bean-容器，加载并注册-Bean\" class=\"headerlink\" title=\"创建 Bean 容器，加载并注册 Bean\"></a>创建 Bean 容器，加载并注册 Bean</h4><p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p>\n<p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p>\n<p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p>\n<p>// AbstractApplicationContext.java</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected ConfigurableListableBeanFactory <span class=\"function\"><span class=\"title\">obtainFreshBeanFactory</span></span>() &#123;</span><br><span class=\"line\">   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span><br><span class=\"line\">   refreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 返回刚刚创建的 BeanFactory</span><br><span class=\"line\">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      logger.debug(<span class=\"string\">\"Bean factory for \"</span> + getDisplayName() + <span class=\"string\">\": \"</span> + beanFactory);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> beanFactory;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>// AbstractRefreshableApplicationContext.java 120</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class=\"line\">   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span><br><span class=\"line\">   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span><br><span class=\"line\">   // ApplicationContext 是否有 BeanFactory</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (hasBeanFactory()) &#123;</span><br><span class=\"line\">      destroyBeans();</span><br><span class=\"line\">      closeBeanFactory();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span><br><span class=\"line\">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class=\"line\">      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span><br><span class=\"line\">      beanFactory.setSerializationId(getId());</span><br><span class=\"line\"></span><br><span class=\"line\">      // 下面这两个方法很重要，别跟丢了，具体细节之后说</span><br><span class=\"line\">      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span><br><span class=\"line\">      customizeBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 加载 Bean 到 BeanFactory 中</span><br><span class=\"line\">      loadBeanDefinitions(beanFactory);</span><br><span class=\"line\">      synchronized (this.beanFactoryMonitor) &#123;</span><br><span class=\"line\">         this.beanFactory = beanFactory;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (IOException ex) &#123;</span><br><span class=\"line\">      throw new ApplicationContextException(<span class=\"string\">\"I/O error parsing bean definition source for \"</span> + getDisplayName(), ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>\n</blockquote>\n<p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：<br><img src=\"/images/spring-ioc2.png\" alt=\"spring\"></p>\n<p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p>\n<blockquote>\n<p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？<br>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。<br>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。</p>\n</blockquote>\n<p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p>\n<p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p>\n<p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p>\n<blockquote>\n<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>\n</blockquote>\n<p><strong>BeanDefinition 接口定义</strong><br>我们来看下 BeanDefinition 的接口定义：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 我们可以看到，默认只提供 sington 和 prototype 两种，</span><br><span class=\"line\">   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span><br><span class=\"line\">   // 不过，它们属于基于 web 的扩展。</span><br><span class=\"line\">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class=\"line\">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 比较不重要，直接跳过吧</span><br><span class=\"line\">   int ROLE_APPLICATION = 0;</span><br><span class=\"line\">   int ROLE_SUPPORT = 1;</span><br><span class=\"line\">   int ROLE_INFRASTRUCTURE = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span><br><span class=\"line\">   // 一句话就是：继承父 Bean 的配置信息而已</span><br><span class=\"line\">   void setParentName(String parentName);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 获取父 Bean</span><br><span class=\"line\">   String getParentName();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置 Bean 的类名称，将来是要通过反射来生成实例的</span><br><span class=\"line\">   void setBeanClassName(String beanClassName);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 获取 Bean 的类名称</span><br><span class=\"line\">   String getBeanClassName();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置 bean 的 scope</span><br><span class=\"line\">   void setScope(String scope);</span><br><span class=\"line\"></span><br><span class=\"line\">   String getScope();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置是否懒加载</span><br><span class=\"line\">   void setLazyInit(boolean lazyInit);</span><br><span class=\"line\"></span><br><span class=\"line\">   boolean isLazyInit();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span><br><span class=\"line\">   // 是 depends-on=<span class=\"string\">\"\"</span> 属性设置的值。</span><br><span class=\"line\">   void setDependsOn(String... dependsOn);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 返回该 Bean 的所有依赖</span><br><span class=\"line\">   String[] getDependsOn();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span><br><span class=\"line\">   // 如果根据名称注入，即使这边设置了 <span class=\"literal\">false</span>，也是可以的</span><br><span class=\"line\">   void setAutowireCandidate(boolean autowireCandidate);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 该 Bean 是否可以注入到其他 Bean 中</span><br><span class=\"line\">   boolean isAutowireCandidate();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 <span class=\"literal\">true</span> 的 bean</span><br><span class=\"line\">   void setPrimary(boolean primary);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 是否是 primary 的</span><br><span class=\"line\">   boolean isPrimary();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span><br><span class=\"line\">   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span><br><span class=\"line\">   void setFactoryBeanName(String factoryBeanName);</span><br><span class=\"line\">   // 获取工厂名称</span><br><span class=\"line\">   String getFactoryBeanName();</span><br><span class=\"line\">   // 指定工厂类中的 工厂方法名称</span><br><span class=\"line\">   void setFactoryMethodName(String factoryMethodName);</span><br><span class=\"line\">   // 获取工厂类中的 工厂方法名称</span><br><span class=\"line\">   String getFactoryMethodName();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 构造器参数</span><br><span class=\"line\">   ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class=\"line\"></span><br><span class=\"line\">   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span><br><span class=\"line\">   MutablePropertyValues getPropertyValues();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 是否 singleton</span><br><span class=\"line\">   boolean isSingleton();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 是否 prototype</span><br><span class=\"line\">   boolean isPrototype();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span><br><span class=\"line\">   // 常用于作为 父bean 用于继承，其实也很少用......</span><br><span class=\"line\">   boolean isAbstract();</span><br><span class=\"line\"></span><br><span class=\"line\">   int getRole();</span><br><span class=\"line\">   String getDescription();</span><br><span class=\"line\">   String getResourceDescription();</span><br><span class=\"line\">   BeanDefinition getOriginatingBeanDefinition();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。<br>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p>\n</blockquote>\n<p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">customizeBeanFactory(beanFactory);</span><br><span class=\"line\">loadBeanDefinitions(beanFactory);</span><br></pre></td></tr></table></figure>\n\n<p>虽然只有两个方法，但路还很长啊。。。</p>\n<p><strong>customizeBeanFactory</strong></p>\n<p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (this.allowBeanDefinitionOverriding != null) &#123;</span><br><span class=\"line\">      // 是否允许 Bean 定义覆盖</span><br><span class=\"line\">      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (this.allowCircularReferences != null) &#123;</span><br><span class=\"line\">      // 是否允许 Bean 间的循环依赖</span><br><span class=\"line\">      beanFactory.setAllowCircularReferences(this.allowCircularReferences);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>\n<p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>\n<p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p>\n<p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p>\n<p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p>\n<p><strong>加载Bean:loadBeanDefinitions</strong></p>\n<p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p>\n<p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p>\n<p>// AbstractXmlApplicationContext.java 80</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class=\"line\">   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span><br><span class=\"line\">   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">   // Configure the bean definition reader with this context<span class=\"string\">'s</span></span><br><span class=\"line\"><span class=\"string\">   // resource loading environment.</span></span><br><span class=\"line\"><span class=\"string\">   beanDefinitionReader.setEnvironment(this.getEnvironment());</span></span><br><span class=\"line\"><span class=\"string\">   beanDefinitionReader.setResourceLoader(this);</span></span><br><span class=\"line\"><span class=\"string\">   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span></span><br><span class=\"line\"><span class=\"string\">   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span></span><br><span class=\"line\"><span class=\"string\">   initBeanDefinitionReader(beanDefinitionReader);</span></span><br><span class=\"line\"><span class=\"string\">   // 重点来了，继续往下</span></span><br><span class=\"line\"><span class=\"string\">   loadBeanDefinitions(beanDefinitionReader);</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p>\n<p>// AbstractXmlApplicationContext.java 120</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class=\"line\">   Resource[] configResources = getConfigResources();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (configResources != null) &#123;</span><br><span class=\"line\">      // 往下看</span><br><span class=\"line\">      reader.loadBeanDefinitions(configResources);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   String[] configLocations = getConfigLocations();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (configLocations != null) &#123;</span><br><span class=\"line\">      // 2</span><br><span class=\"line\">      reader.loadBeanDefinitions(configLocations);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\">   Assert.notNull(resources, <span class=\"string\">\"Resource array must not be null\"</span>);</span><br><span class=\"line\">   int counter = 0;</span><br><span class=\"line\">   // 注意这里是个 <span class=\"keyword\">for</span> 循环，也就是每个文件是一个 resource</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (Resource resource : resources) &#123;</span><br><span class=\"line\">      // 继续往下看</span><br><span class=\"line\">      counter += loadBeanDefinitions(resource);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 最后返回 counter，表示总共加载了多少的 BeanDefinition</span><br><span class=\"line\">   <span class=\"built_in\">return</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// XmlBeanDefinitionReader 303</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> loadBeanDefinitions(new EncodedResource(resource));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// XmlBeanDefinitionReader 314</span><br><span class=\"line\">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\">   Assert.notNull(encodedResource, <span class=\"string\">\"EncodedResource must not be null\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">      logger.info(<span class=\"string\">\"Loading XML bean definitions from \"</span> + encodedResource.getResource());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 用一个 ThreadLocal 来存放配置文件资源</span><br><span class=\"line\">   Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (currentResources == null) &#123;</span><br><span class=\"line\">      currentResources = new HashSet&lt;EncodedResource&gt;(4);</span><br><span class=\"line\">      this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class=\"line\">      throw new BeanDefinitionStoreException(</span><br><span class=\"line\">            <span class=\"string\">\"Detected cyclic loading of \"</span> + encodedResource + <span class=\"string\">\" - check your import definitions!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         InputSource inputSource = new InputSource(inputStream);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (encodedResource.getEncoding() != null) &#123;</span><br><span class=\"line\">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         // 核心部分是这里，往下面看</span><br><span class=\"line\">         <span class=\"built_in\">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      finally &#123;</span><br><span class=\"line\">         inputStream.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (IOException ex) &#123;</span><br><span class=\"line\">      throw new BeanDefinitionStoreException(</span><br><span class=\"line\">            <span class=\"string\">\"IOException parsing XML document from \"</span> + encodedResource.getResource(), ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   finally &#123;</span><br><span class=\"line\">      currentResources.remove(encodedResource);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentResources.isEmpty()) &#123;</span><br><span class=\"line\">         this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 还在这个文件中，第 388 行</span><br><span class=\"line\">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class=\"line\">      throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      // 这里就不看了，将 xml 文件转换为 Document 对象</span><br><span class=\"line\">      Document doc = doLoadDocument(inputSource, resource);</span><br><span class=\"line\">      // 继续</span><br><span class=\"line\">      <span class=\"built_in\">return</span> registerBeanDefinitions(doc, resource);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 还在这个文件中，第 505 行</span><br><span class=\"line\">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span><br><span class=\"line\">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\">   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class=\"line\">   int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class=\"line\">   // 这里</span><br><span class=\"line\">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class=\"line\">   <span class=\"built_in\">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// DefaultBeanDefinitionDocumentReader 90</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class=\"line\">   this.readerContext = readerContext;</span><br><span class=\"line\">   logger.debug(<span class=\"string\">\"Loading bean definitions\"</span>);</span><br><span class=\"line\">   Element root = doc.getDocumentElement();</span><br><span class=\"line\">   // 从 xml 根节点开始解析文件</span><br><span class=\"line\">   doRegisterBeanDefinitions(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p>\n<p><strong>doRegisterBeanDefinitions：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// DefaultBeanDefinitionDocumentReader 116</span><br><span class=\"line\">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class=\"line\">   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，</span><br><span class=\"line\">   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，</span><br><span class=\"line\">   // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了</span><br><span class=\"line\">   BeanDefinitionParserDelegate parent = this.delegate;</span><br><span class=\"line\">   this.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class=\"line\">      // 这块说的是根节点 &lt;beans ... profile=<span class=\"string\">\"dev\"</span> /&gt; 中的 profile 是否是当前环境需要的，</span><br><span class=\"line\">      // 如果当前环境配置的 profile 不包含此 profile，那就直接 <span class=\"built_in\">return</span> 了，不对此 &lt;beans /&gt; 解析</span><br><span class=\"line\">      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区</span><br><span class=\"line\">      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class=\"line\">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class=\"line\">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">               logger.info(<span class=\"string\">\"Skipped XML bean definition file due to specified profiles [\"</span> + profileSpec +</span><br><span class=\"line\">                     <span class=\"string\">\"] not matching: \"</span> + getReaderContext().getResource());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">return</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   preProcessXml(root); // 钩子</span><br><span class=\"line\">   // 往下看</span><br><span class=\"line\">   parseBeanDefinitions(root, this.delegate);</span><br><span class=\"line\">   postProcessXml(root); // 钩子</span><br><span class=\"line\"></span><br><span class=\"line\">   this.delegate = parent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p>\n<p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p>\n<p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;<span class=\"built_in\">alias</span> /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span><br><span class=\"line\">// 其他的属于 custom 的</span><br><span class=\"line\">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class=\"line\">      NodeList nl = root.getChildNodes();</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class=\"line\">         Node node = nl.item(i);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (node instanceof Element) &#123;</span><br><span class=\"line\">            Element ele = (Element) node;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class=\"line\">               // 解析 default namespace 下面的几个元素</span><br><span class=\"line\">               parseDefaultElement(ele, delegate);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               // 解析其他 namespace 的元素</span><br><span class=\"line\">               delegate.parseCustomElement(ele);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      delegate.parseCustomElement(root);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p>\n<p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt;、&lt;beans /&gt;</code>这几个。</p>\n<blockquote>\n<p>这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.springframework.org/schema/beans </span><br></pre></td></tr></table></figure>\n<p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 xmlns 就是咯。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">      xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">      xsi:schemaLocation=<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">           http://www.springframework.org/schema/beans</span></span><br><span class=\"line\"><span class=\"string\">         http://www.springframework.org/schema/beans/spring-beans.xsd\"</span></span><br><span class=\"line\">      default-autowire=<span class=\"string\">\"byName\"</span>&gt; </span><br></pre></td></tr></table></figure>\n<p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code> &lt;mvc /&gt;、&lt;task /&gt;、&lt;context /&gt;、&lt;aop /&gt;</code>等。<br>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。<br>假如读者想分析 <code>&lt;context:property-placeholder location=\"classpath:xx.properties\" /&gt;</code>的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">     xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">     xmlns:context=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></span><br><span class=\"line\">     xmlns:mvc=<span class=\"string\">\"http://www.springframework.org/schema/mvc\"</span></span><br><span class=\"line\">     xsi:schemaLocation=<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/beans </span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/context</span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/mvc   </span></span><br><span class=\"line\"><span class=\"string\">          http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span></span><br><span class=\"line\"><span class=\"string\">      \"</span></span><br><span class=\"line\">     default-autowire=<span class=\"string\">\"byName\"</span>&gt;</span><br><span class=\"line\">   &lt;/bean&gt; </span><br></pre></td></tr></table></figure>\n<p>同理，以后你要是碰到 <code>&lt;<dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。<br>回过神来，看看处理 default 标签的方法：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class=\"line\">      // 处理 &lt;import /&gt; 标签</span><br><span class=\"line\">      importBeanDefinitionResource(ele);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class=\"line\">      // 处理 &lt;<span class=\"built_in\">alias</span> /&gt; 标签定义</span><br><span class=\"line\">      // &lt;<span class=\"built_in\">alias</span> name=<span class=\"string\">\"fromName\"</span> <span class=\"built_in\">alias</span>=<span class=\"string\">\"toName\"</span>/&gt;</span><br><span class=\"line\">      processAliasRegistration(ele);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class=\"line\">      // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧</span><br><span class=\"line\">      processBeanDefinition(ele, delegate);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class=\"line\">      // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span><br><span class=\"line\">      doRegisterBeanDefinitions(ele);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <bean /> 标签出来说。</p>\n<p><strong>processBeanDefinition 解析 bean 标签</strong><br>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p>\n<p>// DefaultBeanDefinitionDocumentReader 298</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class=\"line\">   // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看</span><br><span class=\"line\">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (bdHolder != null) &#123;</span><br><span class=\"line\">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         // Register the final decorated instance.</span><br><span class=\"line\">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      catch (BeanDefinitionStoreException ex) &#123;</span><br><span class=\"line\">         getReaderContext().error(<span class=\"string\">\"Failed to register bean definition with name '\"</span> +</span><br><span class=\"line\">               bdHolder.getBeanName() + <span class=\"string\">\"'\"</span>, ele, ex);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // Send registration event.</span><br><span class=\"line\">      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续往下看怎么解析之前，我们先看下 <code>&lt;bean /&gt;</code> 标签中可以定义哪些属性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Property</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">class</td>\n<td align=\"center\">类的全限定名</td>\n</tr>\n<tr>\n<td align=\"center\">name</td>\n<td align=\"center\">可指定 id、name(用逗号、分号、空格分隔)</td>\n</tr>\n<tr>\n<td align=\"center\">scope</td>\n<td align=\"center\">作用域</td>\n</tr>\n<tr>\n<td align=\"center\">constructor arguments</td>\n<td align=\"center\">指定构造参数</td>\n</tr>\n<tr>\n<td align=\"center\">properties</td>\n<td align=\"center\">设置属性的值</td>\n</tr>\n<tr>\n<td align=\"center\">autowiring mode</td>\n<td align=\"center\">no(默认值)、byName、byType、 constructor</td>\n</tr>\n<tr>\n<td align=\"center\">lazy-initialization mode</td>\n<td align=\"center\">是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td>\n</tr>\n<tr>\n<td align=\"center\">initialization method</td>\n<td align=\"center\">bean 属性设置完成后，会调用这个方法</td>\n</tr>\n<tr>\n<td align=\"center\">destruction method</td>\n<td align=\"center\">bean 销毁后的回调方法</td>\n</tr>\n</tbody></table>\n<p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p>\n<p>简单地说就是像下面这样子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"exampleBean\"</span> name=<span class=\"string\">\"name1, name2, name3\"</span> class=<span class=\"string\">\"com.loonycoder.ExampleBean\"</span></span><br><span class=\"line\">      scope=<span class=\"string\">\"singleton\"</span> lazy-init=<span class=\"string\">\"true\"</span> init-method=<span class=\"string\">\"init\"</span> destroy-method=<span class=\"string\">\"cleanup\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 可以用下面三种形式指定构造参数 --&gt;</span><br><span class=\"line\">    &lt;constructor-arg <span class=\"built_in\">type</span>=<span class=\"string\">\"int\"</span> value=<span class=\"string\">\"7500000\"</span>/&gt;</span><br><span class=\"line\">    &lt;constructor-arg name=<span class=\"string\">\"years\"</span> value=<span class=\"string\">\"7500000\"</span>/&gt;</span><br><span class=\"line\">    &lt;constructor-arg index=<span class=\"string\">\"0\"</span> value=<span class=\"string\">\"7500000\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- property 的几种情况 --&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"beanOne\"</span>&gt;</span><br><span class=\"line\">        &lt;ref bean=<span class=\"string\">\"anotherExampleBean\"</span>/&gt;</span><br><span class=\"line\">    &lt;/property&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"beanTwo\"</span> ref=<span class=\"string\">\"yetAnotherBean\"</span>/&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"integerProperty\"</span> value=<span class=\"string\">\"1\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;、&lt;replaced-method /&gt;、&lt;meta /&gt;、&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p>\n<p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p>\n<p>// BeanDefinitionParserDelegate 428</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> parseBeanDefinitionElement(ele, null);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class=\"line\">   String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class=\"line\">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class=\"line\"></span><br><span class=\"line\">   List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span><br><span class=\"line\">   // 当然，如果你不定义 name 属性的话，就是空的了</span><br><span class=\"line\">   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class=\"line\">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class=\"line\">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   String beanName = id;</span><br><span class=\"line\">   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class=\"line\">      beanName = aliases.remove(0);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">         logger.debug(<span class=\"string\">\"No XML 'id' specified - using '\"</span> + beanName +</span><br><span class=\"line\">               <span class=\"string\">\"' as bean name and \"</span> + aliases + <span class=\"string\">\" as aliases\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (containingBean == null) &#123;</span><br><span class=\"line\">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span><br><span class=\"line\">   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。</span><br><span class=\"line\">   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanDefinition != null) &#123;</span><br><span class=\"line\">      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span><br><span class=\"line\">      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class=\"line\">         try &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (containingBean != null) &#123;// 按照我们的思路，这里 containingBean 是 null 的</span><br><span class=\"line\">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class=\"line\">                     beanDefinition, this.readerContext.getRegistry(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：</span><br><span class=\"line\">               //   1. beanName 为：com.loonycoder.service.MessageServiceImpl<span class=\"comment\">#0</span></span><br><span class=\"line\">               //   2. beanClassName 为：com.loonycoder.service.MessageServiceImpl</span><br><span class=\"line\"></span><br><span class=\"line\">               beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class=\"line\"></span><br><span class=\"line\">               String beanClassName = beanDefinition.getBeanClassName();</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (beanClassName != null &amp;&amp;</span><br><span class=\"line\">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class=\"line\">                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class=\"line\">                  // 把 beanClassName 设置为 Bean 的别名</span><br><span class=\"line\">                  aliases.add(beanClassName);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">               logger.debug(<span class=\"string\">\"Neither XML 'id' nor 'name' specified - \"</span> +</span><br><span class=\"line\">                     <span class=\"string\">\"using generated bean name [\"</span> + beanName + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         catch (Exception ex) &#123;</span><br><span class=\"line\">            error(ex.getMessage(), ele);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class=\"line\">      // 返回 BeanDefinitionHolder</span><br><span class=\"line\">      <span class=\"built_in\">return</span> new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class=\"line\">      Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   this.parseState.push(new BeanEntry(beanName));</span><br><span class=\"line\"></span><br><span class=\"line\">   String className = null;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class=\"line\">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      String parent = null;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class=\"line\">         parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span><br><span class=\"line\">      AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span><br><span class=\"line\">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class=\"line\">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class=\"line\"></span><br><span class=\"line\">      /**</span><br><span class=\"line\">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span><br><span class=\"line\">       * 解析出来以后的信息都放到 bd 的属性中</span><br><span class=\"line\">       */</span><br><span class=\"line\"></span><br><span class=\"line\">      // 解析 &lt;meta /&gt;</span><br><span class=\"line\">      parseMetaElements(ele, bd);</span><br><span class=\"line\">      // 解析 &lt;lookup-method /&gt;</span><br><span class=\"line\">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class=\"line\">      // 解析 &lt;replaced-method /&gt;</span><br><span class=\"line\">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class=\"line\">    // 解析 &lt;constructor-arg /&gt;</span><br><span class=\"line\">      parseConstructorArgElements(ele, bd);</span><br><span class=\"line\">      // 解析 &lt;property /&gt;</span><br><span class=\"line\">      parsePropertyElements(ele, bd);</span><br><span class=\"line\">      // 解析 &lt;qualifier /&gt;</span><br><span class=\"line\">      parseQualifierElements(ele, bd);</span><br><span class=\"line\"></span><br><span class=\"line\">      bd.setResource(this.readerContext.getResource());</span><br><span class=\"line\">      bd.setSource(extractSource(ele));</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">return</span> bd;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">      error(<span class=\"string\">\"Bean class [\"</span> + className + <span class=\"string\">\"] not found\"</span>, ele, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (NoClassDefFoundError err) &#123;</span><br><span class=\"line\">      error(<span class=\"string\">\"Class that bean class [\"</span> + className + <span class=\"string\">\"] depends on not found\"</span>, ele, err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (Throwable ex) &#123;</span><br><span class=\"line\">      error(<span class=\"string\">\"Unexpected failure during bean definition parsing\"</span>, ele, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   finally &#123;</span><br><span class=\"line\">      this.parseState.pop();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p>\n<p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class=\"line\">   // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span><br><span class=\"line\">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (bdHolder != null) &#123;</span><br><span class=\"line\">      // 如果有自定义属性的话，进行相应的解析，先忽略</span><br><span class=\"line\">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         // 我们把这步叫做 注册Bean 吧</span><br><span class=\"line\">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      catch (BeanDefinitionStoreException ex) &#123;</span><br><span class=\"line\">         getReaderContext().error(<span class=\"string\">\"Failed to register bean definition with name '\"</span> +</span><br><span class=\"line\">               bdHolder.getBeanName() + <span class=\"string\">\"'\"</span>, ele, ex);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 注册完成后，发送事件，本文不展开说这个</span><br><span class=\"line\">      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BeanDefinitionHolder implements BeanMetadataElement &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  private final BeanDefinition beanDefinition;</span><br><span class=\"line\"></span><br><span class=\"line\">  private final String beanName;</span><br><span class=\"line\"></span><br><span class=\"line\">  private final String[] aliases;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p>\n<p>下面，我们开始说说注册 Bean 吧。</p>\n<p><strong>注册 Bean</strong><br>// BeanDefinitionReaderUtils 143</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void registerBeanDefinition(</span><br><span class=\"line\">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class=\"line\">      throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   String beanName = definitionHolder.getBeanName();</span><br><span class=\"line\">   // 注册这个 Bean</span><br><span class=\"line\">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span><br><span class=\"line\">   String[] aliases = definitionHolder.getAliases();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (aliases != null) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (String <span class=\"built_in\">alias</span> : aliases) &#123;</span><br><span class=\"line\">         // <span class=\"built_in\">alias</span> -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span><br><span class=\"line\">         // 获取的时候，会先将 <span class=\"built_in\">alias</span> 转换为 beanName，然后再查找</span><br><span class=\"line\">         registry.registerAlias(beanName, <span class=\"built_in\">alias</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p>\n<p>// DefaultListableBeanFactory 793</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class=\"line\">      throws BeanDefinitionStoreException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   Assert.hasText(beanName, <span class=\"string\">\"Bean name must not be empty\"</span>);</span><br><span class=\"line\">   Assert.notNull(beanDefinition, <span class=\"string\">\"BeanDefinition must not be null\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class=\"line\">         throw new BeanDefinitionStoreException(...);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span><br><span class=\"line\">   BeanDefinition oldBeanDefinition;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span><br><span class=\"line\">   oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 处理重复名称的 Bean 定义的情况</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (oldBeanDefinition != null) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class=\"line\">         // 如果不允许覆盖的话，抛异常</span><br><span class=\"line\">         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class=\"line\">         // <span class=\"built_in\">log</span>...用框架定义的 Bean 覆盖用户自定义的 Bean </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class=\"line\">         // <span class=\"built_in\">log</span>...用新的 Bean 覆盖旧的 Bean</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         // <span class=\"built_in\">log</span>...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 <span class=\"literal\">true</span> 的 Bean</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 覆盖</span><br><span class=\"line\">      this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      // 判断是否已经有其他的 Bean 开始初始化了.</span><br><span class=\"line\">      // 注意，<span class=\"string\">\"注册Bean\"</span> 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span><br><span class=\"line\">      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class=\"line\">         // Cannot modify startup-time collection elements anymore (<span class=\"keyword\">for</span> stable iteration)</span><br><span class=\"line\">         synchronized (this.beanDefinitionMap) &#123;</span><br><span class=\"line\">            this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class=\"line\">            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class=\"line\">            updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class=\"line\">            updatedDefinitions.add(beanName);</span><br><span class=\"line\">            this.beanDefinitionNames = updatedDefinitions;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class=\"line\">               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);</span><br><span class=\"line\">               updatedSingletons.remove(beanName);</span><br><span class=\"line\">               this.manualSingletonNames = updatedSingletons;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         // 最正常的应该是进到这个分支。</span><br><span class=\"line\"></span><br><span class=\"line\">         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span><br><span class=\"line\">         this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class=\"line\">         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span><br><span class=\"line\">         this.beanDefinitionNames.add(beanName);</span><br><span class=\"line\">         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span><br><span class=\"line\">         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span><br><span class=\"line\">         // 手动指的是通过调用以下方法注册的 bean ：</span><br><span class=\"line\">         //     registerSingleton(String beanName, Object singletonObject)</span><br><span class=\"line\">         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面<span class=\"string\">\"手动\"</span>注册一些 Bean，</span><br><span class=\"line\">         // 如 <span class=\"string\">\"environment\"</span>、<span class=\"string\">\"systemProperties\"</span> 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span><br><span class=\"line\">         this.manualSingletonNames.remove(beanName);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 这个不重要，在预初始化的时候会用到，不必管它。</span><br><span class=\"line\">      this.frozenBeanDefinitionNames = null;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (oldBeanDefinition != null || containsSingleton(beanName)) &#123;</span><br><span class=\"line\">      resetBeanDefinition(beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>\n<p>——— 分割线 ———</p>\n<p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p>\n<h4 id=\"Bean-容器实例化完成后\"><a href=\"#Bean-容器实例化完成后\" class=\"headerlink\" title=\"Bean 容器实例化完成后\"></a>Bean 容器实例化完成后</h4><p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p>\n<p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class=\"line\">   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span><br><span class=\"line\">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class=\"line\">      prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class=\"line\">      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class=\"line\">      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class=\"line\">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class=\"line\">      // 这块待会会展开说</span><br><span class=\"line\">      prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class=\"line\">         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class=\"line\"></span><br><span class=\"line\">         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class=\"line\">         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class=\"line\">         postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span><br><span class=\"line\">         invokeBeanFactoryPostProcessors(beanFactory);          </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class=\"line\">         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class=\"line\">         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span><br><span class=\"line\">         registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class=\"line\">         initMessageSource();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class=\"line\">         initApplicationEventMulticaster();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span><br><span class=\"line\">         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class=\"line\">         onRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class=\"line\">         registerListeners();</span><br><span class=\"line\"></span><br><span class=\"line\">         // 重点，重点，重点</span><br><span class=\"line\">         // 初始化所有的 singleton beans</span><br><span class=\"line\">         //（lazy-init 的除外）</span><br><span class=\"line\">         finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 最后，广播事件，ApplicationContext 初始化完成，不展开</span><br><span class=\"line\">         finishRefresh();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      catch (BeansException ex) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"Exception encountered during context initialization - \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"cancelling refresh attempt: \"</span> + ex);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         // Destroy already created singletons to avoid dangling resources.</span><br><span class=\"line\">         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class=\"line\">         destroyBeans();</span><br><span class=\"line\"></span><br><span class=\"line\">         // Reset <span class=\"string\">'active'</span> flag.</span><br><span class=\"line\">         cancelRefresh(ex);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 把异常往外抛</span><br><span class=\"line\">         throw ex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      finally &#123;</span><br><span class=\"line\">         // Reset common introspection caches <span class=\"keyword\">in</span> Spring<span class=\"string\">'s core, since we</span></span><br><span class=\"line\"><span class=\"string\">         // might not ever need metadata for singleton beans anymore...</span></span><br><span class=\"line\"><span class=\"string\">         resetCommonCaches();</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">   &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"准备-Bean-容器-prepareBeanFactory\"><a href=\"#准备-Bean-容器-prepareBeanFactory\" class=\"headerlink\" title=\"准备 Bean 容器: prepareBeanFactory\"></a>准备 Bean 容器: prepareBeanFactory</h4><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p>\n<p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Configure the factory<span class=\"string\">'s standard context characteristics,</span></span><br><span class=\"line\"><span class=\"string\"> * such as the context'</span>s ClassLoader and post-processors.</span><br><span class=\"line\"> * @param beanFactory the BeanFactory to configure</span><br><span class=\"line\"> */</span><br><span class=\"line\">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class=\"line\">   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span><br><span class=\"line\">   // 这里设置为加载当前 ApplicationContext 类的类加载器</span><br><span class=\"line\">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class=\"line\"></span><br><span class=\"line\">   // 设置 BeanExpressionResolver</span><br><span class=\"line\">   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">   // </span><br><span class=\"line\">   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class=\"line\"></span><br><span class=\"line\">   // 添加一个 BeanPostProcessor，这个 processor 比较简单：</span><br><span class=\"line\">   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span><br><span class=\"line\">   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span><br><span class=\"line\">   // 注意：它不仅仅回调 ApplicationContextAware，</span><br><span class=\"line\">   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span><br><span class=\"line\">   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class=\"line\"></span><br><span class=\"line\">   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span><br><span class=\"line\">   // Spring 会通过其他方式来处理这些依赖。</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class=\"line\">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class=\"line\"></span><br><span class=\"line\">   /**</span><br><span class=\"line\">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span><br><span class=\"line\">    * 之前我们说过，<span class=\"string\">\"当前 ApplicationContext 持有一个 BeanFactory\"</span>，这里解释了第一行。</span><br><span class=\"line\">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span><br><span class=\"line\">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span><br><span class=\"line\">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span><br><span class=\"line\">    */</span><br><span class=\"line\">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class=\"line\">   beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class=\"line\">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class=\"line\">   beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span><br><span class=\"line\">   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span><br><span class=\"line\">   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class=\"line\"></span><br><span class=\"line\">   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span><br><span class=\"line\">   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class=\"line\">      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class=\"line\">      // Set a temporary ClassLoader <span class=\"keyword\">for</span> <span class=\"built_in\">type</span> matching.</span><br><span class=\"line\">      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   /**</span><br><span class=\"line\">    * 从下面几行代码我们可以知道，Spring 往往很 <span class=\"string\">\"智能\"</span> 就是因为它会帮我们默认注册一些有用的 bean，</span><br><span class=\"line\">    * 我们也可以选择覆盖</span><br><span class=\"line\">    */</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果没有定义 <span class=\"string\">\"environment\"</span> 这个 bean，那么 Spring 会 <span class=\"string\">\"手动\"</span> 注册一个</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 如果没有定义 <span class=\"string\">\"systemProperties\"</span> 这个 bean，那么 Spring 会 <span class=\"string\">\"手动\"</span> 注册一个</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class=\"line\">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 如果没有定义 <span class=\"string\">\"systemEnvironment\"</span> 这个 bean，那么 Spring 会 <span class=\"string\">\"手动\"</span> 注册一个</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p>\n<h4 id=\"初始化所有的-singleton-beans\"><a href=\"#初始化所有的-singleton-beans\" class=\"headerlink\" title=\"初始化所有的 singleton beans\"></a>初始化所有的 singleton beans</h4><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p>\n<p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p>\n<p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p>\n<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。<br>// AbstractApplicationContext.java 834</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 初始化剩余的 singleton beans</span><br><span class=\"line\">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span><br><span class=\"line\">   // 什么，看代码这里没有初始化 Bean 啊！</span><br><span class=\"line\">   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class=\"line\">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class=\"line\">      beanFactory.setConversionService(</span><br><span class=\"line\">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Register a default embedded value resolver <span class=\"keyword\">if</span> no bean post-processor</span><br><span class=\"line\">   // (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class=\"line\">   // at this point, primarily <span class=\"keyword\">for</span> resolution <span class=\"keyword\">in</span> annotation attribute values.</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class=\"line\">      beanFactory.addEmbeddedValueResolver(new <span class=\"function\"><span class=\"title\">StringValueResolver</span></span>() &#123;</span><br><span class=\"line\">         @Override</span><br><span class=\"line\">         public String resolveStringValue(String strVal) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 先初始化 LoadTimeWeaverAware 类型的 Bean</span><br><span class=\"line\">   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span><br><span class=\"line\">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class=\"line\">      getBean(weaverAwareName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Stop using the temporary ClassLoader <span class=\"keyword\">for</span> <span class=\"built_in\">type</span> matching.</span><br><span class=\"line\">   beanFactory.setTempClassLoader(null);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span><br><span class=\"line\">   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span><br><span class=\"line\">   beanFactory.freezeConfiguration();</span><br><span class=\"line\"></span><br><span class=\"line\">   // 开始初始化</span><br><span class=\"line\">   beanFactory.preInstantiateSingletons();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p>\n<p><strong>preInstantiateSingletons</strong><br>// DefaultListableBeanFactory 728</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (this.logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      this.logger.debug(<span class=\"string\">\"Pre-instantiating singletons in \"</span> + this);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // this.beanDefinitionNames 保存了所有的 beanNames</span><br><span class=\"line\">   List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (String beanName : beanNames) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 合并父 Bean 中的配置，注意 &lt;bean id=<span class=\"string\">\"\"</span> class=<span class=\"string\">\"\"</span> parent=<span class=\"string\">\"\"</span> /&gt; 中的 parent，用的不多吧，</span><br><span class=\"line\">      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 <span class=\"string\">\"Bean 继承\"</span>，不了解的请到附录中看一下</span><br><span class=\"line\">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 非抽象、非懒加载的 singletons。如果配置了 <span class=\"string\">'abstract = true'</span>，那是不需要初始化的</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class=\"line\">         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class=\"line\">            // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span><br><span class=\"line\">            final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class=\"line\">            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span><br><span class=\"line\">            boolean isEagerInit;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class=\"line\">               isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class=\"line\">                  @Override</span><br><span class=\"line\">                  public Boolean <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">                     <span class=\"built_in\">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">               &#125;, getAccessControlContext());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class=\"line\">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isEagerInit) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">               getBean(beanName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span><br><span class=\"line\">            getBean(beanName);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span><br><span class=\"line\">   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (String beanName : beanNames) &#123;</span><br><span class=\"line\">      Object singletonInstance = getSingleton(beanName);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class=\"line\">         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class=\"line\">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class=\"line\">               @Override</span><br><span class=\"line\">               public Object <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class=\"line\">                  <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;, getAccessControlContext());</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            smartSingleton.afterSingletonsInstantiated();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p>\n<p><strong>getBean</strong><br>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p>\n<p>// AbstractBeanFactory 196</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Object getBean(String name) throws BeansException &#123;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> doGetBean(name, null, null, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span><br><span class=\"line\">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span><br><span class=\"line\">@SuppressWarnings(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">protected &lt;T&gt; T doGetBean(</span><br><span class=\"line\">      final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class=\"line\">      throws BeansException &#123;</span><br><span class=\"line\">   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span><br><span class=\"line\">   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span><br><span class=\"line\">   final String beanName = transformedBeanName(name);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 注意跟着这个，这个是返回值</span><br><span class=\"line\">   Object bean; </span><br><span class=\"line\"></span><br><span class=\"line\">   // 检查下是不是已经创建过了</span><br><span class=\"line\">   Object sharedInstance = getSingleton(beanName);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span><br><span class=\"line\">   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"...\"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"Returning cached instance of singleton bean '\"</span> + beanName + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span><br><span class=\"line\">      // 如果是 FactoryBean 的话，返回它创建的那个实例对象</span><br><span class=\"line\">      // (FactoryBean 知识，读者若不清楚请移步附录)</span><br><span class=\"line\">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span><br><span class=\"line\">         // 往往是因为陷入了循环引用</span><br><span class=\"line\">         throw new BeanCurrentlyInCreationException(beanName);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 检查一下这个 BeanDefinition 在容器中是否存在</span><br><span class=\"line\">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class=\"line\">         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span><br><span class=\"line\">         String nameToLookup = originalBeanName(name);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (args != null) &#123;</span><br><span class=\"line\">            // 返回父容器的查询结果</span><br><span class=\"line\">            <span class=\"built_in\">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            // No args -&gt; delegate to standard getBean method.</span><br><span class=\"line\">            <span class=\"built_in\">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!typeCheckOnly) &#123;</span><br><span class=\"line\">         // typeCheckOnly 为 <span class=\"literal\">false</span>，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span><br><span class=\"line\">         markBeanAsCreated(beanName);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*</span><br><span class=\"line\">       * 稍稍总结一下：</span><br><span class=\"line\">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span><br><span class=\"line\">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span><br><span class=\"line\">       */</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class=\"line\">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class=\"line\"></span><br><span class=\"line\">         // 先初始化依赖的所有 Bean，这个很好理解。</span><br><span class=\"line\">         // 注意，这里的依赖指的是 depends-on 中定义的依赖</span><br><span class=\"line\">         String[] dependsOn = mbd.getDependsOn();</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (dependsOn != null) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String dep : dependsOn) &#123;</span><br><span class=\"line\">               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class=\"line\">                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class=\"line\">                        <span class=\"string\">\"'Circular depends-on relationship between '\"</span> + beanName + <span class=\"string\">\"' and '\"</span> + dep + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               // 注册一下依赖关系</span><br><span class=\"line\">               registerDependentBean(dep, beanName);</span><br><span class=\"line\">               // 先初始化被依赖项</span><br><span class=\"line\">               getBean(dep);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         // 如果是 singleton scope 的，创建 singleton 的实例</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mbd.isSingleton()) &#123;</span><br><span class=\"line\">            sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class=\"line\">               @Override</span><br><span class=\"line\">               public Object getObject() throws BeansException &#123;</span><br><span class=\"line\">                  try &#123;</span><br><span class=\"line\">                     // 执行创建 Bean，详情后面再说</span><br><span class=\"line\">                     <span class=\"built_in\">return</span> createBean(beanName, mbd, args);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  catch (BeansException ex) &#123;</span><br><span class=\"line\">                     destroySingleton(beanName);</span><br><span class=\"line\">                     throw ex;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         // 如果是 prototype scope 的，创建 prototype 的实例</span><br><span class=\"line\">         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mbd.isPrototype()) &#123;</span><br><span class=\"line\">            // It’s a prototype -&gt; create a new instance.</span><br><span class=\"line\">            Object prototypeInstance = null;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">               beforePrototypeCreation(beanName);</span><br><span class=\"line\">               // 执行创建 Bean</span><br><span class=\"line\">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            finally &#123;</span><br><span class=\"line\">               afterPrototypeCreation(beanName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span><br><span class=\"line\">         <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String scopeName = mbd.getScope();</span><br><span class=\"line\">            final Scope scope = this.scopes.get(scopeName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (scope == null) &#123;</span><br><span class=\"line\">               throw new IllegalStateException(<span class=\"string\">\"No Scope registered for scope name '\"</span> + scopeName + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">               Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class=\"line\">                  @Override</span><br><span class=\"line\">                  public Object getObject() throws BeansException &#123;</span><br><span class=\"line\">                     beforePrototypeCreation(beanName);</span><br><span class=\"line\">                     try &#123;</span><br><span class=\"line\">                        // 执行创建 Bean</span><br><span class=\"line\">                        <span class=\"built_in\">return</span> createBean(beanName, mbd, args);</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\">                     finally &#123;</span><br><span class=\"line\">                        afterPrototypeCreation(beanName);</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (IllegalStateException ex) &#123;</span><br><span class=\"line\">               throw new BeanCreationException(beanName,</span><br><span class=\"line\">                     <span class=\"string\">\"Scope '\"</span> + scopeName + <span class=\"string\">\"' is not active for the current thread; consider \"</span> +</span><br><span class=\"line\">                     <span class=\"string\">\"defining a scoped proxy for this bean if you intend to refer to it from a singleton\"</span>,</span><br><span class=\"line\">                     ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      catch (BeansException ex) &#123;</span><br><span class=\"line\">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class=\"line\">         throw ex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">         <span class=\"built_in\">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      catch (TypeMismatchException ex) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"Failed to convert bean '\"</span> + name + <span class=\"string\">\"' to required type '\"</span> +</span><br><span class=\"line\">                  ClassUtils.getQualifiedName(requiredType) + <span class=\"string\">\"'\"</span>, ex);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> (T) bean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;</span><br></pre></td></tr></table></figure>\n<p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p>\n<p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p>\n<p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MessageServiceImpl implements MessageService &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String <span class=\"function\"><span class=\"title\">getMessage</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> userService.getMessage();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"messageService\"</span> class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p>\n<p>好了，读者要知道这么回事就可以了，继续向前。</p>\n<p>// AbstractAutowireCapableBeanFactory 447</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Central method of this class: creates a bean instance,</span><br><span class=\"line\"> * populates the bean instance, applies post-processors, etc.</span><br><span class=\"line\"> * @see <span class=\"comment\">#doCreateBean</span></span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      logger.debug(<span class=\"string\">\"Creating instance of bean '\"</span> + beanName + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   RootBeanDefinition mbdToUse = mbd;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 确保 BeanDefinition 中的 Class 被加载</span><br><span class=\"line\">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class=\"line\">      mbdToUse = new RootBeanDefinition(mbd);</span><br><span class=\"line\">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; </span><br><span class=\"line\">   // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span><br><span class=\"line\">   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      mbdToUse.prepareMethodOverrides();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (BeanDefinitionValidationException ex) &#123;</span><br><span class=\"line\">      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class=\"line\">            beanName, <span class=\"string\">\"Validation of method overrides failed\"</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span><br><span class=\"line\">      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过</span><br><span class=\"line\">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (bean != null) &#123;</span><br><span class=\"line\">         <span class=\"built_in\">return</span> bean; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (Throwable ex) &#123;</span><br><span class=\"line\">      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class=\"line\">            <span class=\"string\">\"BeanPostProcessor before instantiation of bean failed\"</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 重头戏，创建 bean</span><br><span class=\"line\">   Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      logger.debug(<span class=\"string\">\"Finished creating instance of bean '\"</span> + beanName + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> beanInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建Bean</strong><br>我们继续往里看 doCreateBean 这个方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Actually create the specified bean. Pre-creation processing has already happened</span><br><span class=\"line\"> * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks.</span><br><span class=\"line\"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span><br><span class=\"line\"> * factory method, and autowiring a constructor.</span><br><span class=\"line\"> * @param beanName the name of the bean</span><br><span class=\"line\"> * @param mbd the merged bean definition <span class=\"keyword\">for</span> the bean</span><br><span class=\"line\"> * @param args explicit arguments to use <span class=\"keyword\">for</span> constructor or factory method invocation</span><br><span class=\"line\"> * @<span class=\"built_in\">return</span> a new instance of the bean</span><br><span class=\"line\"> * @throws BeanCreationException <span class=\"keyword\">if</span> the bean could not be created</span><br><span class=\"line\"> * @see <span class=\"comment\">#instantiateBean</span></span><br><span class=\"line\"> * @see <span class=\"comment\">#instantiateUsingFactoryMethod</span></span><br><span class=\"line\"> * @see <span class=\"comment\">#autowireConstructor</span></span><br><span class=\"line\"> */</span><br><span class=\"line\">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</span><br><span class=\"line\">      throws BeanCreationException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Instantiate the bean.</span><br><span class=\"line\">   BeanWrapper instanceWrapper = null;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (mbd.isSingleton()) &#123;</span><br><span class=\"line\">      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (instanceWrapper == null) &#123;</span><br><span class=\"line\">      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span><br><span class=\"line\">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 <span class=\"string\">\"bean 实例\"</span></span><br><span class=\"line\">   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class=\"line\">   // 类型</span><br><span class=\"line\">   Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</span><br><span class=\"line\">   mbd.resolvedTargetType = beanType;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span><br><span class=\"line\">   synchronized (mbd.postProcessingLock) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!mbd.postProcessed) &#123;</span><br><span class=\"line\">         try &#123;</span><br><span class=\"line\">            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span><br><span class=\"line\">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         catch (Throwable ex) &#123;</span><br><span class=\"line\">            throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class=\"line\">                  <span class=\"string\">\"Post-processing of merged bean definition failed\"</span>, ex);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         mbd.postProcessed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Eagerly cache singletons to be able to resolve circular references</span><br><span class=\"line\">   // even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class=\"line\">   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span><br><span class=\"line\">   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class=\"line\">         isSingletonCurrentlyInCreation(beanName));</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (earlySingletonExposure) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">         logger.debug(<span class=\"string\">\"Eagerly caching bean '\"</span> + beanName +</span><br><span class=\"line\">               <span class=\"string\">\"' to allow for resolving potential circular references\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class=\"line\">         @Override</span><br><span class=\"line\">         public Object getObject() throws BeansException &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Initialize the bean instance.</span><br><span class=\"line\">   Object exposedObject = bean;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span><br><span class=\"line\">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (exposedObject != null) &#123;</span><br><span class=\"line\">         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span><br><span class=\"line\">         // 这里就是处理 bean 初始化完成后的各种回调</span><br><span class=\"line\">         exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (Throwable ex) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class=\"line\">         throw (BeanCreationException) ex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         throw new BeanCreationException(</span><br><span class=\"line\">               mbd.getResourceDescription(), beanName, <span class=\"string\">\"Initialization of bean failed\"</span>, ex);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (earlySingletonExposure) &#123;</span><br><span class=\"line\">      // </span><br><span class=\"line\">      Object earlySingletonReference = getSingleton(beanName, <span class=\"literal\">false</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (earlySingletonReference != null) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (exposedObject == bean) &#123;</span><br><span class=\"line\">            exposedObject = earlySingletonReference;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class=\"line\">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class=\"line\">            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class=\"line\">                  actualDependentBeans.add(dependentBean);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class=\"line\">               throw new BeanCurrentlyInCreationException(beanName,</span><br><span class=\"line\">                     <span class=\"string\">\"Bean with name '\"</span> + beanName + <span class=\"string\">\"' has been injected into other beans [\"</span> +</span><br><span class=\"line\">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class=\"line\">                     <span class=\"string\">\"] in its raw version as part of a circular reference, but has eventually been \"</span> +</span><br><span class=\"line\">                     <span class=\"string\">\"wrapped. This means that said other beans do not use the final version of the \"</span> +</span><br><span class=\"line\">                     <span class=\"string\">\"bean. This is often the result of over-eager type matching - consider using \"</span> +</span><br><span class=\"line\">                     <span class=\"string\">\"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Register bean as disposable.</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (BeanDefinitionValidationException ex) &#123;</span><br><span class=\"line\">      throw new BeanCreationException(</span><br><span class=\"line\">            mbd.getResourceDescription(), beanName, <span class=\"string\">\"Invalid destruction signature\"</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">return</span> exposedObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p>\n<p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 </p>\n<p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p>\n<p><strong>创建 Bean 实例</strong><br>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123;</span><br><span class=\"line\">   // 确保已经加载了此 class</span><br><span class=\"line\">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 校验一下这个类的访问权限</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class=\"line\">      throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class=\"line\">            <span class=\"string\">\"Bean class isn't public, and non-public access not allowed: \"</span> + beanClass.getName());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (mbd.getFactoryMethodName() != null)  &#123;</span><br><span class=\"line\">      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean</span><br><span class=\"line\">      <span class=\"built_in\">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果不是第一次创建，比如第二次创建 prototype bean。</span><br><span class=\"line\">   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span><br><span class=\"line\">   boolean resolved = <span class=\"literal\">false</span>;</span><br><span class=\"line\">   boolean autowireNecessary = <span class=\"literal\">false</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (args == null) &#123;</span><br><span class=\"line\">      synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class=\"line\">            resolved = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (resolved) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (autowireNecessary) &#123;</span><br><span class=\"line\">         // 构造函数依赖注入</span><br><span class=\"line\">         <span class=\"built_in\">return</span> autowireConstructor(beanName, mbd, null, null);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         // 无参构造函数</span><br><span class=\"line\">         <span class=\"built_in\">return</span> instantiateBean(beanName, mbd);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 判断是否采用有参构造函数</span><br><span class=\"line\">   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (ctors != null ||</span><br><span class=\"line\">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class=\"line\">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class=\"line\">      // 构造函数依赖注入</span><br><span class=\"line\">      <span class=\"built_in\">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 调用无参构造函数</span><br><span class=\"line\">   <span class=\"built_in\">return</span> instantiateBean(beanName, mbd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      Object beanInstance;</span><br><span class=\"line\">      final BeanFactory parent = this;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class=\"line\">         beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Object <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"built_in\">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;, getAccessControlContext());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         // 实例化</span><br><span class=\"line\">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 包装一下，返回</span><br><span class=\"line\">      BeanWrapper bw = new BeanWrapperImpl(beanInstance);</span><br><span class=\"line\">      initBeanWrapper(bw);</span><br><span class=\"line\">      <span class=\"built_in\">return</span> bw;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (Throwable ex) &#123;</span><br><span class=\"line\">      throw new BeanCreationException(</span><br><span class=\"line\">            mbd.getResourceDescription(), beanName, <span class=\"string\">\"Instantiation of bean failed\"</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，关键的地方在于：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure>\n<p>这里会进行实际的实例化过程，我们进去看看:</p>\n<p>// SimpleInstantiationStrategy 59</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span><br><span class=\"line\">   // 方法覆写 请参见附录<span class=\"string\">\"方法注入\"</span>中对 lookup-method 和 replaced-method 的介绍</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class=\"line\">      Constructor&lt;?&gt; constructorToUse;</span><br><span class=\"line\">      synchronized (bd.constructorArgumentLock) &#123;</span><br><span class=\"line\">         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (constructorToUse == null) &#123;</span><br><span class=\"line\">            final Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (clazz.isInterface()) &#123;</span><br><span class=\"line\">               throw new BeanInstantiationException(clazz, <span class=\"string\">\"Specified class is an interface\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class=\"line\">                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">                     @Override</span><br><span class=\"line\">                     public Constructor&lt;?&gt; run() throws Exception &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">return</span> clazz.getDeclaredConstructor((Class[]) null);</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (Throwable ex) &#123;</span><br><span class=\"line\">               throw new BeanInstantiationException(clazz, <span class=\"string\">\"No default constructor found\"</span>, ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 利用构造方法进行实例化</span><br><span class=\"line\">      <span class=\"built_in\">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span><br><span class=\"line\">      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持</span><br><span class=\"line\">      <span class=\"built_in\">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>bean 属性注入</strong><br>看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。</p>\n<p>// AbstractAutowireCapableBeanFactory 1203</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class=\"line\">   // bean 实例的所有属性都在这里了</span><br><span class=\"line\">   PropertyValues pvs = mbd.getPropertyValues();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (bw == null) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!pvs.isEmpty()) &#123;</span><br><span class=\"line\">         throw new BeanCreationException(</span><br><span class=\"line\">               mbd.getResourceDescription(), beanName, <span class=\"string\">\"Cannot apply property values to null instance\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         // Skip property population phase <span class=\"keyword\">for</span> null instance.</span><br><span class=\"line\">         <span class=\"built_in\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span><br><span class=\"line\">   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span><br><span class=\"line\">   // 我也没找到有实际的使用，所以我们暂且忽略这块吧</span><br><span class=\"line\">   boolean continueWithPropertyPopulation = <span class=\"literal\">true</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class=\"line\">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class=\"line\">            // 如果返回 <span class=\"literal\">false</span>，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class=\"line\">               continueWithPropertyPopulation = <span class=\"literal\">false</span>;</span><br><span class=\"line\">               <span class=\"built_in\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class=\"line\">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class=\"line\">      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class=\"line\">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 通过类型装配。复杂一些</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class=\"line\">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      pvs = newPvs;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class=\"line\">   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class=\"line\">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (hasInstAwareBpps) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class=\"line\">               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class=\"line\">               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span><br><span class=\"line\">               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span><br><span class=\"line\">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (pvs == null) &#123;</span><br><span class=\"line\">                  <span class=\"built_in\">return</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (needsDepCheck) &#123;</span><br><span class=\"line\">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   // 设置 bean 实例的属性值</span><br><span class=\"line\">   applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>initializeBean</strong><br>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class=\"line\">      AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class=\"line\">         @Override</span><br><span class=\"line\">         public Object <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</span><br><span class=\"line\">            invokeAwareMethods(beanName, bean);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;, getAccessControlContext());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span><br><span class=\"line\">      invokeAwareMethods(beanName, bean);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   Object wrappedBean = bean;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class=\"line\">      // BeanPostProcessor 的 postProcessBeforeInitialization 回调</span><br><span class=\"line\">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      // 处理 bean 中定义的 init-method，</span><br><span class=\"line\">      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span><br><span class=\"line\">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (Throwable ex) &#123;</span><br><span class=\"line\">      throw new BeanCreationException(</span><br><span class=\"line\">            (mbd != null ? mbd.getResourceDescription() : null),</span><br><span class=\"line\">            beanName, <span class=\"string\">\"Invocation of init method failed\"</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class=\"line\">      // BeanPostProcessor 的 postProcessAfterInitialization 回调</span><br><span class=\"line\">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> wrappedBean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p>\n<hr>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><h4 id=\"id和name\"><a href=\"#id和name\" class=\"headerlink\" title=\"id和name\"></a>id和name</h4><p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p>\n<p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beanFactory.getBean(<span class=\"string\">\"beanName or alias\"</span>);</span><br></pre></td></tr></table></figure>\n<p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"messageService\"</span> name=<span class=\"string\">\"m1, m2, m3\"</span> class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean name=<span class=\"string\">\"m1, m2, m3\"</span> class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>beanName 为：com.loonycoder.service.MessageServiceImpl#0，</p>\n<p>别名 1 个，为： com.loonycoder.service.MessageServiceImpl</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"messageService\"</span> class=<span class=\"string\">\"com.loonycoder.service.MessageServiceImpl\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>以上配置的结果就是：beanName 为 messageService，没有别名。</p>\n<h4 id=\"配置是否允许-Bean-覆盖、是否允许循环依赖\"><a href=\"#配置是否允许-Bean-覆盖、是否允许循环依赖\" class=\"headerlink\" title=\"配置是否允许 Bean 覆盖、是否允许循环依赖\"></a>配置是否允许 Bean 覆盖、是否允许循环依赖</h4><p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>\n<p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p>\n<p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p>\n<p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p>\n<p>添加这两个属性的作者 Juergen Hoeller 在这个 jira 的讨论中说明了怎么配置这两个属性。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NoBeanOverridingContextLoader extends ContextLoader &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) &#123;</span><br><span class=\"line\">    super.customizeContext(servletContext, applicationContext);</span><br><span class=\"line\">    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;</span><br><span class=\"line\">    arac.setAllowBeanDefinitionOverriding(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  protected ContextLoader <span class=\"function\"><span class=\"title\">createContextLoader</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new NoBeanOverridingContextLoader();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;listener&gt;</span><br><span class=\"line\">    &lt;listener-class&gt;com.loonycoder.MyContextLoaderListener&lt;/listener-class&gt;  </span><br><span class=\"line\">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"profile\"><a href=\"#profile\" class=\"headerlink\" title=\"profile\"></a>profile</h4><p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans profile=<span class=\"string\">\"development\"</span></span><br><span class=\"line\">    xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">    xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">    xmlns:jdbc=<span class=\"string\">\"http://www.springframework.org/schema/jdbc\"</span></span><br><span class=\"line\">    xsi:schemaLocation=<span class=\"string\">\"...\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;jdbc:embedded-database id=<span class=\"string\">\"dataSource\"</span>&gt;</span><br><span class=\"line\">        &lt;jdbc:script location=<span class=\"string\">\"classpath:com/loonycoder/config/sql/schema.sql\"</span>/&gt;</span><br><span class=\"line\">        &lt;jdbc:script location=<span class=\"string\">\"classpath:com/oonycoder/config/sql/test-data.sql\"</span>/&gt;</span><br><span class=\"line\">    &lt;/jdbc:embedded-database&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans profile=<span class=\"string\">\"production\"</span></span><br><span class=\"line\">    xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">    xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">    xmlns:jee=<span class=\"string\">\"http://www.springframework.org/schema/jee\"</span></span><br><span class=\"line\">    xsi:schemaLocation=<span class=\"string\">\"...\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;jee:jndi-lookup id=<span class=\"string\">\"dataSource\"</span> jndi-name=<span class=\"string\">\"java:comp/env/jdbc/datasource\"</span>/&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<p>应该不必做过多解释了吧，看每个文件第一行的 profile=””。</p>\n<p>当然，我们也可以在一个配置文件中使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">    xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">    xmlns:jdbc=<span class=\"string\">\"http://www.springframework.org/schema/jdbc\"</span></span><br><span class=\"line\">    xmlns:jee=<span class=\"string\">\"http://www.springframework.org/schema/jee\"</span></span><br><span class=\"line\">    xsi:schemaLocation=<span class=\"string\">\"...\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;beans profile=<span class=\"string\">\"development\"</span>&gt;</span><br><span class=\"line\">        &lt;jdbc:embedded-database id=<span class=\"string\">\"dataSource\"</span>&gt;</span><br><span class=\"line\">            &lt;jdbc:script location=<span class=\"string\">\"classpath:com/loonycoder/config/sql/schema.sql\"</span>/&gt;</span><br><span class=\"line\">            &lt;jdbc:script location=<span class=\"string\">\"classpath:com/loonycoder/config/sql/test-data.sql\"</span>/&gt;</span><br><span class=\"line\">        &lt;/jdbc:embedded-database&gt;</span><br><span class=\"line\">    &lt;/beans&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;beans profile=<span class=\"string\">\"production\"</span>&gt;</span><br><span class=\"line\">        &lt;jee:jndi-lookup id=<span class=\"string\">\"dataSource\"</span> jndi-name=<span class=\"string\">\"java:comp/env/jdbc/datasource\"</span>/&gt;</span><br><span class=\"line\">    &lt;/beans&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<p>理解起来也很简单吧。</p>\n<p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p>\n<p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p>\n<p>最简单的方式莫过于在程序启动的时候指定：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dspring.profiles.active=<span class=\"string\">\"profile1,profile2\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>profile 可以激活多个</p>\n</blockquote>\n<p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class=\"line\">ctx.getEnvironment().setActiveProfiles(<span class=\"string\">\"development\"</span>);</span><br><span class=\"line\">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class=\"line\">ctx.refresh(); // 重启</span><br></pre></td></tr></table></figure>\n<p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Dspring.profiles.active=prod -jar JavaDoop.jar</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"工厂模式生成-Bean\"><a href=\"#工厂模式生成-Bean\" class=\"headerlink\" title=\"工厂模式生成 Bean\"></a>工厂模式生成 Bean</h4><p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p>\n<p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p>\n<p>静态工厂：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"clientService\"</span></span><br><span class=\"line\">    class=<span class=\"string\">\"examples.ClientService\"</span></span><br><span class=\"line\">    factory-method=<span class=\"string\">\"createInstance\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ClientService &#123;</span><br><span class=\"line\">    private static ClientService clientService = new ClientService();</span><br><span class=\"line\">    private <span class=\"function\"><span class=\"title\">ClientService</span></span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 静态方法</span><br><span class=\"line\">    public static ClientService <span class=\"function\"><span class=\"title\">createInstance</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> clientService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实例工厂：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"serviceLocator\"</span> class=<span class=\"string\">\"examples.DefaultServiceLocator\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"clientService\"</span></span><br><span class=\"line\">    factory-bean=<span class=\"string\">\"serviceLocator\"</span></span><br><span class=\"line\">    factory-method=<span class=\"string\">\"createClientServiceInstance\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"accountService\"</span></span><br><span class=\"line\">    factory-bean=<span class=\"string\">\"serviceLocator\"</span></span><br><span class=\"line\">    factory-method=<span class=\"string\">\"createAccountServiceInstance\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DefaultServiceLocator &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class=\"line\"></span><br><span class=\"line\">    private static AccountService accountService = new AccountServiceImpl();</span><br><span class=\"line\"></span><br><span class=\"line\">    public ClientService <span class=\"function\"><span class=\"title\">createClientServiceInstance</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> clientService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public AccountService <span class=\"function\"><span class=\"title\">createAccountServiceInstance</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> accountService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"FactoryBean\"><a href=\"#FactoryBean\" class=\"headerlink\" title=\"FactoryBean\"></a>FactoryBean</h4><p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class=\"line\">    T getObject() throws Exception;</span><br><span class=\"line\">    Class&lt;T&gt; getObjectType();</span><br><span class=\"line\">    boolean isSingleton();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person &#123; </span><br><span class=\"line\">    private Car car ;</span><br><span class=\"line\">    private void setCar(Car car)&#123; this.car = car;  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;&#123;</span><br><span class=\"line\">    private String make; </span><br><span class=\"line\">    private int year ;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setMake(String m)&#123; this.make =m ; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setYear(int y)&#123; this.year = y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Car <span class=\"function\"><span class=\"title\">getObject</span></span>()&#123; </span><br><span class=\"line\">      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span><br><span class=\"line\">      CarBuilder cb = CarBuilder.car();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(year!=0) cb.setYear(this.year);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(StringUtils.hasText(this.make)) cb.setMake( this.make ); </span><br><span class=\"line\">      <span class=\"built_in\">return</span> cb.factory(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Class&lt;Car&gt; <span class=\"function\"><span class=\"title\">getObjectType</span></span>() &#123; <span class=\"built_in\">return</span> Car.class ; &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isSingleton</span></span>() &#123; <span class=\"built_in\">return</span> <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看看装配的时候是怎么配置的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean class = <span class=\"string\">\"com.loonycoder.MyCarFactoryBean\"</span> id = <span class=\"string\">\"car\"</span>&gt;</span><br><span class=\"line\">  &lt;property name = <span class=\"string\">\"make\"</span> value =<span class=\"string\">\"Honda\"</span>/&gt;</span><br><span class=\"line\">  &lt;property name = <span class=\"string\">\"year\"</span> value =<span class=\"string\">\"1994\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\">&lt;bean class = <span class=\"string\">\"com.loonycoder.Person\"</span> id = <span class=\"string\">\"josh\"</span>&gt;</span><br><span class=\"line\">  &lt;property name = <span class=\"string\">\"car\"</span> ref = <span class=\"string\">\"car\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p>\n<p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration </span><br><span class=\"line\">public class CarConfiguration &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean </span><br><span class=\"line\">    public MyCarFactoryBean <span class=\"function\"><span class=\"title\">carFactoryBean</span></span>()&#123; </span><br><span class=\"line\">      MyCarFactoryBean cfb = new MyCarFactoryBean();</span><br><span class=\"line\">      cfb.setMake(<span class=\"string\">\"Honda\"</span>);</span><br><span class=\"line\">      cfb.setYear(1994);</span><br><span class=\"line\">      <span class=\"built_in\">return</span> cfb;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Person <span class=\"function\"><span class=\"title\">aPerson</span></span>()&#123; </span><br><span class=\"line\">    Person person = new Person();</span><br><span class=\"line\">      // 注意这里的不同</span><br><span class=\"line\">    person.setCar(carFactoryBean().getObject());</span><br><span class=\"line\">    <span class=\"built_in\">return</span> person; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p>\n<h4 id=\"初始化-Bean-的回调\"><a href=\"#初始化-Bean-的回调\" class=\"headerlink\" title=\"初始化 Bean 的回调\"></a>初始化 Bean 的回调</h4><p>有以下四种方案：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"exampleInitBean\"</span> class=<span class=\"string\">\"examples.ExampleBean\"</span> init-method=<span class=\"string\">\"init\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AnotherExampleBean implements InitializingBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">afterPropertiesSet</span></span>() &#123;</span><br><span class=\"line\">        // <span class=\"keyword\">do</span> some initialization work</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean(initMethod = <span class=\"string\">\"init\"</span>)</span><br><span class=\"line\">public Foo <span class=\"function\"><span class=\"title\">foo</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new Foo();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PostConstruct</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">init</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"销毁-Bean-的回调\"><a href=\"#销毁-Bean-的回调\" class=\"headerlink\" title=\"销毁 Bean 的回调\"></a>销毁 Bean 的回调</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"exampleInitBean\"</span> class=<span class=\"string\">\"examples.ExampleBean\"</span> destroy-method=<span class=\"string\">\"cleanup\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AnotherExampleBean implements DisposableBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"function\"><span class=\"title\">destroy</span></span>() &#123;</span><br><span class=\"line\">        // <span class=\"keyword\">do</span> some destruction work (like releasing pooled connections)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean(destroyMethod = <span class=\"string\">\"cleanup\"</span>)</span><br><span class=\"line\">public Bar <span class=\"function\"><span class=\"title\">bar</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> new Bar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@PreDestroy</span><br><span class=\"line\">public void <span class=\"function\"><span class=\"title\">cleanup</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ConversionService\"><a href=\"#ConversionService\" class=\"headerlink\" title=\"ConversionService\"></a>ConversionService</h4><p>既然文中说到了这个，顺便提一下好了。</p>\n<p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p>\n<p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"conversionService\"</span></span><br><span class=\"line\">  class=<span class=\"string\">\"org.springframework.context.support.ConversionServiceFactoryBean\"</span>&gt;</span><br><span class=\"line\">  &lt;property name=<span class=\"string\">\"converters\"</span>&gt;</span><br><span class=\"line\">    &lt;list&gt;</span><br><span class=\"line\">      &lt;bean class=<span class=\"string\">\"com.loonycoder.learning.utils.StringToEnumConverterFactory\"</span>/&gt;</span><br><span class=\"line\">    &lt;/list&gt;</span><br><span class=\"line\">  &lt;/property&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p>\n<p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p>\n<p>来看一个很简单的例子，这样比什么都管用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Date convert(String <span class=\"built_in\">source</span>) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> DateUtils.parseDate(<span class=\"built_in\">source</span>, <span class=\"string\">\"yyyy-MM-dd\"</span>, <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>, <span class=\"string\">\"yyyy-MM-dd HH:mm\"</span>, <span class=\"string\">\"HH:mm:ss\"</span>, <span class=\"string\">\"HH:mm\"</span>);</span><br><span class=\"line\">        &#125; catch (ParseException e) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">return</span> null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p>\n<h4 id=\"Bean-继承\"><a href=\"#Bean-继承\" class=\"headerlink\" title=\"Bean 继承\"></a>Bean 继承</h4><p>在初始化 Bean 的地方，我们说过了这个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure>\n<p>这里涉及到的就是 <code>&lt;bean parent=\"\" /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p>\n<p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p>\n<p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p>\n<p>看如下一个例子:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"inheritedTestBean\"</span> abstract=<span class=\"string\">\"true\"</span> class=<span class=\"string\">\"org.springframework.beans.TestBean\"</span>&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"name\"</span> value=<span class=\"string\">\"parent\"</span>/&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"age\"</span> value=<span class=\"string\">\"1\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"inheritsWithDifferentClass\"</span> class=<span class=\"string\">\"org.springframework.beans.DerivedTestBean\"</span></span><br><span class=\"line\">        parent=<span class=\"string\">\"inheritedTestBean\"</span> init-method=<span class=\"string\">\"initialize\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"name\"</span> value=<span class=\"string\">\"override\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>parent bean 设置了 <code>abstract=\"true\"</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p>\n<p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p>\n<p>当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p>\n<p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"inheritedTestBeanWithoutClass\"</span> abstract=<span class=\"string\">\"true\"</span>&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"name\"</span> value=<span class=\"string\">\"parent\"</span>/&gt;</span><br><span class=\"line\">    &lt;property name=<span class=\"string\">\"age\"</span> value=<span class=\"string\">\"1\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法注入\"><a href=\"#方法注入\" class=\"headerlink\" title=\"方法注入\"></a>方法注入</h4><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p>\n<p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p>\n<p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p>\n<p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p>\n<p><strong>lookup-method</strong><br>我们来看一下 Spring Reference 中提供的一个例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package fiona.apple;</span><br><span class=\"line\"></span><br><span class=\"line\">// no more Spring imports!</span><br><span class=\"line\"></span><br><span class=\"line\">public abstract class CommandManager &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object process(Object commandState) &#123;</span><br><span class=\"line\">        // grab a new instance of the appropriate Command interface</span><br><span class=\"line\">        Command <span class=\"built_in\">command</span> = createCommand();</span><br><span class=\"line\">        // <span class=\"built_in\">set</span> the state on the (hopefully brand new) Command instance</span><br><span class=\"line\">        command.setState(commandState);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> command.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // okay... but <span class=\"built_in\">where</span> is the implementation of this method?</span><br><span class=\"line\">    protected abstract Command createCommand();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"myCommand\"</span> class=<span class=\"string\">\"fiona.apple.AsyncCommand\"</span> scope=<span class=\"string\">\"prototype\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- inject dependencies here as required --&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"commandManager\"</span> class=<span class=\"string\">\"fiona.apple.CommandManager\"</span>&gt;</span><br><span class=\"line\">    &lt;lookup-method name=<span class=\"string\">\"createCommand\"</span> bean=<span class=\"string\">\"myCommand\"</span>/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p>Spring 采用 <strong>CGLIB</strong> 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p>\n<p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class CommandManager &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object process(Object commandState) &#123;</span><br><span class=\"line\">        MyCommand <span class=\"built_in\">command</span> = createCommand();</span><br><span class=\"line\">        command.setState(commandState);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> command.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Lookup(<span class=\"string\">\"myCommand\"</span>)</span><br><span class=\"line\">    protected abstract Command createCommand();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=\"com.loonycoder\" /&gt;</code></p>\n</blockquote>\n<p>甚至，我们可以像下面这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class CommandManager &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object process(Object commandState) &#123;</span><br><span class=\"line\">        MyCommand <span class=\"built_in\">command</span> = createCommand();</span><br><span class=\"line\">        command.setState(commandState);</span><br><span class=\"line\">        <span class=\"built_in\">return</span> command.execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Lookup</span><br><span class=\"line\">    protected abstract MyCommand createCommand();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p>\n</blockquote>\n<p><strong>replaced-method</strong><br>记住它的功能，就是替换掉 bean 中的一些方法。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyValueCalculator &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String computeValue(String input) &#123;</span><br><span class=\"line\">        // some real code...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // some other methods...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法覆写，注意要实现 MethodReplacer 接口：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123;</span><br><span class=\"line\">        // get the input value, work with it, and <span class=\"built_in\">return</span> a computed result</span><br><span class=\"line\">        String input = (String) args[0];</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"built_in\">return</span> ...;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置也很简单：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">\"myValueCalculator\"</span> class=<span class=\"string\">\"x.y.z.MyValueCalculator\"</span>&gt;</span><br><span class=\"line\">    &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span><br><span class=\"line\">    &lt;replaced-method name=<span class=\"string\">\"computeValue\"</span> replacer=<span class=\"string\">\"replacementComputeValue\"</span>&gt;</span><br><span class=\"line\">        &lt;arg-type&gt;String&lt;/arg-type&gt;</span><br><span class=\"line\">    &lt;/replaced-method&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">\"replacementComputeValue\"</span> class=<span class=\"string\">\"a.b.c.ReplacementComputeValue\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p>\n</blockquote>\n<h4 id=\"BeanPostProcessor\"><a href=\"#BeanPostProcessor\" class=\"headerlink\" title=\"BeanPostProcessor\"></a>BeanPostProcessor</h4><p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BeanPostProcessor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p>\n<p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p>\n<p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p>\n<p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p>\n<p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p>\n<p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p>\n<p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>按理说，总结应该写在附录前面，我就不讲究了。</p>\n<p>在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。</p>\n<p>本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。</p>\n<p>（全文完）</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck6xlmiyb0000v9s65fq8aoqo","category_id":"ck6xlmiyk0004v9s6fl2y529d","_id":"ck6xlmiys000fv9s645f219lo"},{"post_id":"ck6xlmiyh0002v9s6d9bphoby","category_id":"ck6xlmiyp000av9s60yqe4f65","_id":"ck6xlmiyw000lv9s64t5kbtnd"},{"post_id":"ck6xlmiyl0006v9s62zjt1tpo","category_id":"ck6xlmiyp000av9s60yqe4f65","_id":"ck6xlmiyz000qv9s6e723c80l"},{"post_id":"ck6xlmiyn0008v9s68nefb2yx","category_id":"ck6xlmiyw000kv9s6ewc0ft4u","_id":"ck6xlmiz1000xv9s6f5ke341j"},{"post_id":"ck6xlmiyo0009v9s6g3vr7hzl","category_id":"ck6xlmiyw000kv9s6ewc0ft4u","_id":"ck6xlmiz30013v9s6grly6mkg"},{"post_id":"ck6xlmiyq000dv9s61eieelkt","category_id":"ck6xlmiz1000wv9s6341naf2q","_id":"ck6xlmiz60019v9s657ajgwrd"},{"post_id":"ck6xlmiyr000ev9s6ezn75w6f","category_id":"ck6xlmiyw000kv9s6ewc0ft4u","_id":"ck6xlmiz8001gv9s689hea5ow"},{"post_id":"ck6xlmiyu000iv9s68ajp3que","category_id":"ck6xlmiz1000wv9s6341naf2q","_id":"ck6xlmiz9001iv9s6c0g51dek"},{"post_id":"ck6xlmiyv000jv9s63r16dxrr","category_id":"ck6xlmiz8001fv9s624ute5p5","_id":"ck6xlmiza001ov9s6bklbfwky"},{"post_id":"ck6xlmiyx000nv9s619sicn6s","category_id":"ck6xlmiz1000wv9s6341naf2q","_id":"ck6xlmizb001rv9s6dmto1bm2"},{"post_id":"ck6xlmiyy000pv9s6e1i0dzgn","category_id":"ck6xlmiz8001fv9s624ute5p5","_id":"ck6xlmizb001uv9s676vc59mf"},{"post_id":"ck6xlmiz0000uv9s6eatecnns","category_id":"ck6xlmiza001qv9s68zld1x33","_id":"ck6xlmizd0021v9s68b7u7g6b"},{"post_id":"ck6xlmiz0000vv9s64ws6dbsb","category_id":"ck6xlmiz8001fv9s624ute5p5","_id":"ck6xlmizf0025v9s6ajjje7bq"},{"post_id":"ck6xlmiz2000zv9s697sy4v92","category_id":"ck6xlmiz8001fv9s624ute5p5","_id":"ck6xlmizg0028v9s687mbemgd"},{"post_id":"ck6xlmiz30011v9s66923d2og","category_id":"ck6xlmizd0024v9s67bno0sxr","_id":"ck6xlmizg002cv9s679ek56mo"},{"post_id":"ck6xlmiz40016v9s66tede85g","category_id":"ck6xlmizg0029v9s60m0if0qy","_id":"ck6xlmizh002gv9s66edwf98u"},{"post_id":"ck6xlmiz50017v9s61sf51iof","category_id":"ck6xlmizg002dv9s6duuc3cn7","_id":"ck6xlmizi002kv9s6fiuw2s17"},{"post_id":"ck6xlmiz6001bv9s63msj8bl3","category_id":"ck6xlmizh002hv9s67x31dto4","_id":"ck6xlmizi002pv9s6akq9ayyv"},{"post_id":"ck6xlmiz7001dv9s6ez0xdctd","category_id":"ck6xlmizg002dv9s6duuc3cn7","_id":"ck6xlmizk002rv9s662xt3ye3"},{"post_id":"ck6xlmizy0031v9s685ai9o4e","category_id":"ck6xlmiz1000wv9s6341naf2q","_id":"ck6xlmizz0033v9s6dfdubk5y"}],"PostTag":[{"post_id":"ck6xlmiyb0000v9s65fq8aoqo","tag_id":"ck6xlmiyl0005v9s669yx685m","_id":"ck6xlmiyq000cv9s62cxe6aqw"},{"post_id":"ck6xlmiyh0002v9s6d9bphoby","tag_id":"ck6xlmiyq000bv9s6596l0dyp","_id":"ck6xlmiyy000ov9s63v97gmvu"},{"post_id":"ck6xlmiyh0002v9s6d9bphoby","tag_id":"ck6xlmiys000hv9s6fvrjeot4","_id":"ck6xlmiyz000rv9s67rbhdwla"},{"post_id":"ck6xlmiyl0006v9s62zjt1tpo","tag_id":"ck6xlmiyq000bv9s6596l0dyp","_id":"ck6xlmiz20010v9s623oif6qf"},{"post_id":"ck6xlmiyl0006v9s62zjt1tpo","tag_id":"ck6xlmiys000hv9s6fvrjeot4","_id":"ck6xlmiz30012v9s654hs3fyq"},{"post_id":"ck6xlmiyn0008v9s68nefb2yx","tag_id":"ck6xlmiyq000bv9s6596l0dyp","_id":"ck6xlmiz7001cv9s6fp89f9l0"},{"post_id":"ck6xlmiyn0008v9s68nefb2yx","tag_id":"ck6xlmiz30014v9s6fr0g7tpr","_id":"ck6xlmiz8001ev9s68rx59dbg"},{"post_id":"ck6xlmiyo0009v9s6g3vr7hzl","tag_id":"ck6xlmiyq000bv9s6596l0dyp","_id":"ck6xlmiz9001lv9s66c9u8n0w"},{"post_id":"ck6xlmiyo0009v9s6g3vr7hzl","tag_id":"ck6xlmiz30014v9s6fr0g7tpr","_id":"ck6xlmiza001mv9s6d89a0t5e"},{"post_id":"ck6xlmiyq000dv9s61eieelkt","tag_id":"ck6xlmiz9001jv9s61waihqyw","_id":"ck6xlmizb001tv9s6gzh99cni"},{"post_id":"ck6xlmiyq000dv9s61eieelkt","tag_id":"ck6xlmiza001pv9s66gchf1dj","_id":"ck6xlmizb001vv9s647wmelx4"},{"post_id":"ck6xlmiyr000ev9s6ezn75w6f","tag_id":"ck6xlmiyq000bv9s6596l0dyp","_id":"ck6xlmizc001yv9s6da51ccjc"},{"post_id":"ck6xlmiyr000ev9s6ezn75w6f","tag_id":"ck6xlmiz30014v9s6fr0g7tpr","_id":"ck6xlmizc001zv9s673bvf8zz"},{"post_id":"ck6xlmiyu000iv9s68ajp3que","tag_id":"ck6xlmizc001xv9s66w3s57l9","_id":"ck6xlmizd0023v9s6cm54e8zg"},{"post_id":"ck6xlmiyv000jv9s63r16dxrr","tag_id":"ck6xlmizd0022v9s62z126jy0","_id":"ck6xlmizf0027v9s64dlf36dw"},{"post_id":"ck6xlmiyx000nv9s619sicn6s","tag_id":"ck6xlmizc001xv9s66w3s57l9","_id":"ck6xlmizg002bv9s65mrjexz1"},{"post_id":"ck6xlmiyy000pv9s6e1i0dzgn","tag_id":"ck6xlmizd0022v9s62z126jy0","_id":"ck6xlmizh002fv9s6etepanmk"},{"post_id":"ck6xlmiz0000uv9s6eatecnns","tag_id":"ck6xlmizg002ev9s60m3259ev","_id":"ck6xlmizh002jv9s69223agsh"},{"post_id":"ck6xlmiz0000vv9s64ws6dbsb","tag_id":"ck6xlmizd0022v9s62z126jy0","_id":"ck6xlmizi002nv9s639a45mji"},{"post_id":"ck6xlmiz2000zv9s697sy4v92","tag_id":"ck6xlmizd0022v9s62z126jy0","_id":"ck6xlmizj002qv9s6cujxeveg"},{"post_id":"ck6xlmiz30011v9s66923d2og","tag_id":"ck6xlmizi002ov9s6gcbp4l04","_id":"ck6xlmizk002tv9s64son5wio"},{"post_id":"ck6xlmiz40016v9s66tede85g","tag_id":"ck6xlmizk002sv9s67cl7263w","_id":"ck6xlmizk002vv9s6edja6v1a"},{"post_id":"ck6xlmiz50017v9s61sf51iof","tag_id":"ck6xlmizk002uv9s6fmp20w41","_id":"ck6xlmizl002xv9s6bt538la1"},{"post_id":"ck6xlmiz6001bv9s63msj8bl3","tag_id":"ck6xlmizk002wv9s6fkt14kzo","_id":"ck6xlmizl002zv9s64mia7u6k"},{"post_id":"ck6xlmiz7001dv9s6ez0xdctd","tag_id":"ck6xlmizk002uv9s6fmp20w41","_id":"ck6xlmizl0030v9s6d3adb5m1"},{"post_id":"ck6xlmizy0031v9s685ai9o4e","tag_id":"ck6xlmizc001xv9s66w3s57l9","_id":"ck6xlmizz0032v9s67xj92q14"}],"Tag":[{"name":"数据结构 - 算法","_id":"ck6xlmiyl0005v9s669yx685m"},{"name":"Java","_id":"ck6xlmiyq000bv9s6596l0dyp"},{"name":"Java基础","_id":"ck6xlmiys000hv9s6fvrjeot4"},{"name":"Java框架 - 数据库","_id":"ck6xlmiz30014v9s6fr0g7tpr"},{"name":"框架","_id":"ck6xlmiz9001jv9s61waihqyw"},{"name":"权限框架","_id":"ck6xlmiza001pv9s66gchf1dj"},{"name":"框架 - Spring","_id":"ck6xlmizc001xv9s66w3s57l9"},{"name":"前端框架","_id":"ck6xlmizd0022v9s62z126jy0"},{"name":"DevOps - 服务器","_id":"ck6xlmizg002ev9s60m3259ev"},{"name":"Java - 面试题","_id":"ck6xlmizi002ov9s6gcbp4l04"},{"name":"HTTP服务器","_id":"ck6xlmizk002sv9s67cl7263w"},{"name":"数据库 - Redis","_id":"ck6xlmizk002uv9s6fmp20w41"},{"name":"Linux - 服务器","_id":"ck6xlmizk002wv9s6fkt14kzo"}]}}