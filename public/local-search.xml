<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>杂记</title>
    <link href="/2020/02/14/interview/"/>
    <url>/2020/02/14/interview/</url>
    
    <content type="html"><![CDATA[<p>近些日子在拉勾网上看到了史上最难Java题，顺便答了一下，结果10道题错了6道，表示十分遗憾。后愤然去网上搜集各种资料，果然还是太年轻，于此记录以告诫自己，学无止境！</p><h3 id="Apache-Dubbo的默认集群容错方案"><a href="#Apache-Dubbo的默认集群容错方案" class="headerlink" title="Apache Dubbo的默认集群容错方案"></a>Apache Dubbo的默认集群容错方案</h3><p>A、Failover Cluster<br>B、Failfast Cluster<br>C、Failsafe Cluster<br>D、Failback Cluster</p><p><strong>答案：A</strong></p><p><strong>解析：</strong><br>Dubbo提供了随机、轮询、最少调用优先等多种负载均衡策略，提供对zk等多种注册中心等支持，能够自动完成服务的注册与发现。Dubbo提供可视化的管理后台，方便对服务状态进行监控和管理。dubbo的数据通信默认使用netty来实现，拥有非常不错的性能。Dubbo默认的容错方案是Failover Cluster，即：失败自动切换，当出现失败，重试其它服务器。</p><p>除此之外，还提供以下其他容错方式：</p><ul><li>Failfast Cluster<br>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li>Failsafe Cluster<br>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li>Failback Cluster<br>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li>Forking Cluster<br>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</li><li>Broadcast Cluster<br>广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ul><hr><h3 id="下面关于Kafka说法错误的是"><a href="#下面关于Kafka说法错误的是" class="headerlink" title="下面关于Kafka说法错误的是:"></a>下面关于Kafka说法错误的是:</h3><p>A、消息是按照topic进行划分的，一个topic就是一个queue，一个topic可以有多个消费方，当生产方在某个topic发出一条消息后，所有订阅了这个topic的消费方都可以接受到这条消息<br>B、kafka为每个topic维护了多个partition分区，能保证一个topic的消息消费有序<br>C、所有的消息读写都是在主partition中进行，其他副本分区只会从主分区复制数据<br>D、消息的发送有三种方式：同步、异步、以及oneway，异步为默认方式</p><p><strong>答案：B、D</strong></p><p><strong>解析：</strong><br><img src="/images/kafka1.png" srcset="/img/loading.gif" alt="kafka"><br><img src="/images/kafka2.png" srcset="/img/loading.gif" alt="kafka"><br>Kafka只保证一个分区内的消息有序，<strong>不能保证一个topic的不同分区之间的消息有序。</strong><br>为了保证较高的处理效率，所有的消息读写都是在主patition中进行，其他副本分区只会从主分区复制数据。Kafka会在Zookeeper上针对每个Topic维护一个称为ISR(in-sync replica)，就是已同步的副本集。如果某个主分区不可用了，Kafka就会从ISR集合中选择一个副本作为新的主分区。<br>消息的发送有三种方式：同步、异步以及oneway。<strong>同步模式下后台线程中发送消息时同步获取结果，这也是默认模式。</strong><br>异步的模式允许生产者批量发送数据，可以极大的提高性能，但是会增加丢失数据的风险。oneway模式只发送消息不需要返回发送结果，消息可靠性最低，但是低延迟、高吞吐，适用于对可靠性要求不高的场景。</p><hr><h3 id="下面关于排序算法的描述正确的是"><a href="#下面关于排序算法的描述正确的是" class="headerlink" title="下面关于排序算法的描述正确的是:"></a>下面关于排序算法的描述正确的是:</h3><p>A、冒泡排序和插入排序都是稳定的排序算法<br>B、如果数组已经按照顺序排好序，使用插入排序，时间复杂度是O(n)<br>C、快速排序每次选择最大值座位基准值能够加入排序过程<br>D、快速排序最好情况的时间复杂度是O(nlogn)</p><p><strong>答案：A、B、D</strong></p><p><strong>解析：</strong><br>快速排序时间复杂度：<br>1、 最优情况：被选出来的基准值都是当前子数组的中间数。<br>不断地把一个规模为 n 的问题分解成规模为 n/2 的问题，一直分解到规模大小为 1。如果 n 等于 2，只需要分一次;如果 n 等于 4，需要分 2 次，以此类推，对于规模为 n 的问题，一共要进行 log(n) 次的切分。<br>把规模大小为 n 的问题分解成 n/2 的两个子问题时，和基准值进行了 n-1 次比较，复杂度就是 O(n)。<br>因此，在最优情况下，快速排序的复杂度是 O(nlogn)。</p><p>2、最坏情况：基准值选择了子数组里的最大或者最小值<br>每次都把子数组分成了两个更小的子数组，其中一个的长度为 1，另外一个的长度只比原子数组少 1，这样就需要n次的切分。<br>因此，算法复杂度为 O(n²)。</p><hr><h3 id="以下有关JVM的说法正确的是"><a href="#以下有关JVM的说法正确的是" class="headerlink" title="以下有关JVM的说法正确的是:"></a>以下有关JVM的说法正确的是:</h3><p>A、程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的。<br>B、虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的。<br>C、方法区用于存储JVM加载的类信息、常量、静态变量、以及编译器编译后的代码等数据，是线程共享的。<br>D、堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用空间时，会抛出OOM异常</p><p><strong>答案：A、B、C、D</strong></p><p><strong>解析：</strong><br><strong>虚拟机栈</strong> 也叫方法栈，是线程私有的，线程在执行每个方法时都会同时创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。<br><strong>本地方法栈</strong> 与虚拟机栈类似，也是用来保存线程执行方法时的信息，不同的是，执行java方法使用虚拟机栈，而执行native方法使用本地方法栈。<br><strong>程序计数器</strong> 保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器。程序计数器为执行java方法服务，执行native方法时，程序计数器为空。<br>栈、本地方法栈、程序计数器这三个部分都是线程独占的。<br><strong>堆</strong> 是JVM管理的内存中最大的一块，堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用的空间时，会抛出OOM异常。根据对象存活的周期不同，jvm把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理。<br>方法区 也是各个线程共享的内存区域，又叫非堆区。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，JDK7中的永久代和JDK8中的Metaspace都是方法区的一种实现。</p><hr><h3 id="关于TCP的关闭过程，说法正确的是"><a href="#关于TCP的关闭过程，说法正确的是" class="headerlink" title="关于TCP的关闭过程，说法正确的是:"></a>关于TCP的关闭过程，说法正确的是:</h3><p>A、处于TIME_WAIT状态的连接等待2MSL后真正关闭连接<br>B、对一个established状态的TCP连接，在调用shutdown函数之前调用close接口，可以让主动调用的一方进入半关闭状态<br>C、主动发送FIN消息的连接端，收到对方回应ack之前不能发只能收，在收到对方回复ack之后不能发也不能收，进入CLOSING状态<br>D、虽然TCP是可靠传输，但在已经成功建立连接的TCP连接上，也可能存在报文丢失</p><p><strong>答案：A、D</strong></p><p><strong>解析：</strong><br><img src="/images/tcp1.png" srcset="/img/loading.gif" alt="TCP"><br>A、等待2倍最大报文段生存时间之后在关闭链接，原因有两个：</p><ul><li>一、保证TCP协议的全双工连接能够可靠关闭</li><li>二、保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆</li></ul><p>B、shutdown可以使TCP半双工，但是如果之前调用了close，则直接关闭了socket</p><p>C、收到了ack之后的状态，也是不能发只能收，进入FIN_WAIT_2<br>通信中client和server两端的链接都是ESTABLISHED状态，然后client先主动发起了关闭链接请求，client向server发送了一个fin包，表示client端已经没有数据要发送了，然后client进入了FIN_WAIT_1状态。<br>server端收到fin后，返回ack，然后进入CLOSE_WAIT状态。此时server属于半关闭状态，因为此时client向server方向已经不会发送数据了，可是server向client端可能还有数据要发送。<br>当server端数据发送完毕后，server端会向client端发送fin，表示server端也没有数据要发送了，此时server进入LAST_ACK状态，就等待client的应答就可以关闭链接了。<br>client端收到server端的fin后，回复ack，然后进入TIME_WAIT状态。TIME_WAIT状态下需要等待2倍的最大报文段生存时间，来保证链接的可靠关闭。之后才会进入CLOSED关闭状态。而server端收到ack后直接就进入CLOSED状态。</p><p>D、由于TCP的下层网络（IP）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。</p><hr><h3 id="关于B-树比B树更适合做索引，以下说法正确的是"><a href="#关于B-树比B树更适合做索引，以下说法正确的是" class="headerlink" title="关于B+树比B树更适合做索引，以下说法正确的是:"></a>关于B+树比B树更适合做索引，以下说法正确的是:</h3><p>A、叶节点之间有指针相连，B+树更适合范围检索<br>B、非叶节点只保存关键字和指针，同样大小非叶节点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低<br>C、B+树的查询效率比较稳定。任何关键字的查找必须走一条从根节点到叶节点的路。所有关键字查询的路径长度相同，效率相当<br>D、非叶节点上，增加了指向同一层下一个非叶节点的指针，将节点的最低利用率从1/2提高到2/3</p><p><strong>答案：A、B、C</strong></p><p><strong>解析：</strong><br>B+树更适合索引系统，原因有：<br>1、由于叶节点之间有指针相连，B+树更适合范围检索;<br>2、由于非叶节点只保存关键字和指针，同样大小非叶节点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低;<br>3、B+树的查询效率比较稳定。任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，效率相当。</p><hr><h3 id="以下关于Netty说法，正确的是"><a href="#以下关于Netty说法，正确的是" class="headerlink" title="以下关于Netty说法，正确的是:"></a>以下关于Netty说法，正确的是:</h3><p>A、Netty线程模型采用”服务端监听线程”和”IO线程”分离的方式<br>B、通常情况下在NIO非阻塞模式下，Netty为每个Channel分配一个EventLoop，并且它的整个生命周期的时间都由这个EventLoop来处理<br>C、一个EventLoop可以绑定多个Channel<br>D、一般接收消息时，由pipeline处理完成会把消息提交到业务线程池进行处理</p><p><strong>答案：A、B、C、D</strong></p><p><strong>解析：</strong><br>Netty线程模型采用“服务端监听线程”和“IO线程”分离的方式，boss线程组负责监听事件，创建socket并绑定到Worker线程组。<br>Worker线程组负责IO处理。线程组由EventLoopGroup实现，其中包含了多个EventLoop事件处理器，每个EventLoop包含一个处理线程。<br>通常情况下在NIO非阻塞模式下，Netty为每个Channel分配一个EventLoop，并且它的整个生命周期中的事件都由这个EventLoop来处理。<br>一个EventLoop可以绑定多个Channel。<br>EventLoop的处理模型，Netty4中Channel的读写事件都是由Worker线程来处理。<br>请求处理中最主要的就是ChannelPipeline，其中包含了一组ChannelHandler。<br>这些Handler组成了责任链模式，依次对Channel中的消息进行处理。<br>一般接收消息时，由pipeline处理完成会把消息提交到业务线程池进行处理，当业务线程处理完成时，会封装成task，提交回Channel对应的EventLoop来写回返回值。</p><h3 id="Mybatis在执行SQL时，正确的调用顺序是"><a href="#Mybatis在执行SQL时，正确的调用顺序是" class="headerlink" title="Mybatis在执行SQL时，正确的调用顺序是:"></a>Mybatis在执行SQL时，正确的调用顺序是:</h3><p>①SqlSessionFactory<br>②SqlSession<br>③StatementHandler<br>④ParameterHandler<br>⑤ResultSetHandler<br>⑥Executor<br>⑦TypeHandler</p><p>A、①②③④⑤⑥⑦<br>B、①②⑥③④⑦⑤<br>C、①②④③⑦⑥⑤<br>D、①②③⑦④⑥⑤</p><p><strong>答案：B</strong></p><p><strong>解析：</strong><br><img src="/images/mybatisflow.png" srcset="/img/loading.gif" alt="mybatisflow"><br>在执行sql时，首先会从SqlSessionFactory中创建一个新的SqlSession。<br>sql语句是通过sqlSession中的Executor来执行，Executor根据SqlSession传递的参数执行query()方法，然后创建一个StatementHandler对象，将必要的参数传递给StatementHandler，由StatementHandler来完成对数据库的查询。<br>StatementHandler调用ParameterHandler的setParameters方法，把用户传递的参数转换成JDBC Statement所需要的参数， 调用原生JDBC来执行语句。<br>最后由ResultSetHandler的handleResultSets方法对JDBC返回的ResultSet结果集转换成对象集，并逐级返回结果，完成一次sql语句执行。</p><hr><h3 id="以下关于向线程池提交任务，正确的步骤是"><a href="#以下关于向线程池提交任务，正确的步骤是" class="headerlink" title="以下关于向线程池提交任务，正确的步骤是:"></a>以下关于向线程池提交任务，正确的步骤是:</h3><p>①判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务<br>②判断线程池中的线程数是否大于设置的核心线程数，创建核心线程执行任务<br>③判断缓冲队列是否满了，如果没满，放入队列等待执行<br>④执行拒绝策略</p><p>A、②①③④<br>B、②③①④<br>C、①②③④<br>D、①③②④</p><p><strong>答案：B</strong></p><p><strong>解析：</strong><br><img src="/images/thread.png" srcset="/img/loading.gif" alt="thread"><br>我们看看向线程池提交任务时的执行顺序。<br>向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。<br>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。<br>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。<br>如果已经达到了最大线程数，则执行指定的拒绝策略。</p><hr><h3 id="以下关于类的加载机制错误的是"><a href="#以下关于类的加载机制错误的是" class="headerlink" title="以下关于类的加载机制错误的是:"></a>以下关于类的加载机制错误的是:</h3><p>A、类的加载指的是将编译好的class类文件中的字节码读入到内存中，将其放在堆内并创建对应的Class对象<br>B、加载是文件到内存的过程。通过类的完全限定名查找类字节码文件，并利用字节码文件创建一个Class对象<br>C、准备阶段是进行内存分配。为类变量也就是类中由static修饰的变量分配内存，并且设置初始值是0或者null，而不是代码中设置的具体值<br>D、解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。</p><p><strong>答案：A</strong></p><p><strong>解析：</strong><br><img src="/images/classloader.png" srcset="/img/loading.gif" alt="classloader"><br>类的加载指的是将编译好的class类文件中的字节码读入到内存中，将其放在方法区内并创建对应的Class对象。<br>类的加载分为加载、链接、初始化，其中链接又包括验证、准备、解析三步。<br>看到图中上半部分深绿色，我们逐个分析：<br>加载是文件到内存的过程。通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个Class对象<br>验证是对类文件内容验证。目的在于确保Class文件符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种：<br>文件格式验证，元数据验证，字节码验证，符号引用验证。<br>准备阶段是进行内存分配。为类变量也就是类中由static修饰的变量分配内存，并且设置初始值，这里要注意，初始值是0或者null，而不是代码中设置的具体值，代码中设置的值是在初始化阶段完成的。另外这里也不包含用final修饰的静态变量，因为final在编译的时候就会分配了。<br>解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。<br>最后是初始化：主要完成静态块执行与静态变量的赋值。这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。<br>只有对类主动使用时，才会进行初始化，初始化的触发条件包括创建类的实例的时候、访问类的静态方法或者静态变量的时候、Class.forName()反射类的时候、或者某个子类被初始化的时候。</p>]]></content>
    
    
    <categories>
      
      <category>Interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java - 面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最全面的TCP/IP协议讲解</title>
    <link href="/2019/09/20/tcpip/"/>
    <url>/2019/09/20/tcpip/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>大学时期学的最差的专业课就是网络通信，而且目前对于三次握手、四次握手的面试命中率极高，基本上是必考题，所以补补课。<br>有幸在csdn上拜读到<strong>涤生_Woo</strong>老师的文章，全程跪着看完。<br>文章转自：<a href="https://blog.csdn.net/wuzhiwei549/article/details/105965493?utm_source=app" target="_blank" rel="noopener">太厉害了，终于有人能把TCP/IP 协议讲的明明白白了</a></p><p><strong>一图看完本文</strong><br><img src="/images/tcpip/tcp1.jpg" srcset="/img/loading.gif" alt="TCP/IP协议"></p><h3 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h3><p>计算机网络体系结构分层</p><p><img src="/images/tcpip/tcp2.jpg" srcset="/img/loading.gif" alt="计算机网络结构"></p><p><img src="/images/tcpip/tcp3.jpg" srcset="/img/loading.gif" alt="计算机网络结构分层"></p><p><strong>不难看出，TCP/IP 与 OSI 在分层模块上稍有区别。OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。</strong></p><h3 id="TCP-IP-基础"><a href="#TCP-IP-基础" class="headerlink" title="TCP/IP 基础"></a>TCP/IP 基础</h3><h4 id="TCP-IP-的具体含义"><a href="#TCP-IP-的具体含义" class="headerlink" title="TCP/IP 的具体含义"></a>TCP/IP 的具体含义</h4><p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。</p><p>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><p>网际协议群</p><p><img src="/images/tcpip/tcp4.jpg" srcset="/img/loading.gif" alt="网际协议群"></p><hr><h4 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h4><p><strong>包、帧、数据包、段、消息</strong></p><p>以上五个术语都用来表述数据的单位，大致区分如下：</p><ul><li><strong>包</strong>可以说是全能性术语；</li><li><strong>帧</strong>用于表示数据链路层中包的单位；</li><li><strong>数据包</strong>是 IP 和 UDP 等网络层以上的分层中包的单位；</li><li><strong>段</strong>则表示 TCP 数据流中的信息；</li><li><strong>消息</strong>是指应用协议中数据的单位。</li></ul><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p><p>数据包首部</p><p><img src="/images/tcpip/tcp5.jpg" srcset="/img/loading.gif" alt="数据包首部"></p><p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。<strong>包首部就像协议的脸。</strong></p><h4 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h4><p>下图以用户 a 向用户 b 发送邮件为例子：</p><p><img src="/images/tcpip/tcp6.jpg" srcset="/img/loading.gif" alt="数据处理流程"></p><p>数据处理流程</p><ul><li>① 应用程序处理</li><li>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；</li><li>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</li><li>② TCP 模块的处理</li><li>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</li><li>③ IP 模块的处理</li><li>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</li><li>④ 网络接口（以太网驱动）的处理</li><li>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</li><li>⑤ 网络接口（以太网驱动）的处理</li><li>主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。</li><li>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</li><li>⑥ IP 模块的处理</li><li>IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。</li><li>另外，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</li><li>⑦ TCP 模块的处理</li><li>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</li><li>⑧ 应用程序的处理</li><li>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</li></ul><hr><h3 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h3><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p><ul><li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</li><li>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</li><li>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</li></ul><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p><h5 id="根据端口号识别应用"><a href="#根据端口号识别应用" class="headerlink" title="根据端口号识别应用"></a>根据端口号识别应用</h5><p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p><p><img src="/images/tcpip/tcp7.jpg" srcset="/img/loading.gif" alt="数据处理流程"></p><h5 id="通过-IP-地址、端口号、协议号进行通信识别"><a href="#通过-IP-地址、端口号、协议号进行通信识别" class="headerlink" title="通过 IP 地址、端口号、协议号进行通信识别"></a>通过 IP 地址、端口号、协议号进行通信识别</h5><ul><li>仅凭目标端口号识别某一个通信是远远不够的。</li></ul><p><img src="/images/tcpip/tcp8.jpg" srcset="/img/loading.gif" alt="数据处理流程"></p><p><img src="/images/tcpip/tcp9.jpg" srcset="/img/loading.gif" alt="数据处理流程"></p><p>通过端口号、IP地址、协议号进行通信识别</p><p>① 和 ② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。<br>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。<br>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</p><h5 id="端口号的确定"><a href="#端口号的确定" class="headerlink" title="端口号的确定"></a>端口号的确定</h5><ul><li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0-1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024-49151 之间，不过这些端口号可用于任何通信用途。</li><li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152-65535 之间。</li></ul><h5 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h5><ul><li>端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。</li><li>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li><li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li><li>此外，传输途中出现丢包，UDP 也不负责重发。</li><li>甚至当包的到达顺序出现乱序时也没有纠正的功能。</li><li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li><li>UDP 常用于一下几个方面：<ul><li>包总量较少的通信（DNS、SNMP等）；</li><li>视频、音频等多媒体通信（即时通信）；</li><li>限定于 LAN 等特定网络中的应用通信；</li><li>广播通信（广播、多播）。</li></ul></li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li><li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li><li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</li></ul><h5 id="三次握手（重点）"><a href="#三次握手（重点）" class="headerlink" title="三次握手（重点）"></a>三次握手（重点）</h5><p>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。<br>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p><p>下面来看看三次握手的流程图：</p><p><img src="/images/tcpip/tcp10.jpg" srcset="/img/loading.gif" alt="三次握手"></p><p><strong>三次握手</strong></p><ul><li>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li><li>第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li><li>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li></ul><h5 id="四次挥手（重点）"><a href="#四次挥手（重点）" class="headerlink" title="四次挥手（重点）"></a>四次挥手（重点）</h5><ul><li>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</li><li>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</li></ul><p>下面来看看四次挥手的流程图：</p><p><img src="/images/tcpip/tcp11.jpg" srcset="/img/loading.gif" alt="四次挥手"></p><p><strong>四次挥手</strong></p><ul><li>中断连接端可以是客户端，也可以是服务器端。</li><li>第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li><li>第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</li><li>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。</li><li>第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li></ul><p><strong>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况</strong></p><p>具体流程如下图：</p><p>同时挥手</p><p><img src="/images/tcpip/tcp12.jpg" srcset="/img/loading.gif" alt="同时挥手"></p><h5 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h5><ul><li>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</li><li>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</li><li>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</li><li>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</li><li>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。</li><li><strong>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</strong></li></ul><p>序列号和确认应答</p><p><img src="/images/tcpip/tcp13.jpg" srcset="/img/loading.gif" alt="序列号和确认应答"></p><h5 id="重发超时的确定"><a href="#重发超时的确定" class="headerlink" title="重发超时的确定"></a>重发超时的确定</h5><ul><li><strong>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。</strong>如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。</li><li>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</li><li>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</li><li>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</li><li>此外，<strong>数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</strong></li></ul><h5 id="以段为单位发送数据"><a href="#以段为单位发送数据" class="headerlink" title="以段为单位发送数据"></a>以段为单位发送数据</h5><ul><li>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</li><li>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</li><li>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</li></ul><h5 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h5><ul><li>TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。</li><li>为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</li></ul><p><img src="/images/tcpip/tcp14.jpg" srcset="/img/loading.gif" alt="序列号和确认应答"></p><ul><li>窗口控制</li><li>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</li></ul><h5 id="滑动窗口控制"><a href="#滑动窗口控制" class="headerlink" title="滑动窗口控制"></a>滑动窗口控制</h5><p>滑动窗口</p><p><img src="/images/tcpip/tcp15.jpg" srcset="/img/loading.gif" alt="滑动窗口"></p><ul><li>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</li><li>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</li><li>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</li></ul><h5 id="窗口控制中的重发控制"><a href="#窗口控制中的重发控制" class="headerlink" title="窗口控制中的重发控制"></a>窗口控制中的重发控制</h5><p>在使用窗口控制中， 出现丢包一般分为两种情况：</p><ul><li>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</li></ul><p>部分确认应答丢失</p><p><img src="/images/tcpip/tcp16.jpg" srcset="/img/loading.gif" alt="部分确认应答丢失"></p><ul><li>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</li></ul><p><img src="/images/tcpip/tcp18.jpg" srcset="/img/loading.gif" alt="高速重发控制"></p><hr><h3 id="网络层中的-IP-协议"><a href="#网络层中的-IP-协议" class="headerlink" title="网络层中的 IP 协议"></a>网络层中的 IP 协议</h3><ul><li>IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。</li><li>网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</li><li><strong>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</strong></li></ul><h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><h5 id="IP-地址概述"><a href="#IP-地址概述" class="headerlink" title="IP 地址概述"></a>IP 地址概述</h5><ul><li>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</li><li>作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</li><li>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</li><li>IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</li></ul><p><img src="/images/tcpip/tcp17.jpg" srcset="/img/loading.gif" alt="IP"></p><h5 id="IP-地址由网络和主机两部分标识组成"><a href="#IP-地址由网络和主机两部分标识组成" class="headerlink" title="IP 地址由网络和主机两部分标识组成"></a>IP 地址由网络和主机两部分标识组成</h5><ul><li>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。</li></ul><p>IP地址的主机标识</p><p><img src="/images/tcpip/tcp19.jpg" srcset="/img/loading.gif" alt="IP地址的主机标识"></p><ul><li>如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</li></ul><p>IP地址的网络标识</p><p><img src="/images/tcpip/tcp20.jpg" srcset="/img/loading.gif" alt="IP地址的网络标识"></p><h5 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h5><ul><li><strong>IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</strong></li><li><strong>A 类 IP 地址是首位以 “0” 开头的地址</strong>。从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。</li><li><strong>B 类 IP 地址是前两位 “10” 的地址。</strong>从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。</li><li><strong>C 类 IP 地址是前三位为 “110” 的地址。</strong>从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。</li><li><strong>D 类 IP 地址是前四位为 “1110” 的地址。</strong>从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li><li>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</li></ul><h5 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h5><ul><li>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。</li><li>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</li></ul><h5 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h5><ul><li>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</li><li>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</li></ul><p><img src="/images/tcpip/tcp21.jpg" srcset="/img/loading.gif" alt="IP多播"></p><ul><li>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。</li><li>此外，对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</li></ul><h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><ul><li>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</li><li>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。</li><li>对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</li></ul><p><img src="/images/tcpip/tcp22.jpg" srcset="/img/loading.gif" alt="子网掩码"></p><ul><li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/” 隔开，如下：</li></ul><p><img src="/images/tcpip/tcp23.jpg" srcset="/img/loading.gif" alt="子网掩码"></p><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul><li>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</li><li>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</li><li>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</li></ul><h5 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h5><ul><li>IP 地址的网络地址部分用于进行路由控制。</li><li>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</li><li>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</li></ul><p>路由控制表与 IP 包发送</p><p><img src="/images/tcpip/tcp24.jpg" srcset="/img/loading.gif" alt="路由控制表与 IP 包发送"></p><h4 id="IP-分包与组包"><a href="#IP-分包与组包" class="headerlink" title="IP 分包与组包"></a>IP 分包与组包</h4><ul><li>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</li><li>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</li><li>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</li></ul><h5 id="路径-MTU-发现"><a href="#路径-MTU-发现" class="headerlink" title="路径 MTU 发现"></a>路径 MTU 发现</h5><ul><li>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</li><li>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。</li><li>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</li></ul><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><ul><li>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。</li></ul><h5 id="IPv6-的特点"><a href="#IPv6-的特点" class="headerlink" title="IPv6 的特点"></a>IPv6 的特点</h5><ul><li>IP 得知的扩大与路由控制表的聚合。</li><li>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li><li>支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。</li><li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li><li>多播、Mobile IP 成为扩展功能。</li></ul><h5 id="IPv6-中-IP-地址的标记方法"><a href="#IPv6-中-IP-地址的标记方法" class="headerlink" title="IPv6 中 IP 地址的标记方法"></a>IPv6 中 IP 地址的标记方法</h5><ul><li>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。</li><li>而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</li></ul><h5 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h5><ul><li>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</li><li>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</li></ul><p><img src="/images/tcpip/tcp25.jpg" srcset="/img/loading.gif" alt="IP地址结构"></p><h5 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h5><ul><li>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</li><li>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</li></ul><p>全局单播地址</p><p><img src="/images/tcpip/tcp26.jpg" srcset="/img/loading.gif" alt="全局单播地址"></p><h5 id="链路本地单播地址"><a href="#链路本地单播地址" class="headerlink" title="链路本地单播地址"></a>链路本地单播地址</h5><ul><li>链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</li></ul><p>链路本地单播地址</p><p><img src="/images/tcpip/tcp27.jpg" srcset="/img/loading.gif" alt="链路本地单播地址"></p><h5 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h5><ul><li>唯一本地地址是不进行互联网通信时所用的地址。</li><li>唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</li><li>L 通常被置为 1</li><li>全局 ID 的值随机决定</li><li>子网 ID 是指该域子网地址</li><li>接口 ID 即为接口的 ID</li></ul><p>唯一本地地址</p><p><img src="/images/tcpip/tcp28.jpg" srcset="/img/loading.gif" alt="唯一本地地址"></p><h5 id="IPv6-分段处理"><a href="#IPv6-分段处理" class="headerlink" title="IPv6 分段处理"></a>IPv6 分段处理</h5><ul><li>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</li><li>IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</li></ul><h5 id="IP-首部（暂略）"><a href="#IP-首部（暂略）" class="headerlink" title="IP 首部（暂略）"></a>IP 首部（暂略）</h5><h4 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h4><ul><li>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</li></ul><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><ul><li>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</li><li>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</li></ul><h5 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h5><ul><li>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</li><li>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</li><li>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</li></ul><h5 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h5><ul><li>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</li><li>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</li></ul><h5 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h5><ul><li>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</li><li>于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</li><li>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</li></ul><h5 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h5><ul><li>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</li><li>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</li><li>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。</li></ul><h5 id="IP-隧道"><a href="#IP-隧道" class="headerlink" title="IP 隧道"></a>IP 隧道</h5><p><img src="/images/tcpip/tcp29.jpg" srcset="/img/loading.gif" alt="IP隧道"></p><p>夹着 IPv4 网络的两个 IPv6 网络</p><ul><li>如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</li><li>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。</li><li>一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络通信</tag>
      
      <tag>Http协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat体系架构分析</title>
    <link href="/2019/09/11/tomcat/"/>
    <url>/2019/09/11/tomcat/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/tomcat/tomcat_logo.jpg" srcset="/img/loading.gif" alt="spring"></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p><strong>源码地址：</strong><a href="https://github.com/LoonyCoder/learn-repository" target="_blank" rel="noopener">手写mini版tomcat</a><br><strong>欢迎star/fork，给作者一些鼓励！</strong></p><h3 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h3><p>虽然网上对于tomcat架构描述已经十分详细了，但在这里还是要先讲讲<strong>架构</strong></p><h4 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h4><p><img src="/images/tomcat/tomcat01.png" srcset="/img/loading.gif" alt="Tomcat顶层架构"></p><p><strong>先来看Connector和Container - 两个Tomcat的心脏：</strong></p><ul><li><code>Connector</code>用于处理连接相关的事情，并提供Socket与Request和Response相关的转化;</li><li><code>Container</code>用于封装和管理Servlet，以及具体处理Request请求；</li></ul><p><strong>Service - 面向外界的连接体</strong></p><ul><li>主要结合<code>Connector</code>和<code>Container</code>，实现封装，向外提供功能</li><li>一个Service只能有一个<code>Container</code>，但可以有多个<code>Connector</code></li></ul><p><strong>Server</strong></p><ul><li>掌控<code>Service</code>的生杀大权，管理整个Tomcat生命周期</li></ul><h4 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h4><p>请求进入Tomcat，经由Service交付到<code>Connector</code>，<code>Connector</code>将接收的请求封装为Request和Response，然后讲封装后的数据传递到<code>Container</code>处理，处理完成后返回<code>Connector</code>，通过Socket将结果返还给客户端。</p><p><img src="/images/tomcat/tomcat02.png" srcset="/img/loading.gif" alt="Tomcat连接示意图"></p><p><strong>Connector</strong></p><p><code>Connector</code>最底层使用的是（TCP/IP）Socket来进行连接的，Request和Response是按照HTTP协议来封装的。<br><img src="/images/tomcat/tomcat03.png" srcset="/img/loading.gif" alt="Connector结构图"></p><ol><li>通过不同类型的<code>ProtocolHandler</code>，<code>Connector</code>可以处理类型的连接请求，比如Socket、nio等连接</li><li>每个<code>ProtocolHandler</code>都包含了三个组件：<code>Endpoint</code>、<code>Processor</code>、<code>Adapter</code></li><li><code>Endpoint</code>实现TCP/IP协议，<code>Processor</code>实现HTTP协议的并将<code>Endpoint</code>接收到的Socket封装成Request，<code>Adapter</code>将Request适配大宋<code>Container</code>进行具体的处理</li><li><code>在Endpoint</code>中，其抽象实现<code>AbstractEndpoint</code>里包含<code>Acceptor</code>（监听请求）和<code>AsyncTimeout</code>（检查异步Request的超时）两个内部类和<code>Handler</code>（处理接收到的Socket，并调用<code>Processor</code>进行处理）接口。</li></ol><p><strong>Container</strong></p><p>管理Servlet，处理Request请求</p><p><img src="/images/tomcat/tomcat04.png" srcset="/img/loading.gif" alt="Container结构图"></p><ol><li>Engine 可以管理多个主机，一个Service最多只能有一个Engine；</li><li>Host 是虚拟主机，通过配置Host就可以添加多台主机；</li><li>Context 就意味着一个WEB应用程序；</li><li>Wrapper 是Tomcat对Servlet的一层封装；</li></ol><p><strong>Container处理请求的方式 - 管道流与阀门</strong></p><ul><li>像普通的责任链设计模式一样，上一个处理者将处理过的请求移交到下一个继续处理。</li><li><code>Pipeline-Valve</code>与责任链模式存在一些差异：<ul><li>每一个Pipeline都有一个特定的Valve，这个Valve处于责任链的末端</li><li>上面讲的四个容器都对应有自己特定的Valve：<code>StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve</code>。</li><li>在这个特定的Valve中会调用下层级的管道，比如：<code>EnginePipeline1 -> EnginePipeline2 -> StandardEngineValve(调用下级Pipeline) -> HostValve1 -> ... -> StandardHostValve -> ... -> StandardWrapperValve</code></li><li>当执行到最后一个Pipeline的特定Valve时，比如这里的<code>StandardWrapperValve</code>，会在<code>StandardWrapperValve</code>中创建FilterChain，其包含了配置的与请求相匹配的Filter和Servlet，并调用其<code>doFilter()</code>方法来处理请求，其<code>doFilter()</code>方法会依次调用所有的Filter的<code>doFilter()</code>方法和Servlet的<code>service()</code>方法，从而完成请求的处理，然后将结果返回给Connector，返还给客户端。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Servlet容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Servlet</tag>
      
      <tag>Http服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轻量级控制反转和面向切面的容器框架——Spring（六）</title>
    <link href="/2019/09/01/spring6/"/>
    <url>/2019/09/01/spring6/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/spring_logo.jpg" srcset="/img/loading.gif" alt="spring"></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前整理过一些关于Spring框架零散的知识点，一直没时间整理，恰好最近又拜读了<strong>应癫</strong>老师的课程，所以赶紧梳理一下关于Spring的相关知识。</p><hr><h3 id="Spring-AOP源码深度剖析"><a href="#Spring-AOP源码深度剖析" class="headerlink" title="Spring AOP源码深度剖析"></a>Spring AOP源码深度剖析</h3><h4 id="代理对象创建"><a href="#代理对象创建" class="headerlink" title="代理对象创建"></a>代理对象创建</h4><h5 id="AOP基础用例准备"><a href="#AOP基础用例准备" class="headerlink" title="AOP基础用例准备"></a>AOP基础用例准备</h5><p>Bean定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class LagouBean &#123;</span><br><span class="line">public void <span class="function"><span class="title">tech</span></span>()&#123;</span><br><span class="line">System.out.println(<span class="string">"java learning......"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Aspect定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class LagouAspect &#123;</span><br><span class="line">@Pointcut(<span class="string">"execution(* com.lagou.*.*(..))"</span>)</span><br><span class="line">public void <span class="function"><span class="title">pointcut</span></span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line">@Before(<span class="string">"pointcut()"</span>)</span><br><span class="line">public void <span class="function"><span class="title">before</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"before method ......"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试⽤例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 测试⽤例：Aop 代理对象创建</span><br><span class="line">*/</span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testAopProxyBuild</span></span>()&#123;</span><br><span class="line">ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">LagouBean lagouBean = applicationContext.getBean(LagouBean.class);</span><br><span class="line">lagouBean.tech();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="时机点分析"><a href="#时机点分析" class="headerlink" title="时机点分析"></a>时机点分析</h5><p><img src="/images/spring/s60.png" srcset="/img/loading.gif" alt="spring"></p><p>我们发现在 getBean 之前，LagouBean对象已经产⽣（即在第⼀⾏初始化代码中完成），⽽且该对象是⼀个代理对象（Cglib代理对象），我们断定，容器初始化过程中⽬标Ban已经完成了代理，返回了代理对象。</p><h5 id="代理对象创建流程"><a href="#代理对象创建流程" class="headerlink" title="代理对象创建流程"></a>代理对象创建流程</h5><p>AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object,org.springframework.beans.factory.support.RootBeanDefinition)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*</span><br><span class="line">* 初始化Bean</span><br><span class="line">包括Bean后置处理器初始化</span><br><span class="line">Bean的⼀些初始化⽅法的执⾏init-method</span><br><span class="line">Bean的实现的声明周期相关接⼝的属性注⼊</span><br><span class="line">*/</span><br><span class="line">protected Object initializeBean(final String beanName, final Object bean,</span><br><span class="line">@Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">// 执⾏所有的AwareMethods</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ifnvokeAwareMethods(beanName, bean);</span><br><span class="line">&#125;</span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">// 执⾏所有的BeanPostProcessor<span class="comment">#postProcessBeforeInitialization 初始化之前的处理器⽅法</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean,beanName);</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">// 这⾥就开始执⾏afterPropertiesSet（实现了InitializingBean接⼝）⽅法和 initMethod</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new BeanCreationException((mbd != null ? mbd.getResourceDescription() : null),beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">// 整个Bean初始化完成，执⾏后置处理器⽅法</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean,beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> wrappedBean; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123;</span><br><span class="line">Object result = existingBean;</span><br><span class="line">// 循环执⾏后置处理器</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">Object current = processor.postProcessAfterInitialization(result,</span><br><span class="line">beanName);</span><br><span class="line"><span class="keyword">if</span> (current == null) &#123;</span><br><span class="line"><span class="built_in">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line">result = current; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/spring/s61.png" srcset="/img/loading.gif" alt="spring"></p><p>创建代理对象的后置处理器AbstractAutoProxyCreator#postProcessAfterInitialization</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Create a proxy with the configured interceptors <span class="keyword">if</span> the bean is</span><br><span class="line">* identified as one to proxy by the subclass.</span><br><span class="line">* @see <span class="comment">#getAdvicesAndAdvisorsForBean</span></span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != null) &#123;</span><br><span class="line">// 检查下该类是否已经暴露过了（可能已经创建了，⽐如A依赖B时，创建A时候，就会先去创建B。</span><br><span class="line">// 当真正需要创建B时，就没必要再代理⼀次已经代理过的对象）,避免重复创建</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (this.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="built_in">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> bean; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractAutoProxyCreator#wrapIfNecessary</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Wrap the given bean <span class="keyword">if</span> necessary, i.e. <span class="keyword">if</span> it is eligible <span class="keyword">for</span> being</span><br><span class="line">proxied.</span><br><span class="line">* @param bean the raw bean instance</span><br><span class="line">* @param beanName the name of the bean</span><br><span class="line">* @param cacheKey the cache key <span class="keyword">for</span> metadata access</span><br><span class="line">* @<span class="built_in">return</span> a proxy wrapping the bean, or the raw bean instance as-is</span><br><span class="line">*/</span><br><span class="line">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line">// targetSourcedBeans包含，说明前⾯创建过</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="built_in">return</span> bean; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="built_in">return</span> bean; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="built_in">return</span> bean; </span><br><span class="line">&#125;</span><br><span class="line">// Create proxy <span class="keyword">if</span> we have advice.</span><br><span class="line">// 得到所有候选Advisor，对Advisors和bean的⽅法双层遍历匹配，最终得到⼀个 List&lt;Advisor&gt;，即specificInterceptors</span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">this.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">// 重点，创建代理对象</span><br><span class="line">Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="built_in">return</span> proxy; </span><br><span class="line">&#125;</span><br><span class="line">this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="built_in">return</span> bean; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractAutoProxyCreator#createProxy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Create an AOP proxy <span class="keyword">for</span> the given bean.</span><br><span class="line">* 为指定 bean 创建代理对象</span><br><span class="line">*/</span><br><span class="line">protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line"><span class="keyword">if</span> (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory)</span><br><span class="line">this.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line">// 创建代理的⼯作交给ProxyFactory</span><br><span class="line">ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line">proxyFactory.copyFrom(this);</span><br><span class="line">// 根据⼀些情况判断是否要设置proxyTargetClass=<span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">// 把指定和通⽤拦截对象合并, 并都适配成Advisor</span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line">// 设置参数</span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line">proxyFactory.setFrozen(this.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 上⾯准备做完就开始创建代理</span><br><span class="line"><span class="built_in">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着跟进到ProxyFactory中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyFactory extends ProxyCreatorSupport &#123;</span><br><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">// ⽤ProxyFactory创建AopProxy, 然后⽤AopProxy创建Proxy, 所以这⾥重要的是看获取的AopProxy对象是什么,</span><br><span class="line">// 然后进去看怎么创建动态代理, 提供了两种：jdk proxy, cglib</span><br><span class="line"><span class="built_in">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">public class ProxyCreatorSupport extends AdvisedSupport &#123;</span><br><span class="line">private AopProxyFactory aopProxyFactory;</span><br><span class="line">public <span class="function"><span class="title">ProxyCreatorSupport</span></span>() &#123;</span><br><span class="line">this.aopProxyFactory = new DefaultAopProxyFactory();</span><br><span class="line">&#125;</span><br><span class="line">protected final synchronized AopProxy <span class="function"><span class="title">createAopProxy</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (!this.active) &#123;</span><br><span class="line">activate();</span><br><span class="line">&#125;</span><br><span class="line">//先获取创建AopProxy的⼯⼚, 再由此创建AopProxy</span><br><span class="line"><span class="built_in">return</span> getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br><span class="line">public AopProxyFactory <span class="function"><span class="title">getAopProxyFactory</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> this.aopProxyFactory; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程就是⽤AopProxyFactory创建AopProxy, 再⽤AopProxy创建代理对象，这⾥的AopProxyFactory默认是DefaultAopProxyFactory，看它的<code>createAopProxy</code>⽅法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123;</span><br><span class="line">@Override</span><br><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == null) &#123;</span><br><span class="line">throw new AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> + <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line"><span class="built_in">return</span> new JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> new ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">return</span> new JdkDynamicAopProxy(config);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* Determine whether the supplied &#123;@link AdvisedSupport&#125; has only the</span><br><span class="line">* &#123;@link org.springframework.aop.SpringProxy&#125; interface specified (or no</span><br><span class="line">* proxy interfaces specified at all).</span><br><span class="line">*/</span><br><span class="line">private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) &#123;</span><br><span class="line">Class&lt;?&gt;[] interfaces = config.getProxiedInterfaces();</span><br><span class="line"><span class="built_in">return</span> (interfaces.length == 0 || (interfaces.length == 1 &amp;&amp; SpringProxy.class.equals(interfaces[0])));</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这⾥决定创建代理对象是⽤JDK Proxy，还是⽤ Cglib 了，最简单的从使⽤⽅⾯使⽤来说：设置proxyTargetClass=true强制使⽤Cglib 代理，什么参数都不设并且对象类实现了接⼝则默认⽤JDK代理，如果没有实现接⼝则也必须⽤Cglib<br>ProxyFactory#getProxy(java.lang.ClassLoader)<br>CglibAopProxy#getProxy(java.lang.ClassLoader)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Creating CGLIB proxy: "</span> + this.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">Class&lt;?&gt; rootClass = this.advised.getTargetClass();</span><br><span class="line">Assert.state(rootClass != null, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line">Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">this.advised.addInterface(additionalInterface);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">// Validate the class, writing <span class="built_in">log</span> messages as necessary.</span><br><span class="line">validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line">// 配置 Cglib 增强</span><br><span class="line">Enhancer enhancer = createEnhancer();</span><br><span class="line"><span class="keyword">if</span> (classLoader != null) &#123;</span><br><span class="line">enhancer.setClassLoader(classLoader);</span><br><span class="line"><span class="keyword">if</span> (classLoader instanceof SmartClassLoader &amp;&amp; ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(new</span><br><span class="line">ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line">Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (int x = 0; x &lt; types.length; x++) &#123;</span><br><span class="line">types[x] = callbacks[x].getClass();</span><br><span class="line">&#125;</span><br><span class="line">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span><br><span class="line">enhancer.setCallbackFilter(new ProxyCallbackFilter(this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap,this.fixedInterceptorOffset));</span><br><span class="line">enhancer.setCallbackTypes(types);</span><br><span class="line">// ⽣成代理类，并且创建⼀个代理类的实例</span><br><span class="line"><span class="built_in">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">&#125;catch (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">throw new AopConfigException(<span class="string">"Could not generate CGLIB subclass of "</span> + this.advised.getTargetClass() +<span class="string">": Common causes of this problem include using a final class or anon-visible class"</span>,ex);</span><br><span class="line">&#125;catch (Throwable ex) &#123;</span><br><span class="line">// TargetSource.getTarget() failed</span><br><span class="line">throw new AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AOP源码分析类⽅法调⽤关系记录</strong></p><blockquote><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean<br><strong>调⽤</strong><br>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization<br><strong>调⽤</strong><br>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization（后置处理器AbstractAutoProxyCreator完成bean代理对象创建）<br><strong>调⽤</strong><br>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#wrapIfNecessary<br><strong>调⽤</strong><br>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy （在这⼀步把委托对象的aop增强和通⽤拦截进⾏合并，最终给代理对象）<br><strong>调⽤</strong><br>org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy<br><strong>调⽤</strong><br>org.springframework.aop.framework.CglibAopProxy#getProxy(java.lang.ClassLoader)</p></blockquote><h4 id="Spring声明式事务控制"><a href="#Spring声明式事务控制" class="headerlink" title="Spring声明式事务控制"></a>Spring声明式事务控制</h4><p>声明式事务很⽅便，尤其纯注解模式，仅仅⼏个注解就能控制事务了<br>思考：这些注解都做了什么？好神奇！<br>@EnableTransactionManagement @Transactional</p><h5 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(TransactionManagementConfigurationSelector.class)</span><br><span class="line">public @interface EnableTransactionManagement &#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableTransactionManagement</code> 注解使⽤ <code>@Import</code> 标签引⼊了TransactionManagementConfigurationSelector类，这个类⼜向容器中导⼊了两个重要的组件</p><p><img src="/images/spring/s62.png" srcset="/img/loading.gif" alt="spring"></p><h5 id="加载事务控制组件"><a href="#加载事务控制组件" class="headerlink" title="加载事务控制组件"></a>加载事务控制组件</h5><ul><li>AutoProxyRegistrar<br>AutoProxyRegistrar 类的 registerBeanDefinitions ⽅法中⼜注册了⼀个组件</li></ul><p><img src="/images/spring/s63.png" srcset="/img/loading.gif" alt="spring"></p><p>进⼊ AopConfigUtils.registerAutoProxyCreatorIfNecessary ⽅法</p><p><img src="/images/spring/s64.png" srcset="/img/loading.gif" alt="spring"></p><p>发现最终，注册了⼀个叫做 InfrastructureAdvisorAutoProxyCreator 的 Bean，⽽这个类是AbstractAutoProxyCreator 的⼦类，实现了 SmartInstantiationAwareBeanPostProcessor 接⼝</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class InfrastructureAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator</span><br><span class="line">public abstract class AbstractAdvisorAutoProxyCreator extends AbstractAutoProxyCreator</span><br><span class="line">public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</span><br></pre></td></tr></table></figure><p>继承体系结构图如下</p><p><img src="/images/spring/s65.png" srcset="/img/loading.gif" alt="spring"></p><p>它实现了SmartInstantiationAwareBeanPostProcessor，说明这是⼀个后置处理器，⽽且跟Spring AOP 开启@EnableAspectJAutoProxy 时注册的 AnnotationAwareAspectJProxyCreator实现的是同⼀个接⼝，所以说，声明式事务是 SpringAOP 思想的⼀种应⽤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* Copyright 2002-2017 the original author or authors.</span><br><span class="line">*</span><br><span class="line">* Licensed under the Apache License, Version 2.0 (the <span class="string">"License"</span>);</span><br><span class="line">* you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">* You may obtain a copy of the License at</span><br><span class="line">*</span><br><span class="line">* https://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">*</span><br><span class="line">* Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">* distributed under the License is distributed on an <span class="string">"AS IS"</span> BASIS,</span><br><span class="line">* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">* See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">* limitations under the License.</span><br><span class="line">*/</span><br><span class="line">package org.springframework.transaction.annotation;</span><br><span class="line">import org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.Role;</span><br><span class="line">import org.springframework.transaction.config.TransactionManagementConfigUtils;</span><br><span class="line">import org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor;</span><br><span class="line">import org.springframework.transaction.interceptor.TransactionAttributeSource;</span><br><span class="line">import org.springframework.transaction.interceptor.TransactionInterceptor;</span><br><span class="line">/**</span><br><span class="line">* &#123;@code @Configuration&#125; class that registers the Spring infrastructure beans</span><br><span class="line">* necessary to <span class="built_in">enable</span> proxy-based annotation-driven transaction management.</span><br><span class="line">*</span><br><span class="line">* @author Chris Beams</span><br><span class="line">* @since 3.1</span><br><span class="line">* @see EnableTransactionManagement</span><br><span class="line">* @see TransactionManagementConfigurationSelector</span><br><span class="line">*/</span><br><span class="line">@Configuration</span><br><span class="line">public class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration &#123;</span><br><span class="line">@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">public BeanFactoryTransactionAttributeSourceAdvisor <span class="function"><span class="title">transactionAdvisor</span></span>()&#123;</span><br><span class="line">// 事务增强器</span><br><span class="line">BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">// 向事务增强器中注⼊ 属性解析器 transactionAttributeSource</span><br><span class="line">advisor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">// 向事务增强器中注⼊ 事务拦截器 transactionInterceptor</span><br><span class="line">advisor.setAdvice(transactionInterceptor());</span><br><span class="line"><span class="keyword">if</span> (this.enableTx != null) &#123;</span><br><span class="line">advisor.setOrder(this.enableTx.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> advisor; </span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">// 属性解析器 transactionAttributeSource</span><br><span class="line">public TransactionAttributeSource <span class="function"><span class="title">transactionAttributeSource</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new AnnotationTransactionAttributeSource();</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">// 事务拦截器 transactionInterceptor</span><br><span class="line">public TransactionInterceptor <span class="function"><span class="title">transactionInterceptor</span></span>() &#123;</span><br><span class="line">TransactionInterceptor interceptor = new TransactionInterceptor();</span><br><span class="line">interceptor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line"><span class="keyword">if</span> (this.txManager != null) &#123;</span><br><span class="line">interceptor.setTransactionManager(this.txManager);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> interceptor; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyTransactionManagementConfiguration是⼀个容器配置类，注册了⼀个组件transactionAdvisor，称为事务增强器，然后在这个事务增强器中⼜注⼊了两个属性：<br>transactionAttributeSource，即属性解析器transactionAttributeSource 和<br>事务拦截器transactionInterceptor</p><ul><li><p>属性解析器 AnnotationTransactionAttributeSource 部分源码如下<br><img src="/images/spring/s66.png" srcset="/img/loading.gif" alt="spring"><br>属性解析器有⼀个成员变量是annotationParsers，是⼀个集合，可以添加多种注解解析器<br>(TransactionAnnotationParser)，我们关注 Spring 的注解解析器，部分源码如下<br><img src="/images/spring/s67.png" srcset="/img/loading.gif" alt="spring"><br>属性解析器的作⽤之⼀就是⽤来解析<code>@Transaction</code>注解</p></li><li><p>TransactionInterceptor 事务拦截器，部分源码如下<br><img src="/images/spring/s68.png" srcset="/img/loading.gif" alt="spring"><br><img src="/images/spring/s69.png" srcset="/img/loading.gif" alt="spring"></p></li><li><p>上述组件如何关联起来的？</p><ul><li>事务拦截器实现了MethodInterceptor接⼝，追溯⼀下上⾯提到的InfrastructureAdvisorAutoProxyCreator后置处理器，它会在代理对象执⾏⽬标⽅法的时候获取其拦截器链，⽽拦截器链就是这个TransactionInterceptor，这就把这两个组件联系起来；</li><li>构造⽅法传⼊PlatformTransactionManager(事务管理器)、TransactionAttributeSource(属性解析器)，但是追溯⼀下上⾯贴的ProxyTransactionManagementConfiguration的源码，在注册事务拦截器的时候并没有调⽤这个带参构造⽅法，⽽是调⽤的⽆参构造⽅法，然后再调⽤set⽅法注⼊这两个属性，效果⼀样。</li></ul></li><li><p>invokeWithinTransaction ⽅法，部分源码如下（关注1、2、3、4 标注处）<br><img src="/images/spring/s70.png" srcset="/img/loading.gif" alt="spring"><br><img src="/images/spring/s71.png" srcset="/img/loading.gif" alt="spring"></p></li></ul><p><strong>声明式事务分析过程记录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@EnableTransactionManagement 注解</span><br><span class="line">1)通过@Import引⼊了TransactionManagementConfigurationSelector类</span><br><span class="line">它的selectImports⽅法导⼊了另外两个类：AutoProxyRegistrar和ProxyTransactionManagementConfiguration</span><br><span class="line"></span><br><span class="line">2)AutoProxyRegistrar类分析</span><br><span class="line">⽅法registerBeanDefinitions中，引⼊了其他类，通过AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)引⼊InfrastructureAdvisorAutoProxyCreator，它继承了AbstractAutoProxyCreator，是⼀个后置处理器类</span><br><span class="line"></span><br><span class="line">3)ProxyTransactionManagementConfiguration是⼀个添加了@Configuration注解的配置类（注册bean）</span><br><span class="line">注册事务增强器（注⼊属性解析器、事务拦截器）</span><br><span class="line">属性解析器：AnnotationTransactionAttributeSource，内部持有了⼀个解析器集合Set&lt;TransactionAnnotationParser&gt; annotationParsers;</span><br><span class="line">具体使⽤的是SpringTransactionAnnotationParser解析器，⽤来解析@Transactional的事务属性</span><br><span class="line">事务拦截器：TransactionInterceptor实现了MethodInterceptor接⼝，该通⽤拦截会在产⽣代理对象之前和aop增强合并，最终⼀起影响到代理对象TransactionInterceptor的invoke⽅法中invokeWithinTransaction会触发原有业务逻辑调⽤（增强事务）</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring全家桶</tag>
      
      <tag>IoC</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轻量级控制反转和面向切面的容器框架——Spring（五）</title>
    <link href="/2019/08/22/spring5/"/>
    <url>/2019/08/22/spring5/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/spring_logo.jpg" srcset="/img/loading.gif" alt="spring"></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前整理过一些关于Spring框架零散的知识点，一直没时间整理，恰好最近又拜读了<strong>应癫</strong>老师的课程，所以赶紧梳理一下关于Spring的相关知识。</p><hr><h3 id="Spring-AOP应用"><a href="#Spring-AOP应用" class="headerlink" title="Spring AOP应用"></a>Spring AOP应用</h3><p>AOP本质：在不改变原有业务逻辑的情况下增强横切逻辑，横切逻辑代码往往是权限校验代码、⽇志代码、事务控制代码、性能监控代码。</p><h4 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h4><h5 id="业务主线"><a href="#业务主线" class="headerlink" title="业务主线"></a>业务主线</h5><p>在讲解AOP术语之前，我们先来看⼀下下⾯这两张图，它们就是第三部分案例需求的扩展（针对这些扩展的需求，我们只进⾏分析，在此基础上去进⼀步回顾AOP，不进⾏实现）</p><p><img src="/images/spring/s58.png" srcset="/img/loading.gif" alt="spring"></p><p>上图描述的就是未采⽤AOP思想设计的程序，当我们红⾊框中圈定的⽅法时，会带来⼤量的重复劳动。程序中充斥着⼤量的重复代码，使我们程序的独⽴性很差。⽽下图中是采⽤了AOP思想设计的程序，它把红框部分的代码抽取出来的同时，运⽤动态代理技术，在运⾏期对需要使⽤的业务逻辑⽅法进⾏增强。</p><p><img src="/images/spring/s58.png" srcset="/img/loading.gif" alt="spring"></p><h5 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h5><table><thead><tr><th align="left">名词</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><strong>Joinpoint(连接点)</strong></td><td align="left">它指的是那些可以⽤于把增强代码加⼊到业务主线中的点，那么由上图中我们可以看出，这些点指的就是⽅法。在⽅法执⾏的前后通过动态代理技术加⼊增强的代码。在Spring框架AOP思想的技术实现中，也只⽀持⽅法类型的连接点。</td></tr><tr><td align="left"><strong>Pointcut(切⼊点)</strong></td><td align="left">它指的是那些已经把增强代码加⼊到业务主线进来之后的连接点。由上图中，我们看出表现层 transfer ⽅法就只是连接点，因为判断访问权限的功能并没有对其增强。</td></tr><tr><td align="left"><strong>Advice(通知/增强)</strong></td><td align="left">它指的是切⾯类中⽤于提供增强功能的⽅法。并且不同的⽅法增强的时机是不⼀样的。⽐如，开启事务肯定要在业务⽅法执⾏之前执⾏；提交事务要在业务⽅法正常执⾏之后执⾏，⽽回滚事务要在业务⽅法执⾏产⽣异常之后执⾏等等。那么这些就是通知的类型。其分类有：前置通知 后置通知 异常通知 最终通知 环绕通知。</td></tr><tr><td align="left"><strong>Target(⽬标对象)</strong></td><td align="left">它指的是代理的⽬标对象。即被代理对象。</td></tr><tr><td align="left"><strong>Proxy(代理)</strong></td><td align="left">它指的是⼀个类被AOP织⼊增强后，产⽣的代理类。即代理对象。</td></tr><tr><td align="left"><strong>Weaving(织⼊)</strong></td><td align="left">它指的是把增强应⽤到⽬标对象来创建新的代理对象的过程。spring采⽤动态代理织⼊，⽽AspectJ采⽤编译期织⼊和类装载期织⼊。</td></tr><tr><td align="left"><strong>Aspect(切⾯)</strong></td><td align="left">它指定是增强的代码所关注的⽅⾯，把这些相关的增强代码定义到⼀个类中，这个类就是切⾯类。例如，事务切⾯，它⾥⾯定义的⽅法就是和事务相关的，像开启事务，提交事务，回滚事务等等，不会定义其他与事务⽆关的⽅法。我们前⾯的案例中 TrasnactionManager 就是⼀个切⾯。</td></tr></tbody></table><p><strong>连接点</strong>：⽅法开始时、结束时、正常运⾏完毕时、⽅法异常时等这些特殊的时机点，我们称之为连接点，项⽬中每个⽅法都有连接点，连接点是⼀种候选点</p><p><strong>切⼊点</strong>：指定AOP思想想要影响的具体⽅法是哪些，描述感兴趣的⽅法</p><p><strong>Advice增强</strong>：<br>第⼀个层次：指的是横切逻辑<br>第⼆个层次：⽅位点（在某⼀些连接点上加⼊横切逻辑，那么这些连接点就叫做⽅位点，描述的是具体的特殊时机）</p><p><strong>Aspect切⾯</strong>：切⾯概念是对上述概念的⼀个综合<br>Aspect切⾯ = 切⼊点 + 增强<br>          = 切⼊点（锁定⽅法）+ ⽅位点（锁定⽅法中的特殊时机）+ 横切逻辑</p><p><strong>众多的概念，⽬的就是为了锁定要在哪个地⽅插⼊什么横切逻辑代码</strong></p><h4 id="Spring中AOP的代理选择"><a href="#Spring中AOP的代理选择" class="headerlink" title="Spring中AOP的代理选择"></a>Spring中AOP的代理选择</h4><p>Spring 实现AOP思想使⽤的是动态代理技术。<br>默认情况下，Spring会根据被代理对象是否实现接⼝来选择使⽤jdk还是cglib。当被代理对象没有实现任何接⼝时，Spring会选择cglib。当被代理对象实现了接⼝，Spring会选择JDK官⽅的代理技术，不过我们可以通过配置的⽅式，让Spring强制使⽤cglib。</p><h4 id="Spring中AOP的配置方式"><a href="#Spring中AOP的配置方式" class="headerlink" title="Spring中AOP的配置方式"></a>Spring中AOP的配置方式</h4><p>在Spring的AOP配置中，也和IoC配置⼀样，⽀持3类配置⽅式。<br>第⼀类：使⽤XML配置<br>第⼆类：使⽤XML+注解组合配置<br>第三类：使⽤纯注解配置</p><h4 id="Spring中AOP实现"><a href="#Spring中AOP实现" class="headerlink" title="Spring中AOP实现"></a>Spring中AOP实现</h4><p>需求：横切逻辑代码是打印⽇志，希望把打印⽇志的逻辑织⼊到⽬标⽅法的特定位置(service层transfer⽅法)</p><h5 id="XML模式"><a href="#XML模式" class="headerlink" title="XML模式"></a>XML模式</h5><p>Spring是模块化开发的框架，使⽤aop就引⼊aop的jar</p><ul><li>坐标</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-aop&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;5.1.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.aspectj&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.9.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>AOP 核⼼配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">Spring基于XML的AOP配置前期准备：</span><br><span class="line">在spring的配置⽂件中加⼊aop的约束</span><br><span class="line">xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">http://www.springframework.org/schema/aop </span><br><span class="line">https://www.springframework.org/schema/aop/spring-aop.xsd</span><br><span class="line">Spring基于XML的AOP配置步骤：</span><br><span class="line">第⼀步：把通知Bean交给Spring管理</span><br><span class="line">第⼆步：使⽤aop:config开始aop的配置</span><br><span class="line">第三步：使⽤aop:aspect配置切⾯</span><br><span class="line">第四步：使⽤对应的标签配置通知的类型</span><br><span class="line">⼊⻔案例采⽤前置通知，标签为aop:before</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!--把通知bean交给spring来管理--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"logUtil"</span> class=<span class="string">"com.loonycoder.utils.LogUtil"</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--开始aop的配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;!--配置切⾯--&gt;</span><br><span class="line">&lt;aop:aspect id=<span class="string">"logAdvice"</span> ref=<span class="string">"logUtil"</span>&gt;</span><br><span class="line">&lt;!--配置前置通知--&gt;</span><br><span class="line">&lt;aop:before method=<span class="string">"printLog"</span> pointcut=<span class="string">"execution(public * com.loonycoder.service.impl.TransferServiceImpl.updateAccountByCardNo(com.loonycoder.pojo.Account))"</span>&gt;&lt;/aop:before&gt;</span><br><span class="line">&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><ul><li><p>细节</p><ul><li>关于切⼊点表达式<br>上述配置实现了对 TransferServiceImpl 的 updateAccountByCardNo ⽅法进⾏增强，在其执⾏之前，输出了记录⽇志的语句。这⾥⾯，我们接触了⼀个⽐较陌⽣的名称：切⼊点表达式，它是做什么的呢？我们往下看。<ul><li>概念及作⽤<br>切⼊点表达式，也称之为AspectJ切⼊点表达式，指的是遵循特定语法结构的字符串，其作⽤是⽤于对符合语法格式的连接点进⾏增强。它是AspectJ表达式的⼀部分。</li><li>关于AspectJ<br>AspectJ是⼀个基于Java语⾔的AOP框架，Spring框架从2.0版本之后集成了AspectJ框架中切⼊点表达式的部分，开始⽀持AspectJ切⼊点表达式。</li><li>切⼊点表达式使⽤示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">全限定⽅法名 访问修饰符 返回值 包名.包名.包名.类名.⽅法名(参数列表)</span><br><span class="line">全匹配⽅式：</span><br><span class="line">public void com.loonycoder.service.impl.TransferServiceImpl.updateAccountByCardNo(com.loonycoder.pojo.Account)</span><br><span class="line">访问修饰符可以省略</span><br><span class="line">void com.loonycoder.service.impl.TransferServiceImpl.updateAccountByCardNo(com.loonycoder.pojo.Account)</span><br><span class="line">返回值可以使⽤*，表示任意返回值</span><br><span class="line">* com.loonycoder.service.impl.TransferServiceImpl.updateAccountByCardNo(com.loonycoder.pojo.Account)</span><br><span class="line">包名可以使⽤.表示任意包，但是有⼏级包，必须写⼏个</span><br><span class="line">* ....TransferServiceImpl.updateAccountByCardNo(com.loonycoder.pojo.Account)</span><br><span class="line">包名可以使⽤..表示当前包及其⼦包</span><br><span class="line">* ..TransferServiceImpl.updateAccountByCardNo(com.loonycoder.pojo.Account)</span><br><span class="line">类名和⽅法名，都可以使⽤.表示任意类，任意⽅法</span><br><span class="line">* ...(com.loonycoder.pojo.Account)</span><br><span class="line">参数列表，可以使⽤具体类型</span><br><span class="line">基本类型直接写类型名称 ： int</span><br><span class="line">引⽤类型必须写全限定类名：java.lang.String</span><br><span class="line">参数列表可以使⽤*，表示任意参数类型，但是必须有参数</span><br><span class="line">* *..*.*(*)</span><br><span class="line">参数列表可以使⽤..，表示有⽆参数均可。有参数可以是任意类型</span><br><span class="line">* *..*.*(..)</span><br><span class="line">全通配⽅式：</span><br><span class="line">* *..*.*(..)</span><br></pre></td></tr></table></figure></li></ul></li><li>改变代理⽅式的配置<br>在前⾯我们已经说了，Spring在选择创建代理对象时，会根据被代理对象的实际情况来选择的。被代理对象实现了接⼝，则采⽤基于接⼝的动态代理。当被代理对象没有实现任何接⼝的时候，Spring会⾃动切换到基于⼦类的动态代理⽅式。但是我们都知道，⽆论被代理对象是否实现接⼝，只要不是final修饰的类都可以采⽤cglib提供的⽅式创建代理对象。所以Spring也考虑到了这个情况，提供了配置的⽅式实现强制使⽤基于⼦类的动态代理（即cglib的⽅式），配置的⽅式有两种<ul><li>使⽤aop:config标签配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config proxy-target-class=<span class="string">"true"</span>&gt;</span><br></pre></td></tr></table></figure></li><li>使⽤aop:aspectj-autoproxy标签配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--此标签是基于XML和注解组合配置AOP时的必备标签，表示Spring开启注解配置AOP的⽀持--&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=<span class="string">"true"</span>&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li>五种通知类型<ul><li>前置通知<br>配置⽅式：aop:before标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--作⽤：</span><br><span class="line">⽤于配置前置通知。</span><br><span class="line">出现位置：</span><br><span class="line">它只能出现在aop:aspect标签内部</span><br><span class="line">属性：</span><br><span class="line">method：⽤于指定前置通知的⽅法名称</span><br><span class="line">pointcut：⽤于指定切⼊点表达式</span><br><span class="line">pointcut-ref：⽤于指定切⼊点表达式的引⽤</span><br><span class="line">--&gt;</span><br><span class="line">&lt;aop:before method=<span class="string">"printLog"</span> pointcut-ref=<span class="string">"pointcut1"</span>&gt;</span><br><span class="line">&lt;/aop:before&gt;</span><br></pre></td></tr></table></figure></li></ul>  <strong>执⾏时机</strong>：前置通知永远都会在切⼊点⽅法（业务核⼼⽅法）执⾏之前执⾏。<br>  <strong>细节</strong>：前置通知可以获取切⼊点⽅法的参数，并对其进⾏增强。</li></ul></li><li><p>正常执⾏时通知</p></li></ul><p><strong>配置⽅式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">作⽤：</span><br><span class="line">⽤于配置正常执⾏时通知</span><br><span class="line">出现位置：</span><br><span class="line">它只能出现在aop:aspect标签内部</span><br><span class="line">属性：</span><br><span class="line">method:⽤于指定后置通知的⽅法名称</span><br><span class="line">pointcut:⽤于指定切⼊点表达式</span><br><span class="line">pointcut-ref:⽤于指定切⼊点表达式的引⽤</span><br><span class="line">--&gt;</span><br><span class="line">&lt;aop:after-returning method=<span class="string">"afterReturningPrintLog"</span> pointcut-ref=<span class="string">"pt1"</span>&gt;&lt;/aop:after-returning&gt;</span><br></pre></td></tr></table></figure><ul><li>异常通知</li></ul><p><strong>配置⽅式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">作⽤：</span><br><span class="line">⽤于配置异常通知。</span><br><span class="line">出现位置：</span><br><span class="line">它只能出现在aop:aspect标签内部</span><br><span class="line">属性：</span><br><span class="line">method:⽤于指定异常通知的⽅法名称</span><br><span class="line">pointcut:⽤于指定切⼊点表达式</span><br><span class="line">pointcut-ref:⽤于指定切⼊点表达式的引⽤</span><br><span class="line">--&gt;</span><br><span class="line">&lt;aop:after-throwing method=<span class="string">"afterThrowingPrintLog"</span> pointcut-ref=<span class="string">"pt1"</span>&gt;&lt;/aop:after-throwing&gt;</span><br></pre></td></tr></table></figure><p><strong>执⾏时机</strong>：最终通知的执⾏时机是在切⼊点⽅法（业务核⼼⽅法）执⾏完成之后，切⼊点⽅法返回之前执⾏。换句话说，⽆论切⼊点⽅法执⾏是否产⽣异常，它都会在返回之前执⾏。<br><strong>细节</strong>：最终通知执⾏时，可以获取到通知⽅法的参数。同时它可以做⼀些清理操作。</p><ul><li>环绕通知</li></ul><p><strong>配置⽅式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">作⽤：</span><br><span class="line">⽤于配置环绕通知。</span><br><span class="line">出现位置：</span><br><span class="line">它只能出现在aop:aspect标签的内部</span><br><span class="line">属性：</span><br><span class="line">method:⽤于指定环绕通知的⽅法名称</span><br><span class="line">pointcut:⽤于指定切⼊点表达式</span><br><span class="line">pointcut-ref:⽤于指定切⼊点表达式的引⽤</span><br><span class="line">--&gt;</span><br><span class="line">&lt;aop:around method=<span class="string">"aroundPrintLog"</span> pointcut-ref=<span class="string">"pt1"</span>&gt;&lt;/aop:around&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>特别说明</strong><br>环绕通知，它是有别于前⾯四种通知类型外的特殊通知。前⾯四种通知（前置，后置，异常和最终）它们都是指定何时增强的通知类型。⽽环绕通知，它是Spring框架为我们提供的⼀种可以通过编码的⽅式，控制增强代码何时执⾏的通知类型。它⾥⾯借助的ProceedingJoinPoint接⼝及其实现类，实现⼿动触发切⼊点⽅法的调⽤。</p></blockquote><h5 id="XML-注解模式"><a href="#XML-注解模式" class="headerlink" title="XML+注解模式"></a>XML+注解模式</h5><ul><li>XML 中开启 Spring 对注解 AOP 的⽀持</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--开启spring对注解aop的⽀持--&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class LogUtil &#123;</span><br><span class="line">/**</span><br><span class="line">* 我们在xml中已经使⽤了通⽤切⼊点表达式，供多个切⾯使⽤，那么在注解中如何使⽤呢？</span><br><span class="line">* 第⼀步：编写⼀个⽅法</span><br><span class="line">* 第⼆步：在⽅法使⽤@Pointcut注解</span><br><span class="line">* 第三步：给注解的value属性提供切⼊点表达式</span><br><span class="line">* 细节：</span><br><span class="line">* 1.在引⽤切⼊点表达式时，必须是⽅法名+()，例如<span class="string">"pointcut()"</span>。 * 2.在当前切⾯中使⽤，可以直接写⽅法名。在其他切⾯中使⽤必须是全限定⽅法名。</span><br><span class="line">*/</span><br><span class="line">@Pointcut(<span class="string">"execution(* com.loonycoder.service.impl.*.*(..))"</span>)</span><br><span class="line">public void <span class="function"><span class="title">pointcut</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Before(<span class="string">"pointcut()"</span>)</span><br><span class="line">public void beforePrintLog(JoinPoint jp)&#123;</span><br><span class="line">Object[] args = jp.getArgs();</span><br><span class="line">System.out.println(<span class="string">"前置通知：beforePrintLog，参数是："</span>+</span><br><span class="line">Arrays.toString(args));</span><br><span class="line">&#125;</span><br><span class="line">@AfterReturning(value = <span class="string">"pointcut()"</span>,returning = <span class="string">"rtValue"</span>)</span><br><span class="line">public void afterReturningPrintLog(Object rtValue)&#123;</span><br><span class="line">System.out.println(<span class="string">"后置通知：afterReturningPrintLog，返回值</span></span><br><span class="line"><span class="string">是："</span>+rtValue);</span><br><span class="line">&#125;</span><br><span class="line">@AfterThrowing(value = <span class="string">"pointcut()"</span>,throwing = <span class="string">"e"</span>)</span><br><span class="line">public void afterThrowingPrintLog(Throwable e)&#123;</span><br><span class="line">System.out.println(<span class="string">"异常通知：afterThrowingPrintLog，异常是："</span>+e);</span><br><span class="line">&#125;</span><br><span class="line">@After(<span class="string">"pointcut()"</span>)</span><br><span class="line">public void <span class="function"><span class="title">afterPrintLog</span></span>()&#123;</span><br><span class="line">System.out.println(<span class="string">"最终通知：afterPrintLog"</span>);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 环绕通知</span><br><span class="line">* @param pjp</span><br><span class="line">* @<span class="built_in">return</span></span><br><span class="line">*/</span><br><span class="line">@Around(<span class="string">"pointcut()"</span>)</span><br><span class="line">public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123;</span><br><span class="line">//定义返回值</span><br><span class="line">Object rtValue = null;</span><br><span class="line">try&#123;</span><br><span class="line">//前置通知</span><br><span class="line">System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">//1.获取参数</span><br><span class="line">Object[] args = pjp.getArgs();</span><br><span class="line">//2.执⾏切⼊点⽅法</span><br><span class="line">rtValue = pjp.proceed(args);</span><br><span class="line">//后置通知</span><br><span class="line">System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">&#125;catch (Throwable t)&#123;</span><br><span class="line">//异常通知</span><br><span class="line">System.out.println(<span class="string">"异常通知"</span>);</span><br><span class="line">t.printStackTrace();</span><br><span class="line"> &#125;finally &#123;</span><br><span class="line">//最终通知</span><br><span class="line">System.out.println(<span class="string">"最终通知"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">return</span> rtValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注解模式"><a href="#注解模式" class="headerlink" title="注解模式"></a>注解模式</h5><p>在使⽤注解驱动开发aop时，我们要明确的就是，是注解替换掉配置⽂件中的下⾯这⾏配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--开启spring对注解aop的⽀持--&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure><p>在配置类中使⽤如下注解进⾏替换上述配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(<span class="string">"com.loonycoder"</span>)</span><br><span class="line">@EnableAspectJAutoProxy //开启spring对注解AOP的⽀持</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring声明式事务的支持"><a href="#Spring声明式事务的支持" class="headerlink" title="Spring声明式事务的支持"></a>Spring声明式事务的支持</h4><p><strong>编程式事务</strong>：在业务代码中添加事务控制代码，这样的事务控制机制就叫做编程式事务<br><strong>声明式事务</strong>：通过xml或者注解配置的⽅式达到事务控制的⽬的，叫做声明式事务</p><h5 id="事务回顾"><a href="#事务回顾" class="headerlink" title="事务回顾"></a>事务回顾</h5><h6 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h6><p>事务指逻辑上的⼀组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。从⽽确保了数据的准确与安全。<br>例如：A——B转帐，对应于如下两条sql语句:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*转出账户减钱*/</span><br><span class="line">update account <span class="built_in">set</span> money=money-100 <span class="built_in">where</span> name=<span class="string">'a'</span>;</span><br><span class="line">/**转⼊账户加钱*/</span><br><span class="line">update account <span class="built_in">set</span> money=money+100 <span class="built_in">where</span> name=<span class="string">'b'</span>;</span><br></pre></td></tr></table></figure><p>这两条语句的执⾏，要么全部成功，要么全部不成功。</p><h6 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h6><p><strong>原⼦性（Atomicity）</strong><br>原⼦性是指事务是⼀个不可分割的⼯作单位，事务中的操作要么都发⽣，要么都不发⽣。<br>从操作的⻆度来描述，事务中的各个操作要么都成功要么都失败。<br><strong>⼀致性（Consistency）</strong><br>事务必须使数据库从⼀个⼀致性状态变换到另外⼀个⼀致性状态。<br>例如转账前A有1000，B有1000。转账后A+B也得是2000。<br>⼀致性是从数据的⻆度来说的，（1000，1000）（900，1100），不应该出现（900，1000）<br><strong>隔离性（Isolation）</strong><br>事务的隔离性是多个⽤户并发访问数据库时，数据库为每⼀个⽤户开启的事务，每个事务不能被其他事务的操作数据所⼲扰，多个并发事务之间要相互隔离。<br>⽐如：事务1给员⼯涨⼯资2000，但是事务1尚未被提交，员⼯发起事务2查询⼯资，发现⼯资涨了2000块钱，读到了事务1尚未提交的数据（脏读）<br><strong>持久性（Durability）</strong><br>持久性是指⼀个事务⼀旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发⽣故障也不应该对其有任何影响。</p><h6 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h6><p>不考虑隔离级别，会出现以下情况：（以下情况全是错误的），也即为隔离级别在解决事务并发问题<br><strong>脏读</strong>：⼀个线程中的事务读到了另外⼀个线程中<strong>未提交</strong>的数据。<br><strong>不可重复读</strong>：⼀个线程中的事务读到了另外⼀个线程中已经提交的<strong>update</strong>的数据（前后内容不⼀样）<br>场景：<br>员⼯A发起事务1，查询⼯资，⼯资为1w，此时事务1尚未关闭<br>财务⼈员发起了事务2，给员⼯A张了2000块钱，<strong>并且提交了事务</strong><br>员⼯A通过事务1再次发起查询请求，发现⼯资为1.2w，原来读出来1w读不到了，叫做不可重复读<br><strong>虚读（幻读）</strong>：⼀个线程中的事务读到了另外⼀个线程中已经提交的insert或者delete的数据（前后条数不⼀样）<br>场景：<br>事务1查询所有⼯资为1w的员⼯的总数，查询出来了10个⼈，此时事务尚未关闭<br>事务2财务⼈员发起，新来员⼯，⼯资1w，向表中插⼊了2条数据，<strong>并且提交了事务</strong><br>事务1再次查询⼯资为1w的员⼯个数，发现有12个⼈，⻅了⻤了</p><p>数据库共定义了四种隔离级别：<br><strong>Serializable（串⾏化）</strong>：可避免脏读、不可重复读、虚读情况的发⽣。（串⾏化） <font style="color: red">最⾼</font><br><strong>Repeatable read（可重复读）</strong>：可避免脏读、不可重复读情况的发⽣。(幻读有可能发⽣) <font style="color: red">第⼆</font>该机制下会对要update的⾏进⾏加锁<br><strong>Read committed（读已提交）</strong>：可避免脏读情况发⽣。不可重复读和幻读⼀定会发⽣。 <font style="color: red">第三</font><br><strong>Read uncommitted（读未提交）</strong>：最低级别，以上情况均⽆法保证。(读未提交)  <font style="color: red">最低</font></p><p><strong>注意：级别依次升⾼，效率依次降低</strong></p><p>MySQL的默认隔离级别是：REPEATABLE READ<br>查询当前使⽤的隔离级别： <code>select @@tx_isolation</code>;<br>设置MySQL事务的隔离级别： <code>set session transaction isolation level xxx</code>; （设置的是当前mysql连接会话的，并不是永久改变的）</p><h6 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h6><p>事务往往在service层进⾏控制，如果出现service层⽅法A调⽤了另外⼀个service层⽅法B，A和B⽅法本身都已经被添加了事务控制，那么A调⽤B的时候，就需要进⾏事务的⼀些协商，这就叫做事务的传播⾏为。<br>A调⽤B，我们站在B的⻆度来观察来定义事务的传播⾏为</p><table><thead><tr><th align="left">PROPAGATION_REQUIRED</th><th align="left">如果当前没有事务，就新建⼀个事务，如果已经存在⼀个事务中，加⼊到这个事务中。这是最常⻅的选择。</th></tr></thead><tbody><tr><td align="left"><strong>PROPAGATION_SUPPORTS</strong></td><td align="left"><strong>⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。</strong></td></tr><tr><td align="left"><strong>PROPAGATION_MANDATORY</strong></td><td align="left"><strong>使⽤当前的事务，如果当前没有事务，就抛出异常。</strong></td></tr><tr><td align="left"><strong>PROPAGATION_REQUIRES_NEW</strong></td><td align="left"><strong>新建事务，如果当前存在事务，把当前事务挂起。</strong></td></tr><tr><td align="left"><strong>PROPAGATION_NOT_SUPPORTED</strong></td><td align="left"><strong>以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。</strong></td></tr><tr><td align="left"><strong>PROPAGATION_NEVER</strong></td><td align="left"><strong>以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。</strong></td></tr><tr><td align="left"><strong>PROPAGATION_NESTED</strong></td><td align="left"><strong>如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则执⾏与PROPAGATION_REQUIRED类似的操作。</strong></td></tr></tbody></table><h5 id="Spring中事务的API"><a href="#Spring中事务的API" class="headerlink" title="Spring中事务的API"></a>Spring中事务的API</h5><p>mybatis: sqlSession.commit();<br>hibernate: session.commit();</p><p><strong>PlatformTransactionManager</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line">/**</span><br><span class="line">* 获取事务状态信息</span><br><span class="line">*/</span><br><span class="line">TransactionStatus getTransaction(@Nullable TransactionDefinition definition)</span><br><span class="line">throws TransactionException;</span><br><span class="line">/**</span><br><span class="line">* 提交事务</span><br><span class="line">*/</span><br><span class="line">void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">/**</span><br><span class="line">* 回滚事务</span><br><span class="line">*/</span><br><span class="line">void rollback(TransactionStatus status) throws TransactionException; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作⽤</strong><br>此接⼝是Spring的事务管理器核⼼接⼝。Spring本身并不⽀持事务实现，只是负责提供标准，应⽤底层⽀持什么样的事务，需要提供具体实现类。此处也是策略模式的具体应⽤。在Spring框架中，也为我们内置了⼀些具体策略，例如：DataSourceTransactionManager、HibernateTransactionManager 等等。（ 和 HibernateTransactionManager 事务管理器在 spring-orm-5.1.12.RELEASE.jar 中）Spring JdbcTemplate（数据库操作⼯具）、Mybatis（mybatis-spring.jar）—&gt;DataSourceTransactionManager、Hibernate框架 —&gt; HibernateTransactionManager DataSourceTransactionManager 归根结底是横切逻辑代码，声明式事务要做的就是使⽤Aop（动态代理）来将事务控制逻辑织⼊到业务代码。</p><h5 id="Spring声明式事务配置"><a href="#Spring声明式事务配置" class="headerlink" title="Spring声明式事务配置"></a>Spring声明式事务配置</h5><ul><li><p>纯xml模式</p><ul><li>导⼊jar<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-context&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;5.1.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.aspectj&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.9.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;5.1.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-tx&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;5.1.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>xml 配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"transactionManager"</span>&gt;</span><br><span class="line">&lt;!--定制事务细节，传播⾏为、隔离级别等--&gt;</span><br><span class="line">&lt;tx:attributes&gt;</span><br><span class="line">&lt;!--⼀般性配置--&gt;</span><br><span class="line">&lt;tx:method name=<span class="string">"*"</span> <span class="built_in">read</span>-only=<span class="string">"false"</span> propagation=<span class="string">"REQUIRED"</span> isolation=<span class="string">"DEFAULT"</span> timeout=<span class="string">"-1"</span>/&gt;</span><br><span class="line">&lt;!--针对查询的覆盖性配置--&gt;</span><br><span class="line">&lt;tx:method name=<span class="string">"query*"</span> <span class="built_in">read</span>-only=<span class="string">"true"</span> propagation=<span class="string">"SUPPORTS"</span>/&gt;</span><br><span class="line">&lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt; </span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;!--advice-ref指向增强=横切逻辑+⽅位--&gt;</span><br><span class="line">&lt;aop:advisor advice-ref=<span class="string">"txAdvice"</span> pointcut=<span class="string">"execution(* com.loonycoder.edu.service.impl.TransferServiceImpl.*(..))"</span>/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>基于XML+注解</p><ul><li>xml配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置事务管理器--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"transactionManager"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt; </span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--开启spring对注解事务的⽀持--&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">"transactionManager"</span>/&gt;</span><br></pre></td></tr></table></figure></li><li>在接⼝、类或者⽅法上添加@Transactional注解<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(readOnly = <span class="literal">true</span>,propagation = Propagation.SUPPORTS)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>基于纯注解<br>Spring基于注解驱动开发的事务控制配置，只需要把 xml 配置部分改为注解实现。只是需要⼀个<br>注解替换掉xml配置⽂件中的 <code>&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;</code> 配置。<br>在 Spring 的配置类上添加 <code>@EnableTransactionManagement</code> 注解即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@EnableTransactionManagement//开启spring注解事务的⽀持</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring全家桶</tag>
      
      <tag>IoC</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轻量级控制反转和面向切面的容器框架——Spring（四）</title>
    <link href="/2019/08/12/spring4/"/>
    <url>/2019/08/12/spring4/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/spring_logo.jpg" srcset="/img/loading.gif" alt="spring"></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前整理过一些关于Spring框架零散的知识点，一直没时间整理，恰好最近又拜读了<strong>应癫</strong>老师的课程，所以赶紧梳理一下关于Spring的相关知识。</p><hr><h3 id="Spring-IoC源码深度剖析"><a href="#Spring-IoC源码深度剖析" class="headerlink" title="Spring IoC源码深度剖析"></a>Spring IoC源码深度剖析</h3><ul><li>好处：提⾼培养代码架构思维、深⼊理解框架</li><li>原则<ul><li>定焦原则：抓主线</li><li>宏观原则：站在上帝视⻆，关注源码结构和业务流程（淡化具体某⾏代码的编写细节）</li></ul></li><li>读源码的⽅法和技巧<ul><li>断点（观察调⽤栈）</li><li>反调（Find Usages）</li><li>经验（spring框架中doXXX，做具体处理的地⽅）</li></ul></li><li>Spring源码构建<ul><li>下载源码（github）</li><li>安装gradle 5.6.3（类似于maven）idea 2019.1 jdk 11.0.5</li><li>导⼊（耗费⼀定时间）</li><li>编译⼯程（顺序：core-oxm-context-beans-aspects-aop）</li><li>⼯程—&gt;tasks—&gt;compileTestJava</li></ul></li></ul><h4 id="Spring-IoC容器初始化主题流程"><a href="#Spring-IoC容器初始化主题流程" class="headerlink" title="Spring IoC容器初始化主题流程"></a>Spring IoC容器初始化主题流程</h4><h5 id="Spring-IoC的容器体系"><a href="#Spring-IoC的容器体系" class="headerlink" title="Spring IoC的容器体系"></a>Spring IoC的容器体系</h5><p>IoC容器是Spring的核⼼模块，是抽象了对象管理、依赖关系管理的框架解决⽅案。Spring 提供了很多<br>的容器，其中 BeanFactory 是顶层容器（根容器），不能被实例化，它定义了所有 IoC 容器 必须遵从<br>的⼀套原则，具体的容器实现可以增加额外的功能，⽐如我们常⽤到的<code>ApplicationContext</code>，其下更具<br>体的实现如 <code>ClassPathXmlApplicationContext</code> 包含了解析 xml 等⼀系列的内容，<br><code>AnnotationConfigApplicationContext</code> 则是包含了注解解析等⼀系列的内容。Spring IoC 容器继承体系<br>⾮常聪明，需要使⽤哪个层次⽤哪个层次即可，不必使⽤功能⼤⽽全的。<br>BeanFactory 顶级接⼝⽅法栈如下</p><p><img src="/images/spring/s33.png" srcset="/img/loading.gif" alt="spring"></p><p>BeanFactory 容器继承体系</p><p><img src="/images/spring/s34.png" srcset="/img/loading.gif" alt="spring"></p><p>通过其接⼝设计，我们可以看到我们⼀贯使⽤的 <code>ApplicationContext</code> 除了继承<code>BeanFactory</code>的⼦接⼝，<br>还继承了<code>ResourceLoader</code>、<code>MessageSource</code>等接⼝，因此其提供的功能也就更丰富了。<br>下⾯我们以 <code>ClasspathXmlApplicationContext</code> 为例，深⼊源码说明 IoC 容器的初始化流程。</p><h5 id="Bean生命周期关键时机点"><a href="#Bean生命周期关键时机点" class="headerlink" title="Bean生命周期关键时机点"></a>Bean生命周期关键时机点</h5><p>思路：创建⼀个类 loonycoderBean ，让其实现⼏个特殊的接⼝，并分别在接⼝实现的构造器、接⼝⽅法中<br>断点，观察线程调⽤栈，分析出 Bean 对象创建和管理关键点的触发时机。</p><p>loonycoderBean类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class loonycoderBean implements InitializingBean&#123;</span><br><span class="line">/**</span><br><span class="line">* 构造函数</span><br><span class="line">*/</span><br><span class="line">public <span class="function"><span class="title">loonycoderBean</span></span>()&#123;</span><br><span class="line">System.out.println(<span class="string">"loonycoderBean 构造器..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* InitializingBean 接⼝实现</span><br><span class="line">*/</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"loonycoderBean afterPropertiesSet..."</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanPostProcessor 接⼝实现类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line">public <span class="function"><span class="title">MyBeanPostProcessor</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"BeanPostProcessor 实现类构造函数..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName)</span><br><span class="line">throws BeansException &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"loonycoderBean"</span>.equals(beanName)) &#123;</span><br><span class="line">System.out.println(<span class="string">"BeanPostProcessor 实现类 postProcessBeforeInitialization ⽅法被调⽤中......"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> bean; </span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName)</span><br><span class="line">throws BeansException &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"loonycoderBean"</span>.equals(beanName)) &#123;</span><br><span class="line">System.out.println(<span class="string">"BeanPostProcessor 实现类 postProcessAfterInitialization ⽅法被调⽤中......"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> bean; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanFactoryPostProcessor 接⼝实现类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">public <span class="function"><span class="title">MyBeanFactoryPostProcessor</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"BeanFactoryPostProcessor的实现类构造函数..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory</span><br><span class="line">beanFactory) throws BeansException &#123;</span><br><span class="line">System.out.println(<span class="string">"BeanFactoryPostProcessor的实现⽅法调⽤中......"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applicationContext.xml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">"</span>&gt;</span><br><span class="line">&lt;bean id=<span class="string">"loonycoderBean"</span> class=<span class="string">"com.loonycoder.loonycoderBean"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"myBeanFactoryPostProcessor"</span></span><br><span class="line">class=<span class="string">"com.loonycoder.MyBeanFactoryPostProcessor"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"myBeanPostProcessor"</span> class=<span class="string">"com.loonycoder.MyBeanPostProcessor"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>IoC 容器源码分析⽤例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testIoC</span></span>() &#123;</span><br><span class="line">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">loonycoderBean loonycoderBean = applicationContext.getBean(loonycoderBean.class);</span><br><span class="line">System.out.println(loonycoderBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>分析 Bean 的创建是在容器初始化时还是在 getBean 时</li></ol><p><img src="/images/spring/s35.png" srcset="/img/loading.gif" alt="spring"></p><p>根据断点调试，我们发现，在未设置延迟加载的前提下，Bean 的创建是在容器初始化过程中完成的。</p><ol start="2"><li>分析构造函数调⽤情况</li></ol><p><img src="/images/spring/s36.png" srcset="/img/loading.gif" alt="spring"></p><p>通过如上观察，我们发现构造函数的调⽤时机在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<br><code>finishBeanFactoryInitialization(beanFactory)</code>处</p><ol start="3"><li>分析 InitializingBean 之 afterPropertiesSet 初始化⽅法调⽤情况</li></ol><p><img src="/images/spring/s37.png" srcset="/img/loading.gif" alt="spring"></p><p>通过如上观察，我们发现 <code>InitializingBean</code>中 <code>afterPropertiesSet()</code> ⽅法的调⽤时机也是在<br><code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>finishBeanFactoryInitialization(beanFactory)</code></p><ol start="4"><li>分析BeanFactoryPostProcessor 初始化和调⽤情况</li></ol><p>分别在构造函数、<code>postProcessBeanFactory()</code> ⽅法处打断点，观察调⽤栈，发现<code>BeanFactoryPostProcessor</code> 初始化在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>invokeBeanFactoryPostProcessors(beanFactory)</code>;<br><code>postProcessBeanFactory()</code> 调⽤在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>invokeBeanFactoryPostProcessors(beanFactory)</code>;</p><ol start="5"><li>分析 BeanPostProcessor 初始化和调⽤情况</li></ol><p>分别在构造函数、<code>postProcessBeanFactory()</code> ⽅法处打断点，观察调⽤栈，发现<code>BeanPostProcessor</code> 初始化在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>registerBeanPostProcessors(beanFactory)</code>;<br><code>postProcessBeforeInitialization()</code>调⽤在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>finishBeanFactoryInitialization(beanFactory)</code>;<br><code>postProcessAfterInitialization()</code> 调⽤在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>finishBeanFactoryInitialization(beanFactory)</code>;</p><ol start="6"><li>总结</li></ol><p>根据上⾯的调试分析，我们发现 Bean对象创建的⼏个关键时机点代码层级的调⽤都在<code>AbstractApplicationContext</code>⽅ 类的 <code>refresh()</code>⽅ ⽅法中，可⻅这个⽅法对于Spring IoC容器初始化来说相当<br>关键，汇总如下：</p><table><thead><tr><th align="left">关键点</th><th align="left">触发代码</th></tr></thead><tbody><tr><td align="left">构造器</td><td align="left">refresh#finishBeanFactoryInitialization(beanFactory)(beanFactory)</td></tr><tr><td align="left">BeanFactoryPostProcessor初始化</td><td align="left">refresh#invokeBeanFactoryPostProcessors(beanFactory)</td></tr><tr><td align="left">BeanFactoryPostProcessor ⽅法调⽤</td><td align="left">refresh#invokeBeanFactoryPostProcessors(beanFactory)</td></tr><tr><td align="left">BeanPostProcessor 初始化</td><td align="left">registerBeanPostProcessors(beanFactory)</td></tr><tr><td align="left">BeanPostProcessor ⽅法调⽤</td><td align="left">refresh#finishBeanFactoryInitialization(beanFactory)</td></tr></tbody></table><h5 id="Spring-IoC容器初始化主流程"><a href="#Spring-IoC容器初始化主流程" class="headerlink" title="Spring IoC容器初始化主流程"></a>Spring IoC容器初始化主流程</h5><p>由上分析可知，Spring IoC 容器初始化的关键环节就在 <code>AbstractApplicationContext#refresh()</code> ⽅法中<br>，我们查看 <code>refresh()</code> ⽅法来俯瞰容器创建的主体流程，主体流程下的具体⼦流程我们后⾯再来讨论。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">// 第⼀步：刷新前的预处理</span><br><span class="line">prepareRefresh();</span><br><span class="line">/*</span><br><span class="line">第⼆步：</span><br><span class="line">获取BeanFactory；默认实现是DefaultListableBeanFactory</span><br><span class="line">加载BeanDefition 并注册到 BeanDefitionRegistry</span><br><span class="line">*/</span><br><span class="line">ConfigurableListableBeanFactory beanFactory =</span><br><span class="line">obtainFreshBeanFactory();</span><br><span class="line">// 第三步：BeanFactory的预准备⼯作（BeanFactory进⾏⼀些设置，⽐如context的类加</span><br><span class="line">载器等）</span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line">try &#123;</span><br><span class="line">// 第四步：BeanFactory准备⼯作完成后进⾏的后置处理⼯作</span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line">// 第五步：实例化并调⽤实现了BeanFactoryPostProcessor接⼝的Bean</span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">// 第六步：注册BeanPostProcessor（Bean的后置处理器），在创建bean的前后等执</span><br><span class="line">⾏</span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line">// 第七步：初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；</span><br><span class="line">initMessageSource();</span><br><span class="line">// 第⼋步：初始化事件派发器</span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line">// 第九步：⼦类重写这个⽅法，在容器刷新的时候可以⾃定义逻辑</span><br><span class="line">onRefresh();</span><br><span class="line">// 第⼗步：注册应⽤的监听器。就是注册实现了ApplicationListener接⼝的监听器</span><br><span class="line">bean</span><br><span class="line">registerListeners();</span><br><span class="line">/*</span><br><span class="line">第⼗⼀步：</span><br><span class="line">初始化所有剩下的⾮懒加载的单例bean</span><br><span class="line">初始化创建⾮懒加载⽅式的单例Bean实例（未设置属性）</span><br><span class="line">填充属性</span><br><span class="line">初始化⽅法调⽤（⽐如调⽤afterPropertiesSet⽅法、init-method⽅法）</span><br><span class="line">调⽤BeanPostProcessor（后置处理器）对实例bean进⾏后置处</span><br><span class="line">*/</span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">/*</span><br><span class="line">第⼗⼆步：</span><br><span class="line">完成context的刷新。主要是调⽤LifecycleProcessor的onRefresh()⽅法，并且发布事</span><br><span class="line">件 （ContextRefreshedEvent）</span><br><span class="line">*/</span><br><span class="line">finishRefresh();</span><br><span class="line"> &#125;</span><br><span class="line"> ......</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BeanFactory创建流程"><a href="#BeanFactory创建流程" class="headerlink" title="BeanFactory创建流程"></a>BeanFactory创建流程</h4><h5 id="获取BeanFactory子流程"><a href="#获取BeanFactory子流程" class="headerlink" title="获取BeanFactory子流程"></a>获取BeanFactory子流程</h5><p>时序图如下</p><p><img src="/images/spring/s38.png" srcset="/img/loading.gif" alt="spring"></p><h5 id="BeanDefinition加载解析及注册子流程"><a href="#BeanDefinition加载解析及注册子流程" class="headerlink" title="BeanDefinition加载解析及注册子流程"></a>BeanDefinition加载解析及注册子流程</h5><ol><li>该⼦流程涉及到如下⼏个关键步骤</li></ol><p><strong>Resource定位</strong>：指对BeanDefinition的资源定位过程。通俗讲就是找到定义Javabean信息的XML⽂件，并将其封装成Resource对象。<br><strong>BeanDefinition载⼊</strong> ：把⽤户定义好的Javabean表示为IoC容器内部的数据结构，这个容器内部的数据结构就是BeanDefinition。<br><strong>注册BeanDefinition到 IoC 容器</strong></p><ol start="2"><li>过程分析</li></ol><p><strong>Step 1</strong>：⼦流程⼊⼝在 <code>AbstractRefreshableApplicationContext#refreshBeanFactory</code> ⽅法中</p><p><img src="/images/spring/s39.png" srcset="/img/loading.gif" alt="spring"></p><p><strong>Step 2</strong>：依次调⽤多个类的 loadBeanDefinitions ⽅法 —&gt; AbstractXmlApplicationContext —&gt; AbstractBeanDefinitionReader —&gt; XmlBeanDefinitionReader ⼀直执⾏到 XmlBeanDefinitionReader 的 <code>doLoadBeanDefinitions</code> ⽅法。</p><p><img src="/images/spring/s40.png" srcset="/img/loading.gif" alt="spring"></p><p><strong>Step 3</strong>：我们重点观察XmlBeanDefinitionReader 类的 <code>registerBeanDefinitions</code> ⽅法，期间产⽣了多<br>次重载调⽤，我们定位到最后⼀个。</p><p><img src="/images/spring/s41.png" srcset="/img/loading.gif" alt="spring"></p><p>此处我们关注两个地⽅：⼀个<code>createRederContext</code>⽅法，⼀个是DefaultBeanDefinitionDocumentReader类的<code>registerBeanDefinitions</code>⽅法，先进⼊<code>createRederContext</code> ⽅法看看。</p><p><img src="/images/spring/s42.png" srcset="/img/loading.gif" alt="spring"></p><p>我们可以看到，此处 Spring ⾸先完成了 NamespaceHandlerResolver 的初始化。<br>我们再进⼊ <code>registerBeanDefinitions</code> ⽅法中追踪，调⽤了<code>DefaultBeanDefinitionDocumentReader#registerBeanDefinitions</code> ⽅法。</p><p><img src="/images/spring/s43.png" srcset="/img/loading.gif" alt="spring"></p><p>进⼊ <code>doRegisterBeanDefinitions</code> ⽅法</p><p><img src="/images/spring/s44.png" srcset="/img/loading.gif" alt="spring"></p><p>进⼊ <code>parseBeanDefinitions</code> ⽅法</p><p><img src="/images/spring/s45.png" srcset="/img/loading.gif" alt="spring"></p><p>进⼊ <code>parseDefaultElement</code> ⽅法</p><p><img src="/images/spring/s46.png" srcset="/img/loading.gif" alt="spring"></p><p>进⼊ <code>processBeanDefinition</code> ⽅法</p><p><img src="/images/spring/s47.png" srcset="/img/loading.gif" alt="spring"></p><p>⾄此，注册流程结束，我们发现，所谓的注册就是把封装的 XML 中定义的 Bean信息封装为 BeanDefinition 对象之后放⼊⼀个Map中，BeanFactory 是以 Map 的结构组织这些 BeanDefinition 的。</p><p><img src="/images/spring/s48.png" srcset="/img/loading.gif" alt="spring"></p><p>可以在DefaultListableBeanFactory中看到此Map的定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** Map of bean definition objects, keyed by bean name. */</span><br><span class="line">private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</span><br></pre></td></tr></table></figure><ol start="3"><li>时序图</li></ol><p><img src="/images/spring/s49.png" srcset="/img/loading.gif" alt="spring"></p><h4 id="Bean创建流程"><a href="#Bean创建流程" class="headerlink" title="Bean创建流程"></a>Bean创建流程</h4><ul><li>通过最开始的关键时机点分析，我们知道Bean创建⼦流程⼊⼝在<code>AbstractApplicationContext#refresh()</code>⽅法的<code>finishBeanFactoryInitialization(beanFactory)</code> 处</li></ul><p><img src="/images/spring/s50.png" srcset="/img/loading.gif" alt="spring"></p><ul><li>进⼊finishBeanFactoryInitialization</li></ul><p><img src="/images/spring/s51.png" srcset="/img/loading.gif" alt="spring"></p><ul><li>继续进⼊DefaultListableBeanFactory类的preInstantiateSingletons⽅法，我们找到下⾯部分的代码，看到⼯⼚Bean或者普通Bean，最终都是通过getBean的⽅法获取实例</li></ul><p><img src="/images/spring/s52.png" srcset="/img/loading.gif" alt="spring"></p><ul><li>继续跟踪下去，我们进⼊到了AbstractBeanFactory类的doGetBean⽅法，这个⽅法中的代码很多，我们直接找到核⼼部分</li></ul><p><img src="/images/spring/s53.png" srcset="/img/loading.gif" alt="spring"></p><ul><li>接着进⼊到AbstractAutowireCapableBeanFactory类的⽅法，找到以下代码部分</li></ul><p><img src="/images/spring/s54.png" srcset="/img/loading.gif" alt="spring"></p><ul><li>进⼊doCreateBean⽅法看看，该⽅法我们关注两块重点区域<ul><li>创建Bean实例，此时尚未设置属性<br><img src="/images/spring/s55.png" srcset="/img/loading.gif" alt="spring"></li><li>给Bean填充属性，调⽤初始化⽅法，应⽤BeanPostProcessor后置处理器<br><img src="/images/spring/s56.png" srcset="/img/loading.gif" alt="spring"></li></ul></li></ul><h4 id="lazy-init延迟加载机制原理"><a href="#lazy-init延迟加载机制原理" class="headerlink" title="lazy-init延迟加载机制原理"></a>lazy-init延迟加载机制原理</h4><ul><li>lazy-init 延迟加载机制分析</li></ul><p>普通 Bean 的初始化是在容器启动初始化阶段执⾏的，⽽被<code>lazy-init=true</code>修饰的 bean 则是在从容器⾥第⼀次进⾏<code>context.getBean()</code> 时进⾏触发。Spring 启动的时候会把所有bean信息(包括XML和注解)解析转化成Spring能够识别的BeanDefinition并存到Hashmap⾥供下⾯的初始化时⽤，然后对每个BeanDefinition 进⾏处理，如果是懒加载的则在容器初始化阶段不处理，其他的则在容器初始化阶段进⾏初始化并依赖注⼊。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">// 所有beanDefinition集合</span><br><span class="line">List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line">// 触发所有⾮懒加载单例bean的初始化</span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">// 获取bean 定义</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">// 判断是否是懒加载单例bean，如果是单例的并且不是懒加载的则在容器创建时初始化</span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">// 判断是否是 FactoryBean</span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;)</span><br><span class="line">getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">boolean isEagerInit;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Boolean <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">/*</span><br><span class="line">如果是普通bean则进⾏初始化并依赖注⼊，此 getBean(beanName)接下来触发的逻辑</span><br><span class="line">和</span><br><span class="line">懒加载时 context.getBean(<span class="string">"beanName"</span>) 所触发的逻辑是⼀样的</span><br><span class="line">*/</span><br><span class="line">getBean(beanName);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结<ul><li>对于被修饰为lazy-init的bean Spring 容器初始化阶段不会进⾏ init 并且依赖注⼊，当第⼀次进⾏getBean时候才进⾏初始化并依赖注⼊</li><li>对于⾮懒加载的bean，getBean的时候会从缓存⾥头获取，因为容器初始化阶段 Bean 已经初始化完成并缓存了起来</li></ul></li></ul><h4 id="Spring-IoC循环依赖问题"><a href="#Spring-IoC循环依赖问题" class="headerlink" title="Spring IoC循环依赖问题"></a>Spring IoC循环依赖问题</h4><h5 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h5><p>循环依赖其实就是循环引⽤，也就是两个或者两个以上的 Bean 互相持有对⽅，最终形成闭环。⽐如A依赖于B，B依赖于C，C⼜依赖于A。</p><p><img src="/images/spring/s57.png" srcset="/img/loading.gif" alt="spring"></p><p>注意，这⾥不是函数的循环调⽤，是对象的相互依赖关系。循环调⽤其实就是⼀个死循环，除⾮有终结条件。</p><p>Spring中循环依赖场景有：</p><ul><li>构造器的循环依赖（构造器注⼊）</li><li>Field 属性的循环依赖（set注⼊）<br>其中，构造器的循环依赖问题⽆法解决，只能拋出 BeanCurrentlyInCreationException 异常，在解决属性循环依赖时，spring采⽤的是提前暴露对象的⽅法。</li></ul><h5 id="循环依赖处理机制"><a href="#循环依赖处理机制" class="headerlink" title="循环依赖处理机制"></a>循环依赖处理机制</h5><ul><li>单例 bean 构造器参数循环依赖（⽆法解决）</li><li>prototype 原型 bean循环依赖（⽆法解决）<br>对于原型bean的初始化过程中不论是通过构造器参数循环依赖还是通过setXxx⽅法产⽣循环依赖，Spring都 会直接报错处理。</li></ul><p>AbstractBeanFactory.doGetBean()⽅法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected boolean isPrototypeCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">Object curVal = this.prototypesCurrentlyInCreation.get();</span><br><span class="line"><span class="built_in">return</span> (curVal != null &amp;&amp; (curVal.equals(beanName) || (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取bean之前如果这个原型bean正在被创建则直接抛出异常。原型bean在创建之前会进⾏标记这个beanName正在被创建，等创建结束之后会删除标记。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">//创建原型bean之前添加标记</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">//创建原型bean</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">//创建原型bean之后删除标记</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：Spring 不⽀持原型 bean 的循环依赖。</p><ul><li>单例bean通过setXxx或者@Autowired进⾏循环依赖<br>Spring 的循环依赖的理论依据基于 Java 的引⽤传递，当获得对象的引⽤时，对象的属性是可以延后设置的，但是构造器必须是在获取引⽤之前<br>Spring通过setXxx或者@Autowired⽅法解决循环依赖其实是通过提前暴露⼀个ObjectFactory对象来完成的，简单来说ClassA在调⽤构造器完成对象初始化之后，在调⽤ClassA的setClassB⽅法之前就把ClassA实例化的对象通过ObjectFactory提前暴露到Spring容器中。<ul><li>Spring容器初始化ClassA通过构造器初始化对象后提前暴露到Spring容器。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"'to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line">//将初始化后的对象提前已ObjectFactory对象注⼊到容器中</span><br><span class="line">addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object getObject() throws BeansException &#123;</span><br><span class="line"><span class="built_in">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ClassA调⽤setClassB⽅法，Spring⾸先尝试从容器中获取ClassB，此时ClassB不存在Spring容器中。</li><li>Spring容器初始化ClassB，同时也会将ClassB提前暴露到Spring容器中</li><li>ClassB调⽤setClassA⽅法，Spring从容器中获取ClassA ，因为第⼀步中已经提前暴露了</li><li>ClassA，因此可以获取到ClassA实例<ul><li>ClassA通过spring容器获取到ClassB，完成了对象初始化操作。</li></ul></li><li>这样ClassA和ClassB都完成了对象初始化操作，解决了循环依赖问题。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring全家桶</tag>
      
      <tag>IoC</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轻量级控制反转和面向切面的容器框架——Spring（三）</title>
    <link href="/2019/07/29/spring3/"/>
    <url>/2019/07/29/spring3/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/spring_logo.jpg" srcset="/img/loading.gif" alt="spring"></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前整理过一些关于Spring框架零散的知识点，一直没时间整理，恰好最近又拜读了<strong>应癫</strong>老师的课程，所以赶紧梳理一下关于Spring的相关知识。</p><hr><h3 id="Spring-IoC应用"><a href="#Spring-IoC应用" class="headerlink" title="Spring IoC应用"></a>Spring IoC应用</h3><h4 id="Spring-IoC-基础"><a href="#Spring-IoC-基础" class="headerlink" title="Spring IoC 基础"></a>Spring IoC 基础</h4><p><img src="/images/spring/s20.png" srcset="/img/loading.gif" alt="spring"></p><h5 id="BeanFactory与ApplicationContext区别"><a href="#BeanFactory与ApplicationContext区别" class="headerlink" title="BeanFactory与ApplicationContext区别"></a>BeanFactory与ApplicationContext区别</h5><p>BeanFactory是Spring框架中IoC容器的顶层接⼝,它只是⽤来定义⼀些基础功能,定义⼀些基础规范,⽽ApplicationContext是它的⼀个⼦接⼝，所以ApplicationContext是具备BeanFactory提供的全部功能的。<br>通常，我们称BeanFactory为SpringIOC的基础容器，ApplicationContext是容器的⾼级接⼝，⽐BeanFactory要拥有更多的功能，⽐如说国际化⽀持和资源访问（xml，java配置类）等等。</p><p><img src="/images/spring/s21.png" srcset="/img/loading.gif" alt="spring"></p><p>启动 IoC 容器的⽅式</p><ul><li>Java环境下启动IoC容器<ul><li>ClassPathXmlApplicationContext：从类的根路径下加载配置⽂件（推荐使⽤）</li><li>FileSystemXmlApplicationContext：从磁盘路径上加载配置⽂件</li><li>AnnotationConfigApplicationContext：纯注解模式下启动Spring容器</li></ul></li><li>Web环境下启动IoC容器<ul><li>从xml启动容器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line"><span class="string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"><span class="string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span><br><span class="line">&lt;web-app&gt; </span><br><span class="line">&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">&lt;!--配置Spring ioc容器的配置⽂件--&gt;</span><br><span class="line">&lt;context-param&gt; </span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; </span><br><span class="line">&lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;!--使⽤监听器启动Spring的IOC容器--&gt;</span><br><span class="line">&lt;listener&gt; </span><br><span class="line">&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li><li>从配置类启动容器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line"><span class="string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"><span class="string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">&lt;!--告诉ContextloaderListener知道我们使⽤注解的⽅式启动ioc容器--&gt;</span><br><span class="line">&lt;context-param&gt; </span><br><span class="line">&lt;param-name&gt;contextClass&lt;/param-name&gt;</span><br><span class="line">&lt;param￾value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;!--配置启动类的全限定类名--&gt;</span><br><span class="line">&lt;context-param&gt; </span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; </span><br><span class="line">&lt;param-value&gt;com.loonycoder.SpringConfig&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;!--使⽤监听器启动Spring的IOC容器--&gt;</span><br><span class="line">&lt;listener&gt; </span><br><span class="line">&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="纯xml模式"><a href="#纯xml模式" class="headerlink" title="纯xml模式"></a>纯xml模式</h5><p>本部分内容我们不采⽤⼀⼀讲解知识点的⽅式，⽽是采⽤Spring IoC 纯 xml 模式改造我们前⾯⼿写的<br>IoC 和 AOP 实现，在改造的过程中，把各个知识点串起来。</p><ul><li>xml ⽂件头</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>实例化Bean的三种⽅式</p><ul><li><p>⽅式⼀：使⽤⽆参构造函数。<br>在默认情况下，它会通过反射调⽤⽆参构造函数来创建对象。如果类中没有⽆参构造函数，将创建失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置service对象--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> class=<span class="string">"com.loonycoder.service.impl.TransferServiceImpl"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>⽅式⼆：使⽤静态⽅法创。<br>在实际开发中，我们使⽤的对象有些时候并不是直接通过构造函数就可以创建出来的，它可能在创建的过程 中会做很多额外的操作。此时会提供⼀个创建对象的⽅法，恰好这个⽅法是static修饰的⽅法，即是此种情况。例如，我们在做Jdbc操作时，会⽤到<code>java.sql.Connection</code>接⼝的实现类，如果是mysql数据库，那么⽤的就 是JDBC4Connection，但是我们不会去写 <code>JDBC4Connection connection = new JDBC4Connection() </code>，因为我们要注册驱动，还要提供URL和凭证信息，⽤ <code>DriverManager.getConnection </code>⽅法来获取连接。那么在实际开发中，尤其早期的项⽬没有使⽤Spring框架来管理对象的创建，但是在设计时使⽤了⼯⼚模式 解耦，那么当接⼊spring之后，⼯⼚类创建对象就具有和上述例⼦相同特征，即可采⽤此种⽅式配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--使⽤静态⽅法创建对象的配置⽅式--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> class=<span class="string">"com.loonycoder.factory.BeanFactory"</span></span><br><span class="line">factory-method=<span class="string">"getTransferService"</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>⽅式三：使⽤实例化⽅法创建。<br>此种⽅式和上⾯静态⽅法创建其实类似，区别是⽤于获取对象的⽅法不再是static修饰的了，⽽是类中的⼀ 个普通⽅法。此种⽅式⽐静态⽅法创建的使⽤⼏率要⾼⼀些。在早期开发的项⽬中，⼯⼚类中的⽅法有可能是静态的，也有可能是⾮静态⽅法，当是⾮静态⽅法时，即可 采⽤下⾯的配置⽅式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--使⽤实例⽅法创建对象的配置⽅式--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"beanFactory"</span> class=<span class="string">"com.loonycoder.factory.instancemethod.BeanFactory"</span>&gt;&lt;/bean&gt; </span><br><span class="line">&lt;bean id=<span class="string">"transferService"</span> factory-bean=<span class="string">"beanFactory"</span> factory-method=<span class="string">"getTransferService"</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Bean的作用范围及⽣命周期</p><ul><li>作⽤范围的改变<br>在spring框架管理Bean对象的创建时，Bean对象默认都是单例的，但是它⽀持配置的⽅式改变作⽤范围。作⽤范围官⽅提供的说明如下图：</li></ul></li></ul><p><img src="/images/spring/s22.png" srcset="/img/loading.gif" alt="spring"></p><p>在上图中提供的这些选项中，我们实际开发中⽤到最多的作⽤范围就是singleton（单例模式）和prototype（原型模式，也叫多例模式）。配置⽅式参考下⾯的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置service对象--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"transferService"</span> class=<span class="string">"com.loonycoder.service.impl.TransferServiceImpl"</span> scope=<span class="string">"singleton"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><pre><code>- 不同作⽤范围的⽣命周期**单例模式：singleton**对象出⽣：当创建容器时，对象就被创建了。对象活着：只要容器在，对象⼀直活着。对象死亡：当销毁容器时，对象就被销毁了。⼀句话总结：单例模式的bean对象⽣命周期与容器相同。**多例模式：prototype**对象出⽣：当使⽤对象时，创建新的对象实例。对象活着：只要对象在使⽤中，就⼀直活着。对象死亡：当对象⻓时间不⽤时，被java的垃圾回收器回收了。⼀句话总结：多例模式的bean对象，spring框架只负责创建，不负责销毁。</code></pre><ul><li>Bean标签属性</li></ul><p>在基于xml的IoC配置中，bean标签是最基础的标签。它表示了IoC容器中的⼀个对象。换句话说，如果⼀个对象想让spring管理，在XML的配置中都需要使⽤此标签配置，Bean标签的属性如下：<br><strong>id属性：</strong>⽤于给bean提供⼀个唯⼀标识。在⼀个标签内部，标识必须唯⼀。<br><strong>class属性：</strong>⽤于指定创建Bean对象的全限定类名。<br><strong>name属性：</strong>⽤于给bean提供⼀个或多个名称。多个名称⽤空格分隔。<br><strong>factory-bean属性：</strong>⽤于指定创建当前bean对象的⼯⼚bean的唯⼀标识。当指定了此属性之后，class属性失效。<br><strong>factory-method属性：</strong>⽤于指定创建当前bean对象的⼯⼚⽅法，如配合factory-bean属性使⽤，则class属性失效。如配合class属性使⽤，则⽅法必须是static的。<br><strong>scope属性：</strong>⽤于指定bean对象的作⽤范围。通常情况下就是singleton。当要⽤到多例模式时，可以配置为prototype。<br><strong>init-method属性：</strong>⽤于指定bean对象的初始化⽅法，此⽅法会在bean对象装配后调⽤。必须是⼀个⽆参⽅法。<br><strong>destory-method属性：</strong>⽤于指定bean对象的销毁⽅法，此⽅法会在bean对象销毁前执⾏。它只能为scope是singleton时起作⽤。</p><ul><li>DI 依赖注⼊的xml配置<ul><li>依赖注⼊分类<ul><li>按照注⼊的⽅式分类<br><strong>构造函数注⼊：</strong>顾名思义，就是利⽤带参构造函数实现对类成员的数据赋值。<br><strong>set⽅法注⼊：</strong>它是通过类成员的set⽅法实现数据的注⼊。（使⽤最多的）</li><li>按照注⼊的数据类型分类<br><strong>基本类型和String</strong><br>注⼊的数据类型是基本类型或者是字符串类型的数据。<br><strong>其他Bean类型</strong><br>注⼊的数据类型是对象类型，称为其他Bean的原因是，这个对象是要求出现在IoC容器中的。那么针对当前Bean来说，就是其他Bean了。<br><strong>复杂类型（集合类型）</strong><br>注⼊的数据类型是Aarry，List，Set，Map，Properties中的⼀种类型。</li></ul></li><li>依赖注⼊的配置实现之构造函数注⼊ 顾名思义，就是利⽤构造函数实现对类成员的赋值。它的使⽤要求是，类中提供的构造函数参数个数必须和配置的参数个数⼀致，且数据类型匹配。同时需要注意的是，当没有⽆参构造时，则必须提供构造函数参数的注⼊，否则Spring框架会报错。</li></ul></li></ul><p><img src="/images/spring/s23.png" srcset="/img/loading.gif" alt="spring"><br><img src="/images/spring/s24.png" srcset="/img/loading.gif" alt="spring"></p><p>在使⽤构造函数注⼊时，涉及的标签是 <code>constructor-arg</code> ，该标签有如下属性：<br><strong>name：</strong>⽤于给构造函数中指定名称的参数赋值。<br><strong>index：</strong>⽤于给构造函数中指定索引位置的参数赋值。<br><strong>value：</strong>⽤于指定基本类型或者String类型的数据。<br><strong>ref：</strong>⽤于指定其他Bean类型的数据。写的是其他bean的唯⼀标识。<br>    - 依赖注⼊的配置实现之set⽅法注⼊<br>    顾名思义，就是利⽤字段的set⽅法实现赋值的注⼊⽅式。此种⽅式在实际开发中是使⽤最多的注⼊⽅式。</p><p><img src="/images/spring/s25.png" srcset="/img/loading.gif" alt="spring"><br><img src="/images/spring/s26.png" srcset="/img/loading.gif" alt="spring"></p><p>在使⽤set⽅法注⼊时，需要使⽤ <code>property</code> 标签，该标签属性如下：<br><strong>name：</strong>指定注⼊时调⽤的set⽅法名称。（注：不包含set这三个字⺟,druid连接池指定属性名称）<br><strong>value：</strong>指定注⼊的数据。它⽀持基本类型和String类型。<br><strong>ref：</strong>指定注⼊的数据。它⽀持其他bean类型。写的是其他bean的唯⼀标识。</p><ul><li>复杂数据类型注⼊。<br>⾸先，解释⼀下复杂类型数据，它指的是集合类型数据。集合分为两类，⼀类是List结构（数组结构），⼀类是Map接⼝（键值对）。接下来就是注⼊的⽅式的选择，只能在构造函数和set⽅法中选择，我们的示例选⽤set⽅法注⼊。</li></ul><p><img src="/images/spring/s27.png" srcset="/img/loading.gif" alt="spring"><br><img src="/images/spring/s28.png" srcset="/img/loading.gif" alt="spring"></p><p>在List结构的集合数据注⼊时， <code>array , list , set</code> 这三个标签通⽤，另外注值的 <code>value</code> 标签内部<br>可以直接写值，也可以使⽤ <code>bean</code> 标签配置⼀个对象，或者⽤ <code>ref</code> 标签引⽤⼀个已经配合的bean<br>的唯⼀标识。<br>在Map结构的集合数据注⼊时， <code>map</code> 标签使⽤ <code>entry</code> ⼦标签实现数据注⼊， <code>entry</code> 标签可以使⽤<strong>key</strong>和<strong>value</strong>属性指定存⼊map中的数据。使⽤value-ref属性指定已经配置好的bean的引⽤。<br>同时 <code>entry</code> 标签中也可以使⽤ <code>ref</code> 标签，但是不能使⽤ <code>bean</code> 标签。⽽ <code>property</code> 标签中不能使⽤ <code>ref</code> 或者 <code>bean</code> 标签引⽤对象。</p><h5 id="xml与注解相结合模式"><a href="#xml与注解相结合模式" class="headerlink" title="xml与注解相结合模式"></a>xml与注解相结合模式</h5><p>注意：</p><ol><li>实际企业开发中，纯xml模式使⽤已经很少了</li><li>引⼊注解功能，不需要引⼊额外的jar</li><li>xml+注解结合模式，xml⽂件依然存在，所以，spring IOC容器的启动仍然从加载xml开始</li><li>哪些bean的定义写在xml中，哪些bean的定义使⽤注解</li></ol><p><strong>第三⽅jar中的bean定义在xml，⽐如德鲁伊数据库连接池<br>⾃⼰开发的bean定义使⽤注解</strong></p><ul><li>xml中标签与注解的对应（IoC）</li></ul><table><thead><tr><th align="left">xml形式</th><th align="left">对应的注解形式</th></tr></thead><tbody><tr><td align="left">标签</td><td align="left">@Component(“accountDao”)，注解加在类上。bean的id属性内容直接配置在注解后⾯如果不配置，默认定义个这个bean的id为类的类名⾸字⺟⼩写；另外，针对分层代码开发提供了@Componenet的三种别名@Controller、@Service、@Repository分别⽤于控制层类、服务层类、dao层类的bean定义，这四个注解的⽤法完全⼀样，只是为了更清晰的区分⽽已。</td></tr><tr><td align="left">标签的scope属性</td><td align="left">@Scope(“prototype”)，默认单例，注解加在类上</td></tr><tr><td align="left">标签的init-method属性</td><td align="left">@PostConstruct，注解加在⽅法上，该⽅法就是初始化后调⽤的⽅法</td></tr><tr><td align="left">标签的destorymethod属性</td><td align="left">@PreDestory，注解加在⽅法上，该⽅法就是销毁前调⽤的⽅法</td></tr></tbody></table><ul><li>DI 依赖注⼊的注解实现⽅式</li></ul><p><strong>@Autowired</strong>（推荐使⽤）<br>@Autowired为Spring提供的注解，需要导⼊包<br><code>org.springframework.beans.factory.annotation.Autowired</code><br>@Autowired采取的策略为按照类型注⼊。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class TransferServiceImpl &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private AccountDao accountDao; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，这样装配回去spring容器中找到类型为AccountDao的类，然后将其注⼊进来。这样会产⽣⼀个问题，当⼀个类型有多个bean值的时候，会造成⽆法选择具体注⼊哪⼀个的情况，这个时候我们需要配合着<code>@Qualifier</code>使⽤。<code>@Qualifier</code>告诉Spring具体去装配哪个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TransferServiceImpl &#123;</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(name=<span class="string">"jdbcAccountDaoImpl"</span>) </span><br><span class="line">private AccountDao accountDao; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们就可以通过类型和名称定位到我们想注⼊的对象。<br><strong>@Resource</strong><br><code>@Resource</code> 注解由 J2EE 提供，需要导⼊包 <code>javax.annotation.Resource</code><br><code>@Resource</code> 默认按照 ByName ⾃动注⼊。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TransferService &#123;</span><br><span class="line">@Resource</span><br><span class="line">private AccountDao accountDao;</span><br><span class="line">@Resource(name=<span class="string">"studentDao"</span>) </span><br><span class="line">private StudentDao studentDao;</span><br><span class="line">@Resource(<span class="built_in">type</span>=<span class="string">"TeacherDao"</span>) </span><br><span class="line">private TeacherDao teacherDao;</span><br><span class="line">@Resource(name=<span class="string">"manDao"</span>,<span class="built_in">type</span>=<span class="string">"ManDao"</span>) </span><br><span class="line">private ManDao manDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>- 如果同时指定了 name 和 type，则从Spring上下⽂中找到唯⼀匹配的bean进⾏装配，找不到则抛出异常。- 如果指定了 name，则从上下⽂中查找名称（id）匹配的bean进⾏装配，找不到则抛出异常。- 如果指定了 type，则从上下⽂中找到类似匹配的唯⼀bean进⾏装配，找不到或是找到多个，都会抛出异常。- 如果既没有指定name，⼜没有指定type，则⾃动按照byName⽅式进⾏装配；</code></pre><p><strong>注意:</strong><br><code>@Resource</code> 在 Jdk 11中已经移除，如果要使⽤，需要单独引⼊jar包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;javax.annotation&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="纯注解模式"><a href="#纯注解模式" class="headerlink" title="纯注解模式"></a>纯注解模式</h5><p>改造xml + 注解模式，将xml中遗留的内容全部以注解的形式迁移出去，最终删除xml，从Java配置类启动。</p><p><strong>对应注解</strong><br><code>@Configuration</code>：表名当前类是⼀个配置类<br><code>@ComponentScan</code>：替代 context:component-scan<br><code>@PropertySource</code>：引⼊外部属性配置⽂件<br><code>@Import</code>：引⼊其他配置类<br><code>@Value</code>：对变量赋值，可以直接赋值，也可以使⽤ ${} 读取资源配置⽂件中的信息<br><code>@Bean</code>：将⽅法返回对象加⼊ SpringIoC 容器</p><h4 id="SpringIoC高级特性"><a href="#SpringIoC高级特性" class="headerlink" title="SpringIoC高级特性"></a>SpringIoC高级特性</h4><h5 id="lazy-init延迟加载"><a href="#lazy-init延迟加载" class="headerlink" title="lazy-init延迟加载"></a>lazy-init延迟加载</h5><p>Bean的延迟加载（延迟创建）<br>ApplicationContext 容器的默认⾏为是在启动服务器时将所有 singleton bean 提前进⾏实例化。提前实例化意味着作为初始化过程的⼀部分，ApplicationContext 实例会创建并配置所有的singleton bean。<br>⽐如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"testBean"</span> class=<span class="string">"cn.loonycoder.LazyBean"</span> /&gt;</span><br><span class="line"> &lt;!--该bean默认的设置为: --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"testBean"</span> calss=<span class="string">"cn.loonycoder.LazyBean"</span> lazy-init=<span class="string">"false"</span> /&gt;</span><br></pre></td></tr></table></figure><p>lazy-init=“false”，⽴即加载，表示在spring启动时，⽴刻进⾏实例化。<br>如果不想让⼀个singleton bean 在 ApplicationContext实现初始化时被提前实例化，那么可以将bean设置为延迟实例化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"testBean"</span> calss=<span class="string">"cn.loonycoder.LazyBean"</span> lazy-init=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure><p>设置 lazy-init 为 true 的 bean 将不会在 ApplicationContext 启动时提前被实例化，⽽是第⼀次向容器通过 getBean 索取 bean 时实例化的。<br>如果⼀个设置了⽴即加载的 bean1，引⽤了⼀个延迟加载的 bean2 ，那么 bean1 在容器启动时被实例化，⽽ bean2 由于被 bean1 引⽤，所以也被实例化，这种情况也符合延时加载的 bean 在第⼀次调⽤时才被实例化的规则。<br>也可以在容器层次中通过在 元素上使⽤ “default-lazy-init” 属性来控制延时初始化。如下⾯配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans default-lazy-init=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;!-- no beans will be eagerly pre-instantiated... --&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>如果⼀个 bean 的 scope 属性为 scope=“pototype” 时，即使设置了 lazy-init=“false”，容器启动时也不会实例化bean，⽽是调⽤ getBean ⽅法实例化的。</p><p><strong>应⽤场景</strong></p><ol><li>开启延迟加载⼀定程度提⾼容器启动和运转性能</li><li>对于不常使⽤的 Bean 设置延迟加载，这样偶尔使⽤的时候再加载，不必要从⼀开始该 Bean 就占⽤资源</li></ol><h5 id="FactoryBean和BeanFactory"><a href="#FactoryBean和BeanFactory" class="headerlink" title="FactoryBean和BeanFactory"></a>FactoryBean和BeanFactory</h5><p>BeanFactory接⼝是容器的顶级接⼝，定义了容器的⼀些基础⾏为，负责⽣产和管理Bean的⼀个⼯⼚，具体使⽤它下⾯的⼦接⼝类型，⽐如ApplicationContext；此处我们重点分析FactoryBean<br>Spring中Bean有两种，⼀种是普通Bean，⼀种是⼯⼚Bean（FactoryBean），FactoryBean可以⽣成某⼀个类型的Bean实例（返回给我们），也就是说我们可以借助于它⾃定义Bean的创建过程。<br>Bean创建的三种⽅式中的静态⽅法和实例化⽅法和FactoryBean作⽤类似，FactoryBean使⽤较多，尤其在Spring框架⼀些组件中会使⽤，还有其他框架和Spring框架整合时使⽤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 可以让我们⾃定义Bean的创建过程（完成复杂Bean的定义）</span><br><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">@Nullable</span><br><span class="line">// 返回FactoryBean创建的Bean实例，如果isSingleton返回<span class="literal">true</span>，则该实例会放到Spring容器</span><br><span class="line">的单例对象缓存池中Map</span><br><span class="line">T getObject() throws Exception;</span><br><span class="line">@Nullable</span><br><span class="line">// 返回FactoryBean创建的Bean类型</span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line">// 返回作⽤域是否单例</span><br><span class="line">default boolean <span class="function"><span class="title">isSingleton</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Company类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.pojo;</span><br><span class="line"></span><br><span class="line">public class Company &#123;</span><br><span class="line">private String name;</span><br><span class="line">private String address;</span><br><span class="line">private int scale;</span><br><span class="line">public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public String <span class="function"><span class="title">getAddress</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line">public void setAddress(String address) &#123;</span><br><span class="line">this.address = address;</span><br><span class="line">&#125;</span><br><span class="line">public int <span class="function"><span class="title">getScale</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> scale;</span><br><span class="line">&#125;</span><br><span class="line">public void setScale(int scale) &#123;</span><br><span class="line">this.scale = scale;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">"Company&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\'</span><span class="string">' + ", address='</span><span class="string">" + address + '\'' + "</span>, scale=<span class="string">" + scale + '&#125;';</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>CompanyFactoryBean类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.factory;</span><br><span class="line">import com.loonycoder.pojo.Company;</span><br><span class="line">import org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line">public class CompanyFactoryBean implements FactoryBean&lt;Company&gt; &#123;</span><br><span class="line">private String companyInfo; // 公司名称,地址,规模</span><br><span class="line">public void setCompanyInfo(String companyInfo) &#123;</span><br><span class="line">this.companyInfo = companyInfo;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Company getObject() throws Exception &#123;</span><br><span class="line">// 模拟创建复杂对象Company</span><br><span class="line">Company company = new Company();</span><br><span class="line">String[] strings = companyInfo.split(<span class="string">","</span>);</span><br><span class="line">company.setName(strings[0]);</span><br><span class="line">company.setAddress(strings[1]);</span><br><span class="line">company.setScale(Integer.parseInt(strings[2]));</span><br><span class="line"><span class="built_in">return</span> company;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Class&lt;?&gt; <span class="function"><span class="title">getObjectType</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> Company.class;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public boolean <span class="function"><span class="title">isSingleton</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"companyBean"</span> class=<span class="string">"com.loonycoder.factory.CompanyFactoryBean"</span>&gt; </span><br><span class="line">&lt;property name=<span class="string">"companyInfo"</span> value=<span class="string">"loonycoder,望京,500"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>测试，获取FactoryBean产⽣的对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object companyBean = applicationContext.getBean(<span class="string">"companyBean"</span>);</span><br><span class="line">System.out.println(<span class="string">"bean:"</span> + companyBean);</span><br><span class="line">// 结果如下</span><br><span class="line">bean:Company&#123;name=<span class="string">'loonycoder'</span>, address=<span class="string">'望京'</span>, scale=500&#125;</span><br></pre></td></tr></table></figure><p>测试，获取FactoryBean，需要在id之前添加“&amp;”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object companyBean = applicationContext.getBean(<span class="string">"&amp;companyBean"</span>);</span><br><span class="line">System.out.println(<span class="string">"bean:"</span> + companyBean);</span><br><span class="line">// 结果如下</span><br><span class="line">bean:com.loonycoder.factory.CompanyFactoryBean@53f6fd09</span><br></pre></td></tr></table></figure><h5 id="后置处理器"><a href="#后置处理器" class="headerlink" title="后置处理器"></a>后置处理器</h5><p>Spring提供了两种后处理bean的扩展接⼝，分别为 BeanPostProcessor 和BeanFactoryPostProcessor，两者在使⽤上是有所区别的。<br>⼯⼚初始化（BeanFactory）—&gt; Bean对象<br>在BeanFactory初始化之后可以使⽤BeanFactoryPostProcessor进⾏后置处理做⼀些事情<br>在Bean对象实例化（并不是Bean的整个⽣命周期完成）之后可以使⽤BeanPostProcessor进⾏后置处理做⼀些事情<br><strong>注意：对象不⼀定是springbean，⽽springbean⼀定是个对象</strong></p><h6 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h6><p>BeanPostProcessor是针对Bean级别的处理，可以针对某个具体的Bean。</p><p><img src="/images/spring/s29.png" srcset="/img/loading.gif" alt="spring"></p><p>该接⼝提供了两个⽅法，分别在Bean的初始化⽅法前和初始化⽅法后执⾏，具体这个初始化⽅法指的是什么⽅法，类似我们在定义bean时，定义了init-method所指定的⽅法。<br>定义⼀个类实现了BeanPostProcessor，默认是会对整个Spring容器中所有的bean进⾏处理。如果要对具体的某个bean处理，可以通过⽅法参数判断，两个类型参数分别为Object和String，第⼀个参数是每个bean的实例，第⼆个参数是每个bean的name或者id属性的值。所以我们可以通过第⼆个参数，来判断我们将要处理的具体的bean。<br><strong>注意：处理是发⽣在Spring容器的实例化和依赖注⼊之后。</strong></p><h6 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h6><p>BeanFactory级别的处理，是针对整个Bean的⼯⼚进⾏处理，典型应⽤:PropertyPlaceholderConfigurer</p><p><img src="/images/spring/s30.png" srcset="/img/loading.gif" alt="spring"></p><p>此接⼝只提供了⼀个⽅法，⽅法参数为ConfigurableListableBeanFactory，该参数类型定义了⼀些⽅法。</p><p><img src="/images/spring/s31.png" srcset="/img/loading.gif" alt="spring"></p><p>其中有个⽅法名为<code>getBeanDefinition</code>的⽅法，我们可以根据此⽅法，找到我们定义bean 的BeanDefinition对象。然后我们可以对定义的属性进⾏修改，以下是BeanDefinition中的⽅法。</p><p><img src="/images/spring/s32.png" srcset="/img/loading.gif" alt="spring"></p><p>⽅法名字类似我们bean标签的属性，<code>setBeanClassName</code>对应bean标签中的class属性，所以当我们拿到BeanDefinition对象时，我们可以⼿动修改bean标签中所定义的属性值。<br><strong>BeanDefinition对象：</strong>我们在 XML 中定义的 bean标签，Spring 解析 bean 标签成为⼀个 JavaBean，这个JavaBean 就是 BeanDefinition<br><strong>注意：调⽤ <code>BeanFactoryPostProcessor</code> ⽅法时，这时候bean还没有实例化，此时 bean 刚被解析成BeanDefinition对象</strong></p>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring全家桶</tag>
      
      <tag>IoC</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轻量级控制反转和面向切面的容器框架——Spring（二）</title>
    <link href="/2019/07/16/spring2/"/>
    <url>/2019/07/16/spring2/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/spring_logo.jpg" srcset="/img/loading.gif" alt="spring"></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前整理过一些关于Spring框架零散的知识点，一直没时间整理，恰好最近又拜读了<strong>应癫</strong>老师的课程，所以赶紧梳理一下关于Spring的相关知识。</p><hr><h3 id="手写实现IoC和AOP"><a href="#手写实现IoC和AOP" class="headerlink" title="手写实现IoC和AOP"></a>手写实现IoC和AOP</h3><h4 id="银行转账案例界面"><a href="#银行转账案例界面" class="headerlink" title="银行转账案例界面"></a>银行转账案例界面</h4><p><img src="/images/spring/s11.png" srcset="/img/loading.gif" alt="spring"></p><h4 id="银行转账案例表结构"><a href="#银行转账案例表结构" class="headerlink" title="银行转账案例表结构"></a>银行转账案例表结构</h4><p><img src="/images/spring/s12.png" srcset="/img/loading.gif" alt="spring"></p><h4 id="银行转账案例代码调用关系"><a href="#银行转账案例代码调用关系" class="headerlink" title="银行转账案例代码调用关系"></a>银行转账案例代码调用关系</h4><p><img src="/images/spring/s13.png" srcset="/img/loading.gif" alt="spring"></p><h4 id="银行转账案例关键代码"><a href="#银行转账案例关键代码" class="headerlink" title="银行转账案例关键代码"></a>银行转账案例关键代码</h4><ul><li>TransferServlet</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import com.loonycoder.service.impl.TransferServiceImpl;</span><br><span class="line">import com.loonycoder.utils.JsonUtils;</span><br><span class="line">import com.loonycoder.pojo.Result;</span><br><span class="line">import com.loonycoder.service.TransferService;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebServlet(name=<span class="string">"transferServlet"</span>,urlPatterns = <span class="string">"/transferServlet"</span>)</span><br><span class="line">public class TransferServlet extends HttpServlet &#123;</span><br><span class="line">// 1. 实例化service层对象</span><br><span class="line">private TransferService transferService = new TransferServiceImpl();</span><br><span class="line">@Override</span><br><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">doPost(req,resp);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">// 设置请求体的字符编码</span><br><span class="line">req.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">String fromCardNo = req.getParameter(<span class="string">"fromCardNo"</span>);</span><br><span class="line">String toCardNo = req.getParameter(<span class="string">"toCardNo"</span>);</span><br><span class="line">String moneyStr = req.getParameter(<span class="string">"money"</span>);</span><br><span class="line">int money = Integer.parseInt(moneyStr);</span><br><span class="line">Result result = new Result();</span><br><span class="line">try &#123;</span><br><span class="line">// 2. 调⽤service层⽅法</span><br><span class="line">transferService.transfer(fromCardNo,toCardNo,money);</span><br><span class="line">result.setStatus(<span class="string">"200"</span>);</span><br><span class="line"> &#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">result.setStatus(<span class="string">"201"</span>);</span><br><span class="line">result.setMessage(e.toString());</span><br><span class="line"> &#125;</span><br><span class="line">// 响应</span><br><span class="line">resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">resp.getWriter().<span class="built_in">print</span>(JsonUtils.object2Json(result));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TransferService接⼝及实现类</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface TransferService &#123;</span><br><span class="line">void transfer(String fromCardNo,String toCardNo,int money) throws Exception; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.service.impl;</span><br><span class="line">import com.loonycoder.dao.AccountDao;</span><br><span class="line">import com.loonycoder.dao.impl.JdbcAccountDaoImpl;</span><br><span class="line">import com.loonycoder.pojo.Account;</span><br><span class="line">import com.loonycoder.service.TransferService;</span><br><span class="line">public class TransferServiceImpl implements TransferService &#123;</span><br><span class="line">private AccountDao accountDao = new JdbcAccountDaoImpl();</span><br><span class="line">@Override</span><br><span class="line">public void transfer(String fromCardNo, String toCardNo, int money)</span><br><span class="line">throws Exception &#123;</span><br><span class="line">Account from = accountDao.queryAccountByCardNo(fromCardNo);</span><br><span class="line">Account to = accountDao.queryAccountByCardNo(toCardNo);</span><br><span class="line">from.setMoney(from.getMoney()-money);</span><br><span class="line">to.setMoney(to.getMoney()+money);</span><br><span class="line">accountDao.updateAccountByCardNo(from);</span><br><span class="line">accountDao.updateAccountByCardNo(to);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AccountDao层接⼝及基于Jdbc的实现类</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line">import com.loonycoder.pojo.Account;</span><br><span class="line"></span><br><span class="line">public interface AccountDao &#123;</span><br><span class="line">Account queryAccountByCardNo(String cardNo) throws Exception;</span><br><span class="line">int updateAccountByCardNo(Account account) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JdbcAccountDaoImpl（Jdbc技术实现Dao层接⼝）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.dao.impl;</span><br><span class="line">import com.loonycoder.pojo.Account;</span><br><span class="line">import com.loonycoder.dao.AccountDao;</span><br><span class="line">import com.loonycoder.utils.DruidUtils;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">public class JdbcAccountDaoImpl implements AccountDao &#123;</span><br><span class="line">@Override</span><br><span class="line">public Account queryAccountByCardNo(String cardNo) throws Exception &#123;</span><br><span class="line">//从连接池获取连接</span><br><span class="line">Connection con = DruidUtils.getInstance().getConnection();</span><br><span class="line">String sql = <span class="string">"select * from account where cardNo=?"</span>;</span><br><span class="line">PreparedStatement preparedStatement = con.prepareStatement(sql);</span><br><span class="line">preparedStatement.setString(1,cardNo);</span><br><span class="line">ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">Account account = new Account();</span><br><span class="line"><span class="keyword">while</span>(resultSet.next()) &#123;</span><br><span class="line">account.setCardNo(resultSet.getString(<span class="string">"cardNo"</span>));</span><br><span class="line">account.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">account.setMoney(resultSet.getInt(<span class="string">"money"</span>));</span><br><span class="line">&#125;</span><br><span class="line">resultSet.close();</span><br><span class="line">preparedStatement.close();</span><br><span class="line">con.close();</span><br><span class="line"><span class="built_in">return</span> account;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">public int updateAccountByCardNo(Account account) throws Exception &#123;</span><br><span class="line">//从连接池获取连接</span><br><span class="line">Connection con = DruidUtils.getInstance().getConnection();</span><br><span class="line">String sql = <span class="string">"update account set money=? where cardNo=?"</span>;</span><br><span class="line">PreparedStatement preparedStatement = con.prepareStatement(sql);</span><br><span class="line">preparedStatement.setInt(1,account.getMoney());</span><br><span class="line">preparedStatement.setString(2,account.getCardNo());</span><br><span class="line">int i = preparedStatement.executeUpdate();</span><br><span class="line">preparedStatement.close();</span><br><span class="line">con.close();</span><br><span class="line"><span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="银行转账案例代码问题分析"><a href="#银行转账案例代码问题分析" class="headerlink" title="银行转账案例代码问题分析"></a>银行转账案例代码问题分析</h4><p><img src="/images/spring/s14.png" srcset="/img/loading.gif" alt="spring"></p><ul><li><p>问题⼀：在上述案例实现中，service 层实现类在使⽤ dao 层对象时，直接在<br>TransferServiceImpl 中通过 <code>AccountDao accountDao = new JdbcAccountDaoImpl() </code>获得了dao层对象，然⽽⼀个 new 关键字却将 TransferServiceImpl 和 dao 层具体的⼀个实现类JdbcAccountDaoImpl 耦合在了⼀起，如果说技术架构发⽣⼀些变动，dao 层的实现要使⽤其它技术，⽐如 Mybatis，思考切换起来的成本？每⼀个 new 的地⽅都需要修改源代码，重新编译，⾯向接⼝开发的意义将⼤打折扣？</p></li><li><p>问题⼆：service 层代码没有竟然还没有进⾏事务控制？如果转账过程中出现异常，将可能导致数据库数据错乱，后果可能会很严重，尤其在⾦融业务。</p></li></ul><h4 id="问题解决思路"><a href="#问题解决思路" class="headerlink" title="问题解决思路"></a>问题解决思路</h4><ul><li>针对问题⼀思考：<ul><li>实例化对象的⽅式除了 new 之外，还有什么技术？反射 (需要把类的全限定类名配置在xml中)</li></ul></li><li>考虑使⽤设计模式中的⼯⼚模式解耦合，另外项⽬中往往有很多对象需要实例化，那就在⼯⼚中使⽤反射技术实例化对象，⼯⼚模式很合适。</li></ul><p><img src="/images/spring/s15.png" srcset="/img/loading.gif" alt="spring"></p><ul><li>更进⼀步，代码中能否只声明所需实例的接⼝类型，不出现 new 也不出现⼯⼚类的字眼，如下<br>图？ 能！声明⼀个变量并提供 set ⽅法，在反射的时候将所需要的对象注⼊进去。</li></ul><p><img src="/images/spring/s16.png" srcset="/img/loading.gif" alt="spring"></p><ul><li>针对问题⼆思考：<ul><li>service 层没有添加事务控制，怎么办？没有事务就添加上事务控制，⼿动控制 JDBC 的Connection 事务，但要注意将Connection和当前线程绑定（即保证⼀个线程只有⼀个Connection，这样操作才针对的是同⼀个 Connection，进⽽控制的是同⼀个事务）</li></ul></li></ul><p><img src="/images/spring/s17.png" srcset="/img/loading.gif" alt="spring"></p><h4 id="案例代码改造"><a href="#案例代码改造" class="headerlink" title="案例代码改造"></a>案例代码改造</h4><ol><li>针对问题⼀的代码改造</li></ol><ul><li>beans.xml</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;beans&gt; &lt;bean id=<span class="string">"transferService"</span> class=<span class="string">"com.loonycoder.service.impl.TransferServiceImpl"</span>&gt; </span><br><span class="line">&lt;property name=<span class="string">"AccountDao"</span> ref=<span class="string">"accountDao"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt; </span><br><span class="line">&lt;bean id=<span class="string">"accountDao"</span> class=<span class="string">"com.loonycoder.dao.impl.JdbcAccountDaoImpl"</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ul><li>增加 BeanFactory.java</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.factory;</span><br><span class="line">import org.dom4j.Document;</span><br><span class="line">import org.dom4j.DocumentException;</span><br><span class="line">import org.dom4j.Element;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class BeanFactory &#123;</span><br><span class="line">/**</span><br><span class="line">* ⼯⼚类的两个任务</span><br><span class="line">* 任务⼀：加载解析xml，读取xml中的bean信息，通过反射技术实例化bean对象，然后放⼊</span><br><span class="line">map待⽤</span><br><span class="line">* 任务⼆：提供接⼝⽅法根据id从map中获取bean（静态⽅法）</span><br><span class="line">*/</span><br><span class="line">private static Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">static &#123;</span><br><span class="line">InputStream resourceAsStream = BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">"beans.xml"</span>);</span><br><span class="line">SAXReader saxReader = new SAXReader();</span><br><span class="line">try &#123;</span><br><span class="line">Document document = saxReader.read(resourceAsStream);</span><br><span class="line">Element rootElement = document.getRootElement();</span><br><span class="line">List&lt;Element&gt; list = rootElement.selectNodes(<span class="string">"//bean"</span>);</span><br><span class="line">// 实例化bean对象</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">Element element = list.get(i);</span><br><span class="line">String id = element.attributeValue(<span class="string">"id"</span>);</span><br><span class="line">String clazz = element.attributeValue(<span class="string">"class"</span>);</span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(clazz);</span><br><span class="line">Object o = aClass.newInstance();</span><br><span class="line">map.put(id,o);</span><br><span class="line"> &#125;</span><br><span class="line">// 维护bean之间的依赖关系</span><br><span class="line">List&lt;Element&gt; propertyNodes =</span><br><span class="line">rootElement.selectNodes(<span class="string">"//property"</span>);</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; propertyNodes.size(); i++) &#123;</span><br><span class="line">Element element = propertyNodes.get(i);</span><br><span class="line">// 处理property元素</span><br><span class="line">String name = element.attributeValue(<span class="string">"name"</span>);</span><br><span class="line">String ref = element.attributeValue(<span class="string">"ref"</span>);</span><br><span class="line">String parentId =</span><br><span class="line">element.getParent().attributeValue(<span class="string">"id"</span>);</span><br><span class="line">Object parentObject = map.get(parentId);</span><br><span class="line">Method[] methods = parentObject.getClass().getMethods();</span><br><span class="line"><span class="keyword">for</span> (int j = 0; j &lt; methods.length; j++) &#123;</span><br><span class="line">Method method = methods[j];</span><br><span class="line"><span class="keyword">if</span>((<span class="string">"set"</span> + name).equalsIgnoreCase(method.getName()))&#123;</span><br><span class="line">// bean之间的依赖关系（注⼊bean）</span><br><span class="line">Object propertyObject = map.get(ref);</span><br><span class="line">method.invoke(parentObject,propertyObject);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">// 维护依赖关系后重新将bean放⼊map中</span><br><span class="line">map.put(parentId,parentObject);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; catch (DocumentException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (InstantiationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static Object getBean(String id) &#123;</span><br><span class="line"><span class="built_in">return</span> map.get(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改 TransferServlet</li></ul><p><img src="/images/spring/s18.png" srcset="/img/loading.gif" alt="spring"></p><ul><li>修改 TransferServiceImpl</li></ul><p><img src="/images/spring/s19.png" srcset="/img/loading.gif" alt="spring"></p><ol start="2"><li>针对问题⼆的改造</li></ol><ul><li>增加 ConnectionUtils</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.utils;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class ConnectionUtils &#123;</span><br><span class="line">/*private <span class="function"><span class="title">ConnectionUtils</span></span>() &#123;&#125;</span><br><span class="line">  private static ConnectionUtils connectionUtils = new ConnectionUtils();</span><br><span class="line">  public static ConnectionUtils <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> connectionUtils;</span><br><span class="line">  &#125;*/</span><br><span class="line">private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;(); //存储当前线程的连接</span><br><span class="line">/**</span><br><span class="line">* 从当前线程获取连接</span><br><span class="line">*/</span><br><span class="line">public Connection getCurrentThreadConn() throws SQLException &#123;</span><br><span class="line">/**</span><br><span class="line">* 判断当前线程中是否已经绑定连接，如果没有绑定，需要从连接池获取⼀个连接绑定到当前线程</span><br><span class="line">*/</span><br><span class="line">Connection connection = threadLocal.get();</span><br><span class="line"><span class="keyword">if</span>(connection == null) &#123;</span><br><span class="line">// 从连接池拿连接并绑定到线程</span><br><span class="line">connection = DruidUtils.getInstance().getConnection();</span><br><span class="line">// 绑定到当前线程</span><br><span class="line">threadLocal.set(connection);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">return</span> connection;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>增加 TransactionManager 事务管理器类</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.utils;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class TransactionManager &#123;</span><br><span class="line">private ConnectionUtils connectionUtils;</span><br><span class="line">public void setConnectionUtils(ConnectionUtils connectionUtils) &#123;</span><br><span class="line">this.connectionUtils = connectionUtils;</span><br><span class="line">&#125;</span><br><span class="line">// 开启事务</span><br><span class="line">public void beginTransaction() throws SQLException &#123;</span><br><span class="line">connectionUtils.getCurrentThreadConn().setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 提交事务</span><br><span class="line">public void commit() throws SQLException &#123;</span><br><span class="line">connectionUtils.getCurrentThreadConn().commit();</span><br><span class="line">&#125;</span><br><span class="line">// 回滚事务</span><br><span class="line">public void rollback() throws SQLException &#123;</span><br><span class="line">connectionUtils.getCurrentThreadConn().rollback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>增加 ProxyFactory 代理⼯⼚类</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.factory;</span><br><span class="line">import com.loonycoder.utils.TransactionManager;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class ProxyFactory &#123;</span><br><span class="line">private TransactionManager transactionManager;</span><br><span class="line">public void setTransactionManager(TransactionManager transactionManager) &#123;</span><br><span class="line">this.transactionManager = transactionManager;</span><br><span class="line">&#125;</span><br><span class="line">public Object getProxy(Object target) &#123;</span><br><span class="line"><span class="built_in">return</span> Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(), new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">Object result = null;</span><br><span class="line">try&#123;</span><br><span class="line">// 开启事务</span><br><span class="line">transactionManager.beginTransaction();</span><br><span class="line">// 调⽤原有业务逻辑</span><br><span class="line">result = method.invoke(target,args);</span><br><span class="line">// 提交事务</span><br><span class="line">transactionManager.commit();</span><br><span class="line"> &#125;catch(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">// 回滚事务</span><br><span class="line">transactionManager.rollback();</span><br><span class="line">// 异常向上抛出,便于servlet中捕获</span><br><span class="line">throw e.getCause();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改 beans.xml</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!--跟标签beans，⾥⾯配置⼀个⼜⼀个的bean⼦标签，每⼀个bean⼦标签都代表⼀个类的配置--&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">&lt;!--id标识对象，class是类的全限定类名--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"accountDao"</span> class=<span class="string">"com.loonycoder.dao.impl.JdbcAccountDaoImpl"</span>&gt; </span><br><span class="line">&lt;property name=<span class="string">"ConnectionUtils"</span> ref=<span class="string">"connectionUtils"</span>/&gt;</span><br><span class="line">&lt;/bean&gt; </span><br><span class="line">&lt;bean id=<span class="string">"transferService"</span> class=<span class="string">"com.loonycoder.service.impl.TransferServiceImpl"</span>&gt;</span><br><span class="line">&lt;!--<span class="built_in">set</span>+ name 之后锁定到传值的<span class="built_in">set</span>⽅法了，通过反射技术可以调⽤该⽅法传⼊对应的值--&gt;</span><br><span class="line">&lt;property name=<span class="string">"AccountDao"</span> ref=<span class="string">"accountDao"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--配置新增的三个Bean--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"connectionUtils"</span> class=<span class="string">"com.loonycoder.utils.ConnectionUtils"</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--事务管理器--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"transactionManager"</span> class=<span class="string">"com.loonycoder.utils.TransactionManager"</span>&gt; </span><br><span class="line">&lt;property name=<span class="string">"ConnectionUtils"</span> ref=<span class="string">"connectionUtils"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--代理对象⼯⼚--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"proxyFactory"</span> class=<span class="string">"com.loonycoder.factory.ProxyFactory"</span>&gt; </span><br><span class="line">&lt;property name=<span class="string">"TransactionManager"</span> ref=<span class="string">"transactionManager"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ul><li>修改 JdbcAccountDaoImpl</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.dao.impl;</span><br><span class="line">import com.loonycoder.pojo.Account;</span><br><span class="line">import com.loonycoder.dao.AccountDao;</span><br><span class="line">import com.loonycoder.utils.ConnectionUtils;</span><br><span class="line">import com.loonycoder.utils.DruidUtils;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">public class JdbcAccountDaoImpl implements AccountDao &#123;</span><br><span class="line">private ConnectionUtils connectionUtils;</span><br><span class="line">public void setConnectionUtils(ConnectionUtils connectionUtils) &#123;</span><br><span class="line">this.connectionUtils = connectionUtils;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Account queryAccountByCardNo(String cardNo) throws Exception &#123;</span><br><span class="line">//从连接池获取连接</span><br><span class="line">// Connection con = DruidUtils.getInstance().getConnection();</span><br><span class="line">Connection con = connectionUtils.getCurrentThreadConn();</span><br><span class="line">String sql = <span class="string">"select * from account where cardNo=?"</span>;</span><br><span class="line">PreparedStatement preparedStatement = con.prepareStatement(sql);</span><br><span class="line">preparedStatement.setString(1,cardNo);</span><br><span class="line">ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">Account account = new Account();</span><br><span class="line"><span class="keyword">while</span>(resultSet.next()) &#123;</span><br><span class="line">account.setCardNo(resultSet.getString(<span class="string">"cardNo"</span>));</span><br><span class="line">account.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">account.setMoney(resultSet.getInt(<span class="string">"money"</span>));</span><br><span class="line">&#125;</span><br><span class="line">resultSet.close();</span><br><span class="line">preparedStatement.close();</span><br><span class="line">//con.close();</span><br><span class="line"><span class="built_in">return</span> account;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int updateAccountByCardNo(Account account) throws Exception &#123;</span><br><span class="line">// 从连接池获取连接</span><br><span class="line">// 改造为：从当前线程当中获取绑定的connection连接</span><br><span class="line">//Connection con = DruidUtils.getInstance().getConnection();</span><br><span class="line">Connection con = connectionUtils.getCurrentThreadConn();</span><br><span class="line">String sql = <span class="string">"update account set money=? where cardNo=?"</span>;</span><br><span class="line">PreparedStatement preparedStatement = con.prepareStatement(sql);</span><br><span class="line">preparedStatement.setInt(1,account.getMoney());</span><br><span class="line">preparedStatement.setString(2,account.getCardNo());</span><br><span class="line">int i = preparedStatement.executeUpdate();</span><br><span class="line">preparedStatement.close();</span><br><span class="line">//con.close();</span><br><span class="line"><span class="built_in">return</span> i;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改 TransferServlet</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.servlet;</span><br><span class="line">import com.loonycoder.factory.BeanFactory;</span><br><span class="line">import com.loonycoder.factory.ProxyFactory;</span><br><span class="line">import com.loonycoder.service.impl.TransferServiceImpl;</span><br><span class="line">import com.loonycoder.utils.JsonUtils;</span><br><span class="line">import com.loonycoder.pojo.Result;</span><br><span class="line">import com.loonycoder.service.TransferService;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebServlet(name=<span class="string">"transferServlet"</span>,urlPatterns = <span class="string">"/transferServlet"</span>)</span><br><span class="line">public class TransferServlet extends HttpServlet &#123;</span><br><span class="line">// 1. 实例化service层对象</span><br><span class="line">//private TransferService transferService = new TransferServiceImpl();</span><br><span class="line">//private TransferService transferService = (TransferService)</span><br><span class="line">BeanFactory.getBean(<span class="string">"transferService"</span>);</span><br><span class="line">// 从⼯⼚获取委托对象（委托对象是增强了事务控制的功能）</span><br><span class="line">// ⾸先从BeanFactory获取到proxyFactory代理⼯⼚的实例化对象</span><br><span class="line">private ProxyFactory proxyFactory = (ProxyFactory)BeanFactory.getBean(<span class="string">"proxyFactory"</span>);</span><br><span class="line">private TransferService transferService = (TransferService)proxyFactory.getJdkProxy(BeanFactory.getBean(<span class="string">"transferService"</span>)) ;</span><br><span class="line">@Override</span><br><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">doPost(req,resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">// 设置请求体的字符编码</span><br><span class="line">req.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">String fromCardNo = req.getParameter(<span class="string">"fromCardNo"</span>);</span><br><span class="line">String toCardNo = req.getParameter(<span class="string">"toCardNo"</span>);</span><br><span class="line">String moneyStr = req.getParameter(<span class="string">"money"</span>);</span><br><span class="line">int money = Integer.parseInt(moneyStr);</span><br><span class="line">Result result = new Result();</span><br><span class="line">try &#123;</span><br><span class="line">// 2. 调⽤service层⽅法</span><br><span class="line">transferService.transfer(fromCardNo,toCardNo,money);</span><br><span class="line">result.setStatus(<span class="string">"200"</span>);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">result.setStatus(<span class="string">"201"</span>);</span><br><span class="line">result.setMessage(e.toString());</span><br><span class="line">&#125;</span><br><span class="line">// 响应</span><br><span class="line">resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">resp.getWriter().<span class="built_in">print</span>(JsonUtils.object2Json(result));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring全家桶</tag>
      
      <tag>IoC</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轻量级控制反转和面向切面的容器框架——Spring（一）</title>
    <link href="/2019/07/08/spring1/"/>
    <url>/2019/07/08/spring1/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/spring_logo.jpg" srcset="/img/loading.gif" alt="spring"></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前整理过一些关于Spring框架零散的知识点，一直没时间整理，恰好最近又拜读了<strong>应癫</strong>老师的课程，所以赶紧梳理一下关于Spring的相关知识。</p><hr><h3 id="Spring-概述"><a href="#Spring-概述" class="headerlink" title="Spring 概述"></a>Spring 概述</h3><h4 id="Spring-简介"><a href="#Spring-简介" class="headerlink" title="Spring 简介"></a>Spring 简介</h4><p>Spring 是分层的 full-stack（全栈） 轻量级开源框架，以 IoC 和 AOP 为内核，提供了展现层 Spring MVC 和业务层事务管理等众多的企业级应⽤技术，还能整合开源世界众多著名的第三⽅框架和类库，已经成为使⽤最多的 Java EE 企业应⽤开源框架。<br>Spring 官⽅⽹址：<a href="http://spring.io/" target="_blank" rel="noopener">http://spring.io/</a><br>我们经常说的 Spring 其实指的是Spring Framework（spring 框架）。</p><h4 id="Spring-发展历程"><a href="#Spring-发展历程" class="headerlink" title="Spring 发展历程"></a>Spring 发展历程</h4><ul><li>1997年 IBM 提出了EJB的思想； 1998年，SUN 制定开发标准规范EJB1.0； 1999年，EJB 1.1发<br>布； 2001年，EJB 2.0发布； 2003年，EJB 2.1发布； 2006年，EJB 3.0发布；</li><li>Rod Johnson（spring之⽗）<ul><li>Expert One-to-One J2EE Design and Development(2002) 阐述了J2EE使⽤EJB开发设计的优点及解决⽅案</li><li>Expert One-to-One J2EE Development without EJB(2004) 阐述了J2EE开发不使⽤EJB的解决⽅式（Spring雏形）<br>2017 年 9 ⽉份发布了 Spring 的最新版本 Spring 5.0 通⽤版（GA）</li></ul></li></ul><h4 id="Spring-的优势"><a href="#Spring-的优势" class="headerlink" title="Spring 的优势"></a>Spring 的优势</h4><blockquote><p>整个 Spring 优势，传达出⼀个信号，Spring 是⼀个综合性，且有很强的思想性框架，每学习⼀天，就能体会到它的⼀些优势。</p></blockquote><ul><li><strong>⽅便解耦，简化开发</strong></li></ul><p>通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进⾏控制，避免硬编码所造成的过度程序耦合。⽤户也不必再为单例模式类、属性⽂件解析等这些很底层的需求编写代码，可以更专注于上层的应⽤。</p><ul><li><strong>AOP编程的⽀持</strong></li></ul><p>通过Spring的AOP功能，⽅便进⾏⾯向切⾯的编程，许多不容易⽤传统OOP实现的功能可以通过AOP轻松应付。</p><ul><li><p><strong>声明式事务的⽀持</strong><br><code>@Transactional</code>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式⽅式灵活的进⾏事务的管理，提⾼开发效率和质量。</p></li><li><p><strong>⽅便程序的测试</strong></p></li></ul><p>可以⽤⾮容器依赖的编程⽅式进⾏⼏乎所有的测试⼯作，测试不再是昂贵的操作，⽽是随⼿可做的事情。</p><ul><li><strong>⽅便集成各种优秀框架</strong></li></ul><p>Spring可以降低各种框架的使⽤难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接⽀持。</p><ul><li><strong>降低JavaEE API的使⽤难度</strong></li></ul><p>Spring对JavaEE API（如JDBC、JavaMail、远程调⽤等）进⾏了薄薄的封装层，使这些API的使⽤难度⼤为降低。</p><ul><li><strong>源码是经典的 Java 学习范例</strong><br>Spring的源代码设计精妙、结构清晰、匠⼼独⽤，处处体现着⼤师对Java设计模式灵活运⽤以及对Java技术的⾼深造诣。它的源代码⽆意是Java技术的最佳实践的范例。</li></ul><h4 id="Spring-的核心结构"><a href="#Spring-的核心结构" class="headerlink" title="Spring 的核心结构"></a>Spring 的核心结构</h4><p>Spring是⼀个分层⾮常清晰并且依赖关系、职责定位⾮常明确的轻量级框架，主要包括⼏个⼤模块：数<br>据处理模块、Web模块、AOP（Aspect Oriented Programming）、Aspects模块、Core Container模块<br>和 Test 模块，如下图所示，Spring依靠这些基本模块，实现了⼀个令⼈愉悦的融合了现有解决⽅案的零<br>侵⼊的轻量级框架。</p><p><img src="images/spring/s1.png" srcset="/img/loading.gif" alt="spring"></p><ul><li>Spring核⼼容器（Core Container） 容器是Spring框架最核⼼的部分，它管理着Spring应⽤中bean的创建、配置和管理。在该模块中，包括了Spring bean⼯⼚，它为Spring提供了DI的功能。基于bean⼯⼚，我们还会发现有多种Spring应⽤上下⽂的实现。所有的Spring模块都构建于核⼼容器之上。</li><li>⾯向切⾯编程（AOP）/Aspects Spring对⾯向切⾯编程提供了丰富的⽀持。这个模块是Spring应⽤系统中开发切⾯的基础，与DI⼀样，AOP可以帮助应⽤对象解耦。</li><li>数据访问与集成（Data Access/Integration）<br>Spring的JDBC和DAO模块封装了⼤量样板代码，这样可以使得数据库代码变得简洁，也可以更专注于我们的业务，还可以避免数据库资源释放失败⽽引起的问题。 另外，Spring AOP为数据访问提供了事务管理服务，同时Spring还对ORM进⾏了集成，如Hibernate、MyBatis等。该模块由JDBC、Transactions、ORM、OXM 和 JMS 等模块组成。</li><li>Web 该模块提供了SpringMVC框架给Web应⽤，还提供了多种构建和其它应⽤交互的远程调⽤⽅<br>案。SpringMVC框架在Web层提升了应⽤的松耦合⽔平。</li><li>Test 为了使得开发者能够很⽅便的进⾏测试，Spring提供了测试模块以致⼒于Spring应⽤的测<br>试。通过该模块，Spring为使⽤Servlet、JNDI等编写单元测试提供了⼀系列的mock对象实现。</li></ul><h4 id="Spring-框架版本"><a href="#Spring-框架版本" class="headerlink" title="Spring 框架版本"></a>Spring 框架版本</h4><p><img src="images/spring/s2.png" srcset="/img/loading.gif" alt="spring"></p><p>Spring Framework不同版本对 Jdk 的要求</p><p><img src="images/spring/s3.png" srcset="/img/loading.gif" alt="spring"></p><hr><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>注意：IoC和AOP不是spring提出的，在Spring之前就已经存在，只不过更偏向于理论化，Spring在技<br>术层次把这两个思想做了⾮常好的实现（Java）</p><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><h5 id="什么是IoC"><a href="#什么是IoC" class="headerlink" title="什么是IoC"></a>什么是IoC</h5><p>IoC Inversion of Control (控制反转/反转控制)，注意它是⼀个技术思想，不是⼀个技术实现。<br>描述的事情：Java开发领域对象的创建，管理的问题<br>传统开发⽅式：⽐如类A依赖于类B，往往会在类A中new⼀个B的对象<br>IoC思想下开发⽅式：我们不⽤⾃⼰去new对象了，⽽是由IoC容器（Spring框架）去帮助我们实例化对<br>象并且管理它，我们需要使⽤哪个对象，去问IoC容器要即可<br>我们丧失了⼀个权利（创建、管理对象的权利）,得到了⼀个福利（不⽤考虑对象的创建、管理等⼀系列<br>事情）<br>为什么叫做控制反转？<br>控制：指的是对象创建（实例化、管理）的权利<br>反转：控制权交给外部环境了（spring框架、IoC容器）</p><p><img src="images/spring/s4.png" srcset="/img/loading.gif" alt="spring"></p><h5 id="IoC解决了什么问题"><a href="#IoC解决了什么问题" class="headerlink" title="IoC解决了什么问题"></a>IoC解决了什么问题</h5><p><strong>IoC解决对象之间的耦合问题</strong></p><p><img src="images/spring/s5.png" srcset="/img/loading.gif" alt="spring"></p><h5 id="IoC和DI的区别"><a href="#IoC和DI的区别" class="headerlink" title="IoC和DI的区别"></a>IoC和DI的区别</h5><p>DI：Dependancy Injection（依赖注⼊）<br>怎么理解：<br>IOC和DI描述的是同⼀件事情，只不过⻆度不⼀样罢了</p><p><img src="images/spring/s6.png" srcset="/img/loading.gif" alt="spring"></p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><h5 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h5><p>AOP: Aspect oriented Programming ⾯向切⾯编程/⾯向⽅⾯编程<br>AOP是OOP的延续，从OOP说起<br>OOP三⼤特征：封装、继承和多态<br>OOP是⼀种垂直继承体系</p><p><img src="images/spring/s7.png" srcset="/img/loading.gif" alt="spring"></p><p>OOP编程思想可以解决⼤多数的代码重复问题，但是有⼀些情况是处理不了的，⽐如下⾯的在顶级⽗类<br>Animal中的多个⽅法中相同位置出现了重复代码，OOP就解决不了</p><p><img src="images/spring/s8.png" srcset="/img/loading.gif" alt="spring"></p><p>横切逻辑代码</p><p><img src="images/spring/s9.png" srcset="/img/loading.gif" alt="spring"></p><p>横切逻辑代码存在什么问题：</p><ul><li>横切代码重复问题</li><li>横切逻辑代码和业务代码混杂在⼀起，代码臃肿，维护不⽅便<br>AOP出场，AOP独辟蹊径提出横向抽取机制，将横切逻辑代码和业务逻辑代码分析</li></ul><p><img src="images/spring/s10.png" srcset="/img/loading.gif" alt="spring"></p><p>代码拆分容易，那么如何在不改变原有业务逻辑的情况下，悄⽆声息的把横切逻辑代码应⽤到原有的业<br>务逻辑中，达到和原来⼀样的效果，这个是⽐较难的。</p><h5 id="AOP解决了什么问题"><a href="#AOP解决了什么问题" class="headerlink" title="AOP解决了什么问题"></a>AOP解决了什么问题</h5><p>在不改变原有业务逻辑情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复</p><h5 id="为什么叫做面向切面编程"><a href="#为什么叫做面向切面编程" class="headerlink" title="为什么叫做面向切面编程"></a>为什么叫做面向切面编程</h5><p>「切」：指的是横切逻辑，原有业务逻辑代码我们不能动，只能操作横切逻辑代码，所以⾯向横切逻辑<br>「⾯」：横切逻辑代码往往要影响的是很多个⽅法，每⼀个⽅法都如同⼀个点，多个点构成⾯，有⼀个⾯的概念在⾥⾯</p>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring全家桶</tag>
      
      <tag>IoC</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优秀而又强大的表现层框架——SpringMVC（五）</title>
    <link href="/2019/06/30/springmvc5/"/>
    <url>/2019/06/30/springmvc5/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近系统的学习了下这个优秀而又强大的表现层框架——SpringMVC，拜读了<strong>应癫</strong>老师的《SpringMVC源码剖析》，深表感谢！</p><p><strong>源码地址：</strong><a href="https://github.com/LoonyCoder/lagou-learn/tree/master/Model%203" target="_blank" rel="noopener">手写SpringMVC框架</a><br><strong>欢迎star/fork，给作者一些鼓励！</strong></p><h3 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h3><h4 id="整合策略"><a href="#整合策略" class="headerlink" title="整合策略"></a>整合策略</h4><p>SSM = Spring + SpringMVC + Mybatis = （Spring + Mybatis）+ SpringMVC</p><p>先整合 Spring + Mybatis 然后再整合 SpringMVC</p><p>基于的需求：查询 Account 表的全部数据显示到⻚⾯。</p><h4 id="Mybatis整合Spring"><a href="#Mybatis整合Spring" class="headerlink" title="Mybatis整合Spring"></a>Mybatis整合Spring</h4><ul><li><p>整合⽬标</p><ul><li>数据库连接池以及事务管理都交给Spring容器来完成</li><li>SqlSessionFactory对象应该放到Spring容器中作为单例对象管理</li><li>Mapper动态代理对象交给Spring管理，我们从Spring容器中直接获得Mapper的代理对象</li></ul></li><li><p>整合所需 Jar 分析</p><ul><li>Junit测试jar（4.12版本）</li><li>Mybatis的jar（3.4.5）</li><li>Spring相关jar（spring-context、spring-test、spring-jdbc、spring-tx、spring-aop、aspectjweaver）</li><li>Mybatis/Spring整合包jar（mybatis-spring-xx.jar）</li><li>Mysql数据库驱动jar</li><li>Druid数据库连接池的jar</li></ul></li><li><p>整合后的 Pom 坐标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;4.12&lt;/version&gt; </span><br><span class="line">&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mybatis--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;mybatis&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;3.4.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--spring相关--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-context&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;5.1.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.springframework&lt;/groupId&gt; </span><br><span class="line"> &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; </span><br><span class="line"> &lt;version&gt;5.1.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-tx&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;5.1.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-aop&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;5.1.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.aspectj&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.8.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mybatis与spring的整合包--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;2.0.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--数据库驱动jar--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--druid连接池--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;druid&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.1.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>jdbc.properties</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/bank</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure></li><li><p>Spring 配置⽂件</p><ul><li>applicationContext-dao.xml</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="line"><span class="string">"</span>&gt;</span><br><span class="line">&lt;!--包扫描--&gt;</span><br><span class="line">&lt;context:component-scan base-package=<span class="string">"com.loonycoder.mapper"</span>/&gt;</span><br><span class="line">&lt;!--数据库连接池以及事务管理都交给Spring容器来完成--&gt;</span><br><span class="line">&lt;!--引⼊外部资源⽂件--&gt;</span><br><span class="line">&lt;context:property-placeholder</span><br><span class="line">location=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span><br><span class="line">&lt;!--第三⽅jar中的bean定义在xml中--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"dataSource"</span> class=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt; &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.driver&#125;</span>"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"url"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.url&#125;</span>"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"username"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.username&#125;</span>"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"password"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.password&#125;</span>"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--SqlSessionFactory对象应该放到Spring容器中作为单例对象管理原来mybaits中sqlSessionFactory的构建是需要素材的：SqlMapConfig.xml中的内容--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"sqlSessionFactory"</span> class=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span><br><span class="line">&lt;!--别名映射扫描--&gt;</span><br><span class="line">&lt;property name=<span class="string">"typeAliasesPackage"</span> value=<span class="string">"com.loonycoder.pojo"</span>/&gt;</span><br><span class="line">&lt;!--数据源dataSource--&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--Mapper动态代理对象交给Spring管理，我们从Spring容器中直接获得Mapper的代理对</span><br><span class="line">象--&gt;</span><br><span class="line">&lt;!--扫描mapper接⼝，⽣成代理对象，⽣成的代理对象会存储在ioc容器中--&gt;</span><br><span class="line">&lt;bean class=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span><br><span class="line">&lt;!--mapper接⼝包路径配置--&gt;</span><br><span class="line">&lt;property name=<span class="string">"basePackage"</span> value=<span class="string">"com.loonycoder.mapper"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"sqlSessionFactoryBeanName"</span> value=<span class="string">"sqlSessionFactory"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><pre><code>- applicationContext-service.xml</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:lcContext=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="line"><span class="string">"</span>&gt;</span><br><span class="line">&lt;!--包扫描--&gt;</span><br><span class="line">&lt;lcContext:component-scan base-package=<span class="string">"com.loonycoder.service"</span>/&gt;</span><br><span class="line">&lt;!--事务管理--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"transactionManager"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt; &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--事务管理注解驱动--&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">"transactionManager"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ul><li>AccountMapper接⼝</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import com.loonycoder.pojo.Account;</span><br><span class="line">import java.util.List;</span><br><span class="line">public interface AccountMapper &#123;</span><br><span class="line">// 定义dao层接⼝⽅法--&gt; 查询account表所有数据</span><br><span class="line">List&lt;Account&gt; queryAccountList() throws Exception; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AccountMapper.xml</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.mapper.AccountMapper"</span>&gt; </span><br><span class="line">&lt;select id=<span class="string">"queryAccountList"</span> resultType=<span class="string">"com.loonycoder.pojo.Account"</span>&gt;</span><br><span class="line"> select * from account</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ul><li>测试程序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import com.loonycoder.pojo.Account;</span><br><span class="line">import com.loonycoder.service.AccountService;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line">import java.util.List;</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &#123;<span class="string">"classpath*:application*.xml"</span>&#125;)</span><br><span class="line">public class MybatisSpringTest &#123;</span><br><span class="line">// 希望测试ioc容器中的哪个对象你注⼊即可。</span><br><span class="line">@Autowired</span><br><span class="line">private AccountService accountService;</span><br><span class="line">@Test</span><br><span class="line">public void testMybatisSpring() throws Exception &#123;</span><br><span class="line">List&lt;Account&gt; accounts = accountService.queryAccountList();</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; accounts.size(); i++) &#123;</span><br><span class="line">Account account = accounts.get(i);</span><br><span class="line">System.out.println(account);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整合SpringMVC"><a href="#整合SpringMVC" class="headerlink" title="整合SpringMVC"></a>整合SpringMVC</h4><ul><li>整合思路</li></ul><p>把SpringMVC的⼊⻔案例整合进来即可（在已有⼯程基础之上开发⼀个SpringMVC⼊⻔案例）</p><ul><li>引⼊pom坐标</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringMVC--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;5.1.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--jsp-api&amp;servlet-api--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;jsp-api&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.1.0&lt;/version&gt; </span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--⻚⾯使⽤jstl表达式--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;jstl&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;jstl&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;taglibs&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;standard&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--json数据交互所需jar，start--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;jackson-core&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; </span><br><span class="line"> &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--json数据交互所需jar，end--&gt;</span><br></pre></td></tr></table></figure><ul><li><p>添加SpringMVC ⼊⻔案例</p><ul><li>springmvc.xml</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/springcontext.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="line"><span class="string">"</span>&gt;</span><br><span class="line">&lt;!--扫描controller--&gt;</span><br><span class="line">&lt;context:component-scan base-package=<span class="string">"com.loonycoder.controller"</span>/&gt;</span><br><span class="line">&lt;mvc:annotation-driven/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><pre><code>- Controller类</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import com.loonycoder.pojo.Account;</span><br><span class="line">import com.loonycoder.service.AccountService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import java.util.List;</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(<span class="string">"/account"</span>)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line">/**</span><br><span class="line">* Spring容器和SpringMVC容器是有层次的（⽗⼦容器）</span><br><span class="line">* Spring容器：service对象+dao对象</span><br><span class="line">* SpringMVC容器：controller对象————可以引⽤到Spring容器中的对象</span><br><span class="line">*/</span><br><span class="line">@Autowired</span><br><span class="line">private AccountService accountService;</span><br><span class="line">@RequestMapping(<span class="string">"/queryAll"</span>)</span><br><span class="line">@ResponseBody</span><br><span class="line">public List&lt;Account&gt; queryAll() throws Exception &#123;</span><br><span class="line"><span class="built_in">return</span> accountService.queryAccountList();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>- web.xml</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line"><span class="string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"><span class="string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span><br><span class="line">&lt;web-app&gt; </span><br><span class="line">&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; </span><br><span class="line">&lt;context-param&gt; </span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; </span><br><span class="line">&lt;param-value&gt;classpath*:applicationContext*.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;!--spring框架启动--&gt;</span><br><span class="line">&lt;listener&gt; </span><br><span class="line">&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line">&lt;!--springmvc启动--&gt;</span><br><span class="line">&lt;servlet&gt; </span><br><span class="line">&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; </span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;init-param&gt; </span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; </span><br><span class="line">&lt;param-value&gt;classpath*:springmvc.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt; </span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt; </span><br><span class="line">&lt;servlet-mapping&gt; </span><br><span class="line">&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; </span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>表现层框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优秀而又强大的表现层框架——SpringMVC（四）</title>
    <link href="/2019/06/19/springmvc4/"/>
    <url>/2019/06/19/springmvc4/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近系统的学习了下这个优秀而又强大的表现层框架——SpringMVC，拜读了<strong>应癫</strong>老师的《SpringMVC源码剖析》，深表感谢！</p><p><strong>源码地址：</strong><a href="https://github.com/LoonyCoder/lagou-learn/tree/master/Model%203" target="_blank" rel="noopener">手写SpringMVC框架</a><br><strong>欢迎star/fork，给作者一些鼓励！</strong></p><h3 id="SpringMVC源码深度剖析"><a href="#SpringMVC源码深度剖析" class="headerlink" title="SpringMVC源码深度剖析"></a>SpringMVC源码深度剖析</h3><h4 id="前端控制器DispatcherServlet继承结构"><a href="#前端控制器DispatcherServlet继承结构" class="headerlink" title="前端控制器DispatcherServlet继承结构"></a>前端控制器DispatcherServlet继承结构</h4><p><img src="/images/springmvc/springmvc8.png" srcset="/img/loading.gif" alt="springmvc"></p><h4 id="重要时机点剖析"><a href="#重要时机点剖析" class="headerlink" title="重要时机点剖析"></a>重要时机点剖析</h4><ol><li>Handler⽅法的执⾏时机</li></ol><p><strong>打断点</strong></p><p><img src="/images/springmvc/springmvc9.png" srcset="/img/loading.gif" alt="springmvc"></p><p><strong>观察调用栈</strong></p><p><img src="/images/springmvc/springmvc10.png" srcset="/img/loading.gif" alt="springmvc"></p><p>doDispathch⽅法中的1064⾏代码完成handler⽅法的调⽤</p><ol start="2"><li>⻚⾯渲染时机（打断点并观察调⽤栈）</li></ol><p><img src="/images/springmvc/springmvc11.png" srcset="/img/loading.gif" alt="springmvc"></p><ul><li>SpringMVC处理请求的流程即为<br><code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code>⽅法的执⾏过程，其中步骤2、3、4、5是核⼼步骤</li></ul><ol><li>调⽤<code>getHandler()</code>获取到能够处理当前请求的执⾏链 HandlerExecutionChain（Handler+拦截<br>器）<strong>但是如何去getHandler的？后⾯进⾏分析</strong></li><li>调⽤<code>getHandlerAdapter()</code>；获取能够执⾏1中Handler的适配器<br>但是如何去getHandlerAdapter的？后⾯进⾏分析</li><li>适配器调⽤Handler执⾏ha.handle（总会返回⼀个ModelAndView对象）</li><li>调⽤<code>processDispatchResult()</code>⽅法完成视图渲染跳转</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse</span><br><span class="line">response) throws Exception &#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = null;</span><br><span class="line">boolean multipartRequestParsed = <span class="literal">false</span>;</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">try &#123;</span><br><span class="line">ModelAndView mv = null;</span><br><span class="line">Exception dispatchException = null;</span><br><span class="line">try &#123;</span><br><span class="line">// 1 检查是否是⽂件上传的请求</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line">// Determine handler <span class="keyword">for</span> the current request.</span><br><span class="line">/*</span><br><span class="line">   2 取得处理当前请求的Controller，这⾥也称为Handler，即处理器</span><br><span class="line"> 这⾥并不是直接返回 Controller，⽽是返回 HandlerExecutionChain 请求处理链对象,该对象封装了Handler和Inteceptor</span><br><span class="line">*/</span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == null) &#123;</span><br><span class="line">// 如果 handler 为空，则返回404</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="built_in">return</span>; </span><br><span class="line">&#125;</span><br><span class="line">// Determine handler adapter <span class="keyword">for</span> the current request.</span><br><span class="line">// 3 获取处理请求的处理器适配器 HandlerAdapter</span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">// Process last-modified header, <span class="keyword">if</span> supported by the handler.</span><br><span class="line">// 处理 last-modified 请求头</span><br><span class="line">String method = request.getMethod();</span><br><span class="line">boolean isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">long lastModified = ha.getLastModified(request,mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (new ServletWebRequest(request,response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="built_in">return</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="built_in">return</span>; </span><br><span class="line">&#125;</span><br><span class="line">// Actually invoke the handler.</span><br><span class="line">// 4 实际处理器处理请求，返回结果视图对象</span><br><span class="line">mv = ha.handle(processedRequest, response,mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="built_in">return</span>; </span><br><span class="line">&#125;</span><br><span class="line">// 结果视图对象的处理</span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;catch (Exception ex) &#123;</span><br><span class="line">dispatchException = ex; </span><br><span class="line">&#125;catch (Throwable err) &#123;</span><br><span class="line">// As of 4.3, we’re processing Errors thrown from handler methods as well,</span><br><span class="line">// making them available <span class="keyword">for</span> @ExceptionHandler methods and other scenarios.</span><br><span class="line">dispatchException = new NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">// 5 跳转⻚⾯，渲染视图</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv,dispatchException);</span><br><span class="line">&#125;catch (Exception ex) &#123;</span><br><span class="line">//最终会调⽤HandlerInterceptor的afterCompletion ⽅法</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,ex);</span><br><span class="line">&#125;catch (Throwable err) &#123;</span><br><span class="line">//最终会调⽤HandlerInterceptor的afterCompletion ⽅法</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">new NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">// Instead of postHandle and afterCompletion</span><br><span class="line"><span class="keyword">if</span> (mappedHandler != null) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest,response);</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">// Clean up any resources used by a multipart request.</span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心步骤getHandler方法剖析"><a href="#核心步骤getHandler方法剖析" class="headerlink" title="核心步骤getHandler方法剖析"></a>核心步骤getHandler方法剖析</h4><p>遍历两个HandlerMapping，试图获取能够处理当前请求的执⾏链</p><p><img src="images/springmvc/springmvc12.png" srcset="/img/loading.gif" alt="springmvc"></p><h4 id="核心步骤getHandlerAdapter方法剖析"><a href="#核心步骤getHandlerAdapter方法剖析" class="headerlink" title="核心步骤getHandlerAdapter方法剖析"></a>核心步骤getHandlerAdapter方法剖析</h4><p>遍历各个HandlerAdapter，看哪个Adapter⽀持处理当前Handler</p><p><img src="images/springmvc/springmvc13.png" srcset="/img/loading.gif" alt="springmvc"></p><h4 id="核心步骤ha-handler方法剖析"><a href="#核心步骤ha-handler方法剖析" class="headerlink" title="核心步骤ha.handler方法剖析"></a>核心步骤ha.handler方法剖析</h4><ul><li>入口</li></ul><p><img src="images/springmvc/springmvc14.png" srcset="/img/loading.gif" alt="springmvc"></p><ul><li>断点从⼊⼝进⼊</li></ul><p><img src="images/springmvc/springmvc15.png" srcset="/img/loading.gif" alt="springmvc"><br><img src="images/springmvc/springmvc16.png" srcset="/img/loading.gif" alt="springmvc"><br><img src="images/springmvc/springmvc17.png" srcset="/img/loading.gif" alt="springmvc"><br><img src="images/springmvc/springmvc18.png" srcset="/img/loading.gif" alt="springmvc"></p><h4 id="核心步骤processDispatcherResult方法剖析"><a href="#核心步骤processDispatcherResult方法剖析" class="headerlink" title="核心步骤processDispatcherResult方法剖析"></a>核心步骤processDispatcherResult方法剖析</h4><ul><li>render⽅法完成渲染</li></ul><p><img src="images/springmvc/springmvc19.png" srcset="/img/loading.gif" alt="springmvc"></p><ul><li>视图解析器解析出View视图对象</li></ul><p><img src="images/springmvc/springmvc20.png" srcset="/img/loading.gif" alt="springmvc"></p><ul><li>在解析出View视图对象的过程中会判断是否重定向、是否转发等，不同的情况封装的是不同的View实现</li></ul><p><img src="images/springmvc/springmvc21.png" srcset="/img/loading.gif" alt="springmvc"></p><ul><li>解析出View视图对象的过程中，要将逻辑视图名解析为物理视图名</li></ul><p><img src="images/springmvc/springmvc22.png" srcset="/img/loading.gif" alt="springmvc"></p><ul><li>封装View视图对象之后，调⽤了view对象的render⽅法</li></ul><p><img src="images/springmvc/springmvc23.png" srcset="/img/loading.gif" alt="springmvc"></p><ul><li>渲染数据</li></ul><p><img src="images/springmvc/springmvc24.png" srcset="/img/loading.gif" alt="springmvc"></p><ul><li>把modelMap中的数据暴露到request域中，这也是为什么后台model.add之后在jsp中可以从请求域取出来的根本原因</li></ul><p><img src="images/springmvc/springmvc25.png" srcset="/img/loading.gif" alt="springmvc"></p><ul><li>将数据设置到请求域中</li></ul><p><img src="images/springmvc/springmvc26.png" srcset="/img/loading.gif" alt="springmvc"></p><h4 id="SpringMVC九大组件初始化"><a href="#SpringMVC九大组件初始化" class="headerlink" title="SpringMVC九大组件初始化"></a>SpringMVC九大组件初始化</h4><ol><li>在DispatcherServlet中定义了九个属性，每⼀个属性都对应⼀种组件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/** MultipartResolver used by this servlet. */</span><br><span class="line">// 多部件解析器</span><br><span class="line">@Nullable</span><br><span class="line">private MultipartResolver multipartResolver;</span><br><span class="line">/** LocaleResolver used by this servlet. */</span><br><span class="line">// 区域化 国际化解析器</span><br><span class="line">@Nullable</span><br><span class="line">private LocaleResolver localeResolver;</span><br><span class="line">/** ThemeResolver used by this servlet. */</span><br><span class="line">// 主题解析器</span><br><span class="line">@Nullable</span><br><span class="line">private ThemeResolver themeResolver;</span><br><span class="line">/** List of HandlerMappings used by this servlet. */</span><br><span class="line">// 处理器映射器组件</span><br><span class="line">@Nullable</span><br><span class="line">private List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">/** List of HandlerAdapters used by this servlet. */</span><br><span class="line">// 处理器适配器组件</span><br><span class="line">@Nullable</span><br><span class="line">private List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line">/** List of HandlerExceptionResolvers used by this servlet. */</span><br><span class="line">// 异常解析器组件</span><br><span class="line">@Nullable</span><br><span class="line">private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;</span><br><span class="line">/** RequestToViewNameTranslator used by this servlet. */</span><br><span class="line">// 默认视图名转换器组件</span><br><span class="line">@Nullable</span><br><span class="line">private RequestToViewNameTranslator viewNameTranslator;</span><br><span class="line">/** FlashMapManager used by this servlet. */</span><br><span class="line">// flash属性管理组件</span><br><span class="line">@Nullable</span><br><span class="line">private FlashMapManager flashMapManager;</span><br><span class="line">/** List of ViewResolvers used by this servlet. */</span><br><span class="line">// 视图解析器</span><br><span class="line">@Nullable</span><br><span class="line">private List&lt;ViewResolver&gt; viewResolvers;</span><br></pre></td></tr></table></figure><p>九⼤组件都是定义了接⼝，接⼝其实就是定义了该组件的规范，⽐如ViewResolver、HandlerAdapter等都是接⼝。</p><ol start="2"><li>九⼤组件的初始化时机</li></ol><ul><li><p>DispatcherServlet中的<code>onRefresh()</code>，该⽅法中初始化了九⼤组件<br><img src="/images/springmvc/springmvc27.png" srcset="/img/loading.gif" alt="springmvc"></p></li><li><p>initStrategies⽅法<br><img src="/images/springmvc/springmvc28.png" srcset="/img/loading.gif" alt="springmvc"></p></li><li><p>观察其中的⼀个组件initHandlerMappings(context)<br><img src="/images/springmvc/springmvc29.png" srcset="/img/loading.gif" alt="springmvc"></p></li><li><p>如果按照类型和按照固定id从ioc容器中找不到对应组件，则会按照默认策略进⾏注册初始化，默认策略在DispatcherServlet.properties⽂件中配置<br><img src="/images/springmvc/springmvc30.png" srcset="/img/loading.gif" alt="springmvc"></p></li><li><p>DispatcherServlet.properties<br><img src="/images/springmvc/springmvc31.png" srcset="/img/loading.gif" alt="springmvc"></p></li><li><p>注意：多部件解析器的初始化必须按照id注册对象（multipartResolver）<br><img src="/images/springmvc/springmvc32.png" srcset="/img/loading.gif" alt="springmvc"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>表现层框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优秀而又强大的表现层框架——SpringMVC（三）</title>
    <link href="/2019/06/10/springmvc3/"/>
    <url>/2019/06/10/springmvc3/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近系统的学习了下这个优秀而又强大的表现层框架——SpringMVC，拜读了<strong>应癫</strong>老师的《SpringMVC源码剖析》，深表感谢！</p><p><strong>源码地址：</strong><a href="https://github.com/LoonyCoder/lagou-learn/tree/master/Model%203" target="_blank" rel="noopener">手写SpringMVC框架</a><br><strong>欢迎star/fork，给作者一些鼓励！</strong></p><h3 id="手写SpringMVC框架"><a href="#手写SpringMVC框架" class="headerlink" title="手写SpringMVC框架"></a>手写SpringMVC框架</h3><ul><li>回顾SpringMVC执⾏的⼤致原理，后续根据这个模仿⼿写⾃⼰的mvc框架</li></ul><p><img src="/images/springmvc/springmvc7.png" srcset="/img/loading.gif" alt="springmvc"></p><ul><li>⼿写MVC框架之注解开发<ul><li>loonycoderController<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line">@Documented</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface loonycoderController &#123;</span><br><span class="line">String value() default <span class="string">""</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>loonycoderService<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line">@Documented</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface loonycoderService &#123;</span><br><span class="line">String value() default <span class="string">""</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>loonycoderAutowired<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line">@Documented</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface loonycoderAutowired &#123;</span><br><span class="line">String value() default <span class="string">""</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>loonycoderRequestMapping<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface loonycoderRequestMapping &#123;</span><br><span class="line">String value() default <span class="string">""</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>lcDispatcherServlet<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">import com.loonycoder.demo.service.IDemoService;</span><br><span class="line">import com.loonycoder.mvcframework.annotations.loonycoderAutowired;</span><br><span class="line">import com.loonycoder.mvcframework.annotations.loonycoderController;</span><br><span class="line">import com.loonycoder.mvcframework.annotations.loonycoderRequestMapping;</span><br><span class="line">import com.loonycoder.mvcframework.annotations.loonycoderService;</span><br><span class="line">import com.loonycoder.mvcframework.pojo.Handler;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import javax.servlet.ServletConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Parameter;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class lcDispatcherServlet extends HttpServlet &#123;</span><br><span class="line">private Properties properties = new Properties();</span><br><span class="line">private List&lt;String&gt; classNames = new ArrayList&lt;&gt;(); // 缓存扫描到的类的</span><br><span class="line">全限定类名</span><br><span class="line">// ioc容器</span><br><span class="line">private Map&lt;String,Object&gt; ioc = new HashMap&lt;String,Object&gt;();</span><br><span class="line">// handlerMapping</span><br><span class="line">//private Map&lt;String,Method&gt; handlerMapping = now HashMap&lt;&gt;(); // 存储</span><br><span class="line">url和Method之间的映射关系</span><br><span class="line">private List&lt;Handler&gt; handlerMapping = new ArrayList&lt;&gt;();</span><br><span class="line">@Override</span><br><span class="line">public void init(ServletConfig config) throws ServletException &#123;</span><br><span class="line">// 1 加载配置⽂件 springmvc.properties</span><br><span class="line">String contextConfigLocation =</span><br><span class="line">config.getInitParameter(<span class="string">"contextConfigLocation"</span>);</span><br><span class="line">doLoadConfig(contextConfigLocation);</span><br><span class="line">// 2 扫描相关的类，扫描注解</span><br><span class="line">doScan(properties.getProperty(<span class="string">"scanPackage"</span>));</span><br><span class="line">// 3 初始化bean对象（实现ioc容器，基于注解）</span><br><span class="line">doInstance();</span><br><span class="line">// 4 实现依赖注⼊</span><br><span class="line">doAutoWired();</span><br><span class="line">// 5 构造⼀个HandlerMapping处理器映射器，将配置好的url和Method建⽴映射关系</span><br><span class="line">initHandlerMapping();</span><br><span class="line">System.out.println(<span class="string">"loonycoder mvc 初始化完成...."</span>);</span><br><span class="line">// 等待请求进⼊，处理请求</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">构造⼀个HandlerMapping处理器映射器</span><br><span class="line">最关键的环节</span><br><span class="line">⽬的：将url和method建⽴关联</span><br><span class="line">*/</span><br><span class="line">private void <span class="function"><span class="title">initHandlerMapping</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span>(ioc.isEmpty()) &#123;</span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Object&gt; entry: ioc.entrySet()) &#123;</span><br><span class="line">// 获取ioc中当前遍历的对象的class类型</span><br><span class="line">Class&lt;?&gt; aClass = entry.getValue().getClass();</span><br><span class="line"><span class="keyword">if</span>(!aClass.isAnnotationPresent(loonycoderController.class))&#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">String baseUrl = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span>(aClass.isAnnotationPresent(loonycoderRequestMapping.class)) &#123;</span><br><span class="line">loonycoderRequestMapping annotation =</span><br><span class="line">aClass.getAnnotation(loonycoderRequestMapping.class);</span><br><span class="line">baseUrl = annotation.value(); // 等同于/demo</span><br><span class="line"> &#125;</span><br><span class="line">// 获取⽅法</span><br><span class="line">Method[] methods = aClass.getMethods();</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; methods.length; i++) &#123;</span><br><span class="line">Method method = methods[i];</span><br><span class="line">// ⽅法没有标识loonycoderRequestMapping，就不处理</span><br><span class="line"><span class="keyword">if</span>(!method.isAnnotationPresent(loonycoderRequestMapping.class))&#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 如果标识，就处理</span><br><span class="line">loonycoderRequestMapping annotation = method.getAnnotation(loonycoderRequestMapping.class);</span><br><span class="line">String methodUrl = annotation.value(); // /query</span><br><span class="line">String url = baseUrl + methodUrl; // 计算出来的url</span><br><span class="line">/demo/query</span><br><span class="line">// 把method所有信息及url封装为⼀个Handler</span><br><span class="line">Handler handler = new Handler(entry.getValue(),method,</span><br><span class="line">Pattern.compile(url));</span><br><span class="line">// 计算⽅法的参数位置信息 // query(HttpServletRequest request, HttpServletResponse response,String name)</span><br><span class="line">Parameter[] parameters = method.getParameters();</span><br><span class="line"><span class="keyword">for</span> (int j = 0; j &lt; parameters.length; j++) &#123;</span><br><span class="line">Parameter parameter = parameters[j];</span><br><span class="line"><span class="keyword">if</span>(parameter.getType() == HttpServletRequest.class || parameter.getType() == HttpServletResponse.class) &#123;</span><br><span class="line">// 如果是request和response对象，那么参数名称写</span><br><span class="line">HttpServletRequest和HttpServletResponse</span><br><span class="line">handler.getParamIndexMapping().put(parameter.getType().getSimpleName(),j) ;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">handler.getParamIndexMapping().put(parameter.getName(),j); // &lt;name,2&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">// 建⽴url和method之间的映射关系（map缓存起来）</span><br><span class="line">handlerMapping.add(handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实现依赖注⼊</span><br><span class="line">private void <span class="function"><span class="title">doAutoWired</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span>(ioc.isEmpty()) &#123;</span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 有对象，再进⾏依赖注⼊处理</span><br><span class="line">// 遍历ioc中所有对象，查看对象中的字段，是否有@loonycoderAutowired注解，如果有需要维护依赖注⼊关系</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Object&gt; entry: ioc.entrySet()) &#123;</span><br><span class="line">// 获取bean对象中的字段信息</span><br><span class="line">Field[] declaredFields =</span><br><span class="line">entry.getValue().getClass().getDeclaredFields();</span><br><span class="line">// 遍历判断处理</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; declaredFields.length; i++) &#123;</span><br><span class="line">Field declaredField = declaredFields[i]; //</span><br><span class="line">@loonycoderAutowired private IDemoService demoService;</span><br><span class="line"><span class="keyword">if</span>(!declaredField.isAnnotationPresent(loonycoderAutowired.class)) &#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 有该注解</span><br><span class="line">loonycoderAutowired annotation = declaredField.getAnnotation(loonycoderAutowired.class);</span><br><span class="line">String beanName = annotation.value(); // 需要注⼊的bean的id</span><br><span class="line"><span class="keyword">if</span>(<span class="string">""</span>.equals(beanName.trim())) &#123;</span><br><span class="line">// 没有配置具体的bean id，那就需要根据当前字段类型注⼊（接⼝注⼊） </span><br><span class="line">IDemoService beanName = declaredField.getType().getName();</span><br><span class="line">&#125;</span><br><span class="line">// 开启赋值</span><br><span class="line">declaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">try &#123;</span><br><span class="line">declaredField.set(entry.getValue(),ioc.get(beanName));</span><br><span class="line">&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// ioc容器</span><br><span class="line">// 基于classNames缓存的类的全限定类名，以及反射技术，完成对象创建和管理</span><br><span class="line">private void <span class="function"><span class="title">doInstance</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span>(classNames.size() == 0) </span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line">try&#123;</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; classNames.size(); i++) &#123;</span><br><span class="line">String className = classNames.get(i); //com.loonycoder.demo.controller.DemoController</span><br><span class="line">// 反射</span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(className);</span><br><span class="line">// 区分controller，区分service</span><br><span class="line"><span class="keyword">if</span>(aClass.isAnnotationPresent(loonycoderController.class)) &#123;</span><br><span class="line">// controller的id此处不做过多处理，不取value了，就拿类的⾸字</span><br><span class="line">⺟⼩写作为id，保存到ioc中</span><br><span class="line">String simpleName = aClass.getSimpleName();//</span><br><span class="line">DemoController</span><br><span class="line">String lowerFirstSimpleName = lowerFirst(simpleName);</span><br><span class="line">// demoController</span><br><span class="line">Object o = aClass.newInstance();</span><br><span class="line">ioc.put(lowerFirstSimpleName,o);</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aClass.isAnnotationPresent(loonycoderService.class)) &#123;</span><br><span class="line">loonycoderService annotation =</span><br><span class="line">aClass.getAnnotation(loonycoderService.class);</span><br><span class="line">//获取注解value值</span><br><span class="line">String beanName = annotation.value();</span><br><span class="line">// 如果指定了id，就以指定的为准</span><br><span class="line"><span class="keyword">if</span>(!<span class="string">""</span>.equals(beanName.trim())) &#123;</span><br><span class="line">ioc.put(beanName,aClass.newInstance());</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">// 如果没有指定，就以类名⾸字⺟⼩写</span><br><span class="line">beanName = lowerFirst(aClass.getSimpleName());</span><br><span class="line">ioc.put(beanName,aClass.newInstance());</span><br><span class="line"> &#125;</span><br><span class="line">// service层往往是有接⼝的，⾯向接⼝开发，此时再以接⼝名为id，放⼊⼀份对象到ioc中，便于后期根据接⼝类型注⼊</span><br><span class="line">Class&lt;?&gt;[] interfaces = aClass.getInterfaces();</span><br><span class="line"><span class="keyword">for</span> (int j = 0; j &lt; interfaces.length; j++) &#123;</span><br><span class="line">Class&lt;?&gt; anInterface = interfaces[j];</span><br><span class="line">// 以接⼝的全限定类名作为id放⼊</span><br><span class="line">ioc.put(anInterface.getName(),aClass.newInstance());</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">// ⾸字⺟⼩写⽅法</span><br><span class="line">public String lowerFirst(String str) &#123;</span><br><span class="line">char[] chars = str.toCharArray();</span><br><span class="line"><span class="keyword">if</span>(<span class="string">'A'</span> &lt;= chars[0] &amp;&amp; chars[0] &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">chars[0] += 32;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">return</span> String.valueOf(chars);</span><br><span class="line"> &#125;</span><br><span class="line">// 扫描类</span><br><span class="line">// scanPackage: com.loonycoder.demo package----&gt; 磁盘上的⽂件夹（File）com/loonycoder/demo</span><br><span class="line">private void doScan(String scanPackage) &#123;</span><br><span class="line">String scanPackagePath = Thread.currentThread().getContextClassLoader().getResource(<span class="string">""</span>).getPath() + scanPackage.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</span><br><span class="line">File pack = new File(scanPackagePath);</span><br><span class="line">File[] files = pack.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File file: files) &#123;</span><br><span class="line"><span class="keyword">if</span>(file.isDirectory()) &#123; // ⼦package</span><br><span class="line">// 递归</span><br><span class="line">doScan(scanPackage + <span class="string">"."</span> + file.getName()); //com.loonycoder.demo.controller</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(file.getName().endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">String className = scanPackage + <span class="string">"."</span> +</span><br><span class="line">file.getName().replaceAll(<span class="string">".class"</span>, <span class="string">""</span>);</span><br><span class="line">classNames.add(className);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 加载配置⽂件</span><br><span class="line">private void doLoadConfig(String contextConfigLocation) &#123;</span><br><span class="line">InputStream resourceAsStream =</span><br><span class="line">this.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);</span><br><span class="line">try &#123;</span><br><span class="line">properties.load(resourceAsStream);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">throws ServletException, IOException &#123;</span><br><span class="line">doPost(req,resp);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void doPost(HttpServletRequest req, HttpServletResponse</span><br><span class="line">resp) throws ServletException, IOException &#123;</span><br><span class="line">// 处理请求：根据url，找到对应的Method⽅法，进⾏调⽤</span><br><span class="line">// 获取uri</span><br><span class="line">// String requestURI = req.getRequestURI();</span><br><span class="line">// Method method = handlerMapping.get(requestURI);// 获取到⼀个反射的</span><br><span class="line">⽅法</span><br><span class="line">// 反射调⽤，需要传⼊对象，需要传⼊参数，此处⽆法完成调⽤，没有把对象缓存起来，</span><br><span class="line">也没有参数！！！！改造initHandlerMapping();</span><br><span class="line">// method.invoke() //</span><br><span class="line">// 根据uri获取到能够处理当前请求的hanlder（从handlermapping中（list））</span><br><span class="line">Handler handler = getHandler(req);</span><br><span class="line"><span class="keyword">if</span>(handler == null) &#123;</span><br><span class="line">resp.getWriter().write(<span class="string">"404 not found"</span>);</span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line">// 参数绑定</span><br><span class="line">// 获取所有参数类型数组，这个数组的⻓度就是我们最后要传⼊的args数组的⻓度</span><br><span class="line">Class&lt;?&gt;[] parameterTypes = handler.getMethod().getParameterTypes();</span><br><span class="line">// 根据上述数组⻓度创建⼀个新的数组（参数数组，是要传⼊反射调⽤的）</span><br><span class="line">Object[] paraValues = new Object[parameterTypes.length];</span><br><span class="line">// 以下就是为了向参数数组中塞值，⽽且还得保证参数的顺序和⽅法中形参顺序⼀致</span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();</span><br><span class="line">// 遍历request中所有参数 （填充除了request，response之外的参数）</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,String[]&gt; param: parameterMap.entrySet()) &#123;</span><br><span class="line">// name=1&amp;name=2 name [1,2]</span><br><span class="line">String value = StringUtils.join(param.getValue(), <span class="string">","</span>); // 如 同 1,2</span><br><span class="line">// 如果参数和⽅法中的参数匹配上了，填充数据</span><br><span class="line"><span class="keyword">if</span>(!handler.getParamIndexMapping().containsKey(param.getKey()))&#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">// ⽅法形参确实有该参数，找到它的索引位置，对应的把参数值放⼊paraValues</span><br><span class="line">Integer index =</span><br><span class="line">handler.getParamIndexMapping().get(param.getKey());//name在第 2 个位置</span><br><span class="line">paraValues[index] = value; // 把前台传递过来的参数值填充到对应的位置去</span><br><span class="line">&#125;</span><br><span class="line">int requestIndex = handler.getParamIndexMapping().get(HttpServletRequest.class.getSimpleName()); // 0</span><br><span class="line">paraValues[requestIndex] = req;</span><br><span class="line">int responseIndex =</span><br><span class="line">handler.getParamIndexMapping().get(HttpServletResponse.class.getSimpleName()); // 1</span><br><span class="line">paraValues[responseIndex] = resp;</span><br><span class="line">// 最终调⽤handler的method属性</span><br><span class="line">try &#123;</span><br><span class="line">handler.getMethod().invoke(handler.getController(),paraValues);</span><br><span class="line">&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private Handler getHandler(HttpServletRequest req) &#123;</span><br><span class="line"><span class="keyword">if</span>(handlerMapping.isEmpty())&#123;<span class="built_in">return</span> null;&#125;</span><br><span class="line">String url = req.getRequestURI();</span><br><span class="line"><span class="keyword">for</span>(Handler handler: handlerMapping) &#123;</span><br><span class="line">Matcher matcher = handler.getPattern().matcher(url);</span><br><span class="line"><span class="keyword">if</span>(!matcher.matches())&#123;<span class="built_in">continue</span>;&#125;</span><br><span class="line"><span class="built_in">return</span> handler;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Pojo类Handler<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import javax.sound.midi.MetaEventListener;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">/**</span><br><span class="line">* 封装handler⽅法相关的信息</span><br><span class="line">*/</span><br><span class="line">public class Handler &#123;</span><br><span class="line">private Object controller; // method.invoke(obj)</span><br><span class="line">private Method method;</span><br><span class="line">private Pattern pattern; // spring中url是⽀持正则的</span><br><span class="line">private Map&lt;String,Integer&gt; paramIndexMapping; // 参数顺序,是为了进⾏参数</span><br><span class="line">绑定，key是参数名，value代表是第⼏个参数 &lt;name,2&gt;</span><br><span class="line">public Handler(Object controller, Method method, Pattern pattern) &#123;</span><br><span class="line">this.controller = controller;</span><br><span class="line">this.method = method;</span><br><span class="line">this.pattern = pattern;</span><br><span class="line">this.paramIndexMapping = new HashMap&lt;&gt;();</span><br><span class="line"> &#125;</span><br><span class="line">public Object <span class="function"><span class="title">getController</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> controller;</span><br><span class="line">&#125;</span><br><span class="line">public void setController(Object controller) &#123;</span><br><span class="line">this.controller = controller;</span><br><span class="line">&#125;</span><br><span class="line">public Method <span class="function"><span class="title">getMethod</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> method;</span><br><span class="line">&#125;</span><br><span class="line">public void setMethod(Method method) &#123;</span><br><span class="line">this.method = method;</span><br><span class="line">&#125;</span><br><span class="line">public Pattern <span class="function"><span class="title">getPattern</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> pattern;</span><br><span class="line">&#125;</span><br><span class="line">public void setPattern(Pattern pattern) &#123;</span><br><span class="line">this.pattern = pattern;</span><br><span class="line">&#125;</span><br><span class="line">public Map&lt;String, Integer&gt; <span class="function"><span class="title">getParamIndexMapping</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> paramIndexMapping;</span><br><span class="line">&#125;</span><br><span class="line">public void setParamIndexMapping(Map&lt;String, Integer&gt; paramIndexMapping) &#123;</span><br><span class="line">this.paramIndexMapping = paramIndexMapping;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>web.xml配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line"><span class="string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"><span class="string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span><br><span class="line">&lt;web-app&gt; </span><br><span class="line">&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; </span><br><span class="line">&lt;servlet&gt; </span><br><span class="line">&lt;servlet-name&gt;loonycodermvc&lt;/servlet-name&gt; </span><br><span class="line">&lt;servletclass&gt;com.loonycoder.mvcframework.servlet.lcDispatcherServlet&lt;/servletclass&gt;</span><br><span class="line">&lt;init-param&gt; </span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; </span><br><span class="line">&lt;param-value&gt;springmvc.properties&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt; </span><br><span class="line">&lt;servlet-mapping&gt; </span><br><span class="line">&lt;servlet-name&gt;loonycodermvc&lt;/servlet-name&gt; </span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>表现层框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优秀而又强大的表现层框架——SpringMVC（二）</title>
    <link href="/2019/05/28/springmvc2/"/>
    <url>/2019/05/28/springmvc2/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近系统的学习了下这个优秀而又强大的表现层框架——SpringMVC，拜读了<strong>应癫</strong>老师的《SpringMVC源码剖析》，深表感谢！</p><p><strong>源码地址：</strong><a href="https://github.com/LoonyCoder/lagou-learn/tree/master/Model%203" target="_blank" rel="noopener">手写SpringMVC框架</a><br><strong>欢迎star/fork，给作者一些鼓励！</strong></p><h3 id="SpringMVC高级技术"><a href="#SpringMVC高级技术" class="headerlink" title="SpringMVC高级技术"></a>SpringMVC高级技术</h3><h4 id="拦截器-Intecepter-使用"><a href="#拦截器-Intecepter-使用" class="headerlink" title="拦截器(Intecepter)使用"></a>拦截器(Intecepter)使用</h4><h5 id="监听器、过滤器和拦截器对比"><a href="#监听器、过滤器和拦截器对比" class="headerlink" title="监听器、过滤器和拦截器对比"></a>监听器、过滤器和拦截器对比</h5><ul><li><p><strong>过滤器（Filter）</strong>：对Request请求起到过滤的作⽤，作⽤在Servlet之前，如果配置为/*可以对所<br>有的资源访问（servlet、js/css静态资源等）进⾏过滤处理。</p></li><li><p><strong>监听器（Listener）</strong>：实现了<code>javax.servlet.ServletContextListener</code>接⼝的服务器端组件，它随<br>Web应⽤的启动⽽启动，只初始化⼀次，然后会⼀直运⾏监视，随Web应⽤的停⽌⽽销毁。</p><ul><li>作⽤⼀：做⼀些初始化⼯作，web应⽤中spring容器启动ContextLoaderListener</li><li>作⽤⼆：监听web中的特定事件，⽐如HttpSession,ServletRequest的创建和销毁；变量的创建、<br>销毁和修改等。可以在某些动作前后增加处理，实现监控，⽐如统计在线⼈数，利⽤<br>HttpSessionLisener等。</li></ul></li><li><p><strong>拦截器（Interceptor）</strong>：是SpringMVC、Struts等表现层框架⾃⼰的，不会拦截<br>jsp/html/css/image的访问等，只会拦截访问的控制器⽅法（Handler）。<br>从配置的⻆度也能够总结发现：serlvet、filter、listener是配置在web.xml中的，⽽interceptor是<br>配置在表现层框架⾃⼰的配置⽂件中的。</p><ul><li>在Handler业务逻辑执⾏之前拦截⼀次</li><li>在Handler逻辑执⾏完毕但未跳转⻚⾯之前拦截⼀次</li><li>在跳转⻚⾯之后拦截⼀次</li></ul></li></ul><p><img src="/images/springmvc/springmvc4.png" srcset="/img/loading.gif" alt="springmvc"></p><h5 id="拦截器的执行流程"><a href="#拦截器的执行流程" class="headerlink" title="拦截器的执行流程"></a>拦截器的执行流程</h5><p>在运⾏程序时，拦截器的执⾏是有⼀定顺序的，该顺序与配置⽂件中所定义的拦截器的顺序相关。 单个<br>拦截器，在程序中的执⾏流程如下图所示：</p><p><img src="/images/springmvc/springmvc5.png" srcset="/img/loading.gif" alt="springmvc"></p><ol><li>程序先执⾏<code>preHandle()</code>⽅法，如果该⽅法的返回值为true，则程序会继续向下执⾏处理器中的⽅<br>法，否则将不再向下执⾏。</li><li>在业务处理器（即控制器Controller类）处理完请求后，会执⾏<code>postHandle()</code>⽅法，然后会通过<br>DispatcherServlet向客户端返回响应。</li><li>在DispatcherServlet处理完请求后，才会执⾏<code>afterCompletion()</code>⽅法。</li></ol><h5 id="多个拦截器的执行流程"><a href="#多个拦截器的执行流程" class="headerlink" title="多个拦截器的执行流程"></a>多个拦截器的执行流程</h5><p>多个拦截器（假设有两个拦截器Interceptor1和Interceptor2，并且在配置⽂件中， Interceptor1拦截<br>器配置在前），在程序中的执⾏流程如下图所示：</p><p><img src="/images/springmvc/springmvc6.png" srcset="/img/loading.gif" alt="springmvc"></p><p>从图可以看出，当有多个拦截器同时⼯作时，它们的<code>preHandle()</code>⽅法会按照配置⽂件中拦截器的配置<br>顺序执⾏，⽽它们的<code>postHandle()⽅法和<code>afterCompletion()</code>⽅法则会按照配置顺序的反序执⾏。</p><p><strong>示例代码</strong></p><p>⾃定义SpringMVC拦截器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* ⾃定义springmvc拦截器</span><br><span class="line">*/</span><br><span class="line">public class MyIntercepter01 implements HandlerInterceptor &#123;</span><br><span class="line">/**</span><br><span class="line">* 会在handler⽅法业务逻辑执⾏之前执⾏</span><br><span class="line">* 往往在这⾥完成权限校验⼯作</span><br><span class="line">* @param request</span><br><span class="line">* @param response</span><br><span class="line">* @param handler</span><br><span class="line">* @<span class="built_in">return</span> 返回值boolean代表是否放⾏，<span class="literal">true</span>代表放⾏，<span class="literal">false</span>代表中⽌</span><br><span class="line">* @throws Exception</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse</span><br><span class="line">response, Object handler) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"MyIntercepter01 preHandle......"</span>);</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">/**</span><br><span class="line">* 会在handler⽅法业务逻辑执⾏之后尚未跳转⻚⾯时执⾏</span><br><span class="line">* @param request</span><br><span class="line">* @param response</span><br><span class="line">* @param handler</span><br><span class="line">* @param modelAndView 封装了视图和数据，此时尚未跳转⻚⾯呢，你可以在这⾥针对返回的</span><br><span class="line">数据和视图信息进⾏修改</span><br><span class="line">* @throws Exception</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public void postHandle(HttpServletRequest request, HttpServletResponse</span><br><span class="line">response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"MyIntercepter01 postHandle......"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">/**</span><br><span class="line">* ⻚⾯已经跳转渲染完毕之后执⾏</span><br><span class="line">* @param request</span><br><span class="line">* @param response</span><br><span class="line">* @param handler</span><br><span class="line">* @param ex 可以在这⾥捕获异常</span><br><span class="line">* @throws Exception</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public void afterCompletion(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">System.out.println(<span class="string">"MyIntercepter01 afterCompletion......"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册SpringMVC拦截器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">&lt;!--拦截所有handler--&gt;</span><br><span class="line">&lt;!--&lt;bean class=<span class="string">"com.loonycoder.interceptor.MyIntercepter01"</span>/&gt;--&gt;</span><br><span class="line">&lt;mvc:interceptor&gt;</span><br><span class="line">&lt;!--配置当前拦截器的url拦截规则，**代表当前⽬录下及其⼦⽬录下的所有url--&gt;</span><br><span class="line">&lt;mvc:mapping path=<span class="string">"/**"</span>/&gt;</span><br><span class="line">&lt;!--exclude-mapping可以在mapping的基础上排除⼀些url拦截--&gt;</span><br><span class="line">&lt;!--&lt;mvc:exclude-mapping path=<span class="string">"/demo/**"</span>/&gt;--&gt;</span><br><span class="line">&lt;bean class=<span class="string">"com.loonycoder.interceptor.MyIntercepter01"</span>/&gt;</span><br><span class="line">&lt;/mvc:interceptor&gt; </span><br><span class="line">&lt;mvc:interceptor&gt; </span><br><span class="line">&lt;mvc:mapping path=<span class="string">"/**"</span>/&gt;</span><br><span class="line">&lt;bean class=<span class="string">"com.loonycoder.interceptor.MyIntercepter02"</span>/&gt;</span><br><span class="line">&lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><h4 id="处理multipart形式的数据"><a href="#处理multipart形式的数据" class="headerlink" title="处理multipart形式的数据"></a>处理multipart形式的数据</h4><p>multipart用于文件上传，首先引入jar包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--⽂件上传所需jar坐标--&gt;</span><br><span class="line">&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置⽂件上传解析器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置⽂件上传解析器，id是固定的multipartResolver--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"multipartResolver"</span> class=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span><br><span class="line">&lt;!--设置上传⼤⼩，单位字节--&gt;</span><br><span class="line">&lt;property name=<span class="string">"maxUploadSize"</span> value=<span class="string">"1000000000"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>前端Form</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">1 method=<span class="string">"post"</span></span><br><span class="line">2 enctype=<span class="string">"multipart/form-data"</span></span><br><span class="line">3 <span class="built_in">type</span>=<span class="string">"file"</span></span><br><span class="line">--%&gt; </span><br><span class="line">&lt;form method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span> action=<span class="string">"/demo/upload"</span>&gt; &lt;input <span class="built_in">type</span>=<span class="string">"file"</span> name=<span class="string">"uploadFile"</span>/&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> value=<span class="string">"上传"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>后台接收Handler</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(<span class="string">"upload"</span>)</span><br><span class="line">public String upload(MultipartFile uploadFile, HttpServletRequest request)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">// ⽂件原名，如xxx.jpg</span><br><span class="line">String originalFilename = uploadFile.getOriginalFilename();</span><br><span class="line">// 获取⽂件的扩展名,如jpg</span><br><span class="line">String extendName =</span><br><span class="line">originalFilename.substring(originalFilename.lastIndexOf(<span class="string">"."</span>) + 1,</span><br><span class="line">originalFilename.length());</span><br><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line">// 新的⽂件名字</span><br><span class="line">String newName = uuid + <span class="string">"."</span> + extendName;</span><br><span class="line">String realPath =</span><br><span class="line">request.getSession().getServletContext().getRealPath(<span class="string">"/uploads"</span>);</span><br><span class="line">// 解决⽂件夹存放⽂件数量限制，按⽇期存放</span><br><span class="line">String datePath = new SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).format(new Date());</span><br><span class="line">File floder = new File(realPath + <span class="string">"/"</span> + datePath);</span><br><span class="line"><span class="keyword">if</span>(!floder.exists()) &#123;</span><br><span class="line">floder.mkdirs();</span><br><span class="line"> &#125;</span><br><span class="line">uploadFile.transferTo(new File(floder,newName));</span><br><span class="line"><span class="built_in">return</span> <span class="string">"success"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在控制器中处理异常"><a href="#在控制器中处理异常" class="headerlink" title="在控制器中处理异常"></a>在控制器中处理异常</h4><p>使用<code>@ControllerAdvice</code>注解</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 可以让我们优雅的捕获所有Controller对象handler⽅法抛出的异常</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class GlobalExceptionResolver &#123;</span><br><span class="line">@ExceptionHandler(ArithmeticException.class)</span><br><span class="line">public ModelAndView handleException(ArithmeticException exception,</span><br><span class="line">HttpServletResponse response) &#123;</span><br><span class="line">ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">modelAndView.addObject(<span class="string">"msg"</span>,exception.getMessage());</span><br><span class="line">modelAndView.setViewName(<span class="string">"error"</span>);</span><br><span class="line"><span class="built_in">return</span> modelAndView;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于Flash属性的跨重定向请求数据传递"><a href="#基于Flash属性的跨重定向请求数据传递" class="headerlink" title="基于Flash属性的跨重定向请求数据传递"></a>基于Flash属性的跨重定向请求数据传递</h4><p>重定向时请求参数会丢失，我们往往需要重新携带请求参数，我们可以进⾏⼿动参数拼接如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span> <span class="string">"redirect:handle01?name="</span> + name;</span><br></pre></td></tr></table></figure><p>但是上述拼接参数的⽅法属于get请求，携带参数⻓度有限制，参数安全性也不⾼，此时，我们可以使<br>⽤SpringMVC提供的flash属性机制，向上下⽂中添加flash属性，框架会在session中记录该属性值，当<br>跳转到⻚⾯之后框架会⾃动删除flash属性，不需要我们⼿动删除，通过这种⽅式进⾏重定向参数传递，<br>参数⻓度和安全性都得到了保障，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* SpringMVC 重定向时参数传递的问题</span><br><span class="line">* 转发：A 找 B 借钱400，B没有钱但是悄悄的找到C借了400块钱给A</span><br><span class="line">* url不会变,参数也不会丢失,⼀个请求</span><br><span class="line">* 重定向：A 找 B 借钱400，B 说我没有钱，你找别⼈借去，那么A ⼜带着400块的借钱需求找到C</span><br><span class="line">* url会变,参数会丢失需要重新携带参数,两个请求</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(<span class="string">"/handleRedirect"</span>)</span><br><span class="line">public String handleRedirect(String name,RedirectAttributes</span><br><span class="line">redirectAttributes) &#123;</span><br><span class="line">//<span class="built_in">return</span> <span class="string">"redirect:handle01?name="</span> + name; // 拼接参数安全性、参数⻓度都有</span><br><span class="line">局限</span><br><span class="line">// addFlashAttribute⽅法设置了⼀个flash类型属性，该属性会被暂存到session中，在</span><br><span class="line">跳转到⻚⾯之后该属性销毁</span><br><span class="line">redirectAttributes.addFlashAttribute(<span class="string">"name"</span>,name);</span><br><span class="line"><span class="built_in">return</span> <span class="string">"redirect:handle01"</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>表现层框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优秀而又强大的表现层框架——SpringMVC（一）</title>
    <link href="/2019/05/19/springmvc1/"/>
    <url>/2019/05/19/springmvc1/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近系统的学习了下这个优秀而又强大的表现层框架——SpringMVC，拜读了<strong>应癫</strong>老师的《SpringMVC源码剖析》，深表感谢！</p><p><strong>源码地址：</strong><a href="https://github.com/LoonyCoder/lagou-learn/tree/master/Model%203" target="_blank" rel="noopener">手写SpringMVC框架</a><br><strong>欢迎star/fork，给作者一些鼓励！</strong></p><h3 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h3><h4 id="MVC体系结构"><a href="#MVC体系结构" class="headerlink" title="MVC体系结构"></a>MVC体系结构</h4><p><strong>三层架构</strong></p><p>我们的开发架构⼀般都是基于两种形式，⼀种是 C/S 架构，也就是客户端/服务器；另⼀种是 B/S 架构<br>，也就是浏览器服务器。在 JavaEE 开发中，⼏乎全都是基于 B/S 架构的开发。那么在 B/S 架构中，系<br>统标准的三层架构包括：表现层、业务层、持久层。三层架构在我们的实际开发中使⽤的⾮常多，所以本文章的所有案例也都是基于三层架构设计的。<br>三层架构中，每⼀层各司其职，接下来我们就说说每层都负责哪些⽅⾯：</p><ul><li><p>表现层 ：也就是我们常说的web 层。它负责接收客户端请求，向客户端响应结果，通常客户端使⽤http协议请求web 层，web 需要接收 http 请求，完成 http 响应。<br>  表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。<br>  表现层依赖业务层，接收到客户端请求⼀般会调⽤业务层进⾏业务处理，并将处理结果响应给客户端。<br>  表现层的设计⼀般都使⽤ MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）</p></li><li><p>业务层 ：也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项⽬的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。<br>  业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务⼀致性。（也就是我们说的， 事务应该放到业务层来控制）</p></li><li><p>持久层 ：也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进<br>⾏持久化的载体，数据访问层是业务层和持久层交互的接⼝，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进⾏增删改查的。</p></li></ul><p><strong>MVC设计模式</strong></p><p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller) 的缩写， 是⼀<br>种⽤于设计创建 Web 应⽤程序表现层的模式。MVC 中每个部分各司其职：</p><ul><li>Model（模型）：模型包含业务模型和数据模型，数据模型⽤于封装数据，业务模型⽤于处理业<br>务。</li><li>View（视图）： 通常指的就是我们的 jsp 或者 html。作⽤⼀般就是展示数据的。通常视图是依据<br>模型数据创建的。</li><li>Controller（控制器）： 是应⽤程序中处理⽤户交互的部分。作⽤⼀般就是处理程序逻辑的。<br>MVC提倡：每⼀层只编写⾃⼰的东⻄，不编写任何其他的代码；分层是为了解耦，解耦是为了维<br>护⽅便和分⼯协作。</li></ul><h4 id="SpringMVC是什么？"><a href="#SpringMVC是什么？" class="headerlink" title="SpringMVC是什么？"></a>SpringMVC是什么？</h4><p>SpringMVC 全名叫 Spring Web MVC，是⼀种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级<br>Web 框架，属于 SpringFrameWork 的后续产品。</p><p><img src="/images/springmvc/springmvc1.png" srcset="/img/loading.gif" alt="spring架构"></p><p>SpringMVC 已经成为 ⽬前最主流的 MVC 框架 之⼀，并且 随着 Spring3.0 的发布，全⾯超越 Struts2，<br>成为最优秀的 MVC 框架。<br>servlet、Struts 实现接⼝、springmvc 中要让⼀个java类能够处理请求只需要添加注解就ok<br>它通过⼀套注解，让⼀个简单的 Java 类成为处理请求的控制器，⽽⽆须实现任何接⼝。同时它还⽀持<br>RESTful 编程⻛格的请求。<br>总之：Spring MVC和Struts2⼀样，都是为了解决表现层问题的web框架，它们都是基于 MVC 设计模<br>式的。⽽这些表现层框架的主要职责就是处理前端 http 请求。<br>Spring MVC 本质可以认为是对servlet的封装，简化了我们 serlvet 的开发<br>作⽤：</p><ul><li>接收请求 </li><li>返回响应，跳转⻚⾯</li></ul><p><img src="/images/springmvc/springmvc2.png" srcset="/img/loading.gif" alt="springmvc工作流"></p><h3 id="Spring-Web-MVC工作流程"><a href="#Spring-Web-MVC工作流程" class="headerlink" title="Spring Web MVC工作流程"></a>Spring Web MVC工作流程</h3><p>需求：前端浏览器请求url：<a href="http://localhost:8080/demo/handle01" target="_blank" rel="noopener">http://localhost:8080/demo/handle01</a>，前端⻚⾯显示后台服务器的时间<br>开发过程：</p><ul><li>配置 DispatcherServlet 前端控制器</li><li>开发处理具体业务逻辑的 Handler（<code>@Controller、@RequestMapping</code>） </li><li>xml 配置⽂件配置 controller 扫描，配置 springmvc 三⼤组件</li><li>将 xml ⽂件路径告诉 springmvc（DispatcherServlet）</li></ul><h4 id="SpringMVC请求处理流程"><a href="#SpringMVC请求处理流程" class="headerlink" title="SpringMVC请求处理流程"></a>SpringMVC请求处理流程</h4><p><img src="/images/springmvc/springmvc3.png" srcset="/img/loading.gif" alt="SpringMVC请求处理流程"></p><p>流程说明：<br>第⼀步：⽤户发送请求⾄前端控制器 DispatcherServlet<br>第⼆步：DispatcherServlet 收到请求调⽤HandlerMapping处理器映射器<br>第三步：处理器映射器根据请求 Url 找到具体的 Handler（后端控制器），⽣成处理器对象及处理器拦截<br>器(如果有则⽣成)⼀并返回 DispatcherServlet<br>第四步：DispatcherServlet 调⽤HandlerAdapter 处理器适配器去调⽤ Handler<br>第五步：处理器适配器执⾏ Handler<br>第六步：Handler 执⾏完成给处理器适配器返回 ModelAndView<br>第七步：处理器适配器向前端控制器返回 ModelAndView，ModelAndView 是SpringMVC 框架的⼀个<br>底层对 象，包括 Model 和 View<br>第⼋步：前端控制器请求视图解析器去进⾏视图解析，根据逻辑视图名来解析真正的视图。<br>第九步：视图解析器向前端控制器返回 View<br>第⼗步：前端控制器进⾏视图渲染，就是将模型数据（在 ModelAndView 对象中）填充到 request 域<br>第⼗⼀步：前端控制器向⽤户响应结果</p><h4 id="SpringMVC九大组件"><a href="#SpringMVC九大组件" class="headerlink" title="SpringMVC九大组件"></a>SpringMVC九大组件</h4><ul><li><strong>HandlerMapping（处理器映射器）</strong><br>HandlerMapping 是⽤来查找 Handler 的，也就是处理器，具体的表现形式可以是类，也可以是<br>⽅法。⽐如，标注了<code>@RequestMapping</code>的每个⽅法都可以看成是⼀个Handler。Handler负责具<br>体实际的请求处理，在请求到达后，HandlerMapping 的作⽤便是找到请求相应的处理器<br>Handler 和 Interceptor.</li><li><strong>HandlerAdapter（处理器适配器）</strong><br>HandlerAdapter 是⼀个适配器。因为 Spring MVC 中 Handler 可以是任意形式的，只要能处理请<br>求即可。但是把请求交给 Servlet 的时候，由于 Servlet 的⽅法结构都是<br>doService(HttpServletRequest req,HttpServletResponse resp)形式的，要让固定的 Servlet 处理<br>⽅法调⽤ Handler 来进⾏处理，便是 HandlerAdapter 的职责。</li><li><strong>HandlerExceptionResolver</strong><br>HandlerExceptionResolver ⽤于处理 Handler 产⽣的异常情况。它的作⽤是根据异常设置<br>ModelAndView，之后交给渲染⽅法进⾏渲染，渲染⽅法会将 ModelAndView 渲染成⻚⾯。</li><li><strong>ViewResolver</strong><br>ViewResolver即视图解析器，⽤于将String类型的视图名和Locale解析为View类型的视图，只有⼀<br>个resolveViewName()⽅法。从⽅法的定义可以看出，Controller层返回的String类型视图名<br>viewName 最终会在这⾥被解析成为View。View是⽤来渲染⻚⾯的，也就是说，它会将程序返回<br>的参数和数据填⼊模板中，⽣成html⽂件。ViewResolver 在这个过程主要完成两件事情：<br>ViewResolver 找到渲染所⽤的模板（第⼀件⼤事）和所⽤的技术（第⼆件⼤事，其实也就是找到<br>视图的类型，如JSP）并填⼊参数。默认情况下，Spring MVC会⾃动为我们配置⼀个<br>InternalResourceViewResolver,是针对 JSP 类型视图的。</li><li><strong>RequestToViewNameTranslator</strong><br>RequestToViewNameTranslator 组件的作⽤是从请求中获取 ViewName.因为 ViewResolver 根据<br>ViewName 查找 View，但有的 Handler 处理完成之后,没有设置 View，也没有设置 ViewName，<br>便要通过这个组件从请求中查找 ViewName。</li><li><strong>LocaleResolver</strong><br>ViewResolver 组件的 resolveViewName ⽅法需要两个参数，⼀个是视图名，⼀个是 Locale。<br>LocaleResolver ⽤于从请求中解析出 Locale，⽐如中国 Locale 是 zh-CN，⽤来表示⼀个区域。这<br>个组件也是 i18n 的基础。</li><li><strong>ThemeResolver</strong><br>ThemeResolver 组件是⽤来解析主题的。主题是样式、图⽚及它们所形成的显示效果的集合。<br>Spring MVC 中⼀套主题对应⼀个 properties⽂件，⾥⾯存放着与当前主题相关的所有资源，如图<br>⽚、CSS样式等。创建主题⾮常简单，只需准备好资源，然后新建⼀个“主题名.properties”并将资<br>源设置进去，放在classpath下，之后便可以在⻚⾯中使⽤了。SpringMVC中与主题相关的类有<br>ThemeResolver、ThemeSource和Theme。ThemeResolver负责从请求中解析出主题名，<br>ThemeSource根据主题名找到具体的主题，其抽象也就是Theme，可以通过Theme来获取主题和<br>具体的资源。</li><li><strong>MultipartResolver</strong><br>MultipartResolver ⽤于上传请求，通过将普通的请求包装成 MultipartHttpServletRequest 来实<br>现。MultipartHttpServletRequest 可以通过 getFile() ⽅法 直接获得⽂件。如果上传多个⽂件，还<br>可以调⽤ getFileMap()⽅法得到Map&lt;FileName，File&gt;这样的结构，MultipartResolver 的作⽤就<br>是封装普通的请求，使其拥有⽂件上传的功能。</li><li><strong>FlashMapManager</strong><br>FlashMap ⽤于重定向时的参数传递，⽐如在处理⽤户订单时候，为了避免重复提交，可以处理完<br>post请求之后重定向到⼀个get请求，这个get请求可以⽤来显示订单详情之类的信息。这样做虽然<br>可以规避⽤户重新提交订单的问题，但是在这个⻚⾯上要显示订单的信息，这些数据从哪⾥来获得<br>呢？因为重定向时么有传递参数这⼀功能的，如果不想把参数写进URL（不推荐），那么就可以通<br>过FlashMap来传递。只需要在重定向之前将要传递的数据写⼊请求（可以通过<br>ServletRequestAttributes.getRequest()⽅法获得）的属性OUTPUT_FLASH_MAP_ATTRIBUTE<br>中，这样在重定向之后的Handler中Spring就会⾃动将其设置到Model中，在显示订单信息的⻚⾯<br>上就可以直接从Model中获取数据。FlashMapManager 就是⽤来管理 FalshMap 的。</li></ul><h3 id="请求参数绑定"><a href="#请求参数绑定" class="headerlink" title="请求参数绑定"></a>请求参数绑定</h3><p>请求参数绑定：说⽩了SpringMVC如何接收请求参数<br>http协议（超⽂本传输协议）<br>原⽣servlet接收⼀个整型参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String ageStr = request.getParameter(<span class="string">"age"</span>);</span><br><span class="line">Integer age = Integer.parseInt(ageStr);</span><br></pre></td></tr></table></figure><p>SpringMVC框架对 Servlet 的封装，简化了Servlet 的很多操作<br>SpringMVC在接收整型参数的时候，直接在 Handler ⽅法中声明形参即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(<span class="string">"xxx"</span>)</span><br><span class="line">public String handle(Integer age) &#123;</span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font style="color: red">参数绑定：取出参数值绑定到 handler ⽅法的形参上</font></p><ul><li><p><strong>默认⽀持 Servlet API 作为⽅法参数</strong><br>当需要使⽤HttpServletRequest、HttpServletResponse、HttpSession等原⽣servlet对象时，直<br>接在handler⽅法中形参声明使⽤即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*</span><br><span class="line">* SpringMVC 对原⽣servlet api的⽀持 url：/demo/handle02?id=1</span><br><span class="line">*</span><br><span class="line">* 如果要在SpringMVC中使⽤servlet原⽣对象，⽐如</span><br><span class="line">* HttpServletRequest、HttpServletResponse、HttpSession，直接在Handler⽅法形参中声</span><br><span class="line">* 明使⽤即可</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(<span class="string">"/handle02"</span>)</span><br><span class="line">public ModelAndView handle02(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response,HttpSession session) &#123;</span><br><span class="line">String id = request.getParameter(<span class="string">"id"</span>);</span><br><span class="line">Date date = new Date();</span><br><span class="line">ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">modelAndView.addObject(<span class="string">"date"</span>,date);</span><br><span class="line">modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line"><span class="built_in">return</span> modelAndView;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>绑定简单类型参数</strong><br>简单数据类型：⼋种基本数据类型及其包装类型<br>参数类型推荐使⽤包装数据类型，因为基础数据类型不可以为null<br>整型：Integer、int<br>字符串：String<br>单精度：Float、float<br>双精度：Double、double<br>布尔型：Boolean、boolean<br>说明：对于布尔类型的参数，<strong>请求的参数值为true或false。或者1或0</strong><br>注意：绑定简单数据类型参数，只需要直接声明形参即可（形参参数名和传递的参数名要保持⼀<br>致，建议 使⽤包装类型，当形参参数名和传递参数名不⼀致时可以使⽤<code>@RequestParam</code>注解进⾏<br>⼿动映射）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* SpringMVC 接收简单数据类型参数 url：/demo/handle03?id=1</span><br><span class="line">*</span><br><span class="line">* 注意：接收简单数据类型参数，直接在handler⽅法的形参中声明即可，框架会取出参数值</span><br><span class="line">* 然后绑定到对应参数上</span><br><span class="line">* 要求：传递的参数名和声明的形参名称保持⼀致</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(<span class="string">"/handle03"</span>)</span><br><span class="line">public ModelAndView handle03(@RequestParam(<span class="string">"ids"</span>) Integer id,Boolean</span><br><span class="line">flag) &#123;</span><br><span class="line">Date date = new Date();</span><br><span class="line">ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">modelAndView.addObject(<span class="string">"date"</span>,date);</span><br><span class="line">modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line"><span class="built_in">return</span> modelAndView;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>绑定Pojo类型参数</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* SpringMVC接收pojo类型参数 url：/demo/handle04?id=1&amp;username=zhangsan</span><br><span class="line">*</span><br><span class="line">* 接收pojo类型参数，直接形参声明即可，类型就是Pojo的类型，形参名⽆所谓</span><br><span class="line">* 但是要求传递的参数名必须和Pojo的属性名保持⼀致</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(<span class="string">"/handle04"</span>)</span><br><span class="line">public ModelAndView handle04(User user) &#123;</span><br><span class="line">Date date = new Date();</span><br><span class="line">ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">modelAndView.addObject(<span class="string">"date"</span>,date);</span><br><span class="line">modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line"><span class="built_in">return</span> modelAndView;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>绑定Pojo包装对象参数</strong></li></ul><p>包装类型 QueryVo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class QueryVo &#123;</span><br><span class="line">private String mail;</span><br><span class="line">private String phone;</span><br><span class="line">// 嵌套了另外的Pojo对象</span><br><span class="line">private User user;</span><br><span class="line">public String <span class="function"><span class="title">getMail</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> mail;</span><br><span class="line"> &#125;</span><br><span class="line">public void setMail(String mail) &#123;</span><br><span class="line">this.mail = mail;</span><br><span class="line"> &#125;</span><br><span class="line">public String <span class="function"><span class="title">getPhone</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> phone;</span><br><span class="line"> &#125;</span><br><span class="line">public void setPhone(String phone) &#123;</span><br><span class="line">this.phone = phone;</span><br><span class="line"> &#125;</span><br><span class="line">public User <span class="function"><span class="title">getUser</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> user;</span><br><span class="line"> &#125;</span><br><span class="line">public void setUser(User user) &#123;</span><br><span class="line">this.user = user;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler⽅法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* SpringMVC接收pojo包装类型参数 url：/demo/handle05?</span><br><span class="line">user.id=1&amp;user.username=zhangsan</span><br><span class="line">* 不管包装Pojo与否，它⾸先是⼀个pojo，那么就可以按照上述pojo的要求来</span><br><span class="line">* 1、绑定时候直接形参声明即可</span><br><span class="line">* 2、传参参数名和pojo属性保持⼀致，如果不能够定位数据项，那么通过属性名 + <span class="string">"."</span> 的</span><br><span class="line">* ⽅式进⼀步锁定数据</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(<span class="string">"/handle05"</span>)</span><br><span class="line">public ModelAndView handle05(QueryVo queryVo) &#123;</span><br><span class="line">Date date = new Date();</span><br><span class="line">ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">modelAndView.addObject(<span class="string">"date"</span>,date);</span><br><span class="line">modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line"><span class="built_in">return</span> modelAndView;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>绑定⽇期类型参数（需要配置⾃定义类型转换器）</strong><ul><li>前端jsp<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;fieldset&gt; &lt;p&gt;测试⽤例：SpringMVC接收⽇期类型参数&lt;/p&gt; &lt;a href=<span class="string">"/demo/handle06?birthday=2019-05-18"</span>&gt;点击测试&lt;/a&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br></pre></td></tr></table></figure></li><li>后台Handler⽅法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 绑定⽇期类型参数</span><br><span class="line">* 定义⼀个SpringMVC的类型转换器 接⼝，扩展实现接⼝接⼝，注册你的实现</span><br><span class="line">* @param birthday</span><br><span class="line">* @<span class="built_in">return</span></span><br><span class="line">*/</span><br><span class="line">@RequestMapping(<span class="string">"/handle06"</span>)</span><br><span class="line">public ModelAndView handle06(Date birthday) &#123;</span><br><span class="line">Date date = new Date();ModelAndView modelAndView = new</span><br><span class="line">ModelAndView();</span><br><span class="line">modelAndView.addObject(<span class="string">"date"</span>,date);</span><br><span class="line">modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line"><span class="built_in">return</span> modelAndView;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>⾃定义类型转换器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class DateConverter implements Converter&lt;String, Date&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public Date convert(String <span class="built_in">source</span>) &#123;</span><br><span class="line">// 完成字符串向⽇期的转换</span><br><span class="line">SimpleDateFormat simpleDateFormat = new</span><br><span class="line">SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">try &#123;</span><br><span class="line">Date parse = simpleDateFormat.parse(<span class="built_in">source</span>);</span><br><span class="line"><span class="built_in">return</span> parse;</span><br><span class="line"> &#125; catch (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>注册⾃定义类型转换器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--⾃动注册最合适的处理器映射器，处理器适配器(调⽤handler⽅法)--&gt;</span><br><span class="line">&lt;mvc:annotation-driven conversion￾service=<span class="string">"conversionServiceBean"</span>/&gt;</span><br><span class="line">&lt;!--注册⾃定义类型转换器--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"conversionServiceBean"</span> class=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt; </span><br><span class="line">&lt;property name=<span class="string">"converters"</span>&gt;</span><br><span class="line">&lt;<span class="built_in">set</span>&gt;</span><br><span class="line">&lt;bean class=<span class="string">"com.loonycoder.converter.DateConverter"</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/<span class="built_in">set</span>&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="对RESTful风格请求支持"><a href="#对RESTful风格请求支持" class="headerlink" title="对RESTful风格请求支持"></a>对RESTful风格请求支持</h3><h4 id="什么是RESTful"><a href="#什么是RESTful" class="headerlink" title="什么是RESTful"></a>什么是RESTful</h4><p>Restful 是⼀种 web 软件架构⻛格，它不是标准也不是协议，它倡导的是⼀个资源定位及资源操作的⻛<br>格。<br><strong>什么是 REST：</strong><br>REST（英⽂：Representational State Transfer，简称 REST）描述了⼀个架构样式的⽹络系统， ⽐如<br>web 应⽤程序。它⾸次出现在 2000 年 Roy Fielding 的博⼠论⽂中，他是 HTTP 规范的主要编写者之<br>⼀。在⽬前主流的三种 Web 服务交互⽅案中，REST 相⽐于 SOAP（Simple Object Access protocol，<br>简单对象访问协议）以及 XML-RPC 更加简单明了，⽆论是对 URL 的处理还是对 Payload 的编码，<br>REST 都倾向于⽤更加简单轻量的⽅法设计和实现。值得注意的是 REST 并没有⼀个明确的标准，⽽更像<br>是⼀种设计的⻛格。</p><p>它本身并没有什么实⽤性，其核⼼价值在于如何设计出符合 REST ⻛格的⽹络接⼝。</p><p><strong>Restful 的优点</strong><br>它结构清晰、符合标准、易于理解、扩展⽅便，所以正得到越来越多⽹站的采⽤。</p><p><strong>Restful 的特性</strong><br>资源（Resources）：⽹络上的⼀个实体，或者说是⽹络上的⼀个具体信息。<br>它可以是⼀段⽂本、⼀张图⽚、⼀⾸歌曲、⼀种服务，总之就是⼀个具体的存在。可以⽤⼀个 URI（统<br>⼀资源定位符）指向它，每种资源对应⼀个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此<br>URI 即为每⼀个资源的独⼀⽆⼆的识别符。<br>表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层 （Representation）。⽐<br>如，⽂本可以⽤ txt 格式表现，也可以⽤ HTML 格式、XML 格式、JSON 格式表现，甚⾄可以采⽤⼆进<br>制格式。<br>状态转化（State Transfer）：每发出⼀个请求，就代表了客户端和服务器的⼀次交互过程。<br>HTTP 协议，是⼀个⽆状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务<br>器， 必须通过某种⼿段，让服务器端发⽣“状态转化”（State Transfer）。⽽这种转化是建⽴在表现层<br>之上的，所以就是 “ 表现层状态转化” 。具体说， 就是 HTTP 协议⾥⾯，四个表示操作⽅式的动词：<br>GET 、POST 、PUT 、DELETE 。它们分别对应四种基本操作：GET ⽤来获取资源，POST ⽤来新建资<br>源，PUT ⽤来更新资源，DELETE ⽤来删除资源。</p><p><strong>RESTful 的示例：</strong><br>rest是⼀个url请求的⻛格，基于这种⻛格设计请求的url<br>没有rest的话，原有的url设计<br><a href="http://localhost:8080/user/queryUserById.action?id=3" target="_blank" rel="noopener">http://localhost:8080/user/queryUserById.action?id=3</a><br>url中定义了动作（操作），参数具体锁定到操作的是谁<br>有了rest⻛格之后<br>rest中，认为互联⽹中的所有东⻄都是资源，既然是资源就会有⼀个唯⼀的uri标识它，代表它<br><a href="http://localhost:8080/user/3" target="_blank" rel="noopener">http://localhost:8080/user/3</a>代表的是id为3的那个⽤户记录（资源）<br>锁定资源之后如何操作它呢？常规操作就是增删改查<br>根据请求⽅式不同，代表要做不同的操作<br><strong>get</strong>:查询，获取资源<br><strong>post</strong>:增加，新建资源<br><strong>put</strong>:更新<br><strong>delete</strong>:删除资源<br>rest⻛格带来的直观体现：就是传递参数⽅式的变化，参数可以在uri中了</p><blockquote><p>/account/1 HTTP GET ：得到 id = 1 的 account<br>/account/1 HTTP DELETE：删除 id = 1 的 account<br>/account/1 HTTP PUT：更新 id = 1 的 account</p></blockquote><p>URL：资源定位符，通过URL地址去定位互联⽹中的资源（抽象的概念，⽐如图⽚、视频、app服务<br>等）。</p><p><strong>RESTful ⻛格 URL</strong>：互联⽹所有的事物都是资源，要求URL中只有表示资源的名称，没有动词。</p><p><strong>RESTful ⻛格资源操作</strong>：使⽤HTTP请求中的method⽅法put、delete、post、get来操作资源。分别对<br>应添加、删除、修改、查询。不过⼀般使⽤时还是 post 和 get。put 和 delete⼏乎不使⽤。</p><p><strong>RESTful ⻛格资源表述</strong>：可以根据需求对URL定位的资源返回不同的表述（也就是返回数据类型，⽐如<br>XML、JSON等数据格式）。<br>Spring MVC ⽀持 RESTful ⻛格请求，具体讲的就是使⽤ <code>@PathVariable</code> 注解获取 RESTful ⻛格的请求<br>URL中的路径变量。</p><ul><li>示例代码<ul><li>前端jsp⻚⾯<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h2&gt;SpringMVC对Restful⻛格url的⽀持&lt;/h2&gt; </span><br><span class="line">&lt;fieldset&gt; </span><br><span class="line">&lt;p&gt;测试⽤例：SpringMVC对Restful⻛格url的⽀持&lt;/p&gt; </span><br><span class="line">&lt;a href=<span class="string">"/demo/handle/15"</span>&gt;rest_get测试&lt;/a&gt; </span><br><span class="line">&lt;form method=<span class="string">"post"</span> action=<span class="string">"/demo/handle"</span>&gt; </span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"username"</span>/&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> value=<span class="string">"提交rest_post请求"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;form method=<span class="string">"post"</span> action=<span class="string">"/demo/handle/15/lisi"</span>&gt; </span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"_method"</span> value=<span class="string">"put"</span>/&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> value=<span class="string">"提交rest_put请求"</span>/&gt;</span><br><span class="line">&lt;/form&gt; </span><br><span class="line">&lt;form method=<span class="string">"post"</span> action=<span class="string">"/demo/handle/15"</span>&gt; </span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"_method"</span> value=<span class="string">"delete"</span>/&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> value=<span class="string">"提交rest_delete请求"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>后台Handler⽅法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* restful get /demo/handle/15</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(value = <span class="string">"/handle/&#123;id&#125;"</span>,method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">public ModelAndView handleGet(@PathVariable(<span class="string">"id"</span>) Integer id) &#123;</span><br><span class="line">Date date = new Date();</span><br><span class="line">ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">modelAndView.addObject(<span class="string">"date"</span>,date);</span><br><span class="line">modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line"><span class="built_in">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">* restful post /demo/handle</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(value = <span class="string">"/handle"</span>,method = &#123;RequestMethod.POST&#125;)</span><br><span class="line">public ModelAndView handlePost(String username) &#123;</span><br><span class="line">Date date = new Date();</span><br><span class="line">ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">modelAndView.addObject(<span class="string">"date"</span>,date);</span><br><span class="line">modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line"><span class="built_in">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">* restful put /demo/handle/15/lisi</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(value = <span class="string">"/handle/&#123;id&#125;/&#123;name&#125;"</span>,method = &#123;RequestMethod.PUT&#125;)</span><br><span class="line">public ModelAndView handlePut(@PathVariable(<span class="string">"id"</span>) Integer id,@PathVariable(<span class="string">"name"</span>) String username) &#123;</span><br><span class="line">Date date = new Date();</span><br><span class="line">ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">modelAndView.addObject(<span class="string">"date"</span>,date);</span><br><span class="line">modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line"><span class="built_in">return</span> modelAndView;</span><br><span class="line"> &#125;</span><br><span class="line">/*</span><br><span class="line">* restful delete /demo/handle/15</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(value = <span class="string">"/handle/&#123;id&#125;"</span>,method = &#123;RequestMethod.DELETE&#125;)</span><br><span class="line">public ModelAndView handleDelete(@PathVariable(<span class="string">"id"</span>) Integer id) &#123;</span><br><span class="line">Date date = new Date();</span><br><span class="line">ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">modelAndView.addObject(<span class="string">"date"</span>,date);</span><br><span class="line">modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line"><span class="built_in">return</span> modelAndView;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>web.xml中配置请求⽅式过滤器（将特定的post请求转换为put和delete请求）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置springmvc请求⽅式转换过滤器，会检查请求参数中是否有_method参数，如果有就</span><br><span class="line">按照指定的请求⽅式进⾏转换--&gt;</span><br><span class="line">&lt;filter&gt; </span><br><span class="line">&lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; </span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt; </span><br><span class="line">&lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt; </span><br><span class="line">&lt;filter-mapping&gt; </span><br><span class="line">&lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; </span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Ajax-Json交互"><a href="#Ajax-Json交互" class="headerlink" title="Ajax/Json交互"></a>Ajax/Json交互</h3><blockquote><p>交互：两个⽅向</p><ol><li>前端到后台：前端ajax发送json格式字符串，后台直接接收为pojo参数，使⽤注解<code>@RequstBody</code></li><li>后台到前端：后台直接返回pojo对象，前端直接接收为json对象或者字符串，使⽤注解<code>@ResponseBody</code></li></ol></blockquote><h4 id="什么是Json"><a href="#什么是Json" class="headerlink" title="什么是Json"></a>什么是Json</h4><p>Json是⼀种与语⾔⽆关的数据交互格式，就是⼀种字符串，只是⽤特殊符号{}内表示对象、[]内表示数<br>组、“”内是属性或值、：表示后者是前者的值<br>{“name”: “Michael”}可以理解为是⼀个包含name为Michael的对象<br>[{“name”: “Michael”},{“name”: “Jerry”}]就表示包含两个对象的数组</p><h4 id="ResponseBody注解"><a href="#ResponseBody注解" class="headerlink" title="@ResponseBody注解"></a>@ResponseBody注解</h4><p><code>@responseBody</code>注解的作⽤是将 controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之<br>后，写⼊到 response 对象的 body 区，通常⽤来返回 Json 数据或者是 xml 数据。 注意：在使⽤此注解之<br>后不会再⾛视图处理器，⽽是直接将数据写⼊到输⼊流中，他的效果等同于通过 response 对象输出指定<br>格式的数据。</p><h4 id="分析SpringMVC使用Json交互"><a href="#分析SpringMVC使用Json交互" class="headerlink" title="分析SpringMVC使用Json交互"></a>分析SpringMVC使用Json交互</h4><p>所需jar包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--json数据交互所需jar，start--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;jackson-core&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--json数据交互所需jar，end--&gt;</span><br></pre></td></tr></table></figure><ul><li>示例代码<ul><li>前端jsp⻚⾯及js代码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt; </span><br><span class="line">&lt;h2&gt;Ajax json交互&lt;/h2&gt; </span><br><span class="line">&lt;fieldset&gt; </span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"ajaxBtn"</span> value=<span class="string">"ajax提交"</span>/&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">$(<span class="string">"#ajaxBtn"</span>).<span class="built_in">bind</span>(<span class="string">"click"</span>,<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">// 发送ajax请求</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url: <span class="string">'/demo/handle07'</span>,</span><br><span class="line"><span class="built_in">type</span>: <span class="string">'POST'</span>,</span><br><span class="line">data: <span class="string">'&#123;"id":"1","name":"李四"&#125;'</span>,</span><br><span class="line">contentType: <span class="string">'application/json;charset=utf-8'</span>,</span><br><span class="line">dataType: <span class="string">'json'</span>,</span><br><span class="line">success: <span class="keyword">function</span> (data) &#123;</span><br><span class="line">alert(data.name);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>后台Handler⽅法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(<span class="string">"/handle07"</span>)</span><br><span class="line">// 添加@ResponseBody之后，不再⾛视图解析器那个流程，⽽是等同于response直接输出</span><br><span class="line">数据</span><br><span class="line">public @ResponseBody User handle07(@RequestBody User user) &#123;</span><br><span class="line">// 业务逻辑处理，修改name为张三</span><br><span class="line">user.setName(<span class="string">"张三"</span>);</span><br><span class="line"><span class="built_in">return</span> user; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>表现层框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析Get和Post的区别</title>
    <link href="/2019/05/05/GetAndPost/"/>
    <url>/2019/05/05/GetAndPost/</url>
    
    <content type="html"><![CDATA[<h4 id="表面的区别"><a href="#表面的区别" class="headerlink" title="表面的区别"></a>表面的区别</h4><ol><li><p>GET在浏览器回退时是无害的，而POST会再次提交请求。</p></li><li><p>GET产生的URL地址可以被Bookmark，而POST不可以。</p></li><li><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p></li><li><p>GET请求只能进行url编码，而POST支持多种编码方式。</p></li><li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p></li><li><p>get方式提交数据的大小（一般来说1024字节），http协议并没有硬性限制，而是与浏览器、服务器、操作系统有关，而POST理论上来说没有大小限制，http协议规范也没有进行大小限制，但实际上post所能传递的数据量根据取决于服务器的设置和内存大小。</p></li><li><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p></li><li><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p></li><li><p>GET参数通过URL传递，POST放在Request body中。</p></li></ol><h4 id="没有区别的回答"><a href="#没有区别的回答" class="headerlink" title="没有区别的回答"></a>没有区别的回答</h4><ol><li><p>GET和POST是HTTP协议中的两种发送请求的方法。</p></li><li><p>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p></li><li><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p></li><li><p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p></li></ol><h4 id="重大区别"><a href="#重大区别" class="headerlink" title="重大区别"></a>重大区别</h4><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。</p><ol><li><p>GET与POST都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li></ol><p>看了这么多，是不是会觉得一脸懵逼，在你做项目的时候要注意：</p><p>get一般是用来获取数据，post提交数据</p><p>post其实是有大小限制的，只不过是取决于服务器的设置和内存大小。</p><p>还有更深入的区别：</p><p>GET是用来向获取服务器信息的，请求报文传输的信息只是用于描述所需资源的参数，返回的信息才是数据本身；POST是用来向服务器传递数据的，其请求报文传递的信息就是数据本身，返回的报文只是操作的结果。</p><p>大概我就先说这么多吧！</p><p>不足的各位请补充</p>]]></content>
    
    
    <categories>
      
      <category>Http</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Http</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程状态切换及基本操作</title>
    <link href="/2019/04/28/thread2/"/>
    <url>/2019/04/28/thread2/</url>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>上篇文章我们讲了Java多线程的基础知识，本文将拓展讲解一下Java多线程状态及状态之间的切换问题，以及常用的基本操作。</p><hr><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><h5 id="什么是线程调度"><a href="#什么是线程调度" class="headerlink" title="什么是线程调度"></a>什么是线程调度</h5><p>线程调度就是系统为线程分配执行时间的过程。</p><h5 id="线程调度的方式"><a href="#线程调度的方式" class="headerlink" title="线程调度的方式"></a>线程调度的方式</h5><p>根据线程调度的控制权是由系统控制或者线程本身来控制划分为：协同式的线程调度和抢占式的线程调度。</p><ol><li>协同式线程调度：线程之间的系统执行时间，由线程本身进行进行控制。这种线程调度方式就像接力赛，一个执行完毕后交由下一个接力。如当前线程执行完毕后，通知系统调度到其他线程执行。</li></ol><ul><li>协同的好处：线程的切换是可预知的。线程之间不存在同步的问题。</li><li>协同的坏处：协同调度的致命缺点是当某个线程执行有问题的时候，会导致整个运行阻塞和系统崩溃。</li></ul><ol start="2"><li>抢占式线程调度：线程之间的系统执行时间，是由系统进行控制。而抢占式的线程调度对线程的不可预知，系统定期的中断当前正在执行的线程，将CPU执行权切换到下一个等待的线程。所以任何一个线程都不能独占CPU。正因为这种定期的线程切换导致线程之间存在不同的问题。当线程执行过程中，某个线程出现问题的时候，由线程对CPU不具有独占性。因此不会造成阻塞。</li></ol><blockquote><p>我们所使用的操作系统都是是用抢占性的线程调度。如果使用协同式的线程调度情况下，如果我们再使用某个软件出现问题时候，操作系统处于阻塞状态，导致整个操作系统崩溃，我们肯定会抓狂。</p></blockquote><ol start="3"><li>JAVA线程调度：Java线程调度就是抢占式调度。</li></ol><h4 id="Java线程的实现方式"><a href="#Java线程的实现方式" class="headerlink" title="Java线程的实现方式"></a>Java线程的实现方式</h4><p>JAVA提供了3中创建线程的方式：</p><ul><li><p>Thread<br>继承Thread类重写run方法，这种创建线程的方式在我们的编程中很少使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static class TheadExtends extends Thread&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"TheadExtends"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Runnable<br>既然JAVA提供了Thread创建线程的方式，为什么还要提供Runnable接口的方式进行创建线程？因为JAVA是单继承，不能多继承。因此就有了Runnable接口的方式来进行创建线程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static class RunnableImpl implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"RunnableImpl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Callable<br>Callable接口与Runnable接口的区别在于Callable在线程调用完毕后有返回结果，而Runnable没有，而对于一些业务处理比较耗时并且无需立即返回处理结果的情况下，我们都会通过asynchronous+Future的方式处理，而对于这种业务情景我们可以通过Callable进行处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadImplement &#123;</span><br><span class="line"></span><br><span class="line">    private static class CallableImpl implements Callable&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            <span class="built_in">return</span> <span class="string">"Callable"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        </span><br><span class="line">        CallableImpl callableImpl=new CallableImpl();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(callableImpl);</span><br><span class="line">        Thread  CallableThread= new Thread(futureTask);</span><br><span class="line">        CallableThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="JAVA线程状态转换"><a href="#JAVA线程状态转换" class="headerlink" title="JAVA线程状态转换"></a>JAVA线程状态转换</h4><h5 id="Java线程状态转换图"><a href="#Java线程状态转换图" class="headerlink" title="Java线程状态转换图"></a>Java线程状态转换图</h5><p><img src="/images/thread/thread3.png" srcset="/img/loading.gif" alt="线程状态转换图"></p><h5 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h5><p>JAVA线程状态包括：</p><ul><li><p><code>New</code>：新创建一个线程是处于该状态。</p></li><li><p><code>Runnable</code>：线程的调度是由操作系统可以决定，因此Runnable是包含Ready和Running。当我们调用了<code>start()</code>方法后，当前的线程处于一个Ready的状态，等待操作系统线程调用到当前线程分配CPU执行时间，若当前线程获得CPU执行时间时，线程就处于一个Running的状态。而在Running状态的情况下，我们可以调用<code>yield()</code>方法，放弃当前线程的CPU执行。而调用yield后当前线程处于一个Ready的状态，这种状态下操作系统在线程调度的时候分配CPU执行时间给当前的线程。</p></li><li><p><code>Blocked</code>：阻塞状态下代表着当前的线程被挂起。而这挂起的原因的线程在等待一个锁。如我们在一个方法或者代码块中使用Synchronized时，同一时间有2个线程进入该方法的时候，先获取到锁的线程执行。而没有获得锁的线程就处于这种阻塞状态。</p></li><li><p><code>WAITING</code>：等待状态下，当前线程不被执行和操作系统不会给该线程进行线程调度。而当前线程处于等待其他线程唤醒。只有被唤醒后，操作系统才会给该线程进行线程调度。这种线程的等待的主要作用是为了线程之间的协作。一般情况下通过Synchronized获得锁后，调用锁的wait的方法进入等待状态，而调用wait方法后，当前的线程会释放锁，而另外一个线程获得锁后，通过<code>notifyall()/notify()</code>进行唤醒处于等待的线程。</p></li><li><p><code>TIMED_WAITING</code>：处于这种有限期的等待的情况下，在限期内当前线程不会被执行和操作系统不会给该线程进行线程调度。在限期过后，操作系统才给该线程进行线程调度。</p></li><li><p><code>TERMINATED</code>：该状态下线程处于终止，而这种终止引起的原因分为正常的执行完毕的终止和非正常情况下的终止，而非正常情况下可能是线程执行异常或者调用<code>interrupt()</code>中止线程引起。</p></li></ul><h4 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h4><h5 id="多线程编程的好处"><a href="#多线程编程的好处" class="headerlink" title="多线程编程的好处"></a>多线程编程的好处</h5><ul><li>充分利用CPU的资源。</li><li>加快请求响应</li><li>异步化</li></ul><h5 id="多线程带来的问题"><a href="#多线程带来的问题" class="headerlink" title="多线程带来的问题"></a>多线程带来的问题</h5><ul><li>设计更复杂<ul><li>线程之间是共享进程资源，存在资源冲突。</li><li>线程之间的协作往往是非常复杂。若不能正确的使用锁的机制，通常会造成数据错误，整个业务功能出现问题。</li></ul></li><li>上下文切换的开销</li><li>增加资源消耗，多线程变成是一种空间换时间的方式。线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈，若开启过多的线程时会导致程序占用过多的内存和机器崩溃。</li></ul><h4 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h4><p><strong>interrupt</strong></p><ul><li><p>JAVA提倡通过协作的方式结束线程，而不是使用强制停止的方式进行结束线程如<code>stop()</code>，<code>resume()</code>,<code>suspend()</code>已不建议使用，<code>stop()</code>会导致线程不会正确释放资源，<code>suspend()</code>容易导致死锁。那么怎样协同的方式结束线程呢？就是同过Thread的<code>interrupt()</code>方法进行协作中断线程。而调用interrupt方法是在线程中设置一个中断的标志位，中断标志默认为false。被中断的线程通过循环的方式监听这个标志位确定当前线程需要中断。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    public static class SafeEndRunnable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">            System.out.println(<span class="string">"flag = "</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"running"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"is end ,flag = "</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SafeEndRunnable safeEndRunnable = new SafeEndRunnable();</span><br><span class="line">        Thread t1 = new Thread(safeEndRunnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(1);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">Thread-0running</span><br><span class="line">Thread-0running</span><br><span class="line">Thread-0running</span><br><span class="line">Thread-0running</span><br><span class="line">Thread-0is end ,flag = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>相关方法</p></li></ul><table><thead><tr><th align="left">方法名</th><th align="left">方法类型</th><th align="left">Demo</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">isInterrupted</td><td align="left">对象方法</td><td align="left"><code>Thread.currentThread().isInterrupted()</code></td><td align="left">判断当前线程是否处于中断状态</td></tr><tr><td align="left">interrupt</td><td align="left">对象方法</td><td align="left"><code>Thread.currentThread().interrupt()</code></td><td align="left">设置标志位为true</td></tr><tr><td align="left">interrupted</td><td align="left">静态方法</td><td align="left"><code>Thread.interrupted()</code></td><td align="left">判断当前线程是否处于中断状态并且设置中断状态为false</td></tr></tbody></table><ul><li>在进行协作处理线程结束的时候清除标志位。在我们的被中断的线程中如果使用到了sleep方法时，如果中断线程调用时，该线程处于sleep时，会抛出InterruptedException，如果使用进行try/catch捕捉该异常的时候会清除标志位。所以我们需要再调用被中断的线程的<code>interrupt()</code>方法。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static class SafeEndThread implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"running"</span>);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">"flag = "</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"is end ,flag = "</span>+Thread.currentThread().isInterrupted());          </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SafeEndThread safeEndThread = new SafeEndThread();</span><br><span class="line">        Thread t2 = new Thread(safeEndThread);</span><br><span class="line">        t2.start(); </span><br><span class="line">        Thread.sleep(1);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">输出：</span><br><span class="line">Thread-0running</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">Thread-0is end ,flag = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>yield</strong></p><p>yield的主要作用的是让出CPU的执行时间，需要注意的时候，调用yield虽然让出了CPU的执行时间，但是会参与下一次的CPU执行时间的竞争中，如果当前线程重新获得CPU执行时间，那么当前的线程再次执行。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public static class ThreadYieldRunnable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"running"</span>+i);</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadYieldRunnable threadYieldRunnable= new ThreadYieldRunnable();</span><br><span class="line">        Thread t1 = new Thread(threadYieldRunnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"t1.yield"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Thread-0running0</span><br><span class="line">Thread-0running1</span><br><span class="line">t1.yield</span><br><span class="line">Thread-0running2</span><br><span class="line">Thread-0running3</span><br><span class="line">Thread-0running4</span><br><span class="line">Thread-0running5</span><br><span class="line">Thread-0running6</span><br><span class="line">Thread-0running7</span><br><span class="line">Thread-0running8</span><br><span class="line">Thread-0running9</span><br><span class="line">Thread-0running10</span><br><span class="line">Thread-0running11</span><br><span class="line">Thread-0running12</span><br><span class="line">Thread-0running13</span><br><span class="line">Thread-0running14</span><br><span class="line">Thread-0running15</span><br><span class="line">Thread-0running16</span><br><span class="line">Thread-0running17</span><br><span class="line">Thread-0running18</span><br><span class="line">Thread-0running19</span><br></pre></td></tr></table></figure><h4 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h4><p>锁的主要作用是保护临界区资源，在多线程访问临界区时互斥。那么在线程访问共享的资源时，JAVA提供了以下保存线程之间的线程共享资源。</p><p><strong>Synchronized</strong></p><ul><li><p>Synchronized的实现方式</p><table><thead><tr><th align="left">方式</th><th align="left">锁对象</th><th align="left">Demo</th></tr></thead><tbody><tr><td align="left">对象同步</td><td align="left">当前对象</td><td align="left"><code>synchronized void demo()</code></td></tr><tr><td align="left">静态同步</td><td align="left">当前类</td><td align="left"><code>static synchronized void demo()</code></td></tr><tr><td align="left">代码块</td><td align="left">当前对象、其他对象、类</td><td align="left"><code>Demo demo = new Demo(); synchronized (demo) {}<br>synchronized (this){}<br>synchronized(Demo.class) {}</code></td></tr></tbody></table></li><li><p>Synchronized的综述</p><ol><li>Synchronized主要作用实现同步。而这种同步是通过互斥锁来保证多线程访问时实现同步。即在同一时间内只有一个线程可以访问临界区的资源，同时保证了共享资源的可预见性和原子性。</li><li>Synchronized的使用：可以在方法定义中使用，也可以使用同步代码块的形式使用。在使用Synchronized的时候，尽量使用代码块的形式，将同步的操作控制在最小的粒度中。如果使用在Synchronized在方法定义中，那么该方法中不存在锁竞争的部分会被同步。如果该方法高并发情况下，可能会导致多线程等待从而引起应用dump掉。</li></ol></li><li><p>Synchronized死锁<br>死锁引起的原因是由于两个线程之间，相互持有对象的锁和相互等待对象释放锁。在使用Synchronized的时候不允许出现死锁的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object lock1 = new Object();</span><br><span class="line">    Object lock2 = new Object();</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread1 get locke1"</span>);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread1 get locke2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread2 get locke2"</span>);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread2 get locke1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>避免使用常量池对象作为锁对象<br>Java为我们提供了String、Integer、Long常量池，因此我们再使用这些常量池的对象作为锁对象的时候，会存在锁隐患。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class ConstLock implements Runnable &#123;</span><br><span class="line">    private Object  lock ;</span><br><span class="line">    </span><br><span class="line">    public ConstLock(Object lock) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"sayHello"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConstLock constLock1 = new ConstLock(<span class="string">"lock"</span>);</span><br><span class="line">        ConstLock constLock2 = new ConstLock(<span class="string">"lock"</span>);</span><br><span class="line">        Thread t1 = new Thread(constLock1,<span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = new Thread(constLock2,<span class="string">"Thread2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConstLock constLock1 = new ConstLock(21);</span><br><span class="line">        ConstLock constLock2 = new ConstLock(21);</span><br><span class="line">        Thread t1 = new Thread(constLock1,<span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = new Thread(constLock2,<span class="string">"Thread2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConstLock constLock1 = new ConstLock(21l);</span><br><span class="line">        ConstLock constLock2 = new ConstLock(21l);</span><br><span class="line">        Thread t1 = new Thread(constLock1,<span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = new Thread(constLock2,<span class="string">"Thread2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Thread1sayHello</span><br><span class="line">Thread1sayHello</span><br><span class="line">Thread1sayHello</span><br></pre></td></tr></table></figure></li></ul><p><strong>volatile关键字</strong></p><p>volatile是JAVA中提供的一种轻量级的同步机制。而这种轻量级的同步机制是通过线程之间的通讯来保证。而不是通过锁的机制进行处理。因此不会对执行的线程造成阻塞。</p><ul><li><p>线程通讯过程<br><img src="/images/thread/thread4.png" srcset="/img/loading.gif" alt="线程通讯过程"></p></li><li><p>volatile主要作用</p><ol><li>确保了所有的线程对volatile修饰的变量具有可见性。</li><li>禁止操作系统指令重排序，如果变量没有被volatile表示禁止指令重排优化的情况下。操作系统默认会对不相关的执行指令进行重排序提高执行的效率。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Reorder &#123;</span><br><span class="line"></span><br><span class="line">    public static int x = 0;</span><br><span class="line">    public static int y = 0;</span><br><span class="line">    public static int a = 0;</span><br><span class="line">    public static int b = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread(()-&gt;&#123;</span><br><span class="line">            a = 1;</span><br><span class="line">            x = b;</span><br><span class="line">        &#125;) ;</span><br><span class="line">        Thread thread2 = new Thread(()-&gt;&#123;</span><br><span class="line">            b = 1;</span><br><span class="line">            y = a;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>如没有禁止指令重排序就会出现:x=1;y=0、x=0;y=1、x=1;y=1、x=0;y=0四种结果。</p><p><img src="/images/thread/thread5.png" srcset="/img/loading.gif" alt="结果"></p><ul><li><p>volatile原子性</p><ul><li>原子性表示一个操作或者多个操作的情况下，要么全部执行成功，要么全部执行失败。</li><li>volatile在符合条件以下条件的情况下具有原子性：<ol><li>对volatile修饰的变量的操作不依赖变量本身，如i++这种复合操作不具有原子性。代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        Thread thread = new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                <span class="keyword">for</span> (int i = 0; i &lt; 10000; i++)</span><br><span class="line">                    counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>确保只有一个线程修改变量的值的情况。</li></ol></li></ul></li><li><p>volatile适用场景</p><ol><li>禁止系统重排序的情况</li><li>只有一个线程写，多个线程读的情况。</li></ol></li></ul><p><strong>ThreadLocal</strong></p><p>ThreadLocal是一个线程本地存储，而每个线程有自己独立的副本。也就是说每个线程可以存放各自变量到线程本地存储中，并且线程之间各自访问各自的线程本地存储。当线程结束后，线程的本地存储会被垃圾回收。如果线程本地存储中的变量被其他引用到的情况下，是不会被回收。我们可以把ThreadLocal看作一个Map&lt;Thread,Object&gt;。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        protected Integer <span class="function"><span class="title">initialValue</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> 1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">startThread</span></span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            Thread t1 = new Thread(new ThreadLocalRunnable(i));</span><br><span class="line">            t1.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    @AllArgsConstructor</span><br><span class="line">    public static class ThreadLocalRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private int id;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  id="</span> + id);</span><br><span class="line">            int beforeId = threadLocal.get();</span><br><span class="line">            int afterId = beforeId + id;</span><br><span class="line">            threadLocal.set(afterId);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  after id ="</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new UseThreadLocal().startThread();</span><br><span class="line">    &#125;</span><br><span class="line">输出：</span><br><span class="line">Thread-0  id=0</span><br><span class="line">Thread-0  after id =1</span><br><span class="line">Thread-1  id=1</span><br><span class="line">Thread-1  after id =2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程基础</title>
    <link href="/2019/04/19/thread1/"/>
    <url>/2019/04/19/thread1/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>在我们工作和学习的过程中，Java线程我们或多或少的都会用到，但是在使用的过程上并不是很顺利，会遇到各种各样的坑，这里我通过讲解Thread类中的核心方法，以求重点掌握以下关键技术点：</p><ul><li>线程的启动</li><li>如何使线程暂停</li><li>如何使线程停止</li><li>线程的优先级</li><li>线程安全相关的问题</li></ul><hr><h4 id="什么是进程和线程？"><a href="#什么是进程和线程？" class="headerlink" title="什么是进程和线程？"></a>什么是进程和线程？</h4><ul><li><strong>进程</strong> - 进程是具有一定独立功能的程序（例如QQ.exe），关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</li><li><strong>线程</strong> - 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位；线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</li></ul><p>一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。</p><p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p><p>在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p><h4 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h4><p>其实多线程从某方面可以等价于多任务，当你有多个任务要处理时，多个任务一起做所消耗的时间肯定比任务串行起来做，所消耗的时间短；下图可以很好的说明：<br><img src="/images/thread/thread1.png" srcset="/img/loading.gif" alt="单任务运行环境与多任务运行环境比较"></p><p>在我们现在的系统中，CPU的运行速度是很快的，其中很大的时间消耗是在等硬盘、IO输入、网络等资源；当多任务时，CPU完全可以在多个任务之间来回切换。使用的花费的时间远远少于所有任务需要消耗的少。</p><h4 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h4><p>在Java的JDK包中，已经自带了对多线程技术的支持，可以非常方便地进行多线程的编程。实现多线程编程的方式主要有两种：</p><ul><li>继承Thread类</li><li>实现Runnable接口</li></ul><p><img src="/images/thread/thread2.png" srcset="/img/loading.gif" alt="接口实现"></p><p>从上面的类图中发现，Thread类实现了Runnable接口，它们之间具有多态关系。</p><p>Runnable接口类源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">   public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread类的主要源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">  public static native Thread currentThread();</span><br><span class="line">  public static native void yield();</span><br><span class="line">  public static native void sleep(long millis) throws InterruptedException;</span><br><span class="line">  public static void sleep(long millis, int nanos) throws InterruptedException &#123;</span><br><span class="line">    // ...</span><br><span class="line">    sleep(millis);</span><br><span class="line">  &#125;</span><br><span class="line">  public <span class="function"><span class="title">Thread</span></span>() &#123;</span><br><span class="line">    init(null, null, <span class="string">"Thread-"</span> + nextThreadNum(), 0);</span><br><span class="line">  &#125;</span><br><span class="line">   public Thread(Runnable target) &#123;</span><br><span class="line">      init(null, target, <span class="string">"Thread-"</span> + nextThreadNum(), 0);</span><br><span class="line">   &#125;</span><br><span class="line">  public Thread(ThreadGroup group, Runnable target) &#123;</span><br><span class="line">        init(group, target, <span class="string">"Thread-"</span> + nextThreadNum(), 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void <span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">    start0(); </span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  private native void start0();</span><br><span class="line">  @Deprecated</span><br><span class="line">  public final void <span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  public void <span class="function"><span class="title">interrupt</span></span>() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line">  public static boolean <span class="function"><span class="title">interrupted</span></span>() &#123;</span><br><span class="line">     <span class="built_in">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  public boolean <span class="function"><span class="title">isInterrupted</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  private native boolean isInterrupted(boolean ClearInterrupted);</span><br><span class="line">  public final native boolean isAlive();</span><br><span class="line">  @Deprecated</span><br><span class="line">  public final void <span class="function"><span class="title">suspend</span></span>() &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        suspend0();</span><br><span class="line">  &#125;</span><br><span class="line">  @Deprecated</span><br><span class="line">  public final void <span class="function"><span class="title">resume</span></span>() &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        resume0();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这二种创建线程的方式有什么区别？</strong></p><p>这个主要是因为Java类是单继承的，而接口可以支持多继承，使用Thread类的方式创建新线程时，最大的局限就是不支持多继承。所以具体选择哪种方式来创建线程，就看你是不是需要具体多继承的特性；其他没有本质的区别。</p><h4 id="Thread详解"><a href="#Thread详解" class="headerlink" title="Thread详解"></a>Thread详解</h4><p>通过Thread的源代码，我们现在对其主要的的一些方法进行讲解一下</p><ul><li><strong>native关键字</strong> - native是与C++联合开发的时候用的！使用native关键字说明这个方法是原生函数，也就是说这个方法是用C/C++语言实现的，并且被编译成dll相关组件，由java来调用。所以从上面的Thread类源代码中可以看到，有好多是调用了原生的函数。</li><li><strong>构造方法</strong> - Thread有一组构造方法，具体指定了<code>线程名称(name)</code>、<code>线程组(ThreadGroup)</code>、<code>接口类(Runnable)</code>、<code>栈大小(stackSize)</code>等参数 具体如下：</li></ul><blockquote><p>public Thread()<br>public Thread(Runnable target)<br>Thread(Runnable target, AccessControlContext acc)<br>public Thread(ThreadGroup group, Runnable target)<br>public Thread(String name)<br>public Thread(ThreadGroup group, String name)<br>public Thread(Runnable target, String name)<br>public Thread(ThreadGroup group, Runnable target, String name)<br>public Thread(ThreadGroup group, Runnable target, String name, long stackSize)</p></blockquote><ul><li><p><strong>isAlive()</strong> - 方法isAlive()是判断当前的线程是否处于活动状态。而这个活动状态指的是：线程已经启动且尚未终止，如<code>正在运行,准备开始运行</code>的状态，都认为线程是”存活”的。</p></li><li><p><strong>sleep()</strong> - 在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指<code>this.currentThread()</code>返回的线程。</p></li><li><p><strong>getId()</strong> - 取得线程的唯一标识。每个线程在初始化的过程中都会调用<code>nextThreadID</code>方法获取到一个唯一标识。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static long threadSeqNumber;</span><br><span class="line">private static synchronized long <span class="function"><span class="title">nextThreadID</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> ++threadSeqNumber;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在一个进程中，线程的ID是唯一的</p></blockquote></li><li><p><strong>停止线程</strong> - 停止线程是在多线程开始时很重要的技术点，而停止线程在Java中并不像break语句那样干脆，需要一些技巧性的处理。</p><blockquote><p>在Java中有以下3种方法可以终止正在运行的线程：</p><ul><li>使用退出标志，使线程正常退出，即当run方法完成后线程终止。</li><li>使用stop方法强行终止线程，但是不推荐使用该方法，因为stop和suspend及resume一样，都是作废过期的方法，使用它们可能产生不可预料的结果。</li><li>使用interrupt方法中断线程。</li></ul></blockquote></li><li><p><strong>暂停线程</strong> - 暂停线程意味着此线程还可以恢复运行。使用<code>suspend()</code>方法暂停线程，<code>resume()</code>方法恢复线程的执行。<br>yield - <code>yield()</code>方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。但是放弃的时间不确定，有可能刚放弃，马上又获得CPU时间片了。</p></li></ul><p>线程优先级 - 在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资料较多，也就是CPU优先执行优先级较高的线程对象中的任务。在Thread中，我们使用<code>setPriority()</code>方法设置优先级别。</p><blockquote><p>Java的线程优先级分为1~10这10个等级<br>public final static int MIN_PRIORITY = 1;<br>public final static int NORM_PRIORITY = 5;<br>public final static int MAX_PRIORITY = 10;</p><ul><li>线程优先级具有继承特性，比如A线程启动B线程，则B线程的优先级与A是一样的。</li><li>优先级具有规则性，虽然我们使用<code>setPriority()</code>方法设置了优先级，但是真正执行的过程中，不会保证优先级高的线程绝对比优先级低的线程优先完成。即<code>CPU尽量CPU尽量将执行资源让给优先级比较高的线程</code>。<br>优先级具有随机性，具优先级较高的线程不一定每一次都先执行完。</li></ul></blockquote><ul><li><strong>守护线程</strong> - 在Java线程中有两种线程，一种是用户线程，另一种是守护线程。<blockquote><p>守护线程是一种特殊的线程，它的特性有”陪伴”的含义，当进程中不存在非守护线程了，则守护线程自动销毁。<br>典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程则没有存在的必要了，自动销毁。<br>只要当前JVM实例中存在任何一个非守护线程没有结束，守护线程就在工作，只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。<br>通过调用<code>Thread.setDaemon(true)</code>设置是否为守护线程。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务管理实现方式之编程式事务与声明式事务详解</title>
    <link href="/2019/04/10/spring-transcation-2/"/>
    <url>/2019/04/10/spring-transcation-2/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>关于Spring事务的传播级别和隔离级别以及分布式事务的简单配置可以参考我上一篇文章<br><a href="https://loonycoder.github.io/2019/04/03/spring-transcation-1/" target="_blank" rel="noopener">Spring事务隔离级别、传播行为以及Spring+Mybatis+Atomikos实现分布式事务管理</a>;</p><hr><h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><p><strong>编码方式实现事务管理（代码演示为JDBC事务管理）</strong></p><p>Spring实现编程式事务，依赖于2大类，分别是上篇文章提到的PlatformTransactionManager，与模版类TransactionTemplate（推荐使用）。下面分别详细介绍Spring是如何通过该类实现事务管理。</p><ol><li>PlatformTransactionManager，上篇文章已经详情解说了该类所拥有的方法，具体请参考上一篇文章。</li></ol><blockquote><p>事务管理器配置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dataSource"</span> class=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">"jdbcUrl"</span> value=<span class="string">"<span class="variable">$&#123;db.jdbcUrl&#125;</span>"</span> /&gt;</span><br><span class="line">  &lt;property name=<span class="string">"user"</span> value=<span class="string">"<span class="variable">$&#123;user&#125;</span>"</span> /&gt;</span><br><span class="line">  &lt;property name=<span class="string">"password"</span> value=<span class="string">"<span class="variable">$&#123;password&#125;</span>"</span> /&gt;</span><br><span class="line">  &lt;property name=<span class="string">"driverClass"</span> value=<span class="string">"<span class="variable">$&#123;db.driverClass&#125;</span>"</span> /&gt;</span><br><span class="line">   &lt;!--连接池中保留的最小连接数。 --&gt; </span><br><span class="line">     &lt;property name=<span class="string">"minPoolSize"</span>&gt; </span><br><span class="line">         &lt;value&gt;5&lt;/value&gt; </span><br><span class="line">     &lt;/property&gt; </span><br><span class="line">     &lt;!--连接池中保留的最大连接数。Default: 15 --&gt; </span><br><span class="line">     &lt;property name=<span class="string">"maxPoolSize"</span>&gt; </span><br><span class="line">         &lt;value&gt;30&lt;/value&gt; </span><br><span class="line">     &lt;/property&gt; </span><br><span class="line">     &lt;!--初始化时获取的连接数，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt; </span><br><span class="line">     &lt;property name=<span class="string">"initialPoolSize"</span>&gt; </span><br><span class="line">         &lt;value&gt;10&lt;/value&gt; </span><br><span class="line">     &lt;/property&gt; </span><br><span class="line">     &lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt; </span><br><span class="line">     &lt;property name=<span class="string">"maxIdleTime"</span>&gt; </span><br><span class="line">         &lt;value&gt;60&lt;/value&gt; </span><br><span class="line">     &lt;/property&gt; </span><br><span class="line">     &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt; </span><br><span class="line">     &lt;property name=<span class="string">"acquireIncrement"</span>&gt; </span><br><span class="line">         &lt;value&gt;5&lt;/value&gt; </span><br><span class="line">     &lt;/property&gt; </span><br><span class="line">     &lt;!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。  如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0 --&gt; </span><br><span class="line">     &lt;property name=<span class="string">"maxStatements"</span>&gt; </span><br><span class="line">         &lt;value&gt;0&lt;/value&gt; </span><br><span class="line">     &lt;/property&gt; </span><br><span class="line">     &lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt; </span><br><span class="line">     &lt;property name=<span class="string">"idleConnectionTestPeriod"</span>&gt; </span><br><span class="line">         &lt;value&gt;60&lt;/value&gt; </span><br><span class="line">     &lt;/property&gt; </span><br><span class="line">     &lt;!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 --&gt; </span><br><span class="line">     &lt;property name=<span class="string">"acquireRetryAttempts"</span>&gt; </span><br><span class="line">         &lt;value&gt;30&lt;/value&gt; </span><br><span class="line">     &lt;/property&gt; </span><br><span class="line">     &lt;!--获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为<span class="literal">true</span>，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。Default: <span class="literal">false</span> --&gt; </span><br><span class="line">     &lt;property name=<span class="string">"breakAfterAcquireFailure"</span>&gt; </span><br><span class="line">         &lt;value&gt;<span class="literal">true</span>&lt;/value&gt; </span><br><span class="line">     &lt;/property&gt; </span><br><span class="line">     &lt;!--因性能消耗大请只在需要的时候使用它。如果设为<span class="literal">true</span>那么在每个connection提交的 时候都将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable等方法来提升连接测试的性能。Default: <span class="literal">false</span> --&gt; </span><br><span class="line">     &lt;property name=<span class="string">"testConnectionOnCheckout"</span>&gt; </span><br><span class="line">         &lt;value&gt;<span class="literal">false</span>&lt;/value&gt; </span><br><span class="line">     &lt;/property&gt; </span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--DataSourceTransactionManager位于org.springframework.jdbc.datasource包下，数据源事务管理类，提供对单个javax.sql.DataSource数据源的事务管理，主要用于JDBC，Mybatis框架事务管理。 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"transactionManager"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><blockquote><p>业务中使用代码(以测试类展示)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Map;</span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line">import org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line">import org.springframework.transaction.TransactionDefinition;</span><br><span class="line">import org.springframework.transaction.TransactionStatus;</span><br><span class="line">import org.springframework.transaction.support.DefaultTransactionDefinition;</span><br><span class="line"> </span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &#123; <span class="string">"classpath:spring-public.xml"</span> &#125;)</span><br><span class="line">public class <span class="built_in">test</span> &#123;</span><br><span class="line">  @Resource</span><br><span class="line">  private PlatformTransactionManager txManager;</span><br><span class="line">  @Resource</span><br><span class="line">  private  DataSource dataSource;</span><br><span class="line">  private static JdbcTemplate jdbcTemplate;</span><br><span class="line">  Logger logger=Logger.getLogger(test.class);</span><br><span class="line">    private static final String INSERT_SQL = <span class="string">"insert into testtranstation(sd) values(?)"</span>;</span><br><span class="line">    private static final String COUNT_SQL = <span class="string">"select count(*) from testtranstation"</span>;</span><br><span class="line">  @Test</span><br><span class="line">  public void <span class="function"><span class="title">testdelivery</span></span>()&#123;</span><br><span class="line">    //定义事务隔离级别，传播行为，</span><br><span class="line">      DefaultTransactionDefinition def = new DefaultTransactionDefinition();  </span><br><span class="line">      def.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);  </span><br><span class="line">      def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);  </span><br><span class="line">      //事务状态类，通过PlatformTransactionManager的getTransaction方法根据事务定义获取；获取事务状态后，Spring根据传播行为来决定如何开启事务</span><br><span class="line">      TransactionStatus status = txManager.getTransaction(def);  </span><br><span class="line">      jdbcTemplate = new JdbcTemplate(dataSource);</span><br><span class="line">      int i = jdbcTemplate.queryForInt(COUNT_SQL);  </span><br><span class="line">      System.out.println(<span class="string">"表中记录总数："</span>+i);</span><br><span class="line">      try &#123;  </span><br><span class="line">          jdbcTemplate.update(INSERT_SQL, <span class="string">"1"</span>);  </span><br><span class="line">          txManager.commit(status);  //提交status中绑定的事务</span><br><span class="line">      &#125; catch (RuntimeException e) &#123;  </span><br><span class="line">          txManager.rollback(status);  //回滚</span><br><span class="line">      &#125;  </span><br><span class="line">      i = jdbcTemplate.queryForInt(COUNT_SQL);  </span><br><span class="line">      System.out.println(<span class="string">"表中记录总数："</span>+i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用TransactionTemplate，该类继承了接口DefaultTransactionDefinition，用于简化事务管理，事务管理由模板类定义，主要是通过TransactionCallback回调接口或TransactionCallbackWithoutResult回调接口指定，通过调用模板类的参数类型为TransactionCallback或TransactionCallbackWithoutResult的execute方法来自动享受事务管理。</li></ol><p>TransactionTemplate模板类使用的回调接口：</p><ul><li>TransactionCallback：通过实现该接口的“T doInTransaction(TransactionStatus status) ”方法来定义需要事务管理的操作代码；</li><li>TransactionCallbackWithoutResult：继承TransactionCallback接口，提供“void doInTransactionWithoutResult(TransactionStatus status)”便利接口用于方便那些不需要返回值的事务操作代码。</li></ul><blockquote><p>还是以测试类方式展示如何实现</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testTransactionTemplate</span></span>()&#123;</span><br><span class="line">  jdbcTemplate = new JdbcTemplate(dataSource);</span><br><span class="line">    int i = jdbcTemplate.queryForInt(COUNT_SQL);  </span><br><span class="line">    System.out.println(<span class="string">"表中记录总数："</span>+i);</span><br><span class="line">  //构造函数初始化TransactionTemplate</span><br><span class="line">  TransactionTemplate template = new TransactionTemplate(txManager);</span><br><span class="line">  template.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);  </span><br><span class="line">  //重写execute方法实现事务管理</span><br><span class="line">  template.execute(new <span class="function"><span class="title">TransactionCallbackWithoutResult</span></span>() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">      jdbcTemplate.update(INSERT_SQL, <span class="string">"饿死"</span>);   //字段sd为int型，所以插入肯定失败报异常，自动回滚，代表TransactionTemplate自动管理事务</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  );</span><br><span class="line">  i = jdbcTemplate.queryForInt(COUNT_SQL);  </span><br><span class="line">    System.out.println(<span class="string">"表中记录总数："</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p><strong>可知编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现。</strong></p><p>声明式事务实现方式主要有2种，一种为通过使用Spring的&lt;tx:advice&gt;定义事务通知与AOP相关配置实现，另为一种通过@Transactional实现事务管理实现，下面详细说明2种方法如何配置，以及相关注意点。</p><ol><li>方式一，配置文件如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">&lt;tx:advice&gt;定义事务通知，用于指定事务属性，其中“transaction-manager”属性指定事务管理器，并通过&lt;tx:attributes&gt;指定具体需要拦截的方法</span><br><span class="line">  &lt;tx:method&gt;拦截方法，其中参数有：</span><br><span class="line">  name:方法名称，将匹配的方法注入事务管理，可用通配符</span><br><span class="line">  propagation：事务传播行为，</span><br><span class="line">  isolation：事务隔离级别定义；默认为“DEFAULT”</span><br><span class="line">  timeout：事务超时时间设置，单位为秒，默认-1，表示事务超时将依赖于底层事务系统；</span><br><span class="line">  <span class="built_in">read</span>-only：事务只读设置，默认为<span class="literal">false</span>，表示不是只读；</span><br><span class="line">    rollback-for：需要触发回滚的异常定义，可定义多个，以“，”分割，默认任何RuntimeException都将导致事务回滚，而任何Checked Exception将不导致事务回滚；</span><br><span class="line">    no-rollback-for：不被触发进行回滚的 Exception(s)；可定义多个，以“，”分割；</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;tx:advice id=<span class="string">"advice"</span> transaction-manager=<span class="string">"transactionManager"</span>&gt;</span><br><span class="line">  &lt;tx:attributes&gt;</span><br><span class="line">      &lt;!-- 拦截save开头的方法，事务传播行为为：REQUIRED：必须要有事务, 如果没有就在上下文创建一个 --&gt;</span><br><span class="line">    &lt;tx:method name=<span class="string">"save*"</span> propagation=<span class="string">"REQUIRED"</span> isolation=<span class="string">"READ_COMMITTED"</span> timeout=<span class="string">""</span> <span class="built_in">read</span>-only=<span class="string">"false"</span> no-rollback-for=<span class="string">""</span> rollback-for=<span class="string">""</span>/&gt;</span><br><span class="line">    &lt;!-- 支持,如果有就有,没有就没有 --&gt;</span><br><span class="line">    &lt;tx:method name=<span class="string">"*"</span> propagation=<span class="string">"SUPPORTS"</span>/&gt;</span><br><span class="line">  &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line">&lt;!-- 定义切入点，expression为切人点表达式，如下是指定impl包下的所有方法，具体以自身实际要求自定义  --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut expression=<span class="string">"execution(* com.loonycoder.*.service.impl.*.*(..))"</span> id=<span class="string">"pointcut"</span>/&gt;</span><br><span class="line">    &lt;!--&lt;aop:advisor&gt;定义切入点，与通知，把tx与aop的配置关联,才是完整的声明事务配置 --&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=<span class="string">"advice"</span> pointcut-ref=<span class="string">"pointcut"</span>/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li></ol><p>关于事务传播行为与隔离级别，可参考<a href="https://loonycoder.github.io/2019/04/03/spring-transcation-1/" target="_blank" rel="noopener">Spring事务隔离级别、传播行为以及Spring+Mybatis+Atomikos实现分布式事务管理</a>;</p><p><strong>注意：</strong></p><ul><li>事务回滚异常只能为RuntimeException异常，而Checked Exception异常不回滚，捕获异常不抛出也不会回滚，但可以强制事务回滚：TransactionAspectSupport.currentTransactionStatus().isRollbackOnly();</li><li>解决“自我调用”而导致的不能设置正确的事务属性问题，可参考<a href="http://www.iteye.com/topic/1122740" target="_blank" rel="noopener">http://www.iteye.com/topic/1122740</a></li></ul><ol start="2"><li>方式二通过@Transactional实现事务管理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"txManager"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;   </span><br><span class="line">     &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;    </span><br><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">"txManager"</span>/&gt; //开启事务注解</span><br></pre></td></tr></table></figure></li></ol><p>@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.READ_COMMITTED)，具体参数跟上面&lt;tx:method&gt;中一样<br>Spring提供的@Transaction注解事务管理，内部同样是利用环绕通知TransactionInterceptor实现事务的开启及关闭。<br>使用@Transactional注意点：</p><ul><li>如果在接口、实现类或方法上都指定了@Transactional 注解，则优先级顺序为方法&gt;实现类&gt;接口；</li><li>建议只在实现类或实现类的方法上使用@Transactional，而不要在接口上使用，这是因为如果使用JDK代理机制（<font style="color: red">基于接口的代理</font>）是没问题；而使用使用CGLIB代理（继承）机制时就会遇到问题，因为其使用基于类的代理而不是接口，这是因为<font style="color: red">接口上的@Transactional注解是“不能继承的”</font>；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务隔离级别、传播行为以及Spring+Mybatis+Atomikos实现分布式事务管理</title>
    <link href="/2019/04/03/spring-transcation-1/"/>
    <url>/2019/04/03/spring-transcation-1/</url>
    
    <content type="html"><![CDATA[<h4 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h4><p><strong>事务是指多个操作单元组成的合集，多个单元操作是整体不可分割的，要么都操作不成功，要么都成功。其必须遵循四个原则（ACID）。</strong></p><blockquote><p><font style="color: red"><strong>原子性（Atomicity）</strong></font>：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做；<br><font style="color: red"><strong>一致性（Consistency）</strong></font>：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数据还是应该处于正确的状态，即数据完整性约束没有被破坏；如银行转帐，A转帐给B，必须保证A的钱一定转给B，一定不会出现A的钱转了但B没收到，否则数据库的数据就处于不一致（不正确）的状态。<br><font style="color: red"><strong>隔离性（Isolation）</strong></font>：并发事务执行之间互不影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性；<br><font style="color: red"><strong>持久性（Durability）</strong></font>：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会因比如遇到系统故障或断电造成数据不一致或丢失。</p></blockquote><h4 id="事务的类型"><a href="#事务的类型" class="headerlink" title="事务的类型"></a>事务的类型</h4><ol><li>数据库分为本地事务跟全局事务<br>本地事务：普通事务，独立一个数据库，能保证在该数据库上操作的ACID。<br>分布式事务：涉及两个或多个数据库源的事务，即跨越多台同类或异类数据库的事务（由每台数据库的本地事务组成的），分布式事务旨在保证这些本地事务的所有操作的ACID，使事务可以跨越多台数据库；</li><li>Java事务类型分为JDBC事务跟JTA事务<br>JDBC事务：即为上面说的数据库事务中的本地事务，通过connection对象控制管理。<br>JTA事务：JTA指Java事务API(Java Transaction API)，是Java EE数据库事务规范， JTA只提供了事务管理接口，由应用程序服务器厂商（如WebSphere Application Server）提供实现，JTA事务比JDBC更强大，支持分布式事务。</li><li>按是否通过编程分为声明式事务和编程式事务，参考<a href="https://loonycoder.github.io/2019/04/10/spring-transcation-2/" target="_blank" rel="noopener">Spring事务管理实现方式之编程式事务与声明式事务详解</a>;<br>声明式事务：通过XML配置或者注解实现。<br>编程式事务：通过编程代码在业务逻辑时需要时自行实现，粒度更小。</li></ol><h4 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a>Spring事务隔离级别</h4><p><strong>Spring有五大隔离级别，其在TransactionDefinition接口中定义。看源码可知，其默isolation_default（底层数据库默认级别），其他四个隔离级别跟数据库隔离级别一致。</strong></p><blockquote><p><font style="color: red"><strong>ISOLATION_DEFAULT</strong></font>：用底层数据库的默认隔离级别，数据库管理员设置什么就是什么<br><font style="color: red"><strong>ISOLATION_READ_UNCOMMITTED（未提交读）</strong></font>：最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）<br><font style="color: red"><strong>ISOLATION_READ_COMMITTED（提交读）</strong></font>：一个事务提交后才能被其他事务读取到（该隔离级别禁止其他事务读取到未提交事务的数据、所以还是会造成幻读、不可重复读）、sql server默认级别<br><font style="color: red"><strong>ISOLATION_REPEATABLE_READ（可重复读）</strong></font>：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（该隔离基本可防止脏读，不可重复读（重点在修改），但会出现幻读（重点在增加与删除））（MySql默认级别，更改可通过set transaction isolation level 级别）<br><font style="color: red"><strong>ISOLATION_SERIALIZABLE（序列化）</strong></font>：代价最高最可靠的隔离级别（该隔离级别能防止脏读、不可重复读、幻读）</p><ul><li>丢失更新：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，这是由于没有加锁造成的；</li><li>幻读：同样的事务操作过程中，不同时间段多次（不同事务）读取同一数据，读取到的内容不一致（一般是行数变多或变少）。</li><li>脏读：一个事务读取到另外一个未提及事务的内容，即为脏读。</li><li>不可重复读：同一事务中，多次读取内容不一致（一般行数不变，而内容变了）。</li></ul></blockquote><p>幻读与不可重复读的区别：幻读的重点在于<font style="color: red">插入与删除</font>，即第二次查询会发现比第一次查询数据变少或者变多了，以至于给人一种幻象一样，而不可重复读重点在于<font style="color: red">修改</font>，即第二次查询会发现查询结果比第一次查询结果不一致，即第一次结果已经不可重现了。</p><p>数据库隔离级别越高，执行代价越高，并发执行能力越差，因此在实际项目开发使用时要综合考虑，为了考虑<font style="color: red">并发性能</font>一般使用提交读隔离级别，它能避免丢失更新和脏读，尽管不可重复读和幻读不能避免，但可以在可能出现的场合使用<font style="color: red">悲观锁或乐观锁</font>来解决这些问题。</p><p>悲观锁与乐观锁可参考：<a href="https://loonycoder.github.io/2019/03/25/lock/" target="_blank" rel="noopener">乐观锁与悲观锁随笔</a></p><h4 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h4><p><strong>有七大传播行为，也是在TransactionDefinition接口中定义。</strong></p><blockquote><p><font style="color: red"><strong>PROPAGATION_REQUIRED</strong></font>：支持当前事务，如当前没有事务，则新建一个。<br><font style="color: red"><strong>PROPAGATION_SUPPORTS</strong></font>：支持当前事务，如当前没有事务，则已非事务性执行（源码中提示有个注意点，看不太明白，留待后面考究）。<br><font style="color: red"><strong>PROPAGATION_MANDATORY</strong></font>：支持当前事务，如当前没有事务，则抛出异常（强制一定要在一个已经存在的事务中执行，业务方法不可独自发起自己的事务）。<br><font style="color: red"><strong>PROPAGATION_REQUIRES_NEW</strong></font>：始终新建一个事务，如当前原来有事务，则把原事务挂起。<br><font style="color: red"><strong>PROPAGATION_NOT_SUPPORTED</strong></font>：不支持当前事务，始终已非事务性方式执行，如当前事务存在，挂起该事务。<br><font style="color: red"><strong>PROPAGATION_NEVER</strong></font>：不支持当前事务；如果当前事务存在，则引发异常。<br><font style="color: red"><strong>PROPAGATION_NESTED</strong></font>：如果当前事务存在，则在嵌套事务中执行，如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作（注意：当应用到JDBC时，只适用JDBC 3.0以上驱动）。</p></blockquote><h4 id="Spring事务支持"><a href="#Spring事务支持" class="headerlink" title="Spring事务支持"></a>Spring事务支持</h4><blockquote><ol><li>Spring提供了很多内置事务管理器，支持不同数据源。常见的有三大类</li></ol></blockquote><ul><li><font style="color: red">DataSourceTransactionManager</font>：org.springframework.jdbc.datasource包下，数据源事务管理类，提供对单个javax.sql.DataSource数据源的事务管理，只要用于JDBC，Mybatis框架事务管理。</li><li><font style="color: red">HibernateTransactionManager</font>：org.springframework.orm.hibernate3包下，数据源事务管理类，提供对单个org.hibernate.SessionFactory事务支持，用于集成Hibernate框架时的事务管理；注意：该事务管理器只支持Hibernate3+版本，且Spring3.0+版本只支持Hibernate 3.2+版本；</li><li><font style="color: red">JtaTransactionManager</font>：位于org.springframework.transaction.jta包中，提供对分布式事务管理的支持，并将事务管理委托给Java EE应用服务器，或者自定义一个本地JTA事务管理器，嵌套到应用程序中。</li></ul><p>内置事务管理器都继承了抽象类AbstractPlatformTransactionManager，而AbstractPlatformTransactionManager又继承了接口PlatformTransactionManager</p><p>Spring框架支持事务管理的核心是事务管理器抽象，对于不同的数据访问框架通过实现策略接口PlatformTransactionManager，从而能支持多钟数据访问框架的事务管理。</p><p>PlatformTransactionManager接口定义如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line">         TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;//返回一个已经激活的事务或创建一个新的事务（具体由TransactionDefinition参数定义的事务属性决定），返回的TransactionStatus对象代表了当前事务的状态，其中该方法抛出TransactionException（未检查异常）表示事务由于某种原因失败。</span><br><span class="line">         void commit(TransactionStatus status) throws TransactionException;//用于提交TransactionStatus参数代表的事务。</span><br><span class="line">         void rollback(TransactionStatus status) throws TransactionException;//用于回滚TransactionStatus参数代表的事务。</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>TransactionDefinition接口定义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionDefinition &#123;  </span><br><span class="line">       int getPropagationBehavior();  //返回定义的事务传播行为</span><br><span class="line">       int getIsolationLevel(); //返回事务隔离级别</span><br><span class="line">       int getTimeout();  //返回定义的事务超时时间</span><br><span class="line">       boolean isReadOnly();  //返回定义的事务是否是只读的</span><br><span class="line">       String getName();  //返回事务名称</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionStatus接口定义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager &#123;  </span><br><span class="line">       boolean isNewTransaction();  //返回当前事务是否是新的事务</span><br><span class="line">       boolean hasSavepoint();  //返回当前事务是否有保存点</span><br><span class="line">       void setRollbackOnly();  //设置事务回滚</span><br><span class="line">       boolean isRollbackOnly();  //设置当前事务是否应该回滚</span><br><span class="line">       void flush();  //用于刷新底层会话中的修改到数据库，一般用于刷新如Hibernate/JPA的会话，可能对如JDBC类型的事务无任何影响；</span><br><span class="line">       boolean isCompleted();  //返回事务是否完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>Spring分布式事务配置</li></ol></blockquote><ul><li>引用应用服务器（如Tomcat）的JNDI数据源，间接实现JTA事务管理，依赖于应用服务器</li><li>直接集成JOTM（官网：<a href="http://jotm.objectweb.org/" target="_blank" rel="noopener">http://jotm.objectweb.org/</a>）、Atomikos（官网：<a href="https://www.atomikos.com/" target="_blank" rel="noopener">https://www.atomikos.com/</a>）提供JTA事务管理（无应用服务器支持，常用于单元测试）</li><li>使用特定于应用服务器的事务管理器，使用JTA事务的高级功能（Weblogic，Websphere）</li></ul><blockquote><p>引用应用服务器（如Tomcat）的JNDI数据源，间接实现JTA事务管理，配置如下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:jee=<span class="string">"http://www.springframework.org/schema/jee"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/jee</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/jee/spring-jee-3.0.xsd"</span>&gt;</span><br><span class="line"> &lt;!-- JNDI数据源 --&gt;</span><br><span class="line">  &lt;jee:jndi-lookup id=<span class="string">"dataSource"</span> jndi-name=<span class="string">"jdbc/test"</span>/&gt;</span><br><span class="line">    &lt;!-- JTA事务管理器  --&gt;</span><br><span class="line">  &lt;bean id=<span class="string">"txManager"</span> class=<span class="string">"org.springframework.transaction.jta.JtaTransactionManager"</span>&gt;</span><br><span class="line">  &lt;!--transactionManagerName指定JTA事务管理器的JNDI名字，从而将事务管理委托给该事务管理器  --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"transactionManagerName"</span> value=<span class="string">"java:comp/TransactionManager"</span>/&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><blockquote><p>使用Atomikos实现分布式事务管理，配置如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span><br><span class="line">xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></span><br><span class="line">xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">    xmlns:task=<span class="string">"http://www.springframework.org/schema/task"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context </span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/task</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/task/spring-task-3.0.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span></span><br><span class="line">&gt;</span><br><span class="line">     </span><br><span class="line">&lt;context:component-scan base-package=<span class="string">"com.loonycoder.*.service.impl"</span> /&gt;</span><br><span class="line">&lt;context:component-scan base-package=<span class="string">"com.loonycoder.util"</span> /&gt;</span><br><span class="line">    &lt;!-- 此方法加载的配置文件仅仅在xml中使用,但是工具类都采用注解的方式 --&gt;</span><br><span class="line">&lt;bean class=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"location"</span> value=<span class="string">"classpath:conn.properties"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 仅仅支持注解不支持在xml配置中使用properties文件  在类中可以使用SPEL表达式来加载相应的值 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"temp"</span> class=<span class="string">"org.springframework.beans.factory.config.PropertiesFactoryBean"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"locations"</span>&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;value&gt;classpath:public.properties&lt;/value&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"abstractXADataSource"</span> class=<span class="string">"com.atomikos.jdbc.AtomikosDataSourceBean"</span> init-method=<span class="string">"init"</span>  destroy-method=<span class="string">"close"</span> abstract=<span class="string">"true"</span>&gt; </span><br><span class="line">        &lt;property name=<span class="string">"borrowConnectionTimeout"</span> value=<span class="string">"60"</span>/&gt;  &lt;!--获取连接失败重新获等待最大时间，在这个时间内如果有可用连接，将返回--&gt;</span><br><span class="line">        &lt;property name=<span class="string">"reapTimeout"</span> value=<span class="string">"20"</span>/&gt; &lt;!--最大获取数据时间，如果不设置这个值，Atomikos使用默认的5分钟，那么在处理大批量数据读取的时候，一旦超过5分钟，就会抛出类似 Resultset is close 的错误.--&gt;        </span><br><span class="line">        &lt;property name=<span class="string">"maintenanceInterval"</span> value=<span class="string">"60"</span> /&gt;  &lt;!--连接回收时间--&gt;    </span><br><span class="line">        &lt;property name=<span class="string">"loginTimeout"</span> value=<span class="string">"60"</span> /&gt;     &lt;!--java数据库连接池，最大可等待获取datasouce的时间--&gt;</span><br><span class="line">        &lt;property name=<span class="string">"logWriter"</span> value=<span class="string">"60"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"minPoolSize"</span> value=<span class="string">"1"</span> /&gt;  &lt;!-- 连接池中保留的最小连接数   --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"maxPoolSize"</span> value=<span class="string">"3"</span> /&gt;  &lt;!-- 连接池中保留的最大连接数    --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"maxIdleTime"</span> value=<span class="string">"60"</span> /&gt; &lt;!-- 最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt;</span><br><span class="line">    &lt;/bean&gt; </span><br><span class="line">     &lt;!-- 配置2个数据源 mysql --&gt;</span><br><span class="line">     &lt;bean id=<span class="string">"ds_loonycoder"</span> parent=<span class="string">"abstractXADataSource"</span>&gt;  </span><br><span class="line">     &lt;!-- uniqueResourceName表示唯一资源名，如有多个数据源不可重复； --&gt;</span><br><span class="line">     &lt;property name=<span class="string">"uniqueResourceName"</span> value=<span class="string">"loonycoderfortest"</span> /&gt;</span><br><span class="line">     &lt;!--  xaDataSourceClassName是具体分布式数据源厂商实现； --&gt;</span><br><span class="line">     &lt;property name=<span class="string">"xaDataSourceClassName"</span> value=<span class="string">"com.mysql.jdbc.jdbc2.optional.MysqlXADataSource"</span>/&gt;</span><br><span class="line">     &lt;!-- xaProperties属性指定具体厂商数据库属性 --&gt;</span><br><span class="line">     &lt;property name=<span class="string">"xaProperties"</span>&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=<span class="string">"URL"</span>&gt;<span class="variable">$&#123;db.jdbcUrlOne&#125;</span>&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=<span class="string">"user"</span>&gt;<span class="variable">$&#123;user&#125;</span>&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=<span class="string">"password"</span>&gt;<span class="variable">$&#123;password&#125;</span>&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"ds_loony"</span>  parent=<span class="string">"abstractXADataSource"</span>&gt;  </span><br><span class="line">&lt;!-- uniqueResourceName表示唯一资源名，如有多个数据源不可重复； --&gt;</span><br><span class="line">&lt;property name=<span class="string">"uniqueResourceName"</span> value=<span class="string">"puildingpurchasefortest"</span> /&gt;</span><br><span class="line">&lt;!-- xaDataSourceClassName是具体分布式数据源厂商实现； --&gt;</span><br><span class="line">&lt;property name=<span class="string">"xaDataSourceClassName"</span> value=<span class="string">"com.mysql.jdbc.jdbc2.optional.MysqlXADataSource"</span>/&gt;</span><br><span class="line">&lt;!-- xaProperties属性指定具体厂商数据库属性 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"xaProperties"</span>&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=<span class="string">"URL"</span>&gt;<span class="variable">$&#123;db.jdbcUrlTwo&#125;</span>&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=<span class="string">"user"</span>&gt;<span class="variable">$&#123;user&#125;</span>&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=<span class="string">"password"</span>&gt;<span class="variable">$&#123;password&#125;</span>&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">    &lt;!-- 动态配置数据源 --&gt; </span><br><span class="line">    &lt;bean id=<span class="string">"dataSource2"</span> class=<span class="string">"com.loonycoder.common.datasource.DynamicDataSource"</span>&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"targetDataSources"</span>&gt;  </span><br><span class="line">            &lt;map key-type =<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">                &lt;entry value-ref =<span class="string">"ds_loonycoder"</span> key=<span class="string">"ds_loonycoder"</span>&gt;&lt;/entry &gt;  </span><br><span class="line">                &lt;entry value-ref =<span class="string">"ds_loony"</span> key=<span class="string">"ds_loony"</span>&gt;&lt;/entry &gt;  </span><br><span class="line">            &lt;/map &gt; </span><br><span class="line">        &lt;/property&gt;  </span><br><span class="line">        &lt;property name =<span class="string">"defaultTargetDataSource"</span> ref=<span class="string">"ds_loonycoder"</span>&gt;&lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    &lt;bean id =<span class="string">"sqlSessionFactoryBeanA"</span> class=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span> &gt;  </span><br><span class="line">       &lt;!-- 指定数据源 --&gt;  </span><br><span class="line">       &lt;property name =<span class="string">"dataSource"</span> ref=<span class="string">"ds_loonycoder"</span> /&gt;  </span><br><span class="line">       &lt;!-- 指定mybatis 的配置文件 --&gt;  </span><br><span class="line">       &lt;property name =<span class="string">"configLocation"</span> value=<span class="string">"classpath:mybatis.cfg.xml"</span> /&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id =<span class="string">"sqlSessionFactoryBeanB"</span> class=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span> &gt;  </span><br><span class="line">       &lt;!-- 指定数据源 --&gt;  </span><br><span class="line">       &lt;property name =<span class="string">"dataSource"</span> ref=<span class="string">"ds_loony"</span> /&gt;  </span><br><span class="line">       &lt;!-- 指定mybatis 的配置文件 --&gt;  </span><br><span class="line">       &lt;property name =<span class="string">"configLocation"</span> value=<span class="string">"classpath:mybatis.cfg.xml"</span> /&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--CustomSqlSessionTemplate继承SqlSessionTemplate重写getSqlSessionFactory方法，具体请下载查看--&gt; </span><br><span class="line">&lt;bean id=<span class="string">"sqlSessionTemplate"</span> class=<span class="string">"com.loonycoder.util.CustomSqlSessionTemplate"</span> scope=<span class="string">"prototype"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"sqlSessionFactoryBeanA"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"targetSqlSessionFactorys"</span>&gt;</span><br><span class="line">            &lt;map&gt;     </span><br><span class="line">                &lt;entry value-ref =<span class="string">"sqlSessionFactoryBeanA"</span> key=<span class="string">"ds_loonycoder1"</span>&gt;&lt;/entry &gt;  </span><br><span class="line">                &lt;entry value-ref =<span class="string">"sqlSessionFactoryBeanB"</span> key=<span class="string">"ds_loony1"</span>&gt;&lt;/entry &gt;  </span><br><span class="line">            &lt;/map&gt; </span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">    </span><br><span class="line">&lt;!-- 配置atomikos事务管理器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"atomikosTransactionManager"</span> class = <span class="string">"com.atomikos.icatch.jta.UserTransactionManager"</span> init-method=<span class="string">"init"</span> destroy-method = <span class="string">"close"</span>&gt;    </span><br><span class="line">      &lt;property name=<span class="string">"forceShutdown"</span> value=<span class="string">"true"</span>/&gt;    </span><br><span class="line">&lt;/bean&gt;    </span><br><span class="line">&lt;bean id=<span class="string">"atomikosUserTransaction"</span> class=<span class="string">"com.atomikos.icatch.jta.UserTransactionImp"</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!-- 配置spring事务管理器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"transactionManager"</span> class=<span class="string">"org.springframework.transaction.jta.JtaTransactionManager"</span>&gt;    </span><br><span class="line">    &lt;property name=<span class="string">"transactionManager"</span>&gt;    </span><br><span class="line">        &lt;ref bean=<span class="string">"atomikosTransactionManager"</span>/&gt;    </span><br><span class="line">    &lt;/property&gt;    </span><br><span class="line">    &lt;property name=<span class="string">"userTransaction"</span>&gt;    </span><br><span class="line">        &lt;ref bean=<span class="string">"atomikosUserTransaction"</span>/&gt;    </span><br><span class="line">    &lt;/property&gt; </span><br><span class="line">    &lt;!-- 必须设置，否则程序出现异常 JtaTransactionManager does not support custom isolation levels by default --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"allowCustomIsolationLevels"</span> value=<span class="string">"true"</span>/&gt;    </span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;tx:advice id=<span class="string">"advice"</span> transaction-manager=<span class="string">"transactionManager"</span>&gt;</span><br><span class="line">&lt;tx:attributes&gt;</span><br><span class="line">    &lt;!-- REQUIRED：必须要有事务, 如果没有就在上下文创建一个 --&gt;</span><br><span class="line">&lt;tx:method name=<span class="string">"save*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">&lt;tx:method name=<span class="string">"creat*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">&lt;tx:method name=<span class="string">"add*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">&lt;tx:method name=<span class="string">"update*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">&lt;tx:method name=<span class="string">"delete*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">&lt;!-- 支持,如果有就有,没有就没有 --&gt;</span><br><span class="line">&lt;tx:method name=<span class="string">"*"</span> propagation=<span class="string">"SUPPORTS"</span>/&gt;</span><br><span class="line">&lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut expression=<span class="string">"execution(* com.loonycoder.*.service.impl.*.*(..))"</span> id=<span class="string">"pointcut"</span>/&gt;</span><br><span class="line">    &lt;!-- 吧 tx与aop的配置关联,才是完整的声明事务配置 --&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=<span class="string">"advice"</span> pointcut-ref=<span class="string">"pointcut"</span>/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">&lt;!-- 采用包扫描机制,自动会把指定的包里面的所有dao注册 --&gt;</span><br><span class="line">&lt;bean class=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span><br><span class="line">&lt;!-- 注意注入sqlSessionTemplate --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"sqlSessionTemplateBeanName"</span> value=<span class="string">"sqlSessionTemplate"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"basePackage"</span> value=<span class="string">"com.loonycoder.*.dao"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"viewResolver"</span> class=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"viewClass"</span>&gt;</span><br><span class="line">&lt;value&gt;org.springframework.web.servlet.view.InternalResourceView&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!--jsp存放的目录--&gt;</span><br><span class="line">&lt;property name=<span class="string">"prefix"</span>&gt;</span><br><span class="line">&lt;value&gt;/&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!--jsp文件的后缀--&gt;</span><br><span class="line">&lt;property name=<span class="string">"suffix"</span>&gt;</span><br><span class="line">&lt;value&gt;.jsp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 验证码 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"captchaProducer"</span> class=<span class="string">"com.google.code.kaptcha.impl.DefaultKaptcha"</span>&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"config"</span>&gt;  </span><br><span class="line">            &lt;bean class=<span class="string">"com.google.code.kaptcha.util.Config"</span>&gt;  </span><br><span class="line">                &lt;constructor-arg&gt;  </span><br><span class="line">                    &lt;props&gt;  </span><br><span class="line">                        &lt;prop key=<span class="string">"kaptcha.border"</span>&gt;no&lt;/prop&gt;  </span><br><span class="line">                        &lt;prop key=<span class="string">"kaptcha.border.color"</span>&gt;105,179,90&lt;/prop&gt;  </span><br><span class="line">                        &lt;prop key=<span class="string">"kaptcha.textproducer.font.color"</span>&gt;red&lt;/prop&gt;  </span><br><span class="line">                        &lt;prop key=<span class="string">"kaptcha.image.width"</span>&gt;200&lt;/prop&gt;  </span><br><span class="line">                        &lt;prop key=<span class="string">"kaptcha.textproducer.font.size"</span>&gt;60&lt;/prop&gt;  </span><br><span class="line">                        &lt;prop key=<span class="string">"kaptcha.image.height"</span>&gt;80&lt;/prop&gt;  </span><br><span class="line">                        &lt;prop key=<span class="string">"kaptcha.session.key"</span>&gt;code&lt;/prop&gt;  </span><br><span class="line">                        &lt;prop key=<span class="string">"kaptcha.textproducer.char.length"</span>&gt;4&lt;/prop&gt;  </span><br><span class="line">                        &lt;prop key=<span class="string">"kaptcha.textproducer.font.names"</span>&gt;宋体,楷体,微软雅黑&lt;/prop&gt;  </span><br><span class="line">                    &lt;/props&gt;  </span><br><span class="line">                &lt;/constructor-arg&gt;  </span><br><span class="line">            &lt;/bean&gt;  </span><br><span class="line">        &lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"messageSource"</span> class=<span class="string">"org.springframework.context.support.ReloadableResourceBundleMessageSource"</span>&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"basename"</span> value=<span class="string">"classpath:messages"</span>/&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"fileEncodings"</span> value=<span class="string">"utf-8"</span>/&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"cacheSeconds"</span> value=<span class="string">"120"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐观锁与悲观锁随笔</title>
    <link href="/2019/03/25/lock/"/>
    <url>/2019/03/25/lock/</url>
    
    <content type="html"><![CDATA[<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p><strong>介绍：</strong></p><p>认为数据在使用过程中，不会被其他程序修改、所以只有在数据提交时才检测数据是否已经被修改</p><p><strong>实现方法：</strong></p><blockquote><p>1.使用版本号：给数据所在表加个字段，记录数据版本号。提交时检测版本号与未修改前的版本号一不一致。不一致说明数据已经被其他线程修改。 </p></blockquote><p><img src="/images/lock/lock1.jpg" srcset="/img/loading.gif" alt="lock"></p><blockquote><p>2.使用时间截：给数据所在表加个字段，记录时间。提交时检测时间与取出的时间截一不一致。不一致说明数据已经被其他线程修改。</p></blockquote><p><strong>使用场景：</strong></p><p>如上下级审核文件。</p><hr><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p><strong>介绍：</strong></p><p>悲观的认为数据提交时会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p><p><strong>使用方法：</strong></p><p>在准备修改某数据时，给该数据加锁，加锁失败说明有人正在占用，成功则修改数据提交，事务完成释放锁。</p><p><strong>使用场景：</strong></p><p>数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p><p><strong>注意项：</strong></p><p>MySQL InnoDB中使用悲观锁一定要关闭自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。 set autocommit=0;</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合Mybatis实现CRUD</title>
    <link href="/2019/03/16/springboot-mybatis/"/>
    <url>/2019/03/16/springboot-mybatis/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p><strong>源码地址：</strong><a href="https://github.com/LoonyCoder/Springboot-Mybatis" target="_blank" rel="noopener">SpringBoot整合Mybatis</a><br><strong>欢迎star/fork，给作者一些鼓励！</strong></p><p>继上篇文章：<a href="https://loonycoder.github.io/2019/03/06/springboot-1/" target="_blank" rel="noopener">初识Spring Boot——工程搭建</a>。这次我们整合SpringBoot-Mybatis实现简单的CRUD业务。<br><strong>项目源码</strong>请看我的Github仓库：<a href="https://github.com/LoonyCoder/ssm" target="_blank" rel="noopener">教你优雅的入门Spring Boot框架</a><br><strong>如果觉得不错就点击右上角star鼓励一下笔者吧(#^.^#)</strong></p><hr><p><img src="/images/springboot/springboot_logo.png" srcset="/img/loading.gif" alt="springboot"></p><hr><p>需求：</p><ul><li>详解SpringBoot工程的构建、与SSM项目在工程搭建上的不同。</li><li>实现SpringBoot-Mybatis整合征服数据库。</li><li>解决页面跳转，详解与SSM阶段的不同。</li><li>实现分页查询，使用PaheHelper插件和ElementUI分页控件。</li><li>实现文件上传。</li><li>使用Spring AOP切面编程实现简易的实现登录拦截工程。</li></ul><p><strong>教你优雅的入门Spring Boot框架</strong></p><p>技术栈</p><ul><li>后端： SpringBoot + Mybatis</li><li>前端： Vue.js + ElementUI</li></ul><p>测试环境</p><ul><li>IDEA + SpringBoot-2.0.5</li></ul><p>项目设计</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── db  -- sql文件</span><br><span class="line">├── mvnw </span><br><span class="line">├── mvnw.cmd</span><br><span class="line">├── pom.xml  -- 项目依赖</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   │       └── loonyCoder</span><br><span class="line">    │   │           ├── SpringbootApplication.java  -- Spring Boot启动类</span><br><span class="line">    │   │           ├── controller  -- MVC-WEB层</span><br><span class="line">    │   │           ├── entity  -- 实体类</span><br><span class="line">    │   │           ├── interceptor  -- 自定义拦截器</span><br><span class="line">    │   │           ├── mapper  -- mybatis-Mapper层接口</span><br><span class="line">    │   │           └── service  -- service业务层</span><br><span class="line">    │   └── resources  -- Spring Boot资源文件 </span><br><span class="line">    │       ├── application.yml  -- Spring Boot核心配置文件</span><br><span class="line">    │       ├── mapper  -- Mybatis Mapper层配置文件</span><br><span class="line">    │       ├── static  -- 前端静态文件</span><br><span class="line">    │       └── templates  -- Thymeleaf模板引擎识别的HTML页面目录</span><br><span class="line">    └── <span class="built_in">test</span>  -- 测试文件</span><br></pre></td></tr></table></figure><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>开始实战Spring Boot项目，首先，你需要将Spring Boot工程搭建出来。<br>Spring Boot工程搭建请看我的博客：<a href="https://loonycoder.github.io/2019/03/06/springboot-1/" target="_blank" rel="noopener">初识Spring Boot——工程搭建</a></p><h4 id="Spring-Boot应用启动器"><a href="#Spring-Boot应用启动器" class="headerlink" title="Spring Boot应用启动器"></a>Spring Boot应用启动器</h4><p>Spring Boot提供了很多应用启动器，分别用来支持不同的功能，说白了就是pom.xml中的依赖配置，因为Spring Boot的自动化配置特性，我们并不需再考虑项目依赖版本问题，使用Spring Boot的应用启动器，它能自动帮我们将相关的依赖全部导入到项目中。<br>我们这里介绍几个常见的应用启动器：</p><ul><li>spring-boot-starter: Spring Boot的核心启动器，包含了自动配置、日志和YAML</li><li>spring-boot-starter-aop: 支持AOP面向切面编程的功能，包括spring-aop和AspecJ</li><li>spring-boot-starter-cache: 支持Spring的Cache抽象</li><li>spring-boot-starter-artermis: 通过Apache Artemis支持JMS（Java Message Service）的API</li><li>spring-boot-starter-data-jpa: 支持JPA</li><li>spring-boot-starter-data-solr: 支持Apache Solr搜索平台，包括spring-data-solr</li><li>spring-boot-starter-freemarker: 支持FreeMarker模板引擎</li><li>spring-boot-starter-jdbc: 支持JDBC数据库</li><li>spring-boot-starter-Redis: 支持Redis键值储存数据库，包括spring-redis</li><li>spring-boot-starter-security: 支持spring-security</li><li>spring-boot-starter-thymeleaf: 支持Thymeleaf模板引擎，包括与Spring的集成</li><li>spring-boot-starter-web: 支持全栈式web开发，包括tomcat和Spring-WebMVC</li><li>spring-boot-starter-log4j: 支持Log4J日志框架</li><li>spring-boot-starter-logging: 引入Spring Boot默认的日志框架Logback</li></ul><h4 id="Spring-Boot项目结构设计"><a href="#Spring-Boot项目结构设计" class="headerlink" title="Spring Boot项目结构设计"></a>Spring Boot项目结构设计</h4><p>Spring Boot项目（即Maven项目），当然拥有最基础的Maven项目结构。除此之外：</p><ol><li>Spring Boot项目中不包含webapp(webroot)目录。</li><li>Spring Boot默认提供的静态资源目录需要置于classpath下，且其下的目录名称要符合一定规定。</li><li>Spring Boot默认不提倡用XML配置文件，主张使用YML作为配置文件格式，YML有更简洁的语法。当然也可以使用.properties作为配置文件格式。</li><li>Spring Boot官方推荐使用Thymeleaf作为前端模板引擎，并且Thymeleaf默认将templates作为静态页面的存放目录（由配置文件指定）。</li><li>Spring Boot默认将resources作为静态资源的存放目录，存放前端静态文件、项目配置文件。</li><li>Spring Boot规定resources下的子级目录名要符合一定规则，一般我们设置resources/static为前端静态（JS,CSS）的存放目录；设置resources/templates作为HTML页面的存放目录。</li><li>Spring Boot指定的Thymeleaf模板引擎文件目录/resources/templates是受保护的目录，想当与之前的WEB-INF文件夹，里面的静态资源不能直接访问，一般我们通过Controller映射访问。</li><li>建议将Mybatis-Mapper的XML映射文件放于resources/目录下，我这里设为resources/mapper目录，且src/main/java/Mapper下的Mapper层接口要使用@Mapper注解标识，不然mybatis找不到接口对应的XML映射文件。</li><li>SpringBootApplication.java为项目的启动器类，项目不需要部署到Tomcat上，由SpringBoot提供的服务器部署项目（运行启动器类即可）；且SpringBoot会自动扫描该启动器同级和子级下用注解标识的Bean。</li><li>Spring Boot不建议使用JSP页面，如果想使用，请自行百度解决办法。</li><li>上面说了Spring Boot提供的存放HTML静态页面的目录resources/templates是受保护的目录，访问其中的HTML页面要通过Controller映射，这就间接规定了你需要配置Spring的视图解析器，且Controller类不能使用@RestController标识。</li></ol><h4 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h4><p>首先： 我想特殊强调的是：<strong>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式。</strong>一定要切记这一点。<br>学习SpringBoot框架，只是为了更简便的使用Spring框架，我们在SSM阶段学习的知识现在放在Spring Boot框架上开发是完全适用的，我们学习的大多数是SpringBoot的自动化配置方式。<br>因为Spring Boot框架的一大优势就是自动化配置，从pom.xml的配置中就能明显感受到。</p><h4 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.loonycoder&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;springboot&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project <span class="keyword">for</span> Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- spring-aop支持 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;!--&lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;--&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- alibaba的druid数据库连接池 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.9&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 分页插件 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- fastjson --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;fork&gt;<span class="literal">true</span>&lt;/fork&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><p>建表语句及准备数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">-- CREATE DATABASE springboot DEFAULT CHARACTER SET utf8;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS tb_user;</span><br><span class="line">DROP TABLE IF EXISTS tb_goods;</span><br><span class="line"></span><br><span class="line">-- 用户表</span><br><span class="line">CREATE TABLE tb_user(</span><br><span class="line">  id BIGINT AUTO_INCREMENT COMMENT <span class="string">'编号'</span>,</span><br><span class="line">  username VARCHAR(100) COMMENT <span class="string">'用户名'</span>,</span><br><span class="line">  password VARCHAR(100) COMMENT <span class="string">'密码'</span>,</span><br><span class="line">  CONSTRAINT pk_sys_user PRIMARY KEY(id)</span><br><span class="line">) CHARSET=utf8 ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">INSERT INTO tb_user VALUES(1, <span class="string">'loonycoder'</span>, <span class="string">'123'</span>);</span><br><span class="line">INSERT INTO tb_user VALUES(2, <span class="string">'望月'</span>, <span class="string">'123'</span>);</span><br><span class="line"></span><br><span class="line">-- 商品表</span><br><span class="line">CREATE TABLE tb_goods(</span><br><span class="line">  id BIGINT AUTO_INCREMENT COMMENT <span class="string">'编号'</span>,</span><br><span class="line">  title VARCHAR(1000) COMMENT <span class="string">'商品标题'</span>,</span><br><span class="line">  price VARCHAR(100) COMMENT <span class="string">'商品价格'</span>,</span><br><span class="line">  image VARCHAR(1000) COMMENT <span class="string">'商品图片'</span>,</span><br><span class="line">  brand VARCHAR(100) COMMENT <span class="string">'商品品牌'</span>,</span><br><span class="line">  CONSTRAINT pk_sys_user PRIMARY KEY(id)</span><br><span class="line">) CHARSET=utf8 ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line"></span><br><span class="line">INSERT INTO `tb_goods` VALUES (974401, <span class="string">'苹果(Apple) iPhone 5s (A1533) 16GB 银色 电信3G手机'</span>, 4099.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3160/284/298314156/78089/fd106c0c/57b00f93Nc77f215f.jpg'</span>, <span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (975641, <span class="string">'苹果(Apple) iPhone 5s (A1533) 16GB 金色 电信3G手机'</span>, 4099.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3160/284/298314156/78089/fd106c0c/57b00f93Nc77f215f.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (976898, <span class="string">'苹果 iPhone 4S 8G 白色 联通3G手机'</span>, 1999.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3712/359/495301542/119558/da44ceda/580cb3adN14e04e47.jpg'</span>, <span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1057740, <span class="string">'苹果(Apple) iPhone 5s (A1530) 16GB 深空灰色 移动联通4G手机'</span>, 4129.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3160/284/298314156/78089/fd106c0c/57b00f93Nc77f215f.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1057741, <span class="string">'苹果(Apple) iPhone 5s (A1530) 16GB 银色 移动联通4G手机'</span>, 4119.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3160/284/298314156/78089/fd106c0c/57b00f93Nc77f215f.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1057746, <span class="string">'苹果(Apple) iPhone 5s (A1530) 16GB 金色 移动联通4G手机'</span>, 4119.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3160/284/298314156/78089/fd106c0c/57b00f93Nc77f215f.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217493, <span class="string">'苹果（Apple）iPhone 6 (A1589) 16GB 金色 移动4G手机'</span>, 5088.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217494, <span class="string">'苹果（Apple）iPhone 6 (A1589) 16GB 深空灰色 移动4G手机'</span>, 4999.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217499, <span class="string">'苹果（Apple）iPhone 6 (A1586) 16GB 金色 移动联通电信4G手机'</span>, 5288.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217500, <span class="string">'苹果（Apple）iPhone 6 (A1586) 16GB 深空灰色 移动联通电信4G手机'</span>, 5288.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217501, <span class="string">'苹果（Apple）iPhone 6 (A1586) 16GB 银色 移动联通电信4G手机'</span>, 5288.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217508, <span class="string">'苹果（Apple）iPhone 6 (A1586) 64GB 金色 移动联通电信4G手机'</span>, 5988.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217509, <span class="string">'苹果（Apple）iPhone 6 (A1586) 64GB 深空灰色 移动联通电信4G手机'</span>, 5988.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217510, <span class="string">'苹果（Apple）iPhone 6 (A1586) 64GB 银色 移动联通电信4G手机'</span>, 5988.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217516, <span class="string">'苹果（Apple）iPhone 6 (A1586) 128GB 金色 移动联通电信4G手机'</span>, 6488.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217517, <span class="string">'苹果（Apple）iPhone 6 (A1586) 128GB 深空灰色 移动联通电信4G手机'</span>, 6488.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217518, <span class="string">'苹果（Apple）iPhone 6 (A1586) 128GB 银色 移动联通电信4G手机'</span>, 6488.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217524, <span class="string">'苹果（Apple）iPhone 6 Plus (A1524) 16GB 金色 移动联通电信4G手机'</span>, 6088.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217525, <span class="string">'苹果（Apple）iPhone 6 Plus (A1524) 16GB 深空灰色 移动联通电信4G手机'</span>, 5888.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217526, <span class="string">'苹果（Apple）iPhone 6 Plus (A1524) 16GB 银色 移动联通电信4G手机'</span>, 5988.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217533, <span class="string">'苹果（Apple）iPhone 6 Plus (A1524) 64GB 深空灰色 移动联通电信4G手机'</span>, 6788.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217534, <span class="string">'苹果（Apple）iPhone 6 Plus (A1524) 64GB 银色 移动联通电信4G手机'</span>, 6788.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217539, <span class="string">'苹果（Apple）iPhone 6 Plus (A1524) 128GB 金色 移动联通电信4G手机'</span>, 7388.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1217540, <span class="string">'苹果（Apple）iPhone 6 Plus (A1524) 128GB 深空灰色 移动联通电信4G手机'</span>, 7388.00, <span class="string">'http://img11.360buyimg.com/n1/s450x450_jfs/t3286/138/5179502023/67325/93373553/585b52b7N8d296f80.jpg'</span>,<span class="string">'苹果'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (691300, <span class="string">'三星 B9120 钛灰色 联通3G手机 双卡双待双通'</span>, 4399.00, <span class="string">'http://img10.360buyimg.com/n1/s450x450_jfs/t3457/294/236823024/102048/c97f5825/58072422Ndd7e66c4.jpg'</span>,<span class="string">'三星'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (738388, <span class="string">'三星 Note II (N7100) 云石白 联通3G手机'</span>, 1699.00, <span class="string">'http://img10.360buyimg.com/n1/s450x450_jfs/t3457/294/236823024/102048/c97f5825/58072422Ndd7e66c4.jpg'</span>,<span class="string">'三星'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (741524, <span class="string">'三星 Note II (N7100) 钛金灰 联通3G手机'</span>, 1699.00, <span class="string">'http://img10.360buyimg.com/n1/s450x450_jfs/t3457/294/236823024/102048/c97f5825/58072422Ndd7e66c4.jpg'</span>, <span class="string">'三星'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (816448, <span class="string">'三星 Note II (N7100) 钻石粉 联通3G手机'</span>, 1699.00, <span class="string">'http://img10.360buyimg.com/n1/s450x450_jfs/t3457/294/236823024/102048/c97f5825/58072422Ndd7e66c4.jpg'</span>, <span class="string">'三星'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1124089, <span class="string">'华为 Ascend P7 (P7-L00) 黑色 联通4G手机 双卡双待双通'</span>, 2388.00, <span class="string">'http://img12.360buyimg.com/n1/s450x450_jfs/t3034/299/2060854617/119711/577e85cb/57d11b6cN1fd1194d.jpg'</span>, <span class="string">'华为'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1124090, <span class="string">'华为 Ascend P7 (P7-L00) 白色 联通4G手机 双卡双待双通'</span>, 2388.00, <span class="string">'http://img12.360buyimg.com/n1/s450x450_jfs/t3034/299/2060854617/119711/577e85cb/57d11b6cN1fd1194d.jpg'</span>,<span class="string">'华为'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1124331, <span class="string">'华为 Ascend P7 (P7-L05/L07) 黑色 移动4G手机'</span>, 2388.00, <span class="string">'http://img12.360buyimg.com/n1/s450x450_jfs/t3034/299/2060854617/119711/577e85cb/57d11b6cN1fd1194d.jpg'</span>,<span class="string">'华为'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1124332, <span class="string">'华为 Ascend P7 (P7-L05/L07) 白色 移动4G手机'</span>, 2388.00, <span class="string">'http://img12.360buyimg.com/n1/s450x450_jfs/t3034/299/2060854617/119711/577e85cb/57d11b6cN1fd1194d.jpg'</span>,<span class="string">'华为'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1124365, <span class="string">'华为 Ascend P7 (P7-L09) 白 电信4G手机 双卡双待双通'</span>, 2388.00, <span class="string">'http://img12.360buyimg.com/n1/s450x450_jfs/t3034/299/2060854617/119711/577e85cb/57d11b6cN1fd1194d.jpg'</span>,<span class="string">'华为'</span>);</span><br><span class="line">INSERT INTO `tb_goods` VALUES (1124369, <span class="string">'华为 Ascend P7 (P7-L09) 黑 电信4G手机 双卡双待双通'</span>, 2388.00, <span class="string">'http://img12.360buyimg.com/n1/s450x450_jfs/t3034/299/2060854617/119711/577e85cb/57d11b6cN1fd1194d.jpg'</span>,<span class="string">'华为'</span>);</span><br></pre></td></tr></table></figure><h4 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h4><p>之前已经说过：<strong>SpringBoot框架不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</strong><br>所以说，SpringBoot整合Mybatis的思想和Spring整合Mybatis的思想基本相同，不同之处有两点：</p><ul><li>1.Mapper接口的XML配置文件变化。之前我们使用Mybatis接口代理开发，规定Mapper映射文件要和接口在一个目录下；而这里Mapper映射文件置于resources/mapper/下，且置于src/main/java/下的Mapper接口需要用@Mapper注解标识，不然映射文件与接口无法匹配。</li><li>2.SpringBoot建议使用YAML作为配置文件，它有更简便的配置方式。所以整合Mybatis在配置文件上有一定的区别，但最终都是那几个参数的配置。<br>关于YAML的语法请自行百度，我这里也仅仅是满足基本的配置需求，不涉及那种不易理解的语法。</li></ul><h5 id="整合配置文件"><a href="#整合配置文件" class="headerlink" title="整合配置文件"></a>整合配置文件</h5><p>在Spring阶段用XML配置mybatis无非就是配置：1.连接池；2.数据库url连接；3.mysql驱动；4.其他初始化配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    name: springboot</span><br><span class="line">    <span class="built_in">type</span>: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    <span class="comment">#druid相关配置</span></span><br><span class="line">    druid:</span><br><span class="line">      <span class="comment">#监控统计拦截的filters</span></span><br><span class="line">      filter: <span class="built_in">stat</span></span><br><span class="line">      <span class="comment">#mysql驱动</span></span><br><span class="line">      driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">      <span class="comment">#基本属性</span></span><br><span class="line">      url: jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=<span class="literal">true</span>&amp;characterEncoding=UTF-8&amp;allowMultiQueries=<span class="literal">true</span></span><br><span class="line">      username: root</span><br><span class="line">      password: root</span><br><span class="line">      <span class="comment">#配置初始化大小/最小/最大</span></span><br><span class="line">      initial-size: 1</span><br><span class="line">      min-idle: 1</span><br><span class="line">      max-active: 20</span><br><span class="line">      <span class="comment">#获取连接等待超时时间</span></span><br><span class="line">      max-wait: 60000</span><br><span class="line">      <span class="comment">#间隔多久进行一次检测，检测需要关闭的空闲连接</span></span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line"></span><br><span class="line">  thymeleaf:</span><br><span class="line">    prefix: classpath:/templates/</span><br><span class="line">    check-template-location: <span class="literal">true</span></span><br><span class="line">    suffix: .html</span><br><span class="line">    encoding: UTF-8</span><br><span class="line">    mode: LEGACYHTML5</span><br><span class="line">    cache: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#文件上传相关设置</span></span><br><span class="line">  servlet:</span><br><span class="line">    multipart:</span><br><span class="line">      max-file-size: 10Mb</span><br><span class="line">      max-request-size: 100Mb</span><br><span class="line"></span><br><span class="line">  <span class="comment">#devtools插件</span></span><br><span class="line">  devtools:</span><br><span class="line">    livereload:</span><br><span class="line">      enabled: <span class="literal">true</span> <span class="comment">#是否支持livereload</span></span><br><span class="line">      port: 35729</span><br><span class="line">    restart:</span><br><span class="line">      enabled: <span class="literal">true</span> <span class="comment">#是否支持热部署</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#spring-aop配置</span></span><br><span class="line">  aop:</span><br><span class="line">    <span class="comment">#启用@Aspectj注解驱动的切面，允许Spring创建基于类的代理</span></span><br><span class="line">    auto: <span class="literal">true</span></span><br><span class="line">    proxy-target-class: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#mybatis配置</span></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  <span class="built_in">type</span>-aliases-package: com.loonycoder.entity</span><br><span class="line"></span><br><span class="line"><span class="comment">#mybaatis分页插件pagehelper设置</span></span><br><span class="line">pagehelper:</span><br><span class="line">  pagehelperDialect: mysql</span><br><span class="line">  reasonable: <span class="literal">true</span></span><br><span class="line">  support-methods-arguments: <span class="literal">true</span></span><br><span class="line">  <span class="comment">#params: count=countSql</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ol><li>我们实现的是spring-mybatis的整合，包含mybatis的配置以及datasource数据源的配置当然属于spring配置中的一部分，所以需要在spring:下。</li><li>mapper-locations相当于XML中的<code>&lt;property name="mapperLocations"&gt;</code>用来扫描Mapper层的配置文件，由于我们的配置文件在resources下，所以需要指定classpath:。</li><li>type-aliases-package相当与XML中<code>&lt;property name="typeAliasesPackase"&gt;</code>别名配置，一般取其下实体类类名作为别名。</li><li>datasource数据源的配置，name表示当前数据源的名称，类似于之前的<code>&lt;bean id="dataSource"&gt;</code>id属性，这里可以任意指定，因为我们无需关注Spring是怎么注入这个Bean对象的。</li><li>druid代表本项目中使用了阿里的druid连接池，driver-class-name:相当于XML中的<code>&lt;property name="driverClassName"&gt;</code>；url代表XML中的<code>&lt;property name="url"&gt;</code>；username代表XML中的<code>&lt;property name="username"&gt;</code>；password代表XML中的<code>&lt;property name="password"&gt;</code>；其他druid的私有属性配置不再解释。这里注意druid连接池和c3p0连接池在XML的的name中就不同，在此处SpringBoot的配置中当然名称也不同。</li></ol><p>如果Spring整合Mybtis的配置你已经很熟悉了，那么这个配置你肯定也很眼熟，从英文名称上就很容易区分出来。这里需要注意的就是YAML语法规定不同行空格代表了不同的层级结构。<br>既然完成了SpringBoot-Mybatis基本配置下面我们实战讲解如何实现基本的CRUD。</p><h4 id="实现查询"><a href="#实现查询" class="headerlink" title="实现查询"></a>实现查询</h4><blockquote><ol><li>在src/main/java/com/loonycoder/entity/下新建User.java实体类</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private Long id; //编号</span><br><span class="line">    private String username; //用户名</span><br><span class="line">    private String password; //密码</span><br><span class="line">    //getter/setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>在src/main/java/com/loonycoder/service/下创建BaseService.java通用接口，目的是简化service层接口基本CRUD方法的编写。</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface BaseService&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 查询所有</span><br><span class="line">    List&lt;T&gt; findAll();</span><br><span class="line"></span><br><span class="line">    //根据ID查询</span><br><span class="line">    List&lt;T&gt; findById(Long id);</span><br><span class="line"></span><br><span class="line">    //添加</span><br><span class="line">    void create(T t);</span><br><span class="line"></span><br><span class="line">    //删除（批量）</span><br><span class="line">    void delete(Long... ids);</span><br><span class="line"></span><br><span class="line">    //修改</span><br><span class="line">    void update(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是我对Service层基本CRUD接口的简易封装，使用了泛型类，其继承接口指定了什么泛型，T就代表什么类。</p><blockquote><ol start="3"><li>在src/main/java/com/loonycoder/service/下创建UserService.java接口：</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService extends BaseService&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>在src/main/java/com/loonycoder/service/impl/下创建UserServiceImpl.java实现类：</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;User&gt; <span class="function"><span class="title">findAll</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> userMapper.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    List&lt;T&gt; findById(Long id)&#123;</span><br><span class="line">    <span class="built_in">return</span> userMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void create(T t)&#123;</span><br><span class="line">    userMapper.create(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void delete(Long... ids)&#123;</span><br><span class="line">    userMapper.delete(ds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void update(T t)&#123;</span><br><span class="line">    userMapper.update(t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="5"><li>在src/main/java/com/loonycoder/mapper/下创建UserMapper.javaMapper接口类：</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">    List&lt;T&gt; findById(Long id);</span><br><span class="line">    void create(T t);</span><br><span class="line">    void delete(Long... ids);</span><br><span class="line">    void update(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们一定要使用@Mapper接口标识这个接口，不然Mybatis找不到其对应的XML映射文件。</p><blockquote><ol start="6"><li>在src/main/resources/mapper/下创建UserMapper.xml映射文件：</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.mapper.UserMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 查询所有 --&gt;</span><br><span class="line">    &lt;select id=<span class="string">"findAll"</span> resultType=<span class="string">"com.loonycoder.entity.User"</span>&gt;</span><br><span class="line">        SELECT * FROM tb_user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><blockquote><ol start="7"><li>在src/main/java/com/loonycoder/controller/admin/下创建UserController.java</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(<span class="string">"/findAll"</span>)</span><br><span class="line">    public List&lt;User&gt; <span class="function"><span class="title">findAll</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> userService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="8"><li>src/main/java/com/loonycoder/Application.java的main方法，启动springboot</li></ol></blockquote><p>在浏览器上访问localhost:8080/findAll即可得到一串JSON数据。</p><h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><p>看了上面一步步的讲解。你应该明白了，其实和SSM阶段的CRUD基本相同，这里我就不再举例其他方法。<br>下面我们讲解一下不同的地方：</p><h4 id="实现页面跳转"><a href="#实现页面跳转" class="headerlink" title="实现页面跳转"></a>实现页面跳转</h4><p>因为Thymeleaf指定的目录src/main/resources/templates/是受保护的目录，其下的资源不能直接通过浏览器访问，可以使用Controller映射的方式访问，怎么映射呢？</p><blockquote><ol><li>在application.yml中添加配置</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  thymeleaf:</span><br><span class="line">    prefix: classpath:/templates/</span><br><span class="line">    check-template-location: <span class="literal">true</span></span><br><span class="line">    suffix: .html</span><br><span class="line">    encoding: UTF-8</span><br><span class="line">    mode: LEGACYHTML5</span><br><span class="line">    cache: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>指定Thymeleaf模板引擎扫描resources下的templates文件夹中已.html结尾的文件。这样就实现了MVC中关于视图解析器的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置视图解析器 --&gt;</span><br><span class="line">&lt;bean class=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>是不是感觉方便很多呢？但这里需要注意的是：classpath:后的目录地址一定要先加/，比如目前的classpath:/templates/。</p><blockquote><ol start="2"><li>在Controller添加映射方法</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;)</span><br><span class="line">public String <span class="function"><span class="title">index</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"home/index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，访问localhost:8080/index将直接跳转到resources/templates/home/index.html页面。</p><h5 id="实现分页查询"><a href="#实现分页查询" class="headerlink" title="实现分页查询"></a>实现分页查询</h5><p>首先我们需要在application.yml中配置pageHelper插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pagehelper:</span><br><span class="line">  pagehelperDialect: mysql</span><br><span class="line">  reasonable: <span class="literal">true</span></span><br><span class="line">  support-methods-arguments: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我这里使用了Mybatis的PageHelper分页插件，前端使用了ElementUI自带的分页插件。</p><p><strong>核心配置：</strong></p><p>UserServiceImp.java</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public PageBean findByPage(Goods goods, int pageCode, int pageSize) &#123;</span><br><span class="line">    //使用Mybatis分页插件</span><br><span class="line">    PageHelper.startPage(pageCode, pageSize);</span><br><span class="line"></span><br><span class="line">    //调用分页查询方法，其实就是查询所有数据，mybatis自动帮我们进行分页计算</span><br><span class="line">    Page&lt;Goods&gt; page = goodsMapper.findByPage(goods);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> new PageBean(page.getTotal(), page.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现文件上传"><a href="#实现文件上传" class="headerlink" title="实现文件上传"></a>实现文件上传</h4><p>这里涉及的无非就是SpringMVC的文件上传，本项目中前端使用了ElementUI+Vue.JS技术。<br>除了代码的编写，这里还要在application.yml中进行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  servlet:</span><br><span class="line">    multipart:</span><br><span class="line">      max-file-size: 10Mb</span><br><span class="line">      max-request-size: 100Mb</span><br></pre></td></tr></table></figure><p>这就相当于SpringMVC的XML配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"multipartResolver"</span> class=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"maxUploadSize"</span> value=<span class="string">"500000"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="使用Spring-AOP切面编程实现简单的登录拦截器"><a href="#使用Spring-AOP切面编程实现简单的登录拦截器" class="headerlink" title="使用Spring AOP切面编程实现简单的登录拦截器"></a>使用Spring AOP切面编程实现简单的登录拦截器</h4><p>本项目，我们先不整合Shiro和Spring Security这些安全框架，使用Spring AOP切面编程思想实现简单的登录拦截：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(<span class="string">"within (com.loonycoder.controller..*) &amp;&amp; !within(com.loonycoder.admin.LoginController)"</span>)</span><br><span class="line">    public void <span class="function"><span class="title">pointCut</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Around(<span class="string">"pointCut()"</span>)</span><br><span class="line">    public Object trackInfo(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        User user = (User) request.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == null) &#123;</span><br><span class="line">            attributes.getResponse().sendRedirect(<span class="string">"/login"</span>); //手动转发到/login映射路径</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li>关于Spring AOP的切面编程请自行百度，或者你也可以看我的博客：Spring AOP思想。我们需要注意以下几点<br>一定要熟悉AspectJ的切点表达式，在这里：..*表示其目录下的所有方法和子目录方法。</li><li>如果进行了登录拦截，即在session中没有获取到用户的登录信息，我们可能需要手动转发到login页面，这里访问的是login映射。</li><li>基于2，一定要指定Object返回值，若AOP拦截的Controller return了一个视图地址，那么本来Controller应该跳转到这个视图地址的，但是被AOP拦截了，那么原来Controller仍会执行return，但是视图地址却找不到404了。</li><li>切记一定要调用proceed()方法，proceed()：执行被通知的方法，如不调用将会阻止被通知的方法的调用，也就导致Controller中的return会404。</li></ol><h4 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h4><p><img src="/images/sbm/sbm1.png" srcset="/img/loading.gif" alt="springboot"></p><p><img src="/images/sbm/sbm2.png" srcset="/img/loading.gif" alt="springboot"></p><p><img src="/images/sbm/sbm3.png" srcset="/img/loading.gif" alt="springboot"></p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java框架</tag>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Spring Boot——工程搭建</title>
    <link href="/2019/03/06/springboot-1/"/>
    <url>/2019/03/06/springboot-1/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>源码地址：<a href="https://github.com/LoonyCoder/springboot" target="_blank" rel="noopener">SpringBoot搭建</a><br>欢迎star/fork，给作者一些鼓励！</p><hr><p><img src="/images/springboot/springboot_logo.png" srcset="/img/loading.gif" alt="springboot"></p><h4 id="初识Spring-Boot"><a href="#初识Spring-Boot" class="headerlink" title="初识Spring Boot"></a>初识Spring Boot</h4><p>在之前我们一直使用Spring、SpringMVC、Mybatis进行开发，的确，Spring让我们认识到了项目开发原来可以这么方便。但是大量的配置文件却是令人头痛的，即使我们想写一个简单的请求映射并在浏览器上发送Get请求测试，那么需要：<br>1.在web.xml中配置DispatcherServlet;<br>2.在application.xml中配置注解扫描、注解驱动。可以看到：虽然Spring是轻量级的，但是Spring的配置却是重量级的。并且搭建每个Spring项目我们都需要考虑依赖版本是否冲突的问题等。</p><p>So，SpringBoot将这一切都解决了。SpringBoot提供了一种固定的、约定优于配置风格的框架，让开发者能更快的创建基于Spring的应用程序和服务。</p><p>SpringBoot有如下特性：</p><ul><li>更高效的创建基于Spring的应用服务</li><li>无需XML配置，可以修改默认值来满足特定的需求</li><li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全</li><li>Spring Boot并不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</li></ul><h4 id="SpringBoot项目搭建"><a href="#SpringBoot项目搭建" class="headerlink" title="SpringBoot项目搭建"></a>SpringBoot项目搭建</h4><p><strong>这里我选择使用IDEA来创建SpringBoot项目：</strong></p><blockquote><p>1.选择Spring Initializr，并选择本地的JDK版本</p></blockquote><p><img src="/images/springboot/springboot1.png" srcset="/img/loading.gif" alt="springboot"></p><blockquote><p>2.Next，指定Group和Artifact名称，并选择本机JDK版本</p></blockquote><p><img src="/images/springboot/springboot2.png" srcset="/img/loading.gif" alt="springboot"></p><blockquote><p>3.选择项目所需依赖</p></blockquote><p><img src="/images/springboot/springboot3.png" srcset="/img/loading.gif" alt="springboot"></p><p><strong>解释：</strong></p><ul><li>Spring Boot DevTools: SpringBoot提供的热部署插件，可以避免每次修改代码都要重新启动项目。。</li><li>Lomback: 使用Lomback可以减少项目中很多重复代码的书写，比如getter/setter/toString等方法的书写（虽然这些可能我们都是用的快捷键生成的代码）。具体用法可以参考博文：lomback介绍</li><li>Thymeleaf: 语法的支持<br>注意： 以上依赖非必选，如果仅仅想尝试一下Spring Boot-HelloWorld，只需要选择其中的web依赖即可。</li></ul><h4 id="SpringBoot起步"><a href="#SpringBoot起步" class="headerlink" title="SpringBoot起步"></a>SpringBoot起步</h4><p><img src="/images/springboot/springboot4.png" srcset="/img/loading.gif" alt="springboot"></p><p>以上是新创建的Spring Boot项目。在SpringBoot中有一个启动器（引导类）的概念，我们首先看一下Application.java:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.spring;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，仅是一个简单的main方法，其中最核心的就是@SpringBootApplication注解，它是一下三个注解的总和：</p><ul><li>@Configuration: 用于定义一个配置类。</li><li>@EnableAutoConfiguration: SpringBoot会自动根据你的jar包依赖来自动配置项目。</li><li>@ComponentSacn: 告诉Spring哪个packages的用注解标识的类会被Spring自动扫描并且转入Bean容器。<br>通过以上三个注解你就应该了解到了SpringBoot的作用：自动化配置项目。之前我们要手动进行的XML配置在这里仅需要这一个注解就完成了。且SpringBoot项目不需要单独部署到Tomcat中才能启动，通过这个启动器，SpringBoot会自动构建一个web容器，并将项目部署到其中。</li></ul><p>So,</p><blockquote><p>Run SpringBootApplication</p></blockquote><p><img src="/images/springboot/springboot5.png" srcset="/img/loading.gif" alt="springboot"></p><p>发现报错，说DataSource数据源的url地址没有配置。之前我们提到了SpringBoot的特性就是自动化配置，它会根据你的依赖文件来配置项目，我们再看一下我们的pom.xml：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.4.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.loonycoder&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;spring&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project <span class="keyword">for</span> Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>其中最上层的&lt;parent&gt;节点约束了整个下面所有spring-boot依赖的版本，即这里使用了SpringBoot-2.2.4。然后关注&lt;dependencies&gt;节点下的前四个依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Spring Boot应用启动器</p><ul><li>spring-boot-starter: Spring Boot的核心启动器，包含了自动配置、日志和YAML。</li><li>spring-boot-starter-jdbc: 支持JDBC数据库。</li><li>spring-boot-starter-thymeleaf: 支持Thymeleaf模板引擎，包括与Spring的集成。</li><li>spring-boot-starter-web: 支持全栈式开发，包括Tomcat和Spring-WebMVC。</li><li>mybatis-spring-boot-starter: 整合spring-mybatis依赖。<br>前面我们强调的一点是Spring Boot能实现自动化配置，那么项目的依赖就决定了Spring Boot将如何自动配置项目，Spring Boot的启动器就决定了项目会以什么样的配置启动项目；如此，我们会明白这个报错是为什么了。<br>因为我们配置配置JDBC连接的数据库，所以报错，注释掉spring-boot-starter-jdbc和mybatis-spring-boot-starter依赖，再次启动SpringBootApplication:</li></ul><p><img src="/images/springboot/springboot6.png" srcset="/img/loading.gif" alt="springboot"></p><p>启动成功。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在src/main/java/com/loonycoder/springboot/下创建controller文件夹并创建LoginController.java类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class LoginController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">"/login"</span>)</span><br><span class="line">    public String login(@RequestParam(<span class="string">"username"</span>) String username, @RequestParam(<span class="string">"password"</span>) String password) &#123;</span><br><span class="line">        System.out.println(<span class="string">"username:"</span> + username + <span class="string">", password:"</span> + password);</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上就完成了在SSM阶段一个最基本的SpringMVC Controller映射方法的书写，那么测试一下：<br>在浏览器上访问：</p><blockquote><p>localhost:8080/login?username=loonycoder&amp;password=1234</p></blockquote><p>后端即可接收到username和password参数。<br><img src="/images/springboot/springboot7.png" srcset="/img/loading.gif" alt="springboot"></p><p>这时你会发现，SpringBoot内置的Web容器默认访问地址就是8080端口，如果想改变这个默认端口，修改src/main/resources/application.properties：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8088</span><br></pre></td></tr></table></figure><p>重启SpringbootApplication，访问：localhost:8088/login?username=loonycoder&amp;password=1234</p><h4 id="读取配置文件信息"><a href="#读取配置文件信息" class="headerlink" title="读取配置文件信息"></a>读取配置文件信息</h4><p>在src/main/resources/application.properties中添加配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=http://111.229.232.226</span><br></pre></td></tr></table></figure><p>在LoginController.java中添加映射方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class LoginController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">"/blog"</span>)</span><br><span class="line">    public String <span class="function"><span class="title">login</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> environment.getProperty(<span class="string">"url"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring提供的Environment类用户读取配置文件中参数，访问：localhost:8088/blog即可得到。</p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java框架</tag>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出JVM虚拟机——JVM调优</title>
    <link href="/2019/02/27/jvm-2/"/>
    <url>/2019/02/27/jvm-2/</url>
    
    <content type="html"><![CDATA[<p><strong>参考文章:</strong> <a href="https://www.jianshu.com/p/aaee11115f37" target="_blank" rel="noopener">JVM调优指南</a></p><hr><h3 id="JVM参数的类型"><a href="#JVM参数的类型" class="headerlink" title="JVM参数的类型"></a>JVM参数的类型</h3><h4 id="标准参数：在各jdk版本中较稳定"><a href="#标准参数：在各jdk版本中较稳定" class="headerlink" title="标准参数：在各jdk版本中较稳定"></a>标准参数：在各jdk版本中较稳定</h4><code>    -help<br>    -server -client<br>    -version -showversion<br>    -cp -classpath<br></code><h4 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h4><h5 id="非标准化参数"><a href="#非标准化参数" class="headerlink" title="非标准化参数"></a>非标准化参数</h5><h5 id="Xint：完全解释执行"><a href="#Xint：完全解释执行" class="headerlink" title="-Xint：完全解释执行"></a>-Xint：完全解释执行</h5><p>调整为<code>完全解释执行</code>编译模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:dubbo-learn loonycoder$ java -Xint -version</span><br><span class="line">java version <span class="string">"1.8.0_161"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, interpreted mode)</span><br></pre></td></tr></table></figure><h5 id="Xcomp：第一次使用就编译成本地代码"><a href="#Xcomp：第一次使用就编译成本地代码" class="headerlink" title="-Xcomp：第一次使用就编译成本地代码"></a>-Xcomp：第一次使用就编译成本地代码</h5><p>调整为<code>编译执行</code>编译模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:dubbo-learn loonycoder$ java -Xcomp -version</span><br><span class="line">java version <span class="string">"1.8.0_161"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, compiled mode)</span><br></pre></td></tr></table></figure><h5 id="Xmixed：混合模式，JVM自己来决定是否编译成本地代码"><a href="#Xmixed：混合模式，JVM自己来决定是否编译成本地代码" class="headerlink" title="-Xmixed：混合模式，JVM自己来决定是否编译成本地代码"></a>-Xmixed：混合模式，JVM自己来决定是否编译成本地代码</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:~ loonycoder$ java -version</span><br><span class="line">java version <span class="string">"1.8.0_161"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</span><br></pre></td></tr></table></figure><p>最后一行的<code>mixed mode</code>表明JVM默认使用的编译模式是<code>混合模式</code></p><h4 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h4><p>使用最多的一种参数类型</p><h5 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h5><p>格式：<code>-XX:[+/-] &lt;name&gt;</code>表示启用或者禁用name属性<br>比如：<br><code>-XX:+UseConcMarkSweepGC</code> 表示启用CMS垃圾回收器<br><code>-XX:+UseG1GC</code> 表示启用G1垃圾回收器</p><h5 id="非Boolean类型"><a href="#非Boolean类型" class="headerlink" title="非Boolean类型"></a>非Boolean类型</h5><p>格式：<code>-XX:&lt;name&gt; = &lt;value&gt;</code> 表示name属性的值为value<br>比如：<br><code>-XX:MaxGCPauseMillis=500</code> 表示GC最大停顿时间是500毫秒<br><code>-XX:GCTimeRatio=19</code> 表示吞吐量大小(通常是0-100之间的整数)假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。 </p><h5 id="Xmx-Xms"><a href="#Xmx-Xms" class="headerlink" title="-Xmx -Xms"></a>-Xmx -Xms</h5><p>虽然1以X开头，但是不是X类型参数，而是XX类型的参数</p><ul><li><p>-Xmx等价于-XX:MaxHeapSize 表示最大堆内存大小，可使用<code>jinfo -flag MaxHeapSize</code>进程id查看，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ps -ef|grep java</span></span><br><span class="line">root      9723     1  0 4月24 ?       04:28:59 /usr/program/jdk1.8.0_72/jre/bin/java -Djava.util.logging.config.file=/opt/tomcat/apache-tomcat-8.0.50/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dignore.endorsed.dirs= -classpath /opt/tomcat/apache-tomcat-8.0.50/bin/bootstrap.jar:/opt/tomcat/apache-tomcat-8.0.50/bin/tomcat-juli.jar -Dcatalina.base=/opt/tomcat/apache-tomcat-8.0.50 -Dcatalina.home=/opt/tomcat/apache-tomcat-8.0.50 -Djava.io.tmpdir=/opt/tomcat/apache-tomcat-8.0.50/temp org.apache.catalina.startup.Bootstrap start</span><br><span class="line">root     20037 19984  0 20:53 pts/2    00:00:00 grep --color=auto java</span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ./jinfo -flag MaxHeapSize 9723</span></span><br><span class="line">-XX:MaxHeapSize=482344960</span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li><li><p>-Xms等价于-XX:InitalHeapSize 表示堆内存初始大小</p></li><li><p>-Xss等价于-XX:InitalStackSize 表示线程栈的初始大小，可以使用<code>jinfo -flag ThreadStackSize</code>进程id查看，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ps -ef</span></span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ps -ef|grep java</span></span><br><span class="line">root      9723     1  0 4月24 ?       04:28:59 /usr/program/jdk1.8.0_72/jre/bin/java -Djava.util.logging.config.file=/opt/tomcat/apache-tomcat-8.0.50/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dignore.endorsed.dirs= -classpath /opt/tomcat/apache-tomcat-8.0.50/bin/bootstrap.jar:/opt/tomcat/apache-tomcat-8.0.50/bin/tomcat-juli.jar -Dcatalina.base=/opt/tomcat/apache-tomcat-8.0.50 -Dcatalina.home=/opt/tomcat/apache-tomcat-8.0.50 -Djava.io.tmpdir=/opt/tomcat/apache-tomcat-8.0.50/temp org.apache.catalina.startup.Bootstrap start</span><br><span class="line">root     20037 19984  0 20:53 pts/2    00:00:00 grep --color=auto java</span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ./jinfo -flag MaxHeapSize 9723</span></span><br><span class="line">-XX:MaxHeapSize=482344960</span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ./jinfo -flag ThreadStackSize 9723</span></span><br><span class="line">-XX:ThreadStackSize=1024</span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="VM运行时参数查看"><a href="#VM运行时参数查看" class="headerlink" title="VM运行时参数查看"></a>VM运行时参数查看</h3><ul><li><code>-XX:+printFlagsInitial</code> 查看JVM运行时初始值</li><li><code>-XX:+printFlagsFinal</code> 查看JVM运行时最终值</li><li><code>-XX:+UnlockExperimentalVMOptions</code> 解锁实验参数</li><li><code>-XX:+UnlockDiagnosticVMOptions</code> 解锁诊断参数</li><li><code>-XX:+PrintCommandLineFlags</code> 打印命令行参数</li></ul><p>如查看JVM版本信息：<code>java -XX:+PrintFlagsFinal -version &gt; ~/version.txt</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version.txt中部分参数：</span><br><span class="line">[Global flags]</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyCollectionCostMargin    = 50                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyInitializingSteps       = 20                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyOutputInterval          = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyWeight                  = 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeThroughPutPolicy              = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveTimeWeight                        = 25                                  &#123;product&#125;</span><br><span class="line">     bool AdjustConcurrency                         = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool AggressiveOpts                            = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool C1ProfileVirtualCalls                     = <span class="literal">true</span>                                &#123;C1 product&#125;</span><br><span class="line">     bool C1UpdateMethodData                        = <span class="literal">true</span>                                &#123;C1 product&#125;</span><br><span class="line">     intx CICompilerCount                          := 2                                   &#123;product&#125;</span><br><span class="line">     bool CICompilerCountPerCPU                     = <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     bool CITime                                    = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool CMSAbortSemantics                         = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">    uintx CMSAbortablePrecleanMinWorkPerIteration   = 100                                 &#123;product&#125;</span><br><span class="line">     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;</span><br><span class="line">    uintx CMSBitMapYieldQuantum                     = 10485760</span><br></pre></td></tr></table></figure><p>注：<code>=</code>表示默认值，<code>=:</code>表示修改后的值</p><h4 id="jps：查看Java进程"><a href="#jps：查看Java进程" class="headerlink" title="jps：查看Java进程"></a>jps：查看Java进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ./jps</span></span><br><span class="line">20160 Jps</span><br><span class="line">9723 Bootstrap</span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ./jps -l</span></span><br><span class="line">20170 sun.tools.jps.Jps</span><br><span class="line">9723 org.apache.catalina.startup.Bootstrap</span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>关于jps等命令的详解，可参考此文档<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/index.html</a></p><h4 id="jinfo：查看指定Java进程运行时参数"><a href="#jinfo：查看指定Java进程运行时参数" class="headerlink" title="jinfo：查看指定Java进程运行时参数"></a>jinfo：查看指定Java进程运行时参数</h4><p>如查看一个java进程id为9723的tomcat服务最大堆内存大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ps -ef|grep java</span></span><br><span class="line">root      9723     1  0 4月24 ?       04:29:03 /usr/program/jdk1.8.0_72/jre/bin/java -Djava.util.logging.config.file=/opt/tomcat/apache-tomcat-8.0.50/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dignore.endorsed.dirs= -classpath /opt/tomcat/apache-tomcat-8.0.50/bin/bootstrap.jar:/opt/tomcat/apache-tomcat-8.0.50/bin/tomcat-juli.jar -Dcatalina.base=/opt/tomcat/apache-tomcat-8.0.50 -Dcatalina.home=/opt/tomcat/apache-tomcat-8.0.50 -Djava.io.tmpdir=/opt/tomcat/apache-tomcat-8.0.50/temp org.apache.catalina.startup.Bootstrap start</span><br><span class="line">root     20187 20123  0 21:34 pts/2    00:00:00 grep --color=auto java</span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ./jinfo -flag MaxHeapSize 9723</span></span><br><span class="line">-XX:MaxHeapSize=482344960</span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>查看一个进程的所有运行时参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ./jinfo -flags 9732</span></span><br><span class="line">Attaching to process ID 9732, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.72-b15</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=2 </span><br><span class="line">-XX:InitialHeapSize=31457280 -XX:MaxHeapSize=482344960 </span><br><span class="line">-XX:MaxNewSize=160759808 -XX:MinHeapDeltaBytes=196608 </span><br><span class="line">-XX:NewSize=10485760 -XX:OldSize=20971520 </span><br><span class="line">-XX:+UseCompressedClassPointers -XX:+UseCompressedOops</span><br><span class="line">Command line:  -Djava.util.logging.config.file=/opt/tomcat/apache-tomcat-8.0.50/conf/logging.properties </span><br><span class="line">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 </span><br><span class="line">-Djava.protocol.handler.pkgs=org.apache.catalina.webresources </span><br><span class="line">-Dignore.endorsed.dirs= -Dcatalina.base=/opt/tomcat/apache-tomcat-8.0.50 </span><br><span class="line">-Dcatalina.home=/opt/tomcat/apache-tomcat-8.0.50 </span><br><span class="line">-Djava.io.tmpdir=/opt/tomcat/apache-tomcat-8.0.50/temp</span><br><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><code>Non-default VM flags</code>表示手动赋值过的参数，其中有些是tomcat设置的<br><code>Command line</code>：与<code>Non-default VM flags</code></p><p>查看垃圾回收器信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:dubbo-learn loonycoder$ jinfo -flag UseConcMarkSweepGc 29159</span><br><span class="line">no such flag <span class="string">'UseConcMarkSweepGc'</span></span><br><span class="line">MacBook-Pro:dubbo-learn loonycoder$ jinfo -flag UseG1Gc 29159</span><br><span class="line">no such flag <span class="string">'UseG1Gc'</span></span><br><span class="line">MacBook-Pro:dubbo-learn loonycoder$ jinfo -flag UseParallelGc 29159</span><br><span class="line">no such flag <span class="string">'UseParallelGc'</span></span><br></pre></td></tr></table></figure><hr><h3 id="jstat查看虚拟机统计信息"><a href="#jstat查看虚拟机统计信息" class="headerlink" title="jstat查看虚拟机统计信息"></a>jstat查看虚拟机统计信息</h3><h4 id="类装载"><a href="#类装载" class="headerlink" title="类装载"></a>类装载</h4><p>格式：<code>jstat -class 进程id 每隔多少毫秒 一共输出多少次</code><br>如：查看一个进程id为29159的java进程，每隔1s输出，一共输出10次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:dubbo-learn loonycoder$ jstat -class 29159 1000 10</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line">  3204  6088.2        0     0.0       2.14</span><br><span class="line">  3204  6088.2        0     0.0       2.14</span><br><span class="line">  3204  6088.2        0     0.0       2.14</span><br><span class="line">  3204  6088.2        0     0.0       2.14</span><br><span class="line">  3204  6088.2        0     0.0       2.14</span><br><span class="line">  3204  6088.2        0     0.0       2.14</span><br><span class="line">  3204  6088.2        0     0.0       2.14</span><br><span class="line">  3204  6088.2        0     0.0       2.14</span><br><span class="line">  3204  6088.2        0     0.0       2.14</span><br><span class="line">  3204  6088.2        0     0.0       2.14</span><br></pre></td></tr></table></figure><ul><li>Loaded：表示类加载的个数</li><li>Bytes：表示类加载的大小，单位为kb</li><li>UnLoaded：表示类卸载的个数</li><li>Bytes：表示类卸载的大小，单位为kb</li><li>Time：表示类加载和卸载的时间</li></ul><h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>要查看一个java进程的垃圾收集器信息，可使用<code>jstat -gc 进程id 每隔多少毫秒 一共输出多少次</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:dubbo-learn loonycoder$ jstat -gc 29159 1000 3</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">5120.0 5120.0 4308.8  0.0   33280.0  17845.6   87552.0      88.0    18944.0 18304.7 2304.0 2144.9      2    0.014   0      0.000    0.014</span><br><span class="line">5120.0 5120.0 4308.8  0.0   33280.0  17845.6   87552.0      88.0    18944.0 18304.7 2304.0 2144.9      2    0.014   0      0.000    0.014</span><br><span class="line">5120.0 5120.0 4308.8  0.0   33280.0  17845.6   87552.0      88.0    18944.0 18304.7 2304.0 2144.9      2    0.014   0      0.000    0.014</span><br></pre></td></tr></table></figure><p><code>S0C</code>: Current survivor space 0 capacity (kB).<code>表示survivor 0区的总大小</code><br><code>S1C</code>: Current survivor space 1 capacity (kB).<code>表示survivor 1区的总大小</code><br><code>S0U</code>: Survivor space 0 utilization (kB).<code>表示survivor 0区使用了的大小</code><br><code>S1U</code>: Survivor space 1 utilization (kB).<code>表示survivor 1区使用了的大小</code><br><code>EC</code>: Current eden space capacity (kB).<code>表示eden区总大小</code><br><code>EU</code>: Eden space utilization (kB).<code>表示eden区使用了的大小</code><br><code>OC</code>: Current old space capacity (kB).<code>表示old区总大小</code><br><code>OU</code>: Old space utilization (kB).<code>表示old区使用了的大小</code><br><code>MC</code>: Metaspace capacity (kB).<code>表示Metaspace区总大小</code><br><code>MU</code>: Metacspace utilization (kB).<code>表示Metaspace区使用了的大小</code><br><code>CCSC</code>: Compressed class space capacity (kB).<code>表示压缩类空间总量</code><br><code>CCSU</code>: Compressed class space used (kB).<code>表示压缩类空间使用量</code><br><code>YGC</code>: Number of young generation garbage collection events.<code>表示Young GC的次数</code><br><code>YGCT</code>: Young generation garbage collection time.<code>表示Young GC的时间</code><br><code>FGC</code>: Number of full GC events.<code>表示full GC的次数</code><br><code>FGCT</code>: Full garbage collection time.<code>表示full GC的时间</code><br><code>GCT</code>: Total garbage collection time.<code>表示总的 GC的时间</code></p><h4 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h4><h5 id="compiler参数"><a href="#compiler参数" class="headerlink" title="-compiler参数"></a>-compiler参数</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:dubbo-learn loonycoder$ jstat -compiler 29159 1000 5</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    1284      0       0     3.50          0</span><br><span class="line">    1284      0       0     3.50          0</span><br><span class="line">    1284      0       0     3.50          0</span><br><span class="line">    1284      0       0     3.50          0</span><br><span class="line">    1284      0       0     3.50          0</span><br></pre></td></tr></table></figure><ul><li>Compiled：表示编译成功的方法数量</li><li>Failed：表示编译失败的方法数量</li><li>Invalid：表示编译无效的方法数量</li><li>Time：编译所花费的时间</li><li>FailedType：编译失败类型</li><li>FailedMethod：编译失败方法</li></ul><h5 id="printcompilation参数"><a href="#printcompilation参数" class="headerlink" title="-printcompilation参数"></a>-printcompilation参数</h5><hr><h3 id="jmap-MAT实战内存溢出"><a href="#jmap-MAT实战内存溢出" class="headerlink" title="jmap+MAT实战内存溢出"></a>jmap+MAT实战内存溢出</h3><p>模拟内存溢出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MemoryController &#123;</span><br><span class="line">    </span><br><span class="line">    private List&lt;User&gt;  userList = new ArrayList&lt;User&gt;();</span><br><span class="line">    private List&lt;Class&lt;?&gt;&gt;  classList = new ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * -Xmx32M -Xms32M</span><br><span class="line">     * */</span><br><span class="line">    @GetMapping(<span class="string">"/heap"</span>)</span><br><span class="line">    public String <span class="function"><span class="title">heap</span></span>() &#123;</span><br><span class="line">        int i=0;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            userList.add(new User(i++, UUID.randomUUID().toString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * -XX:MetaspaceSize=32M -XX:MaxMetaspaceSize=32M</span><br><span class="line">     * */</span><br><span class="line">    @GetMapping(<span class="string">"/nonheap"</span>)</span><br><span class="line">    public String <span class="function"><span class="title">nonheap</span></span>() &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            classList.addAll(Metaspace.createClasses());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.monitor_tuning.chapter2;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.objectweb.asm.ClassWriter;</span><br><span class="line">import org.objectweb.asm.MethodVisitor;</span><br><span class="line">import org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * https://blog.csdn.net/bolg_hero/article/details/78189621</span><br><span class="line"> * 继承ClassLoader是为了方便调用defineClass方法，因为该方法的定义为protected</span><br><span class="line"> * */</span><br><span class="line">public class Metaspace extends ClassLoader &#123;</span><br><span class="line">    </span><br><span class="line">    public static List&lt;Class&lt;?&gt;&gt; <span class="function"><span class="title">createClasses</span></span>() &#123;</span><br><span class="line">        // 类持有</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        // 循环1000w次生成1000w个不同的类。</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 10000000; ++i) &#123;</span><br><span class="line">            ClassWriter cw = new ClassWriter(0);</span><br><span class="line">            // 定义一个类名称为Class&#123;i&#125;，它的访问域为public，父类为java.lang.Object，不实现任何接口</span><br><span class="line">            cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC, <span class="string">"Class"</span> + i, null,</span><br><span class="line">                    <span class="string">"java/lang/Object"</span>, null);</span><br><span class="line">            // 定义构造函数&lt;init&gt;方法</span><br><span class="line">            MethodVisitor mw = cw.visitMethod(Opcodes.ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>,</span><br><span class="line">                    <span class="string">"()V"</span>, null, null);</span><br><span class="line">            // 第一个指令为加载this</span><br><span class="line">            mw.visitVarInsn(Opcodes.ALOAD, 0);</span><br><span class="line">            // 第二个指令为调用父类Object的构造函数</span><br><span class="line">            mw.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="string">"java/lang/Object"</span>,</span><br><span class="line">                    <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line">            // 第三条指令为<span class="built_in">return</span></span><br><span class="line">            mw.visitInsn(Opcodes.RETURN);</span><br><span class="line">            mw.visitMaxs(1, 1);</span><br><span class="line">            mw.visitEnd();</span><br><span class="line">            Metaspace <span class="built_in">test</span> = new Metaspace();</span><br><span class="line">            byte[] code = cw.toByteArray();</span><br><span class="line">            // 定义类</span><br><span class="line">            Class&lt;?&gt; exampleClass = test.defineClass(<span class="string">"Class"</span> + i, code, 0, code.length);</span><br><span class="line">            classes.add(exampleClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.monitor_tuning.chapter2;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    public User(int id, String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置启动参数：</p><p><img src="images/jvm/jvm16.png" srcset="/img/loading.gif" alt="jvm"></p><p>启动application，发现出现内存溢出</p><h4 id="如何导出内存溢出映像文件"><a href="#如何导出内存溢出映像文件" class="headerlink" title="如何导出内存溢出映像文件"></a>如何导出内存溢出映像文件</h4><h5 id="内存溢出自动导出"><a href="#内存溢出自动导出" class="headerlink" title="内存溢出自动导出"></a>内存溢出自动导出</h5><code>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath=./<br></code><p><img src="images/jvm/jvm17.png" srcset="/img/loading.gif" alt="jvm"></p><h5 id="使用jmap命令手动导出"><a href="#使用jmap命令手动导出" class="headerlink" title="使用jmap命令手动导出"></a>使用jmap命令手动导出</h5><p>格式：<code>jmap -dump:format=b,file=路径/heap.hprof 进程id</code><br>其他命令：<code>jmap -heap 进程id</code> 查看堆信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@izwz93osmk5vi5qwqyscxaz bin]<span class="comment"># ./jmap -heap 9723</span></span><br><span class="line">Attaching to process ID 9723, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.72-b15</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Mark Sweep Compact GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 482344960 (460.0MB)</span><br><span class="line">   NewSize                  = 10485760 (10.0MB)</span><br><span class="line">   MaxNewSize               = 160759808 (153.3125MB)</span><br><span class="line">   OldSize                  = 20971520 (20.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 32178176 (30.6875MB)</span><br><span class="line">   used     = 16081160 (15.336189270019531MB)</span><br><span class="line">   free     = 16097016 (15.351310729980469MB)</span><br><span class="line">   49.97536218336303% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 28639232 (27.3125MB)</span><br><span class="line">   used     = 16054760 (15.311012268066406MB)</span><br><span class="line">   free     = 12584472 (12.001487731933594MB)</span><br><span class="line">   56.058626153103546% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 3538944 (3.375MB)</span><br><span class="line">   used     = 26400 (0.025177001953125MB)</span><br><span class="line">   free     = 3512544 (3.349822998046875MB)</span><br><span class="line">   0.7459852430555556% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 3538944 (3.375MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 3538944 (3.375MB)</span><br><span class="line">   0.0% used</span><br><span class="line">tenured generation:</span><br><span class="line">   capacity = 71221248 (67.921875MB)</span><br><span class="line">   used     = 57115304 (54.469398498535156MB)</span><br><span class="line">   free     = 14105944 (13.452476501464844MB)</span><br><span class="line">   80.19419148622613% used</span><br><span class="line"></span><br><span class="line">27532 interned Strings occupying 3194040 bytes.</span><br></pre></td></tr></table></figure><h5 id="使用MAT分析映像文件"><a href="#使用MAT分析映像文件" class="headerlink" title="使用MAT分析映像文件"></a>使用MAT分析映像文件</h5><p><img src="images/jvm/jvm18.png" srcset="/img/loading.gif" alt="jvm"></p><ul><li>Class Name：类名</li><li>Objects：对象数量</li><li>Shallow Heap：</li><li>Retained Heap：占用的内存大小</li></ul><p>右键查看com.imooc.monitor_tuning.chapter2.User的强引用</p><p><img src="images/jvm/jvm19.png" srcset="/img/loading.gif" alt="jvm"><br><img src="images/jvm/jvm20.png" srcset="/img/loading.gif" alt="jvm"></p><p>也可以查看对象树：</p><p><img src="images/jvm/jvm21.png" srcset="/img/loading.gif" alt="jvm"></p><hr><h3 id="jstack实战死循环与死锁"><a href="#jstack实战死循环与死锁" class="headerlink" title="jstack实战死循环与死锁"></a>jstack实战死循环与死锁</h3><p>格式：<code>jstack 进程id</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">2018-09-05 07:59:21</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.72-b15 mixed mode):</span><br><span class="line"></span><br><span class="line"><span class="string">"Attach Listener"</span> <span class="comment">#16 daemon prio=9 os_prio=0 tid=0x00007f3d9c001000 nid=0x521f waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"localhost-startStop-1"</span> <span class="comment">#15 daemon prio=5 os_prio=0 tid=0x00007f3dac002800 nid=0x5208 runnable [0x00007f3da15d1000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at java.io.FileInputStream.readBytes(Native Method)</span><br><span class="line">    at java.io.FileInputStream.read(FileInputStream.java:255)</span><br><span class="line">    at sun.security.provider.SeedGenerator<span class="variable">$URLSeedGenerator</span>.getSeedBytes(SeedGenerator.java:539)</span><br><span class="line">    at sun.security.provider.SeedGenerator.generateSeed(SeedGenerator.java:144)</span><br><span class="line">    at sun.security.provider.SecureRandom<span class="variable">$SeederHolder</span>.&lt;clinit&gt;(SecureRandom.java:203)</span><br><span class="line">    at sun.security.provider.SecureRandom.engineNextBytes(SecureRandom.java:221)</span><br><span class="line">    - locked &lt;0x00000000e3e90be0&gt; (a sun.security.provider.SecureRandom)</span><br><span class="line">    at java.security.SecureRandom.nextBytes(SecureRandom.java:468)</span><br><span class="line">    - locked &lt;0x00000000e3e910c0&gt; (a java.security.SecureRandom)</span><br><span class="line">    at java.security.SecureRandom.next(SecureRandom.java:491)</span><br><span class="line">    at java.util.Random.nextInt(Random.java:329)</span><br><span class="line">    at org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom(SessionIdGeneratorBase.java:240)</span><br><span class="line">    at org.apache.catalina.util.SessionIdGeneratorBase.getRandomBytes(SessionIdGeneratorBase.java:174)</span><br><span class="line">    at org.apache.catalina.util.StandardSessionIdGenerator.generateSessionId(StandardSessionIdGenerator.java:34)</span><br><span class="line">    at org.apache.catalina.util.SessionIdGeneratorBase.generateSessionId(SessionIdGeneratorBase.java:167)</span><br><span class="line">    at org.apache.catalina.util.SessionIdGeneratorBase.startInternal(SessionIdGeneratorBase.java:260)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)</span><br><span class="line">    - locked &lt;0x00000000e3e90730&gt; (a org.apache.catalina.util.StandardSessionIdGenerator)</span><br><span class="line">    at org.apache.catalina.session.ManagerBase.startInternal(ManagerBase.java:717)</span><br><span class="line">    at org.apache.catalina.session.StandardManager.startInternal(StandardManager.java:352)</span><br><span class="line">    - locked &lt;0x00000000e42eefb0&gt; (a org.apache.catalina.session.StandardManager)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)</span><br><span class="line">    - locked &lt;0x00000000e42eefb0&gt; (a org.apache.catalina.session.StandardManager)</span><br><span class="line">    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5339)</span><br><span class="line">    - locked &lt;0x00000000ed3c6ca0&gt; (a org.apache.catalina.core.StandardContext)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)</span><br><span class="line">    - locked &lt;0x00000000ed3c6ca0&gt; (a org.apache.catalina.core.StandardContext)</span><br><span class="line">    at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:753)</span><br><span class="line">    at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:729)</span><br><span class="line">    at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:717)</span><br><span class="line">    at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:974)</span><br><span class="line">    at org.apache.catalina.startup.HostConfig<span class="variable">$DeployWar</span>.run(HostConfig.java:1850)</span><br><span class="line">    at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:511)</span><br><span class="line">    at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line"><span class="string">"Catalina-startStop-1"</span> <span class="comment">#14 daemon prio=5 os_prio=0 tid=0x00007f3dc4437000 nid=0x5207 waiting on condition [0x00007f3da16d2000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">    at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">    - parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x00000000ed3c6fc0&gt; (a java.util.concurrent.FutureTask)</span><br><span class="line">    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">    at java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)</span><br><span class="line">    at java.util.concurrent.FutureTask.get(FutureTask.java:191)</span><br><span class="line">    at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:766)</span><br><span class="line">    at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:436)</span><br><span class="line">    at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1580)</span><br><span class="line">    at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:322)</span><br><span class="line">    at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:95)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:388)</span><br><span class="line">    - locked &lt;0x00000000ed03ec38&gt; (a org.apache.catalina.core.StandardHost)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:333)</span><br><span class="line">    - locked &lt;0x00000000ed03ec38&gt; (a org.apache.catalina.core.StandardHost)</span><br><span class="line">    at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:960)</span><br><span class="line">    - locked &lt;0x00000000ed03ec38&gt; (a org.apache.catalina.core.StandardHost)</span><br><span class="line">    at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:871)</span><br><span class="line">    - locked &lt;0x00000000ed03ec38&gt; (a org.apache.catalina.core.StandardHost)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)</span><br><span class="line">    - locked &lt;0x00000000ed03ec38&gt; (a org.apache.catalina.core.StandardHost)</span><br><span class="line">    at org.apache.catalina.core.ContainerBase<span class="variable">$StartChild</span>.call(ContainerBase.java:1408)</span><br><span class="line">    at org.apache.catalina.core.ContainerBase<span class="variable">$StartChild</span>.call(ContainerBase.java:1398)</span><br><span class="line">    at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line"><span class="string">"NioBlockingSelector.BlockPoller-2"</span> <span class="comment">#13 daemon prio=5 os_prio=0 tid=0x00007f3dc4429800 nid=0x5206 runnable [0x00007f3da17d4000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">    at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)</span><br><span class="line">    at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)</span><br><span class="line">    at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)</span><br><span class="line">    - locked &lt;0x00000000ed3c75a8&gt; (a sun.nio.ch.Util<span class="variable">$2</span>)</span><br><span class="line">    - locked &lt;0x00000000ed3c75b8&gt; (a java.util.Collections<span class="variable">$UnmodifiableSet</span>)</span><br><span class="line">    - locked &lt;0x00000000ed3c7560&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line">    at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)</span><br><span class="line">    at org.apache.tomcat.util.net.NioBlockingSelector<span class="variable">$BlockPoller</span>.run(NioBlockingSelector.java:301)</span><br><span class="line"></span><br><span class="line"><span class="string">"NioBlockingSelector.BlockPoller-1"</span> <span class="comment">#12 daemon prio=5 os_prio=0 tid=0x00007f3dc440e800 nid=0x5205 runnable [0x00007f3da18d5000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">    at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)</span><br><span class="line">    at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)</span><br><span class="line">    at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)</span><br><span class="line">    - locked &lt;0x00000000ed3c77e0&gt; (a sun.nio.ch.Util<span class="variable">$2</span>)</span><br><span class="line">    - locked &lt;0x00000000ed3c77f0&gt; (a java.util.Collections<span class="variable">$UnmodifiableSet</span>)</span><br><span class="line">    - locked &lt;0x00000000ed3c7798&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line">    at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)</span><br><span class="line">    at org.apache.tomcat.util.net.NioBlockingSelector<span class="variable">$BlockPoller</span>.run(NioBlockingSelector.java:301)</span><br><span class="line"></span><br><span class="line"><span class="string">"GC Daemon"</span> <span class="comment">#11 daemon prio=2 os_prio=0 tid=0x00007f3dc4356800 nid=0x5204 in Object.wait() [0x00007f3dc81a0000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    - waiting on &lt;0x00000000ed0d57f0&gt; (a sun.misc.GC<span class="variable">$LatencyLock</span>)</span><br><span class="line">    at sun.misc.GC<span class="variable">$Daemon</span>.run(GC.java:117)</span><br><span class="line">    - locked &lt;0x00000000ed0d57f0&gt; (a sun.misc.GC<span class="variable">$LatencyLock</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"AsyncFileHandlerWriter-789451787"</span> <span class="comment">#10 daemon prio=5 os_prio=0 tid=0x00007f3dc4105000 nid=0x5203 waiting on condition [0x00007f3dc8338000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">    at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">    - parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x00000000ecec1210&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)</span><br><span class="line">    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>.awaitNanos(AbstractQueuedSynchronizer.java:2078)</span><br><span class="line">    at java.util.concurrent.LinkedBlockingDeque.pollFirst(LinkedBlockingDeque.java:522)</span><br><span class="line">    at java.util.concurrent.LinkedBlockingDeque.poll(LinkedBlockingDeque.java:684)</span><br><span class="line">    at org.apache.juli.AsyncFileHandler<span class="variable">$LoggerThread</span>.run(AsyncFileHandler.java:153)</span><br><span class="line"></span><br><span class="line"><span class="string">"Service Thread"</span> <span class="comment">#7 daemon prio=9 os_prio=0 tid=0x00007f3dc40b3800 nid=0x5201 runnable [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"C1 CompilerThread1"</span> <span class="comment">#6 daemon prio=9 os_prio=0 tid=0x00007f3dc40b0800 nid=0x5200 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"C2 CompilerThread0"</span> <span class="comment">#5 daemon prio=9 os_prio=0 tid=0x00007f3dc40ae800 nid=0x51ff waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"Signal Dispatcher"</span> <span class="comment">#4 daemon prio=9 os_prio=0 tid=0x00007f3dc40ad000 nid=0x51fe runnable [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"Finalizer"</span> <span class="comment">#3 daemon prio=8 os_prio=0 tid=0x00007f3dc407a000 nid=0x51fd in Object.wait() [0x00007f3dc893e000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    - waiting on &lt;0x00000000ecec2320&gt; (a java.lang.ref.ReferenceQueue<span class="variable">$Lock</span>)</span><br><span class="line">    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class="line">    - locked &lt;0x00000000ecec2320&gt; (a java.lang.ref.ReferenceQueue<span class="variable">$Lock</span>)</span><br><span class="line">    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class="line">    at java.lang.ref.Finalizer<span class="variable">$FinalizerThread</span>.run(Finalizer.java:209)</span><br><span class="line"></span><br><span class="line"><span class="string">"Reference Handler"</span> <span class="comment">#2 daemon prio=10 os_prio=0 tid=0x00007f3dc4075000 nid=0x51fc in Object.wait() [0x00007f3dc8a3f000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    - waiting on &lt;0x00000000ecec24d8&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span><br><span class="line">    at java.lang.Object.wait(Object.java:502)</span><br><span class="line">    at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">    - locked &lt;0x00000000ecec24d8&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span><br><span class="line">    at java.lang.ref.Reference<span class="variable">$ReferenceHandler</span>.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f3dc4009000 nid=0x51fa waiting on condition [0x00007f3dcc417000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">    at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">    - parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x00000000ed3c7340&gt; (a java.util.concurrent.FutureTask)</span><br><span class="line">    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">    at java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)</span><br><span class="line">    at java.util.concurrent.FutureTask.get(FutureTask.java:191)</span><br><span class="line">    at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:943)</span><br><span class="line">    - locked &lt;0x00000000ecfb7038&gt; (a org.apache.catalina.core.StandardEngine)</span><br><span class="line">    at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262)</span><br><span class="line">    - locked &lt;0x00000000ecfb7038&gt; (a org.apache.catalina.core.StandardEngine)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)</span><br><span class="line">    - locked &lt;0x00000000ecfb7038&gt; (a org.apache.catalina.core.StandardEngine)</span><br><span class="line">    at org.apache.catalina.core.StandardService.startInternal(StandardService.java:441)</span><br><span class="line">    - locked &lt;0x00000000ecfb7038&gt; (a org.apache.catalina.core.StandardEngine)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)</span><br><span class="line">    - locked &lt;0x00000000ecfa2330&gt; (a org.apache.catalina.core.StandardService)</span><br><span class="line">    at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:789)</span><br><span class="line">    - locked &lt;0x00000000ecf4e258&gt; (a java.lang.Object)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)</span><br><span class="line">    - locked &lt;0x00000000ecf1c578&gt; (a org.apache.catalina.core.StandardServer)</span><br><span class="line">    at org.apache.catalina.startup.Catalina.start(Catalina.java:641)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">    at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:349)</span><br><span class="line">    at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:483)</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Thread"</span> os_prio=0 tid=0x00007f3dc406d800 nid=0x51fb runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Periodic Task Thread"</span> os_prio=0 tid=0x00007f3dc40b7000 nid=0x5202 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 59</span><br></pre></td></tr></table></figure><ul><li>localhost-startStop-1：线程名</li><li>daemon：后台线程</li><li>prio：优先级</li><li>os_prio：系统优先级</li><li>tid：线程id</li><li>nid：操作系统id</li><li>java.lang.Thread.State：线程状态；NEW-线程尚未启动， RUNNABLE- 线程运行中，BLOCKED-等待一个锁， WAITINH-等待另一个线程， TIMED_WAITING-限时等待另一个线程， TERMINATED-已退出</li></ul><h4 id="实战死循环"><a href="#实战死循环" class="headerlink" title="实战死循环"></a>实战死循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class CpuController &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 死循环</span><br><span class="line">     * */</span><br><span class="line">    @RequestMapping(<span class="string">"/loop"</span>)</span><br><span class="line">    public List&lt;Long&gt; <span class="function"><span class="title">loop</span></span>()&#123;</span><br><span class="line">        String data = <span class="string">"&#123;\"data\":[&#123;\"partnerid\":]"</span>;</span><br><span class="line">        <span class="built_in">return</span> getPartneridsFromJson(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Object lock1 = new Object();</span><br><span class="line">    private Object lock2 = new Object();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 死锁</span><br><span class="line">     * */</span><br><span class="line">    @RequestMapping(<span class="string">"/deadlock"</span>)</span><br><span class="line">    public String <span class="function"><span class="title">deadlock</span></span>()&#123;</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized(lock1) &#123;</span><br><span class="line">                try &#123;Thread.sleep(1000);&#125;catch(Exception e) &#123;&#125;</span><br><span class="line">                synchronized(lock2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread1 over"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) .start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized(lock2) &#123;</span><br><span class="line">                try &#123;Thread.sleep(1000);&#125;catch(Exception e) &#123;&#125;</span><br><span class="line">                synchronized(lock1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread2 over"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) .start();</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"deadlock"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public static List&lt;Long&gt; getPartneridsFromJson(String data)&#123;  </span><br><span class="line">        //&#123;\"data\":[&#123;\"partnerid\":982,\"count\":\"10000\",\"cityid\":\"11\"&#125;,&#123;\"partnerid\":983,\"count\":\"10000\",\"cityid\":\"11\"&#125;,&#123;\"partnerid\":984,\"count\":\"10000\",\"cityid\":\"11\"&#125;]&#125;  </span><br><span class="line">        //上面是正常的数据  </span><br><span class="line">        List&lt;Long&gt; list = new ArrayList&lt;Long&gt;(2);  </span><br><span class="line">        <span class="keyword">if</span>(data == null || data.length() &lt;= 0)&#123;  </span><br><span class="line">            <span class="built_in">return</span> list;  </span><br><span class="line">        &#125;      </span><br><span class="line">        int datapos = data.indexOf(<span class="string">"data"</span>);  </span><br><span class="line">        <span class="keyword">if</span>(datapos &lt; 0)&#123;  </span><br><span class="line">            <span class="built_in">return</span> list;  </span><br><span class="line">        &#125;  </span><br><span class="line">        int leftBracket = data.indexOf(<span class="string">"["</span>,datapos);  </span><br><span class="line">        int rightBracket= data.indexOf(<span class="string">"]"</span>,datapos);  </span><br><span class="line">        <span class="keyword">if</span>(leftBracket &lt; 0 || rightBracket &lt; 0)&#123;  </span><br><span class="line">            <span class="built_in">return</span> list;  </span><br><span class="line">        &#125;  </span><br><span class="line">        String partners = data.substring(leftBracket+1,rightBracket);  </span><br><span class="line">        <span class="keyword">if</span>(partners == null || partners.length() &lt;= 0)&#123;  </span><br><span class="line">            <span class="built_in">return</span> list;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span>(partners!=null &amp;&amp; partners.length() &gt; 0)&#123;  </span><br><span class="line">            int idpos = partners.indexOf(<span class="string">"partnerid"</span>);  </span><br><span class="line">            <span class="keyword">if</span>(idpos &lt; 0)&#123;  </span><br><span class="line">                <span class="built_in">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            int colonpos = partners.indexOf(<span class="string">":"</span>,idpos);  </span><br><span class="line">            int commapos = partners.indexOf(<span class="string">","</span>,idpos);  </span><br><span class="line">            <span class="keyword">if</span>(colonpos &lt; 0 || commapos &lt; 0)&#123;  </span><br><span class="line">                //partners = partners.substring(idpos+<span class="string">"partnerid"</span>.length());//1  </span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            String pid = partners.substring(colonpos+1,commapos);  </span><br><span class="line">            <span class="keyword">if</span>(pid == null || pid.length() &lt;= 0)&#123;  </span><br><span class="line">                //partners = partners.substring(idpos+<span class="string">"partnerid"</span>.length());//2  </span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            try&#123;  </span><br><span class="line">                list.add(Long.parseLong(pid));  </span><br><span class="line">            &#125;catch(Exception e)&#123;  </span><br><span class="line">                //<span class="keyword">do</span> nothing  </span><br><span class="line">            &#125;  </span><br><span class="line">            partners = partners.substring(commapos);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">return</span> list;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问/loop端点三次，然后使用top命令：</p><p><img src="/images/jvm/jvm22.png" srcset="/img/loading.gif" alt="jvm"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导出线程堆栈</span></span><br><span class="line">$ jstack 7930 &gt; 7930.txt</span><br><span class="line"><span class="comment">#打印该进程下的线程</span></span><br><span class="line">$ top -p 7930 -H</span><br></pre></td></tr></table></figure><p><img src="/images/jvm/jvm23.png" srcset="/img/loading.gif" alt="jvm"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将十进制线程id转换为16进制</span></span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">"%x"</span> 8247</span><br><span class="line">2037</span><br></pre></td></tr></table></figure><p>然后在导出的7930.txt文件中找到2037</p><p><img src="/images/jvm/jvm24.png" srcset="/img/loading.gif" alt="jvm"></p><p>访问/loop端点，制造死循环，使用jstack命令导出线程堆栈信息：</p><p><img src="/images/jvm/jvm25.png" srcset="/img/loading.gif" alt="jvm"></p><p>最后一行已提示：Found 1 deadlock</p>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出JVM虚拟机——JVM原理</title>
    <link href="/2019/02/18/jvm-1/"/>
    <url>/2019/02/18/jvm-1/</url>
    
    <content type="html"><![CDATA[<p><strong>参考文章:</strong> <a href="https://blog.csdn.net/weixin_43866728/article/details/99842788" target="_blank" rel="noopener">全面阐述JVM原理</a></p><hr><h3 id="JMV入门"><a href="#JMV入门" class="headerlink" title="JMV入门"></a>JMV入门</h3><h4 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h4><p>JVM是<strong>Java Virtual Machine</strong>（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台(不同的操作系统)上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p><h4 id="JDK-JRE-JVM是什么关系"><a href="#JDK-JRE-JVM是什么关系" class="headerlink" title="JDK/JRE/JVM是什么关系"></a>JDK/JRE/JVM是什么关系</h4><p>JDK(<strong>Java Development Kit</strong>)是程序开发者用来来编译、调试Java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是安装的一部分。所以在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。</p><p>JRE(<strong>Java Runtime Environment</strong>，Java运行环境)，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。</p><p>JVM(<strong>Java Virtual Machine</strong>，Java虚拟机)是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。</p><h4 id="Java运行原理"><a href="#Java运行原理" class="headerlink" title="Java运行原理"></a>Java运行原理</h4><p>JVM是Java的核心和基础，在Java编译器和OS平台之间的虚拟处理器。它是一种利用软件方法实现的抽象的计算机基于下层的操作系统和硬件平台，可以在上面执行Java的字节码程序。Java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，运行在不同的OS平台，Java也是因JVM而实现了跨平台。</p><p><img src="/images/jvm/jvm1.png" srcset="/img/loading.gif" alt="jvm"></p><hr><h3 id="JVM规范"><a href="#JVM规范" class="headerlink" title="JVM规范"></a>JVM规范</h3><p>根据《Java虚拟机规范》规定，目前实现虚拟机规范的虚拟机有三种：Sun公司的HotSpot虚拟机、Oracle公司的JRockit虚拟机、IBM公司的J9虚拟机。其中Sun公司的HotSpot虚拟机是我们最常用的虚拟机。<br>JVM的基本结构一般如下图所示：</p><p><img src="/images/jvm/jvm2.png" srcset="/img/loading.gif" alt="jvm"></p><p>由上图可知JVM基本机构包括：类加载器、JVM运行时数据区、执行引擎、本地库接口。<br>这里我们说明一下JVM运行时数据区，运行时内存区主要可以划分为5个区域：<br>   - 虚拟机栈 ( Java Virtual Machine Stacks )<br>   - 本地方法栈 ( Native Method Stacks )<br>   - 程序计数器 ( Program Counter (PC) Register )<br>   - 方法区 ( Method Area )<br>   - 堆内存 ( Heap ) </p><p>接下里就详细说明一下这些区域的区别：</p><h4 id="虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="虚拟机栈 ( Java Virtual Machine Stacks )"></a>虚拟机栈 ( Java Virtual Machine Stacks )</h4><p><font style="color: red"><strong>Java虚拟机栈是线程私有的，生命周期与线程相同。</strong></font><br>Java虚拟机栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。讲到这里，大家就应该会明白为什么 在 使用 递归方法的时候容易导致栈内存溢出的现象了以及为什么栈区的空间不用程序员去管理了（当然在Java中，程序员基本不用关系到内存分配和释放的事情，因为Java有自己的垃圾回收机制），这部分空间的分配和释放都是由系统自动实施的。对于所有的程序设计语言来说，栈这部分空间对程序员来说是不透明的。<br>由于栈帧的进出栈，显而易见的带来了空间分配上的问题。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常；如果虚拟机栈可以扩展，扩展时无法申请到足够的内存，将会抛出OutOfMemoryError，这种情况大多数是由于循环调用或递归调用带来的。<br>下图表示了一个Java栈的模型：</p><p><img src="/images/jvm/jvm3.png" srcset="/img/loading.gif" alt="jvm"></p><blockquote><p><font style="color: green">局部变量表</font>：就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。<br><font style="color: green">操作数栈</font>：想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。<br><font style="color: green">指向运行时常量池的引用</font>：因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。<br><font style="color: green">方法返回地址</font>：当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。<br>由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。</p></blockquote><h4 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈 ( Native Method Stacks )"></a>本地方法栈 ( Native Method Stacks )</h4><p><font style="color: red"><strong>本地方法栈是线程私有的。</strong></font><br>Java官方对于本地方法的定义为methods written in a language other than the Java programming language，就是使用非Java语言实现的方法，但是通常我们指的一般为C或者C++，因此这个栈也有着C栈这一称号。一个不支持本地方法执行的JVM没有必要实现这个数据区域。本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java虚拟机栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。其大小也是可以设置为固定值或者动态增加，因此也会对应抛出StackOverflowError和OutOfMemoryError错误。</p><h4 id="程序计数器-Program-Counter-PC-Register"><a href="#程序计数器-Program-Counter-PC-Register" class="headerlink" title="程序计数器 ( Program Counter (PC) Register )"></a>程序计数器 ( Program Counter (PC) Register )</h4><p><font style="color: red"><strong>程序计数器是线程私有的，生命周期与线程相同。</strong></font><br>程序计数器（Program Counter Register），也有称作为PC寄存器。想必学过汇编语言的朋友对程序计数器这个概念并不陌生，在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。<br>虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示 执行哪条指令的。<br>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。<br>在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。<br>由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p><h4 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区 ( Method Area )"></a>方法区 ( Method Area )</h4><p><font style="color: red"><strong>方法区是线程共享区域，生命周期与JVM相同。</strong></font><br>　　方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。<br>　　在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。<br>　　在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。<br>　　在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。HotSpot虚拟机中JDK1.8开始使用元空间取代永久代。</p><blockquote><p><font style="color: green">① 方法区的特点：</font><br>　　- 1、方法区是线程安全的，由于所有的线程都共享方法区，所以方法区里的数据访问必须被设计成线程安全的。<br>　　- 2、方法区的大小不必是固定的，JVM可根据应用需要动态调整。<br>　　- 3、方法区也可被垃圾收集，当某个类不在被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集。<br>HotSpot 虚拟机，很多人愿意把方法区称为“永久代”（Permanent Generation）。本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机来说是不存在永久代的概念的。<br><strong>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</strong><br><font style="color: green">② 方法区内存大小设置：</font><br>JDK8中永久代被移除了，取而代之的是元数据区。<br>不同的是元数据区是堆外直接内存，与永久代区不同，在不指定大小的情况下，虚拟机会耗尽所有可用的系统内存。<br><strong>元数据区发生溢出，虚拟机一样抛出异常：java.lang.OutOfMemoryError Metaspace</strong></p></blockquote><h4 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 ( Heap )"></a>堆 ( Heap )</h4><p><font style="color: red"><strong>堆是线程共享区域，生命周期与JVM相同。</strong></font><br>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。<br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；新生代又可以细分为Eden空间、From Survivor空间(S0)和To Survivor空间(S1)。<br>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。<br><font style="color: red"><strong>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。<br>堆大小 = 新生代 + 老年代。</strong></font>其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。<br><font style="color: red"><strong>默认情况下，老年代 ( Old ) 与新生代 ( Young ) 的比例的值为 2 ：1( 该值可以通过参数 –XX:NewRatio来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。</strong></font></p><p><img src="/images/jvm/jvm4.png" srcset="/img/loading.gif" alt="jvm"></p><p>通过-XX:NewRatio参数指定老年代/新生代的堆内存比例。在HotSpot虚拟机中，堆内存 = 新生代 + 老年代。如果 -XX:NewRatio = 4，表示老年代与新生代所占比值为 4 ：1，新生代占整个堆内存的1/5，老年代占整个堆内存的4/5。在设置了-XX:MaxNewSize的情况下，-XX:NewRatio的值会被忽略，老年代的内存 = 堆内存 - 新生代内存。老年代的最大内存 = 堆内存 - 新生代最大内存。</p><h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p><font style="color: red"><strong>程序新创建的对象都是从新生代分配内存(新生代中绝大部分对象都是“朝生夕死”)，</strong></font>新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成。<br>可通过-Xmn参数来指定新生代的大小；也可以通过-XX:SurvivorRation来调整Eden Space及SurvivorSpace的大小。</p><ul><li>新生代的大小可以通过参数-XX:NewSize和-XX:MaxNewSize(-Xmn)指定JVM启动时分配的新生代内存大小和新生代最大内存大小；</li><li>新生代中Eden和From Survivor空间(S0)或To Survivor空间(S1)的比例默认为8：1，也即 <font style="color: red">Eden：From Survivor：To Survivor = 8：1：1</font> (该比例可以通过参数-XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，From Survivor(S0) = To Survivor (S1) = 1/10 的新生代空间大小。 <font style="color: red">JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块Survivor 区域是空闲着的。新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间</font></li></ul><h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><p>老年代主要存放比较大的对象或者JVM认为生命周期比较长的对象(经过几次新生代的垃圾回收后仍然存在)，垃圾回收也相对没有那么频繁。老年代的垃圾回收(又称Major GC)通常使用“标记-清除”或“标记-整理”算法(依据垃圾回收器而定)。整个堆空间(新生代和老年代)的垃圾回收称为Full GC。</p><h4 id="JVM虚拟机规范的小结"><a href="#JVM虚拟机规范的小结" class="headerlink" title="JVM虚拟机规范的小结"></a>JVM虚拟机规范的小结</h4><table><thead><tr><th align="left">名称</th><th align="left">特征</th><th align="left">存储对象</th><th align="left">配置参数</th><th align="left">异常</th></tr></thead><tbody><tr><td align="left"><font style="color: blue">程序计数器Program Counter (PC) Register</font></td><td align="left">线程私有、生命周期与线程相同、占用内存小</td><td align="left">存储字节码行号指示器</td><td align="left">无</td><td align="left">无</td></tr><tr><td align="left"><font style="color: blue">虚拟机栈Java Virtual Machine Stacks</font></td><td align="left">线程私有、生命周期与线程相同、使用连续的内存空间</td><td align="left">局部变量表、操作树栈、动态链接、方法出口等信息</td><td align="left">-Xss</td><td align="left">StackOverflowError OutOfMemoryError</td></tr><tr><td align="left"><font style="color: blue">本地方法栈Native Method Stacks</font></td><td align="left">线程私有</td><td align="left">Native方法信息</td><td align="left">无</td><td align="left">StackOverflowError OutOfMemoryError</td></tr><tr><td align="left"><font style="color: blue">方法区Method Area</font></td><td align="left">线程共享、生命周期与JVM相同、可不使用连续的内存空间</td><td align="left">已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等信息</td><td align="left">JDK7：-XX:PermSize -XX:MaxPermSize</td><td align="left">OutOfMemoryError</td></tr><tr><td align="left"><font style="color: blue">堆Heap</font></td><td align="left">线程共享、生命周期与JVM相同、可不使用连续的内存空间</td><td align="left">保存对象实例、所有对象实例，包括数组</td><td align="left">-Xms -Xmx -Xmn</td><td align="left">OutOfMemoryError</td></tr></tbody></table><hr><h3 id="JVM分代垃圾回收"><a href="#JVM分代垃圾回收" class="headerlink" title="JVM分代垃圾回收"></a>JVM分代垃圾回收</h3><h4 id="分代垃圾回收过程"><a href="#分代垃圾回收过程" class="headerlink" title="分代垃圾回收过程"></a>分代垃圾回收过程</h4><p>堆是垃圾回收的主要区域。GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、老年代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停。<br>不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：<br>（1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）；<br>（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）；<br>（3）弱引用：在GC时一定会被GC回收；<br>（4）虚引用：由于虚引用只是用来得知对象是否被GC；<br>GC主要分为两种：Minor GC 和 Full GC(或称为Major GC，一般人们总是习惯把老年代的GC称之为Full GC)。</p><blockquote><p>Minor GC、Major GC、Full GC区别<br>Minor GC : 针对新生代，从新生代回收内存<br>Major GC : 针对老年代，从老年代回收内存<br>Full GC : 针对真个堆空间( 包括新生代、老年代、方法区(永久代) )，清理整个堆空间</p></blockquote><h5 id="新生代垃圾回收过程"><a href="#新生代垃圾回收过程" class="headerlink" title="新生代垃圾回收过程"></a>新生代垃圾回收过程</h5><p>新生代的垃圾回收称为Minor GC，采用复制算法。新创建的对象优先进去新生代的Eden区，当Eden区满了之后再使用From Survivor区，当From Survivor也满了之后就进行Minor GC(新生代GC)，将Eden和From Survivor中存活的对象复制到To Survivor，然后清空Eden和From Survivor，这个时候原来的From Survivor成了新的To Survivor，原来的To Survivor成了新的From Survivor。复制的时候，如果To Survivor无法容纳全部存活的对象，则根据老年代的分配担保（类似于银行的贷款担保）将对象copy进去老年代，如果老年代也无法容纳，则进行Full GC（老年代GC）。<br>如果创建的对象比较大，则直接进入老年代：JVM中有个参数配置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。</p><blockquote><p>Minor GC触发的条件：<br>1、Eden区域满；<br>2、新创建的对象大小大于Eden区所剩空间大小；</p></blockquote><h5 id="老年代垃圾回收过程"><a href="#老年代垃圾回收过程" class="headerlink" title="老年代垃圾回收过程"></a>老年代垃圾回收过程</h5><p>长期存活的对象进入老年代：JVM给每个对象定义一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移入Survivor并且年龄设定为1。每熬过一次Minor GC，年龄就加1，当他的年龄到一定程度（默认为15岁，可以通过XX:MaxTenuringThreshold来设定），就会移入老年代。但是JVM并不是永远要求年龄必须达到最大年龄才会晋升老年代，如果Survivor 空间中相同年龄（如年龄为x）所有对象大小的总和大于Survivor的一半，年龄大于等于x的所有对象直接进入老年代，无需等到最大年龄要求。</p><blockquote><p>Full GC触发条件：<br>1、老年代所剩空间不足；<br>2、方法区空间不足；<br>3、调用System.gc( ) 方法；<br>4、通过Minor GC后进入老年代的平均大小大于老年代的可用内存；<br>5、由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小；</p></blockquote><h4 id="对象“已死”的判定算法"><a href="#对象“已死”的判定算法" class="headerlink" title="对象“已死”的判定算法"></a>对象“已死”的判定算法</h4><p>由于程序计数器、Java虚拟机栈、本地方法栈都是线程私有的，其占用的内存也是随线程生而生、随线程结束而回收。而Java堆和方法区则不同，线程共享的，是GC的所关注的部分。<br>在堆中几乎存在着所有对象，GC之前需要考虑哪些对象还活着不能回收，哪些对象已经死去可以回收。<br>有两种算法可以判定对象是否存活：<br>   <font style="color: red">(1）引用计数算法：</font>给对象中添加一个引用计数器，每当一个地方应用了对象，计数器加1；当引用失效，计数器减1；当计数器为0表示该对象已死、可回收。但是它很难解决两个对象之间相互循环引用的情况。<br>   <font style="color: red">(2）可达性分析算法：</font>通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（即对象到GC Roots不可达），则证明此对象已死、可回收。Java中可以作为GC Roots的对象包括如下几种：</p><ul><li>虚拟机栈(栈桢中的本地变量表)中的引用的对象；</li><li>本地方法栈中Native方法引用的对象；</li><li>方法区中类的静态属性引用的对象；</li><li>方法区中常量引用的对象；</li></ul><p>JVM是通过<font style="color: red">可达性分析算法</font>来判定对象是否存活的。</p><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p>JVM的垃圾回收算法有三种：<font style="color: red">标记-清除、复制、标记-整理</font></p><h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h5><p>这种算法是最简单最直接的算法，也是其它算法的一些最初思路。标记清除算法其实就是对内存中的对象依次的进行判断，如果对象需要回收那么就打一个标记，如果对象仍然需要使用，那么就保留下来。这样经过一次扫描之后，所有的对象都会被筛选判断一次。紧接着会对内存中已经标记的对象依次进行清除。 这个算法比较简单粗暴，实现起来比较简单。<br>标记-清除算法有两个缺点：<br><font style="color: greed">(1). 效率问题：</font>标记和清除需要两遍循环内存中的对象，标记和清除操作都是比较麻烦的工作，因此这种算法的效率不高。<br><font style="color: greed">(2). 空间问题：</font>对于分配的内存来说，往往是连续的比较好，因为这样有利于分配大数据的对象。标记清除之后会产生大量不连续的内存碎片（类似于我们电脑的磁盘碎片），空间碎片太多导致需要分配大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作，也就是空间不足而导致频繁GC和性能下降。</p><p><img src="/images/jvm/ivm5.png" srcset="/img/loading.gif" alt="jvm"></p><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>为了解决效率问题，出现了“复制”算法，他将可用内存按容量划分为大小相等的两块，每次只需要使用其中一块。当一块内存用完了，将还存活的对象复制到另一块上面，然后再把刚刚用完的内存空间一次清理掉。这样就解决了内存碎片问题，但是代价就是可以用内容就缩小为原来的一半。<br>算法使用了空间换取时间的思想，因此需要一块空白的区域作为内存对象要粘贴的区域。这无疑会造成一种浪费。只有在有效对象占据总回收内存是非常小的时候，这种算法的性价比才会达到最高。否则大量的复制操作所浪费的时间可能要远远大于空间换取时间得到的收益。因此这种算法在JVM中，也只被用来作为初级的对象回收。因为这时的有效对象比例最低，算法的性价比是最高的。<br>复制算法的优点：</p><ul><li>如果垃圾对象较多的情况下，该算法效率比较高；</li><li>垃圾清理之后，内存不会出现碎片化；</li></ul><p>复制算法的缺点：</p><ul><li>不适用在垃圾较少的情况下适用，例如老年代中；</li><li>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低；</li></ul><p><img src="/images/jvm/ivm6.png" srcset="/img/loading.gif" alt="jvm"></p><h5 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h5><p>复制算法在对象存活率较高时就会进行频繁的复制操作，效率将降低。因此又有了标记-整理算法，标记过程同标记-清除算法，但是在后续步骤不是直接对对象进行清理，而是让所有存活的对象都向一侧移动，然后直接清理掉边界以外的内存。<br>复制算法需要一块额外的内存空间，用于存放幸存的内存对象。这无疑造成了内存的浪费。我们还可以在原有的标记清除算法的基础上，提出了优化方案。也就是标记到的可用对象整体向一侧移动，然后直接清除掉可用对象边界意外的内存。这样既解决了内存碎片的问题。又不需要原有的空间换时间的硬件浪费。由于老年代中的幸存对象较多，而且对象内存占用较大。这就使得一旦出现内存回收，需要被回收的对象并不多，碎片也就相对的比较少。所以不需要太多的复制和移动步骤。因此这种方法常常被应用到老年代中。<br>标记整理算法的缺点：<br>标记整理算法由于需要不断的移动对象到另外一侧，而这种不断的移动其实是非常不适合杂而多的小内存对象的。每次的移动和计算都是非常复杂的过程。因此在使用场景上，就注定限制了标记整理算法的使用不太适合频繁创建和回收对象的内存中。</p><p><img src="/images/jvm/ivm7.png" srcset="/img/loading.gif" alt="jvm"></p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>垃圾收集算法是方法论，垃圾收集器是具体实现。JVM规范对于垃圾收集器的应该如何实现没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器差别较大，这里只看HotSpot虚拟机。<br>JDK7/8后，HotSpot虚拟机所有收集器及组合（连线）如下：</p><p><img src="/images/jvm/ivm8.png" srcset="/img/loading.gif" alt="jvm"></p><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>Serial收集器是最基本、历史最久的收集器，曾是新生代手机的唯一选择。它是单线程的，只会使用一个CPU或一条收集线程去完成垃圾收集工作，并且它在收集的时候，必须暂停其它所有的用户线程，直到它结束，即“Stop the World”。停掉所有的用户线程，对很多应用来说难以接受。比如你在做一件事情，被别人强制停掉，用户的体验非常差<br>尽管如此，它仍然是虚拟机运行在client模式下的默认新生代收集器：简单而高效（与其它收集器的单个线程相比，因为没有线程切换的开销）。<br><strong>工作示意图：</strong></p><p><img src="/images/jvm/ivm9.png" srcset="/img/loading.gif" alt="jvm"></p><h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>ParNew收集器是Serial收集器的多线程版本，除了使用了多线程之外，其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同Serial收集器一样。<br>是许多运行在Server模式下的JVM中首选的新生代收集器，其中一个很重还要的原因就是除了Serial之外，只有他能和老年代的CMS收集器配合工作。<br><strong>工作示意图：</strong></p><p><img src="/images/jvm/ivm10.png" srcset="/img/loading.gif" alt="jvm"></p><h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>新生代收集器，并行的多线程收集器。它的目标是达到一个可控的吞吐量（就是CPU运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=行用户代码的时间/[行用户代码的时间+垃圾收集时间]），这样可以高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。<br><strong>工作示意图：</strong></p><p><img src="/images/jvm/ivm11.png" srcset="/img/loading.gif" alt="jvm"></p><h5 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h5><p>Serial 收集器的老年代版本，单线程，采用“标记-整理”算法，主要是给Client模式下的虚拟机使用。<br>另外还可以在Server模式下：<br>JDK 1.5之前的版本中与Parallel Scavenge 收集器搭配使用<br>可以作为CMS的后背方案，在CMS发生Concurrent Mode Failure是使用<br><strong>工作示意图：</strong></p><p><img src="/images/jvm/ivm12.png" srcset="/img/loading.gif" alt="jvm"></p><h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><p>Parallel Scavenge的老年代版本，多线程，采用“标记-整理”算法，JDK 1.6才出现。在此之前Parallel Scavenge只能同Serial Old搭配使用，由于Serial Old的性能较差导致Parallel Scavenge的优势发挥不出来。<br>Parallel Old收集器的出现，使“吞吐量优先”收集器终于有了名副其实的组合。在吞吐量和CPU敏感的场合，都可以使用Parallel Scavenge/Parallel Old组合。<br><strong>工作示意图：</strong></p><p><img src="/images/jvm/ivm13.png" srcset="/img/loading.gif" alt="jvm"></p><h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。<br>基于“标记-清除”算法，并发收集、低停顿，运作过程复杂。CMS收集器的垃圾回收过程分为如下四步：<br>   <font style="color: pink">1. 初始标记：</font>仅仅标记GC Roots能直接关联到的对象，速度快，但是需要“Stop The World”；<br>   <font style="color: pink">2. 并发标记：</font>就是进行追踪引用链的过程，可以和用户线程并发执行；<br>   <font style="color: pink">3. 重新标记：</font>修正并发标记阶段因用户线程继续运行而导致标记发生变化的那部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要“Stop The World”；<br>   <font style="color: pink">4. 并发清除：</font>清除标记为可以回收对象，可以和用户线程并发执行；<br>由于整个过程耗时最长的并发标记和并发清除都可以和用户线程一起工作，所以总体上来看，CMS收集器的内存回收过程和用户线程是并发执行的。<br><strong>工作示意图：</strong></p><p><img src="/images/jvm/ivm14.png" srcset="/img/loading.gif" alt="jvm"></p><p>CMS是一款优秀的收集器，来分别看看它的优点和缺点。<br><strong>优点：</strong><br><font style="color: pink">1. 并发收集</font><br><font style="color: pink">2. 低停顿</font><br><strong>缺点：</strong><br><font style="color: pink">1. 对CPU资源非常敏感</font><br>并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。<br>CMS的默认收集线程数量是 = (CPU数量 + 3) / 4；当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。<br><font style="color: pink">2. 无法处理浮动垃圾（在并发清除时，用户线程新产生的垃圾叫浮动垃圾）</font><br>并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集；如果CMS预留内存空间无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败；这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生；<br><font style="color: pink">3. 产生大量内存碎片</font><br>CMS收集器基于”标记-清除”算法，清除后不进行整理压缩操作而产生大量不连续的内存碎片，这样会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作。</p><p><strong>CMS收集器的适用场景：</strong><br>如果你的应用程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU(也就是硬件牛逼)，那么使用CMS来收集会给你带来好处。还有，如果在JVM中，有相对较多存活时间较长的对象(老年代比较大)会更适合使用CMS。</p><p><strong>CMS收集器的总结：</strong><br>CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。</p><h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p>G1（Garbage-First）是JDK7-u4才正式推出商用的收集器。G1是面向服务端应用的垃圾收集器(JDK9默认的收集器是G1)。它的使命是未来可以替换掉CMS收集器。<br><strong>G1收集器特性：</strong></p><p><font style="color: pink">1.并行与并发：</font>G1收集器能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop The World停顿时间。部分其他收集器原本需要暂停Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。【能充分利用多CPU、多核环境的硬件优势，缩短停顿时间；能和用户线程并发执行】<br><font style="color: pink">2. 分代收集：</font>虽然G1收集器可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间的对象，熬过多次GC的旧对象以获取更好的收集效果。<br><font style="color: pink">3. 空间整合：</font>与CMS收集器的“标记-清除”算法不同，G1收集器整体上看采用“标记-整理“算法，局部看采用“复制”算法（两个Region之间），不会有内存碎片，不会因为大对象找不到足够的连续空间而提前触发GC，这点优于CMS收集器；<br><font style="color: pink">4. 可预测的停顿：</font>这是G1收集器相对于CMS收集器的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超N毫秒，这点优于CMS收集器。</p><p><strong>为什么能做到可预测的停顿？</strong><br>是因为可以有计划的避免在整个Java堆中进行全区域的垃圾收集。<br>G1收集器将内存分大小相等的独立区域（Region），新生代和老年代概念保留，但是已经不再物理隔离。<br>G1跟踪各个Region获得其收集价值大小，在后台维护一个优先列表；<br>每次根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）；<br>这就保证了在有限的时间内可以获取尽可能高的收集效率。</p><blockquote><p><font style="color: green">对象被其他Region的对象引用了怎么办？</font><br>判断对象存活时，是否需要扫描整个Java堆才能保证准确？<br>在其他的分代收集器，也存在这样的问题（而G1更突出）：新生代回收的时候不得不扫描老年代？<br>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：<br>每个Region都有一个对应的Remembered Set；<br>每次Reference类型数据写操作时，都会产生一个Write Barrier 暂时中断操作；<br>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；<br>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；<br>进行垃圾收集时，在GC根节点的枚举范围加入 Remembered Set ，就可以保证不进行全局扫描，也不会有遗漏。</p></blockquote><p>不计算维护Remembered Set的操作，G1收集器回收过程可以分为四个步骤（与CMS较为相似）：<br><font style="color: pink">1. 初始标记：</font>仅仅标记GC Roots能直接关联到的对象，并修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时能在正确可用的Region中创建新对象，需要“Stop The World”；<br><font style="color: pink">2. 并发标记：</font>从GC Roots开始进行可达性分析，找出存活对象，耗时长，可与用户线程并发执行；<br><font style="color: pink">3. 最终标记：</font>修正并发标记阶段因用户线程继续运行而导致标记发生变化的那部分对象的标记记录。并发标记时虚拟机将对象变化记录在线程Remember Set Logs里面，最终标记阶段将Remember Set Logs整合到Remember Set中，比初始标记时间长但远比并发标记时间短，需要“Stop The World”；<br><font style="color: pink">4. 筛选回收：</font>首先对各个Region的回收价值和成本进行排序，然后根据用户期望的GC停顿时间来定制回收计划，最后按计划回收一些价值高的Region中垃圾对象。回收时采用复制算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；可以并发进行，降低停顿时间，并增加吞吐量；</p><p><strong>工作示意图：</strong></p><p><img src="/images/jvm/ivm15.png" srcset="/img/loading.gif" alt="jvm"></p><blockquote><p><font style="color: green">G1收集器相对于CMS收集器的区别在：</font></p><ul><li>G1在压缩空间方面有优势</li><li>G1通过将内存空间分成区域（Region）的方式避免内存碎片问题</li><li>Eden, Survivor, Old区不再固定、在内存使用效率上来说更灵活</li><li>G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象</li><li>G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（Stop The World）的时候做</li><li>G1会在整个堆(新生代和老年代)中使用、而CMS只能在老年代中使用</li></ul></blockquote><blockquote><p><font style="color: green">就目前而言、CMS还是默认首选的GC策略、可能在以下场景下G1更适合：</font></p><ul><li>服务端多核CPU、JVM内存占用较大的应用（至少大于4G）</li><li>应用在运行过程中会产生大量内存碎片、需要经常压缩空间</li><li>想要更可控、可预期的GC停顿周期；防止高并发下应用雪崩现象</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通俗易懂搞定HashMap的底层原理</title>
    <link href="/2019/02/06/hashmap/"/>
    <url>/2019/02/06/hashmap/</url>
    
    <content type="html"><![CDATA[<p><strong>HashMap的底层原理面试必考题。</strong></p><p>为什么面试官如此青睐这道题？</p><p>HashMap里面涉及了很多的知识点，可以比较全面考察面试者的基本功，想要拿到一个好offer,这是一个迈不过的坎，接下来我用最通俗易懂的语言带着大家揭开HashMap的神秘面纱</p><p><strong>一：HashMap的节点</strong>：HashMap是一个集合，键值对的集合,源码中每个节点用Node&lt;K,V&gt;表示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">   final int <span class="built_in">hash</span>;</span><br><span class="line">   final K key;</span><br><span class="line">   V value;</span><br><span class="line">   Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure><p>Node是一个内部类，这里的key为键，value为值，next指向下一个元素，可以看出HashMap中的元素不是一个单纯的键值对，<strong>还包含下一个元素的引用</strong>。</p><p><strong>二：HashMap的数据结构</strong>：HashMap的数据结构为 <strong>数组+(链表或红黑树)</strong>，上图：</p><p><img src="/images/hashmap/hashmap1.jpg" srcset="/img/loading.gif" alt="hashmap"></p><p>为什么采用这种结构来存储元素呢？</p><p><strong>数组的特点：查询效率高，插入，删除效率低。</strong></p><p><strong>链表的特点：查询效率低，插入，删除效率高。</strong></p><p>在HashMap底层使用数组加（链表或红黑树）的结构完美的解决了数组和链表的问题，使得查询和插入，删除的效率都很高。</p><p><strong>三：HashMap存储元素的过程：</strong></p><p>有这样一段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">"loonycoder"</span>,<span class="string">"24"</span>);</span><br><span class="line">map.put(<span class="string">"欧阳娜娜"</span>,<span class="string">"22"</span>);</span><br></pre></td></tr></table></figure><p>现在我要把键值对 “loonycoder”,”24”存入map:</p><p>第一步：计算出键“loonycode”的hashcode，该值用来定位要将这个元素存放到数组中的什么位置。</p><p><strong>什么是hashcode？</strong></p><p>在Object类中有一个方法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure><p>该方法用native修饰，所以是一个本地方法，所谓本地方法就是非java代码，这个代码通常用c或c++写成，在java中可以去调用它。</p><p>调用这个方法会生成一个int型的整数，我们叫它哈希码，哈希码和调用它的对象地址和内容有关。</p><p><strong>哈希码的特点是:</strong></p><p><strong>对于同一个对象如果没有被修改（使用equals比较返回true）那么无论何时它的hashcode值都是相同的</strong></p><p><strong>对于两个对象如果他们的equals返回false,那么他们的hashcode值也有可能相等</strong></p><p>明白了hashcode我们再来看元素如何通过hashcode定位到要存储在数组的哪里，通过hashcode值和数组长度取模我们可以得到元素存储的下标。</p><p>loonycoder的hashcode为20977295 数组长度为 16则要存储在数组索引为 20977295%16=1的地方<br><img src="/images/hashmap/hashmap2.png" srcset="/img/loading.gif" alt="hashmap"></p><p>可以分两种情况:</p><ol><li><p>数组索引为1的地方是空的，这种情况很简单，直接将元素放进去就好了。</p></li><li><p>已经有元素占据了索引为1的位置，这种情况下我们需要判断一下该位置的元素和当前元素是否相等，使用equals来比较。</p></li></ol><p>如果使用默认的规则是比较两个对象的地址。也就是两者需要是同一个对象才相等，当然我们也可以重写equals方法来实现我们自己的比较规则最常见的是通过比较属性值来判断是否相等。</p><p><strong>如果两者相等则直接覆盖，如果不等则在原元素下面使用链表的结构存储该元素</strong></p><p><img src="/images/hashmap/hashmap3.png" srcset="/img/loading.gif" alt="hashmap"></p><p>每个元素节点都有一个next属性指向下一个节点，这里由数组结构变成了数组+链表结构,红黑树又是怎么回事呢？</p><p>因为链表中元素太多的时候会影响查找效率，所以当链表的元素个数达到8的时候使用链表存储就转变成了使用红黑树存储，原因就是<strong>红黑树是平衡二叉树，在查找性能方面比链表要高。</strong></p><p><strong>四：HashMap中的两个重要的参数</strong>：HashMap中有两个重要的参数：<strong>初始容量大小和加载因子</strong>，初始容量大小是创建时给数组分配的容量大小，默认值为16，<strong>用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用rehash方法将数组容量增加到原来的两倍，专业术语叫做扩容。</strong></p><p><strong>在做扩容的时候会生成一个新的数组，原来的所有数据需要重新计算哈希码值重新分配到新的数组，所以扩容的操作非常消耗性能。</strong></p><p><img src="/images/hashmap/hashmap4.png" srcset="/img/loading.gif" alt="hashmap"></p><p>创建HashMap时我们可以通过合理的设置初始容量大小来达到尽量少的扩容的目的。加载因子也可以设置，但是除非特殊情况不建议设置。</p>]]></content>
    
    
    <categories>
      
      <category>HashMap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring、SpringMVC、Mybatis整合+实现简单CRUD</title>
    <link href="/2019/01/28/ssm/"/>
    <url>/2019/01/28/ssm/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>仓库地址：<a href="https://github.com/LoonyCoder/ssm" target="_blank" rel="noopener">SSM整合</a><br>欢迎star/fork，给作者一些鼓励！</p><hr><p>在目前的企业级Java应用中，Spring框架是必须的。Struts2框架与Spring的整合问题日益凸显，而Spring MVC作为新一代的MVC框架，因其可以与Spring框架无缝整合的特性收到了越来越多的欢迎。Hibernate框架在面对需要存储过程或者复杂SQL时显得力不从心，不能提供高效的数据库控制。而Mybatis框架作为持久层的框架，虽然需要自己编写SQL语句，但是其对高并发高响应的支持，以及对动态SQL和动态绑定的支持使其脱颖而出。</p><p>因此SSM框架（Spring + Spring MVC +Mybatis）逐渐取代了之前广泛使用的SSH框架（Spring + Struts2 + Hibernate），成为了目前使用最多的框架。</p><p>本文使用IDEA，利用Maven管理项目，整合SSM框架搭建论文管理系统，实现简单的增、删、改、查功能。步骤详细，讲解丰富，适合新手入门。</p><hr><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li>Mac OS 10.15</li><li>IntelliJ IDEA Ultimate 20183</li><li>Apache-tomcat-7</li><li>JDK 1.8.0_121</li><li>MySQL 5.7</li><li>Maven 3.3.9</li></ul><hr><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>最终完成的工程结构：</p><p><img src="/images/ssm/ssm1.png" srcset="/img/loading.gif" alt="ssm"><br>下面开始详细的讲解项目的开发过程。</p><hr><h3 id="IDEA-Maven搭建项目骨架"><a href="#IDEA-Maven搭建项目骨架" class="headerlink" title="IDEA+Maven搭建项目骨架"></a>IDEA+Maven搭建项目骨架</h3><h4 id="新建Maven项目："><a href="#新建Maven项目：" class="headerlink" title="新建Maven项目："></a>新建Maven项目：</h4><p>点击File -&gt; New -&gt; Project -&gt; Maven -&gt; 勾选 Create from archetype -&gt; 选择 maven-archetype-webapp (<strong>注意：此处不要错选成上面的cocoom-22-archetype-webapp</strong>) </p><p><img src="/images/ssm/ssm2.png" srcset="/img/loading.gif" alt="ssm"></p><p><img src="/images/ssm/ssm3.png" srcset="/img/loading.gif" alt="ssm"></p><p>在弹出的new project 选项卡中填写GroupId和Artifactid，其中GroupID是项目组织唯一的标识符，实际对应JAVA的包的结构，是main目录里java的目录结构，ArtifactID是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。对于入门练习，这两项可以随意填写。</p><p><img src="/images/ssm/ssm4.png" srcset="/img/loading.gif" alt="ssm"></p><p>之后点击next 选择Maven版本（其中IDEA 专业版自带Maven，也可以选择自己下载的maven）。之后填写项目名称和项目地址，完成后点击Finish，完成项目骨架的创建。 </p><p><img src="/images/ssm/ssm5.png" srcset="/img/loading.gif" alt="ssm"></p><p>点击finish开始创建工程。</p><h4 id="在新建的项目中添加所需要的文件-文件夹"><a href="#在新建的项目中添加所需要的文件-文件夹" class="headerlink" title="在新建的项目中添加所需要的文件/文件夹"></a>在新建的项目中添加所需要的文件/文件夹</h4><p>创建之后的项目如图所示，我们需要在这之上新建一些目录。<br>首先在项目的根目录下新建target文件夹，系统自动将其设置为”Excluded”</p><p><img src="/images/ssm/ssm6.png" srcset="/img/loading.gif" alt="ssm"></p><p>在src/main目录下新建Directory：”java”和”resource”，此时查看下java包是否蓝色的，如果是灰色的，单击右键，并将其设置为”Source Root”（即：此项目默认的代码文件源目录）<br>查看”resource”目录是否带有四个横线，如果没有，同样的方式设置成”Resources Boot”<br><img src="/images/ssm/ssm7.png" srcset="/img/loading.gif" alt="ssm"></p><p>在刚才新建的java文件下新建”com.loonycoder”包，再在com包下新建四个包，分别命名为：pojo、service、dao、controller。</p><p><img src="/images/ssm/ssm8.png" srcset="/img/loading.gif" alt="ssm"></p><p>上面新建的四个包：pojo、service、dao、controller，其所存放的分别是：</p><ul><li>pojo: 存放自定义的java类。如：paper类，user类，book类等，每个类的属性设为private，并提供public属性的getter/setter方法让外界访问</li><li>service：定义接口，包含系统所提供的功能。（之后还会在service包下再新建impl包）。</li><li>dao：定义接口，包含与数据库进行交互的功能。</li><li>controller：控制器，负责接收页面请求，转发和处理。<br>在resource包下新建Directory：”mapper”（用于存放xxxMapper.xml文件）和”spring”（用于存放spring-xxx.xml配置文件），新建文件：”jdbc.properties”（mysql数据库配置文件）,”log4j.properties”（日志输出配置文件）,”mybatis-config.xml”（mybatis框架配置文件）。 </li></ul><p>然后，在web-inf目录下新建”jsp”包，存放xxx.jsp显示界面。<br>补充之后的项目目录如下图所示，至此项目骨架搭建完毕，开始写代码实现增删改查功能。<br><img src="/images/ssm/ssm9.png" srcset="/img/loading.gif" alt="ssm"></p><h4 id="在pom-xml中引入相关依赖"><a href="#在pom-xml中引入相关依赖" class="headerlink" title="在pom.xml中引入相关依赖"></a>在pom.xml中引入相关依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">  xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.loonycoder&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;ssm&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;loonycoder ssm&lt;/name&gt;</span><br><span class="line">  &lt;!-- FIXME change it to the project’s website --&gt;</span><br><span class="line">  &lt;url&gt;www.loonycoder.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;spring.version&gt;5.0.3.RELEASE&lt;/spring.version&gt;</span><br><span class="line">    &lt;mybatis.version&gt;3.4.4&lt;/mybatis.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 单元测试 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">      &lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 第一部分：Spring 配置--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring core --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;<span class="variable">$&#123;spring.version&#125;</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;<span class="variable">$&#123;spring.version&#125;</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;<span class="variable">$&#123;spring.version&#125;</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;<span class="variable">$&#123;spring.version&#125;</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring DAO --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;<span class="variable">$&#123;spring.version&#125;</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;<span class="variable">$&#123;spring.version&#125;</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring mvc --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;<span class="variable">$&#123;spring.version&#125;</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;<span class="variable">$&#123;spring.version&#125;</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;<span class="variable">$&#123;spring.version&#125;</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 第二部分：Servlet web --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;taglibs&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;standard&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;1.1.2&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;2.9.4&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 第三部分：数据库和mybatis --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 数据库 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;5.1.38&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 数据库连接池 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;com.mchange&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;0.9.5.2&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- MyBatis --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;<span class="variable">$&#123;mybatis.version&#125;</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- mybatis-spring整合包 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;1.3.1&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 第四部分：日志 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 实现slf4j接口并整合 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">      &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;ssm&lt;/finalName&gt;</span><br><span class="line">    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class="line">      &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html<span class="comment">#Plugin_bindings_for_war_packaging --&gt;</span></span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;2.22.1&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;2.5.2&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;2.8.2&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">      &lt;/plugins&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;<span class="built_in">source</span>&gt;6&lt;/<span class="built_in">source</span>&gt;</span><br><span class="line">          &lt;target&gt;6&lt;/target&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h4 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">SET FOREIGN_KEY_CHECKS=0;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">-- Table structure <span class="keyword">for</span> `paper`</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `paper`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `paper` (</span><br><span class="line"></span><br><span class="line">`paper_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT <span class="string">'paperID'</span>,</span><br><span class="line"></span><br><span class="line">`name` varchar(100) NOT NULL COMMENT <span class="string">'paper名称'</span>,</span><br><span class="line"></span><br><span class="line">`number` int(11) NOT NULL COMMENT <span class="string">'paper数量'</span>,</span><br><span class="line"></span><br><span class="line">`detail` varchar(200) NOT NULL COMMENT <span class="string">'paper描述'</span>,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY (`paper_id`)</span><br><span class="line"></span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 COMMENT=<span class="string">'paper表'</span>;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">-- Records of paper</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">INSERT INTO `paper` VALUES (<span class="string">'1'</span>, <span class="string">'loonycoder1'</span>, <span class="string">'5'</span>, <span class="string">'望月1'</span>);</span><br><span class="line"></span><br><span class="line">INSERT INTO `paper` VALUES (<span class="string">'2'</span>, <span class="string">'loonycoder2'</span>, <span class="string">'8'</span>, <span class="string">'望月2'</span>);</span><br><span class="line"></span><br><span class="line">INSERT INTO `paper` VALUES (<span class="string">'3'</span>, <span class="string">'loonycoder3'</span>, <span class="string">'10'</span>, <span class="string">'望月3'</span>);</span><br></pre></td></tr></table></figure><h4 id="新建Pojo实体类和接口"><a href="#新建Pojo实体类和接口" class="headerlink" title="新建Pojo实体类和接口"></a>新建Pojo实体类和接口</h4><blockquote><p>1.在pojo包中新建Paper.java</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.pojo;</span><br><span class="line"></span><br><span class="line">public class Paper &#123;</span><br><span class="line">    private long paperId;</span><br><span class="line"></span><br><span class="line">    private String paperName;</span><br><span class="line"></span><br><span class="line">    private int paperNum;</span><br><span class="line"></span><br><span class="line">    private String paperDetail;</span><br><span class="line"></span><br><span class="line">    public long <span class="function"><span class="title">getPaperId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> paperId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPaperId(long paperId) &#123;</span><br><span class="line">        this.paperId = paperId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getPaperName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> paperName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPaperName(String paperName) &#123;</span><br><span class="line">        this.paperName = paperName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">getPaperNum</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> paperNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPaperNum(int paperNum) &#123;</span><br><span class="line">        this.paperNum = paperNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getPaperDetail</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> paperDetail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPaperDetail(String paperDetail) &#123;</span><br><span class="line">        this.paperDetail = paperDetail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.在service包中新建接口 IPaperService.java：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.service;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.pojo.Paper;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IPaperService &#123;</span><br><span class="line">    int addPaper(Paper paper);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int deletePaperById(long id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int updatePaper(Paper paper);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Paper queryById(long id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;Paper&gt; queryAllPaper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.在service下新建impl包，提供接口实现类 PaperServiceImpl.java</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.service.impl;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.dao.IPaperDao;</span><br><span class="line">import com.loonycoder.pojo.Paper;</span><br><span class="line">import com.loonycoder.service.IPaperService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class IPaperServiceImpl implements IPaperService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IPaperDao paperDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int addPaper(Paper paper) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> paperDao.addPaper(paper);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int deletePaperById(long id) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> paperDao.deletePaperById(id);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public int updatePaper(Paper paper) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> paperDao.updatePaper(paper);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public Paper queryById(long id) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> paperDao.queryById(id);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public List&lt;Paper&gt; <span class="function"><span class="title">queryAllPaper</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> paperDao.queryAllPaper();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>4.在dao包下面提供dao层接口 IPaperDao.java</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.pojo.Paper;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IPaperDao &#123;</span><br><span class="line">    int addPaper(Paper paper);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int deletePaperById(long id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int updatePaper(Paper paper);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Paper queryById(long id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;Paper&gt; queryAllPaper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>5.在controller包中新建 PaperController.java</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.controller;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.pojo.Paper;</span><br><span class="line">import com.loonycoder.service.IPaperService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(<span class="string">"/paper"</span>)</span><br><span class="line">public class PaperController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private IPaperService paperService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">"/allPaper"</span>)</span><br><span class="line"></span><br><span class="line">    public String list(Model model) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Paper&gt; list = paperService.queryAllPaper();</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">"list"</span>, list);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="string">"allPaper"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">"toAddPaper"</span>)</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">toAddPaper</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="string">"addPaper"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">"/addPaper"</span>)</span><br><span class="line"></span><br><span class="line">    public String addPaper(Paper paper) &#123;</span><br><span class="line"></span><br><span class="line">        paperService.addPaper(paper);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="string">"redirect:/paper/allPaper"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">"/del/&#123;paperId&#125;"</span>)</span><br><span class="line"></span><br><span class="line">    public String deletePaper(@PathVariable(<span class="string">"paperId"</span>) Long id) &#123;</span><br><span class="line"></span><br><span class="line">        paperService.deletePaperById(id);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="string">"redirect:/paper/allPaper"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">"toUpdatePaper"</span>)</span><br><span class="line"></span><br><span class="line">    public String toUpdatePaper(Model model, Long id) &#123;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">"paper"</span>, paperService.queryById(id));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="string">"updatePaper"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">"/updatePaper"</span>)</span><br><span class="line"></span><br><span class="line">    public String updatePaper(Model model, Paper paper) &#123;</span><br><span class="line"></span><br><span class="line">        paperService.updatePaper(paper);</span><br><span class="line"></span><br><span class="line">        paper = paperService.queryById(paper.getPaperId());</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">"paper"</span>, paper);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="string">"redirect:/paper/allPaper"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完善所有配置文件"><a href="#完善所有配置文件" class="headerlink" title="完善所有配置文件"></a>完善所有配置文件</h4><blockquote><p>1.在resource/mapper包下新建 PaperMapper.xml（mybatis框架mapper代理开发配置文件）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line"></span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IPaperDao"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap <span class="built_in">type</span>=<span class="string">"Paper"</span> id=<span class="string">"paperResultMap"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;id property=<span class="string">"paperId"</span> column=<span class="string">"paper_id"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;result property=<span class="string">"paperName"</span> column=<span class="string">"name"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;result property=<span class="string">"paperNum"</span> column=<span class="string">"number"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;result property=<span class="string">"paperDetail"</span> column=<span class="string">"detail"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">"addPaper"</span> parameterType=<span class="string">"Paper"</span>&gt;</span><br><span class="line"></span><br><span class="line">INSERT INTO paper(paper_id,name,number,detail) VALUE (<span class="comment">#&#123;paperId&#125;,#&#123;paperName&#125;, #&#123;paperNum&#125;, #&#123;paperDetail&#125;)</span></span><br><span class="line"></span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;delete id=<span class="string">"deletePaperById"</span> parameterType=<span class="string">"long"</span>&gt;</span><br><span class="line"></span><br><span class="line">DELETE FROM paper WHERE paper_id=<span class="comment">#&#123;paperID&#125;</span></span><br><span class="line"></span><br><span class="line">&lt;/delete&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;update id=<span class="string">"updatePaper"</span> parameterType=<span class="string">"Paper"</span>&gt;</span><br><span class="line"></span><br><span class="line">UPDATE paper</span><br><span class="line"></span><br><span class="line">SET NAME = <span class="comment">#&#123;paperName&#125;,NUMBER = #&#123;paperNum&#125;,detail = #&#123;paperDetail&#125;</span></span><br><span class="line"></span><br><span class="line">WHERE paper_id = <span class="comment">#&#123;paperId&#125;</span></span><br><span class="line"></span><br><span class="line">&lt;/update&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"queryById"</span> resultType=<span class="string">"Paper"</span> parameterType=<span class="string">"long"</span>&gt;</span><br><span class="line"></span><br><span class="line">SELECT paper_id,name,number,detail</span><br><span class="line"></span><br><span class="line">FROM paper</span><br><span class="line"></span><br><span class="line">WHERE paper_id=<span class="comment">#&#123;paperId&#125;</span></span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"queryAllPaper"</span> resultMap=<span class="string">"paperResultMap"</span>&gt;</span><br><span class="line"></span><br><span class="line">SELECT paper_id,name,number,detail</span><br><span class="line"></span><br><span class="line">FROM paper</span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><blockquote><p>2.在resource/spring包下分别新建配置文件：spring-dao.xml , spring-mvc.xml , spring-service.xml</p></blockquote><p><font style="color: red"><strong>spring-dao.xml</strong></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line"></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置整合mybatis过程 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 1.配置数据库相关参数properties的属性：<span class="variable">$&#123;url&#125;</span> --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:property-placeholder location=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 2.数据库连接池 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"dataSource"</span> class=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 配置连接池属性 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"driverClass"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.driver&#125;</span>"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"jdbcUrl"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.url&#125;</span>"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"user"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.username&#125;</span>"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"password"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.password&#125;</span>"</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- c3p0连接池的私有属性 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"maxPoolSize"</span> value=<span class="string">"30"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"minPoolSize"</span> value=<span class="string">"10"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 关闭连接后不自动commit --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"autoCommitOnClose"</span> value=<span class="string">"false"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 获取连接超时时间 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"checkoutTimeout"</span> value=<span class="string">"10000"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 当获取连接失败重试次数 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"acquireRetryAttempts"</span> value=<span class="string">"2"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"sqlSessionFactory"</span> class=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"configLocation"</span> value=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 扫描pojo包 使用别名 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"typeAliasesPackage"</span> value=<span class="string">"com.loonycoder.pojo"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"mapperLocations"</span> value=<span class="string">"classpath:mapper/*.xml"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 注入sqlSessionFactory --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"sqlSessionFactoryBeanName"</span> value=<span class="string">"sqlSessionFactory"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br><span class="line">        &lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"basePackage"</span> value=<span class="string">"com.loonycoder.dao"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><font style="color: red"><strong>spring-mvc.xml</strong></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line"></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line"></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置SpringMVC --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 1.开启SpringMVC注解模式 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 简化配置：</span><br><span class="line"></span><br><span class="line">    (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter</span><br><span class="line"></span><br><span class="line">    (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持</span><br><span class="line"></span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 2.静态资源默认servlet配置</span><br><span class="line"></span><br><span class="line">    (1)加入对静态资源的处理：js,gif,png</span><br><span class="line"></span><br><span class="line">    (2)允许使用<span class="string">"/"</span>做整体映射</span><br><span class="line"></span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mvc:default-servlet-handler/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 3.配置jsp 显示ViewResolver --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"viewClass"</span> value=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 4.扫描web相关的bean --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">"com.loonycoder.controller"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><font style="color: red"><strong>spring-service.xml</strong></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line"></span><br><span class="line">       xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line"></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 扫描service包下所有使用注解的类型 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">"com.loonycoder.service"</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置事务管理器 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"transactionManager"</span></span><br><span class="line"></span><br><span class="line">          class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置基于注解的声明式事务 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=<span class="string">"transactionManager"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><blockquote><p>3.在resource包下添加mybatis-config.xml</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line"></span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置全局属性 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;settings&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;setting name=<span class="string">"useGeneratedKeys"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- 使用列别名替换列名 默认:<span class="literal">true</span> --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;setting name=<span class="string">"useColumnLabel"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;setting name=<span class="string">"mapUnderscoreToCamelCase"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><blockquote><p>4.在resource包下添加log4j.properties和jdbc.properties</p></blockquote><p><font style="color: red"><b>jdbc.properties<b></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line"><span class="comment"># 以下部分修改成你自己的数据库信息即可</span></span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/ssm?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8</span><br><span class="line"></span><br><span class="line">jdbc.username=root</span><br><span class="line"></span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><p><font style="color: red"><b>log4j.properties<b></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=ERROR, stdout</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure><blockquote><p>5.修改web.xml文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line"></span><br><span class="line">        <span class="string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;web-app xmlns=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span><br><span class="line"></span><br><span class="line">         version=<span class="string">"3.1"</span> metadata-complete=<span class="string">"true"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line"></span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置springMVC需要加载的配置文件</span><br><span class="line"></span><br><span class="line">    spring-dao.xml,spring-service.xml,spring-mvc.xml</span><br><span class="line"></span><br><span class="line">    Mybatis - &gt; spring -&gt; springmvc</span><br><span class="line"></span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line"></span><br><span class="line">      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line"></span><br><span class="line">      &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 默认匹配所有的请求 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">  &lt;filter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter-class&gt;</span><br><span class="line"></span><br><span class="line">      org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line"></span><br><span class="line">    &lt;/filter-class&gt;</span><br><span class="line"></span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line"></span><br><span class="line">      &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line"></span><br><span class="line">      &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><h4 id="添加相关页面"><a href="#添加相关页面" class="headerlink" title="添加相关页面"></a>添加相关页面</h4><p>所有页面我都写好了，大家直接用我的页面即可，如果觉得不美观，可自行改造~</p><blockquote><p>1.修改index.jsp</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">         pageEncoding=<span class="string">"UTF-8"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/fmt"</span>  prefix=<span class="string">"fmt"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line"></span><br><span class="line">    pageContext.setAttribute(<span class="string">"path"</span>, request.getContextPath());</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line"></span><br><span class="line">        a &#123;</span><br><span class="line"></span><br><span class="line">            text-decoration: none;</span><br><span class="line"></span><br><span class="line">            color: black;</span><br><span class="line"></span><br><span class="line">            font-size: 18px;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        h3 &#123;</span><br><span class="line"></span><br><span class="line">            width: 180px;</span><br><span class="line"></span><br><span class="line">            height: 38px;</span><br><span class="line"></span><br><span class="line">            margin: 100px auto;</span><br><span class="line"></span><br><span class="line">            text-align: center;</span><br><span class="line"></span><br><span class="line">            line-height: 38px;</span><br><span class="line"></span><br><span class="line">            background: deepskyblue;</span><br><span class="line"></span><br><span class="line">            border-radius: 4px;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body onload=<span class="string">"fun()"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">"container"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=<span class="string">"page-header"</span>&gt;</span><br><span class="line"></span><br><span class="line">                &lt;h1 align=<span class="string">"center"</span>&gt;</span><br><span class="line"></span><br><span class="line">                    基于SSM框架的管理系统：简单实现增、删、改、查。</span><br><span class="line"></span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;</span><br><span class="line"></span><br><span class="line">    &lt;a href=<span class="string">"<span class="variable">$&#123;path &#125;</span>/paper/allPaper"</span>&gt;点击进入管理页面&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>2.在jsp包下添加三个页面：allPaper.jsp/addPaper.jsp/updatePaper.jsp</p></blockquote><p><font style="color: red"><b>allPaper.jsp<b></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line"></span><br><span class="line">Created by IntelliJ IDEA.</span><br><span class="line"></span><br><span class="line">User: lenovo</span><br><span class="line"></span><br><span class="line">Date: 2018/4/6</span><br><span class="line"></span><br><span class="line">Time: 16:57</span><br><span class="line"></span><br><span class="line">To change this template use File | Settings | File Templates.</span><br><span class="line"></span><br><span class="line">--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;% String appPath = request.getContextPath(); %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Paper列表&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link href=<span class="string">"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">"container"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=<span class="string">"page-header"</span>&gt;</span><br><span class="line"></span><br><span class="line">                &lt;h1&gt;</span><br><span class="line"></span><br><span class="line">                    基于SSM框架的管理系统：简单实现增、删、改、查。</span><br><span class="line"></span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=<span class="string">"page-header"</span>&gt;</span><br><span class="line"></span><br><span class="line">                &lt;h1&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;small&gt;论文列表 —— 显示所有论文&lt;/small&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">"row"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">"col-md-4 column"</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;a class=<span class="string">"btn btn-primary"</span> href=<span class="string">"<span class="variable">$&#123;path&#125;</span>/paper/toAddPaper"</span>&gt;新增&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;table class=<span class="string">"table table-hover table-striped"</span>&gt;</span><br><span class="line"></span><br><span class="line">                &lt;thead&gt;</span><br><span class="line"></span><br><span class="line">                &lt;tr&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;th&gt;论文编号&lt;/th&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;th&gt;论文名字&lt;/th&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;th&gt;论文数量&lt;/th&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;th&gt;论文详情&lt;/th&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line"></span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line"></span><br><span class="line">                &lt;c:forEach var=<span class="string">"paper"</span> items=<span class="string">"<span class="variable">$&#123;requestScope.get('list')&#125;</span>"</span> varStatus=<span class="string">"status"</span>&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;td&gt;<span class="variable">$&#123;paper.paperId&#125;</span>&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;td&gt;<span class="variable">$&#123;paper.paperName&#125;</span>&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;td&gt;<span class="variable">$&#123;paper.paperNum&#125;</span>&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;td&gt;<span class="variable">$&#123;paper.paperDetail&#125;</span>&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;td&gt;</span><br><span class="line"></span><br><span class="line">                            &lt;a href=<span class="string">"<span class="variable">$&#123;path&#125;</span>/paper/toUpdatePaper?id=<span class="variable">$&#123;paper.paperId&#125;</span>"</span>&gt;更改&lt;/a&gt; |</span><br><span class="line"></span><br><span class="line">                            &lt;a href=<span class="string">"&lt;%=appPath%&gt;/paper/del/<span class="variable">$&#123;paper.paperId&#125;</span>"</span>&gt;删除&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/table&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><font style="color: red"><b>addPaper.jsp<b></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line"></span><br><span class="line">Created by IntelliJ IDEA.</span><br><span class="line"></span><br><span class="line">User: lenovo</span><br><span class="line"></span><br><span class="line">Date: 2018/4/7</span><br><span class="line"></span><br><span class="line">Time: 16:45</span><br><span class="line"></span><br><span class="line">To change this template use File | Settings | File Templates.</span><br><span class="line"></span><br><span class="line">--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line"></span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line"></span><br><span class="line">    String basePath = request.getScheme() + <span class="string">"://"</span></span><br><span class="line"></span><br><span class="line">            + request.getServerName() + <span class="string">":"</span> + request.getServerPort()</span><br><span class="line"></span><br><span class="line">            + path + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;新增论文&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link href=<span class="string">"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">"container"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=<span class="string">"page-header"</span>&gt;</span><br><span class="line"></span><br><span class="line">                &lt;h1&gt;</span><br><span class="line"></span><br><span class="line">                    基于SSM框架的管理系统：简单实现增、删、改、查。</span><br><span class="line"></span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=<span class="string">"page-header"</span>&gt;</span><br><span class="line"></span><br><span class="line">                &lt;h1&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;small&gt;新增论文&lt;/small&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;form action=<span class="string">""</span> name=<span class="string">"userForm"</span>&gt;</span><br><span class="line"></span><br><span class="line">        论文名称：&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"paperName"</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">        论文数量：&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"paperNum"</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">        论文详情：&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"paperDetail"</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"添加"</span> onclick=<span class="string">"addPaper()"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">addPaper</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">            var form = document.forms[0];</span><br><span class="line"></span><br><span class="line">            form.action = <span class="string">"&lt;%=basePath %&gt;paper/addPaper"</span>;</span><br><span class="line"></span><br><span class="line">            form.method = <span class="string">"post"</span>;</span><br><span class="line"></span><br><span class="line">            form.submit();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><font style="color: red"><b>updatePaper.jsp<b></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line"></span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line"></span><br><span class="line">    String basePath = request.getScheme() + <span class="string">"://"</span></span><br><span class="line"></span><br><span class="line">            + request.getServerName() + <span class="string">":"</span> + request.getServerPort()</span><br><span class="line"></span><br><span class="line">            + path + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;修改论文&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link href=<span class="string">"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">"container"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=<span class="string">"page-header"</span>&gt;</span><br><span class="line"></span><br><span class="line">                &lt;h1&gt;</span><br><span class="line"></span><br><span class="line">                    基于SSM框架的管理系统：简单实现增、删、改、查。</span><br><span class="line"></span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=<span class="string">"page-header"</span>&gt;</span><br><span class="line"></span><br><span class="line">                &lt;h1&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;small&gt;修改论文&lt;/small&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;form action=<span class="string">""</span> name=<span class="string">"userForm"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"paperId"</span> value=<span class="string">"<span class="variable">$&#123;paper.paperId&#125;</span>"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        论文名称：&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"paperName"</span> value=<span class="string">"<span class="variable">$&#123;paper.paperName&#125;</span>"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        论文数量：&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"paperNum"</span> value=<span class="string">"<span class="variable">$&#123;paper.paperNum&#125;</span>"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        论文详情：&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"paperDetail"</span> value=<span class="string">"<span class="variable">$&#123;paper.paperDetail &#125;</span>"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"提交"</span> onclick=<span class="string">"updatePaper()"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">updatePaper</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">            var form = document.forms[0];</span><br><span class="line"></span><br><span class="line">            form.action = <span class="string">"&lt;%=basePath %&gt;paper/updatePaper"</span>;</span><br><span class="line"></span><br><span class="line">            form.method = <span class="string">"post"</span>;</span><br><span class="line"></span><br><span class="line">            form.submit();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h4><p>以上所有工程搭建完毕之后，我们开始配置Tomcat</p><p><img src="/images/ssm/ssm10.png" srcset="/img/loading.gif" alt="ssm"><br><img src="/images/ssm/ssm11.png" srcset="/img/loading.gif" alt="ssm"><br><img src="/images/ssm/ssm12.png" srcset="/img/loading.gif" alt="ssm"><br><img src="/images/ssm/ssm13.png" srcset="/img/loading.gif" alt="ssm"><br><img src="/images/ssm/ssm14.png" srcset="/img/loading.gif" alt="ssm"></p><hr><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>配置好tomcat之后，我们启动tomcat访问我们的页面，如图：<br><img src="/images/ssm/ssm15.png" srcset="/img/loading.gif" alt="ssm"></p><p>我们测试下增删改查的功能，点击进入管理页面：<br><img src="/images/ssm/ssm16.png" srcset="/img/loading.gif" alt="ssm"></p><p>好了我们进行一下新增操作：<br><img src="/images/ssm/ssm17.png" srcset="/img/loading.gif" alt="ssm"><br><img src="/images/ssm/ssm18.png" srcset="/img/loading.gif" alt="ssm"></p><p>修改操作：<br><img src="/images/ssm/ssm19.png" srcset="/img/loading.gif" alt="ssm"><br><img src="/images/ssm/ssm20.png" srcset="/img/loading.gif" alt="ssm"></p><p>最后测试一下删除操作：<br><img src="/images/ssm/ssm20.png" srcset="/img/loading.gif" alt="ssm"></p><p>到目前为止我们已经完成了Spring、SpringMVC、Mybatis的整合，并且实现了简单的增删改查功能。</p>]]></content>
    
    
    <categories>
      
      <category>SSM框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java - SSM框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式消息中间件Kafka——Kafka的高可用</title>
    <link href="/2019/01/18/kafka-3/"/>
    <url>/2019/01/18/kafka-3/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/kafka-logo.png" srcset="/img/loading.gif" alt="kafka"></p><h3 id="高可用的由来"><a href="#高可用的由来" class="headerlink" title="高可用的由来"></a>高可用的由来</h3><h4 id="为何需要Replication"><a href="#为何需要Replication" class="headerlink" title="为何需要Replication"></a>为何需要Replication</h4><p>在Kafka在0.8以前的版本中，是没有Replication的，一旦某一个Broker宕机，则其上所有的Partition数据都不可被消费，这与Kafka数据持久性及Delivery Guarantee的设计目标相悖。同时Producer都不能再将数据存于这些Partition中。</p><p>　　如果Producer使用同步模式则Producer会在尝试重新发送message.send.max.retries（默认值为3）次后抛出Exception，用户可以选择停止发送后续数据也可选择继续选择发送。而前者会造成数据的阻塞，后者会造成本应发往该Broker的数据的丢失。</p><p>　　如果Producer使用异步模式，则Producer会尝试重新发送message.send.max.retries（默认值为3）次后记录该异常并继续发送后续数据，这会造成数据丢失并且用户只能通过日志发现该问题。同时，Kafka的Producer并未对异步模式提供callback接口。</p><p>　　由此可见，在没有Replication的情况下，一旦某机器宕机或者某个Broker停止工作则会造成整个系统的可用性降低。随着集群规模的增加，整个集群中出现该类异常的几率大大增加，因此对于生产系统而言Replication机制的引入非常重要。</p><h4 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h4><p> 引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。</p><p>因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一个宕机后其它Replica必须要能继续服务并且即不能造成数据重复也不能造成数据丢失）。如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（N×N条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的几率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。</p><hr><h3 id="Kafka-HA设计解析"><a href="#Kafka-HA设计解析" class="headerlink" title="Kafka HA设计解析"></a>Kafka HA设计解析</h3><h4 id="如何将所有Replica均匀分布到整个集群"><a href="#如何将所有Replica均匀分布到整个集群" class="headerlink" title="如何将所有Replica均匀分布到整个集群"></a>如何将所有Replica均匀分布到整个集群</h4><p>为了更好的做负载均衡，Kafka尽量将所有的Partition均匀分配到整个集群上。一个典型的部署方式是一个Topic的Partition数量大于Broker的数量。同时为了提高Kafka的容错能力，也需要将同一个Partition的Replica尽量分散到不同的机器。实际上，如果所有的Replica都在同一个Broker上，那一旦该Broker宕机，该Partition的所有Replica都无法工作，也就达不到HA的效果。同时，如果某个Broker宕机了，需要保证它上面的负载可以被均匀的分配到其它幸存的所有Broker上。</p><p>Kafka分配Replica的算法如下：</p><ol><li><p>将所有Broker（假设共n个Broker）和待分配的Partition排序</p></li><li><p>将第i个Partition分配到第（i mod n）个Broker上</p></li><li><p>将第i个Partition的第j个Replica分配到第（(i + j) mode n）个Broker上</p></li></ol><h4 id="Data-Replication（副本策略）"><a href="#Data-Replication（副本策略）" class="headerlink" title="Data Replication（副本策略）"></a>Data Replication（副本策略）</h4><p>Kafka的高可靠性的保障来源于其健壮的副本（replication）策略。</p><h5 id="消息传递同步策略"><a href="#消息传递同步策略" class="headerlink" title="消息传递同步策略"></a>消息传递同步策略</h5><p>Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少，Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW并且向Producer发送ACK。</p><p>为了提高性能，每个Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中。因此，对于已经commit的消息，Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被Consumer消费。</p><p>Consumer读消息也是从Leader读取，只有被commit过的消息才会暴露给Consumer。</p><p>Kafka Replication的数据流如下图所示：</p><p><img src="/images/kafka9.png" srcset="/img/loading.gif" alt="kafka"></p><h5 id="ACK前需要保证有多少个备份"><a href="#ACK前需要保证有多少个备份" class="headerlink" title="ACK前需要保证有多少个备份"></a>ACK前需要保证有多少个备份</h5><p>对于Kafka而言，定义一个Broker是否“活着”包含两个条件：</p><ul><li>一是它必须维护与ZooKeeper的session（这个通过ZooKeeper的Heartbeat机制来实现）。</li><li>二是Follower必须能够及时将Leader的消息复制过来，不能“落后太多”。<br>Leader会跟踪与其保持同步的Replica列表，该列表称为ISR（即in-sync Replica）。如果一个Follower宕机，或者落后太多，Leader将把它从ISR中移除。这里所描述的“落后太多”指Follower复制的消息落后于Leader后的条数超过预定值（该值可在$KAFKA_HOME/config/server.properties中通过replica.lag.max.messages配置，其默认值是4000）或者Follower超过一定时间（该值可在$KAFKA_HOME/config/server.properties中通过replica.lag.time.max.ms来配置，其默认值是10000）未向Leader发送fetch请求。</li></ul><p>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，完全同步复制要求所有能工作的Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率（高吞吐率是Kafka非常重要的一个特性）。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下如果Follower都复制完都落后于Leader，而如果Leader突然宕机，则会丢失数据。而Kafka的这种使用ISR的方式则很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，这样极大的提高复制性能（批量写磁盘），极大减少了Follower与Leader的差距。</p><p>需要说明的是，Kafka只解决fail/recover，不处理“Byzantine”（“拜占庭”）问题。一条消息只有被ISR里的所有Follower都从Leader复制过去才会被认为已提交。这样就避免了部分数据被写进了Leader，还没来得及被任何Follower复制就宕机了，而造成数据丢失（Consumer无法消费这些数据）。而对于Producer而言，它可以选择是否等待消息commit，这可以通过request.required.acks来设置。这种机制确保了只要ISR有一个或以上的Follower，一条被commit的消息就不会丢失。</p><h5 id="Leader-Election算法"><a href="#Leader-Election算法" class="headerlink" title="Leader Election算法"></a>Leader Election算法</h5><p>Leader选举本质上是一个分布式锁，有两种方式实现基于ZooKeeper的分布式锁：</p><ul><li>节点名称唯一性：多个客户端创建一个节点，只有成功创建节点的客户端才能获得锁</li><li>临时顺序节点：所有客户端在某个目录下创建自己的临时顺序节点，只有序号最小的才获得锁</li></ul><p>一种非常常用的选举leader的方式是“Majority Vote”（“少数服从多数”），但Kafka并未采用这种方式。这种模式下，如果我们有2f+1个Replica（包含Leader和Follower），那在commit之前必须保证有f+1个Replica复制完消息，为了保证正确选出新的Leader，fail的Replica不能超过f个。因为在剩下的任意f+1个Replica里，至少有一个Replica包含有最新的所有消息。这种方式有个很大的优势，系统的latency只取决于最快的几个Broker，而非最慢那个。Majority Vote也有一些劣势，为了保证Leader Election的正常进行，它所能容忍的fail的follower个数比较少。如果要容忍1个follower挂掉，必须要有3个以上的Replica，如果要容忍2个Follower挂掉，必须要有5个以上的Replica。也就是说，在生产环境下为了保证较高的容错程度，必须要有大量的Replica，而大量的Replica又会在大数据量下导致性能的急剧下降。这就是这种算法更多用在ZooKeeper这种共享集群配置的系统中而很少在需要存储大量数据的系统中使用的原因。例如HDFS的HA Feature是基于majority-vote-based journal，但是它的数据存储并没有使用这种方式。</p><p>Kafka在ZooKeeper中动态维护了一个ISR（in-sync replicas），这个ISR里的所有Replica都跟上了leader，只有ISR里的成员才有被选为Leader的可能。在这种模式下，对于f+1个Replica，一个Partition能在保证不丢失已经commit的消息的前提下容忍f个Replica的失败。在大多数使用场景中，这种模式是非常有利的。事实上，为了容忍f个Replica的失败，Majority Vote和ISR在commit前需要等待的Replica数量是一样的，但是ISR需要的总的Replica的个数几乎是Majority Vote的一半。</p><p>虽然Majority Vote与ISR相比有不需等待最慢的Broker这一优势，但是Kafka作者认为Kafka可以通过Producer选择是否被commit阻塞来改善这一问题，并且节省下来的Replica和磁盘使得ISR模式仍然值得。</p><h5 id="如何处理所有Replica都不工作"><a href="#如何处理所有Replica都不工作" class="headerlink" title="如何处理所有Replica都不工作"></a>如何处理所有Replica都不工作</h5><p>在ISR中至少有一个follower时，Kafka可以确保已经commit的数据不丢失，但如果某个Partition的所有Replica都宕机了，就无法保证数据不丢失了。这种情况下有两种可行的方案：</p><ol><li><p>等待ISR中的任一个Replica“活”过来，并且选它作为Leader</p></li><li><p>选择第一个“活”过来的Replica（不一定是ISR中的）作为Leader</p></li></ol><p>这就需要在可用性和一致性当中作出一个简单的折衷。如果一定要等待ISR中的Replica“活”过来，那不可用的时间就可能会相对较长。而且如果ISR中的所有Replica都无法“活”过来了，或者数据都丢失了，这个Partition将永远不可用。选择第一个“活”过来的Replica作为Leader，而这个Replica不是ISR中的Replica，那即使它并不保证已经包含了所有已commit的消息，它也会成为Leader而作为consumer的数据源（前文有说明，所有读写都由Leader完成）。Kafka0.8.x使用了第二种方式。根据Kafka的文档，在以后的版本中，Kafka支持用户通过配置选择这两种方式中的一种，从而根据不同的使用场景选择高可用性还是强一致性。</p><h5 id="选举Leader"><a href="#选举Leader" class="headerlink" title="选举Leader"></a>选举Leader</h5><p>最简单最直观的方案是，所有Follower都在ZooKeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（ZooKeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。</p><p>但是该方法会有3个问题：</p><ol><li><p>split-brain 这是由ZooKeeper的特性引起的，虽然ZooKeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致</p></li><li><p>herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整</p></li><li><p>ZooKeeper负载过重 每个Replica都要为此在ZooKeeper上注册一个Watch，当集群规模增加到几千个Partition时ZooKeeper负载会过重。</p></li></ol><p>Kafka 0.8.x的Leader Election方案解决了上述问题，它在所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比ZooKeeper Queue的方式更高效）通知需为为此作为响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。</p><hr><h3 id="HA相关ZooKeeper结构"><a href="#HA相关ZooKeeper结构" class="headerlink" title="HA相关ZooKeeper结构"></a>HA相关ZooKeeper结构</h3><p><img src="/images/kafka10.png" srcset="/img/loading.gif" alt="kafka"></p><h4 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h4><p>该目录下znode只有在有相关操作时才会存在，操作结束时会将其删除</p><p>/admin/reassign_partitions用于将一些Partition分配到不同的broker集合上。对于每个待重新分配的Partition，Kafka会在该znode上存储其所有的Replica和相应的Broker id。该znode由管理进程创建并且一旦重新分配成功它将会被自动移除。</p><h4 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h4><p>即/brokers/ids/[brokerId]）存储“活着”的broker信息。</p><p>topic注册信息（/brokers/topics/[topic]），存储该topic的所有partition的所有replica所在的broker id，第一个replica即为preferred replica，对一个给定的partition，它在同一个broker上最多只有一个replica,因此broker id可作为replica id。</p><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>/controller -&gt; int (broker id of the controller)存储当前controller的信息</p><p>/controller_epoch -&gt; int (epoch)直接以整数形式存储controller epoch，而非像其它znode一样以JSON字符串形式存储。</p><h3 id="producer发布消息"><a href="#producer发布消息" class="headerlink" title="producer发布消息"></a>producer发布消息</h3><h4 id="写入方式"><a href="#写入方式" class="headerlink" title="写入方式"></a>写入方式</h4><p>producer 采用 push 模式将消息发布到 broker，每条消息都被 append 到 patition 中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障 kafka 吞吐率）。</p><h4 id="消息路由"><a href="#消息路由" class="headerlink" title="消息路由"></a>消息路由</h4><p>producer 发送消息到 broker 时，会根据分区算法选择将其存储到哪一个 partition。其路由机制为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、 指定了 patition，则直接使用；</span><br><span class="line">2、 未指定 patition 但指定 key，通过对 key 的 value 进行<span class="built_in">hash</span> 选出一个 patition</span><br><span class="line">3、 patition 和 key 都未指定，使用轮询选出一个 patition。</span><br></pre></td></tr></table></figure><h4 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h4><p>producer 写入消息序列图如下所示：</p><p><img src="/images/kafka11.png" srcset="/img/loading.gif" alt="kafka"><br>流程说明：</p><blockquote><p>1、 producer 先从 zookeeper 的 “/brokers/…/state” 节点找到该 partition 的 leader<br>2、 producer 将消息发送给该 leader<br>3、 leader 将消息写入本地 log<br>4、 followers 从 leader pull 消息，写入本地 log 后 leader 发送 ACK<br>5、 leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset） 并向 producer 发送 ACK</p></blockquote><hr><h3 id="broker保存消息"><a href="#broker保存消息" class="headerlink" title="broker保存消息"></a>broker保存消息</h3><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>物理上把 topic 分成一个或多个 patition（对应 server.properties 中的 num.partitions=3 配置），每个 patition 物理上对应一个文件夹（该文件夹存储该 patition 的所有消息和索引文件），如下：</p><p><img src="/images/kafka12.png" srcset="/img/loading.gif" alt="kafka"></p><h4 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h4><p>无论消息是否被消费，kafka 都会保留所有消息。有两种策略可以删除旧数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、 基于时间：log.retention.hours=168 </span><br><span class="line">2、 基于大小：log.retention.bytes=1073741824</span><br></pre></td></tr></table></figure><hr><h3 id="Topic的创建和删除"><a href="#Topic的创建和删除" class="headerlink" title="Topic的创建和删除"></a>Topic的创建和删除</h3><h4 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h4><p>创建 topic 的序列图如下所示：<br><img src="/images/kafka13.png" srcset="/img/loading.gif" alt="kafka"></p><p>流程说明：</p><blockquote><p>1、 controller 在 ZooKeeper 的 /brokers/topics 节点上注册 watcher，当 topic 被创建，则 controller 会通过 watch 得到该 topic 的 partition/replica 分配。<br>2、 controller从 /brokers/ids 读取当前所有可用的 broker 列表，对于 set_p 中的每一个 partition：<br>     2.1、 从分配给该 partition 的所有 replica（称为AR）中任选一个可用的 broker 作为新的 leader，并将AR设置为新的 ISR<br>     2.2、 将新的 leader 和 ISR 写入 /brokers/topics/[topic]/partitions/[partition]/state<br>3、 controller 通过 RPC 向相关的 broker 发送 LeaderAndISRRequest。</p></blockquote><h4 id="删除topic"><a href="#删除topic" class="headerlink" title="删除topic"></a>删除topic</h4><p>删除 topic 的序列图如下所示：<br><img src="/images/kafka14.png" srcset="/img/loading.gif" alt="kafka"></p><p>流程说明：</p><blockquote><p>1、 controller 在 zooKeeper 的 /brokers/topics 节点上注册 watcher，当 topic 被删除，则 controller 会通过 watch 得到该 topic 的 partition/replica 分配。<br>2、 若 delete.topic.enable=false，结束；否则 controller 注册在 /admin/delete_topics 上的 watch 被 fire，controller 通过回调向对应的 broker 发送 StopReplicaRequest。</p></blockquote><h3 id="broker-failover"><a href="#broker-failover" class="headerlink" title="broker failover"></a>broker failover</h3><p>kafka broker failover 序列图如下所示：<br><img src="/images/kafka15.png" srcset="/img/loading.gif" alt="kafka"></p><p>流程说明：</p><blockquote><p>1、 controller 在 zookeeper 的 /brokers/ids/[brokerId] 节点注册 Watcher，当 broker 宕机时 zookeeper 会 fire watch<br>2、 controller 从 /brokers/ids 节点读取可用broker<br>3、 controller决定set_p，该集合包含宕机 broker 上的所有 partition<br>4、 对 set_p 中的每一个 partition<br>    4.1、 从/brokers/topics/[topic]/partitions/[partition]/state 节点读取 ISR<br>    4.2、 决定新 leader<br>    4.3、 将新 leader、ISR、controller_epoch 和 leader_epoch 等信息写入 state 节点<br>5、 通过 RPC 向相关 broker 发送 leaderAndISRRequest 命令</p></blockquote><h3 id="controller-failover"><a href="#controller-failover" class="headerlink" title="controller failover"></a>controller failover</h3><p>当 controller 宕机时会触发 controller failover。每个 broker 都会在 zookeeper 的 “/controller” 节点注册 watcher，当 controller 宕机时 zookeeper 中的临时节点消失，所有存活的 broker 收到 fire 的通知，每个 broker 都尝试创建新的 controller path，只有一个竞选成功并当选为 controller。</p><p>当新的 controller 当选时，会触发 KafkaController.onControllerFailover 方法，在该方法中完成如下操作：</p><blockquote><p>1、 读取并增加 Controller Epoch。<br>2、 在 reassignedPartitions Patch(/admin/reassign_partitions) 上注册 watcher。<br>3、 在 preferredReplicaElection Path(/admin/preferred_replica_election) 上注册 watcher。<br>4、 通过 partitionStateMachine 在 broker Topics Patch(/brokers/topics) 上注册 watcher。<br>5、 若 delete.topic.enable=true（默认值是 false），则 partitionStateMachine 在 Delete Topic Patch(/admin/delete_topics) 上注册 watcher。<br>6、 通过 replicaStateMachine在 Broker Ids Patch(/brokers/ids)上注册Watch。<br>7、 初始化 ControllerContext 对象，设置当前所有 topic，“活”着的 broker 列表，所有 partition 的 leader 及 ISR等。<br>8、 启动 replicaStateMachine 和 partitionStateMachine。<br>9、 将 brokerState 状态设置为 RunningAsController。<br>10、 将每个 partition 的 Leadership 信息发送给所有“活”着的 broker。<br>11、 若 auto.leader.rebalance.enable=true（默认值是true），则启动 partition-rebalance 线程。<br>12、 若 delete.topic.enable=true 且Delete Topic Patch(/admin/delete_topics)中有值，则删除相应的Topic。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka - 消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式消息中间件Kafka——Kafka的架构</title>
    <link href="/2019/01/06/kafka-2/"/>
    <url>/2019/01/06/kafka-2/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/kafka-logo.png" srcset="/img/loading.gif" alt="kafka"></p><h3 id="Kafka的架构"><a href="#Kafka的架构" class="headerlink" title="Kafka的架构"></a>Kafka的架构</h3><p><img src="/images/kafka6.png" srcset="/img/loading.gif" alt="kafka"></p><p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p><h3 id="Topics和Partition"><a href="#Topics和Partition" class="headerlink" title="Topics和Partition"></a>Topics和Partition</h3><p>Topic在逻辑上可以被认为是一个queue，每条消费都必须指定它的Topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时也会导致更高的不可用性，kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。因为每条消息都被append到该Partition中，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。</p><p><img src="/images/kafka7.png" srcset="/img/loading.gif" alt="kafka"></p><p>对于传统的message queue而言，一般会删除已经被消费的消息，而Kafka集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此Kafka提供两种策略删除旧数据。一是基于时间，二是基于Partition文件大小。例如可以通过配置$KAFKA_HOME/config/server.properties，让Kafka删除一周前的数据，也可在Partition文件超过1GB时删除旧数据，配置如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The minimum age of a log file to be eligible for deletion</span></span><br><span class="line">log.retention.hours=168</span><br><span class="line"><span class="comment"># The maximum size of a log segment file. When this size is reached a new log segment will be created.</span></span><br><span class="line">log.segment.bytes=1073741824</span><br><span class="line"><span class="comment"># The interval at which log segments are checked to see if they can be deleted according to the retention policies</span></span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line"><span class="comment"># If log.cleaner.enable=true is set the cleaner will be enabled and individual logs can then be marked for log compaction.</span></span><br><span class="line">log.cleaner.enable=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高Kafka性能无关。选择怎样的删除策略只与磁盘以及具体的需求有关。另外，Kafka会为每一个Consumer Group保留一些metadata信息——当前消费的消息的position，也即offset。这个offset由Consumer控制。正常情况下Consumer会在消费完一条消息后递增该offset。当然，Consumer也可将offset设成一个较小的值，重新消费一些消息。因为offet由Consumer控制，所以Kafka broker是无状态的，它不需要标记哪些消息被哪些消费过，也不需要通过broker去保证同一个Consumer Group只有一个Consumer能消费某一条消息，因此也就不需要锁机制，这也为Kafka的高吞吐率提供了有力保障。</p><h3 id="Producer消息路由"><a href="#Producer消息路由" class="headerlink" title="Producer消息路由"></a>Producer消息路由</h3><p>Producer发送消息到broker时，会根据Paritition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就实现了负载均衡。如果一个Topic对应一个文件，那这个文件所在的机器I/O将会成为这个Topic的性能瓶颈，而有了Partition后，不同的消息可以并行写入不同broker的不同Partition里，极大的提高了吞吐率。可以在$KAFKA_HOME/config/server.properties中通过配置项num.partitions来指定新建Topic的默认Partition数量，也可在创建Topic时通过参数指定，同时也可以在Topic创建之后通过Kafka提供的工具修改。</p><p>在发送一条消息时，可以指定这条消息的key，Producer根据这个key和Partition机制来判断应该将这条消息发送到哪个Parition。Paritition机制可以通过指定Producer的paritition. class这一参数来指定，该class必须实现kafka.producer.Partitioner接口。</p><h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>使用Consumer high level API时，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group可同时消费这一消息。</p><p><img src="/images/kafka8.png" srcset="/img/loading.gif" alt="kafka"></p><p>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某一个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要实现广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Consumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不需要多次发送消息到不同的Topic。</p><p>实际上，Kafka的设计理念之一就是同时提供离线处理和实时处理。根据这一特性，可以使用Storm这种实时流处理系统对消息进行实时在线处理，同时使用Hadoop这种批处理系统进行离线处理，还可以同时将数据实时备份到另一个数据中心，只需要保证这三个操作所使用的Consumer属于不同的Consumer Group即可。</p><h3 id="Push-vs-Pull"><a href="#Push-vs-Pull" class="headerlink" title="Push vs Pull"></a>Push vs Pull</h3><p>作为一个消息系统，Kafka遵循了传统的方式，选择由Producer向broker push消息并由Consumer从broker pull消息。一些logging-centric system，比如Facebook的Scribe和Cloudera的Flume，采用push模式。事实上，push模式和pull模式各有优劣。</p><p>push模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成Consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据Consumer的消费能力以适当的速率消费消息。</p><p>对于Kafka而言，pull模式更合适。pull模式可简化broker的设计，Consumer可自主控制消费消息的速率，同时Consumer可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p><h3 id="Kafka-delivery-guarantee"><a href="#Kafka-delivery-guarantee" class="headerlink" title="Kafka delivery guarantee"></a>Kafka delivery guarantee</h3><p>有这么几种可能的delivery guarantee：</p><blockquote><p>At most once 　　消息可能会丢，但绝不会重复传输<br>At least one 　　消息绝不会丢，但可能会重复传输<br>Exactly once 　　每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。</p></blockquote><p>当Producer向broker发送消息时，一旦这条消息被commit，因数replication的存在，它就不会丢。但是如果Producer发送数据给broker后，遇到网络问题而造成通信中断，那Producer就无法判断该条消息是否已经commit。虽然Kafka无法确定网络故障期间发生了什么，但是Producer可以生成一种类似于主键的东西，发生故障时幂等性的重试多次，这样就做到了Exactly once。</p><p>接下来讨论的是消息从broker到Consumer的delivery guarantee语义。（仅针对Kafka consumer high level API）。Consumer在从broker读取消息后，可以选择commit，该操作会在Zookeeper中保存该Consumer在该Partition中读取的消息的offset。该Consumer下一次再读该Partition时会从下一条开始读取。如未commit，下一次读取的开始位置会跟上一次commit之后的开始位置相同。当然可以将Consumer设置为autocommit，即Consumer一旦读到数据立即自动commit。如果只讨论这一读取消息的过程，那Kafka是确保了Exactly once。但实际使用中应用程序并非在Consumer读取完数据就结束了，而是要进行进一步处理，而数据处理与commit的顺序在很大程度上决定了消息从broker和consumer的delivery guarantee semantic。</p><p><font style="color: red">Kafka默认保证At least once</font>，并且允许通过设置Producer异步提交来实现At most once。而Exactly once要求与外部存储系统协作，幸运的是Kafka提供的offset可以非常直接非常容易得使用这种方式。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka - 消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式消息中间件Kafka——Kafka的简介</title>
    <link href="/2018/12/29/kafka-1/"/>
    <url>/2018/12/29/kafka-1/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/kafka-logo.png" srcset="/img/loading.gif" alt="kafka"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p><p>主要应用场景是：日志收集系统和消息系统。</p><p>Kafka主要设计目标如下：</p><ul><li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。</li><li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。</li><li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。</li><li>同时支持离线数据处理和实时数据处理。</li><li>Scale out:支持在线水平扩展。</li></ul><h4 id="消息系统介绍"><a href="#消息系统介绍" class="headerlink" title="消息系统介绍"></a>消息系统介绍</h4><p>一个消息系统负责将数据从一个应用传递到另外一个应用，应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。分布式消息传递基于可靠的消息队列，在客户端应用和消息系统之间异步传递消息。有两种主要的消息传递模式：<font style="color: red">点对点传递模式、发布-订阅模式</font>。大部分的消息系统选用发布-订阅模式。<font style="color: red">Kafka就是一种发布-订阅模式。</font></p><h4 id="点对点消息传递模式"><a href="#点对点消息传递模式" class="headerlink" title="点对点消息传递模式"></a>点对点消息传递模式</h4><p>在点对点消息系统中，消息持久化到一个队列中。此时，将有一个或多个消费者消费队列中的数据。但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序。这种架构描述示意图如下：</p><p><img src="/images/kafka3.png" srcset="/img/loading.gif" alt="kafka"><br><font style="color: red">生产者发送一条消息到queue，只有一个消费者能收到。</font></p><h4 id="发布-订阅消息传递模式"><a href="#发布-订阅消息传递模式" class="headerlink" title="发布-订阅消息传递模式"></a>发布-订阅消息传递模式</h4><p>在发布-订阅消息系统中，消息被持久化到一个topic中。与点对点消息系统不同的是，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除。在发布-订阅消息系统中，消息的生产者称为发布者，消费者称为订阅者。该模式的示例图如下：</p><p><img src="/images/kafka4.png" srcset="/img/loading.gif" alt="kafka"><br><font style="color: red">发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。</font></p><hr><h3 id="Kafka的优点"><a href="#Kafka的优点" class="headerlink" title="Kafka的优点"></a>Kafka的优点</h3><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><h4 id="冗余-副本"><a href="#冗余-副本" class="headerlink" title="冗余(副本)"></a>冗余(副本)</h4><p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p><h4 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h4><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p><h4 id="灵活性-amp-峰值处理能力"><a href="#灵活性-amp-峰值处理能力" class="headerlink" title="灵活性&amp;峰值处理能力"></a>灵活性&amp;峰值处理能力</h4><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p><h4 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性"></a>可恢复性</h4><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p><h4 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h4><p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。</p><h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。</p><h4 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h4><p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h3 id="常用Message-Queue对比"><a href="#常用Message-Queue对比" class="headerlink" title="常用Message Queue对比"></a>常用Message Queue对比</h3><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p><h4 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h4><p>ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm 0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块）。</p><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p>ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</p><h4 id="Kafka-Jafka"><a href="#Kafka-Jafka" class="headerlink" title="Kafka/Jafka"></a>Kafka/Jafka</h4><p>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p><h3 id="Kafka中的术语解释"><a href="#Kafka中的术语解释" class="headerlink" title="Kafka中的术语解释"></a>Kafka中的术语解释</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>在深入理解Kafka之前，先介绍一下Kafka中的术语。下图展示了Kafka的相关术语以及之间的关系：<br><img src="/images/kafka5.png" srcset="/img/loading.gif" alt="kafka"></p><p>上图中一个topic配置了3个partition。Partition1有两个offset：0和1。Partition2有4个offset。Partition3有1个offset。副本的id和副本所在的机器的id恰好相同。</p><p>如果一个topic的副本数为3，那么Kafka将在集群中为每个partition创建3个相同的副本。集群中的每个broker存储一个或多个partition。多个producer和consumer可同时生产和消费数据。</p><h4 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h4><p>Kafka 集群包含一个或多个服务器，服务器节点称为broker。</p><p>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</p><p>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</p><p>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</p><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p><p>类似于数据库的表名</p><h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><p>topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</p><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><p>生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息<font style="color: red">追加</font>到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</p><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</p><h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><p>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p><h4 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h4><p>每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</p><h4 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h4><p>Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka - 消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息中间件ActiveMQ入门学习</title>
    <link href="/2018/12/22/ActiveMQ/"/>
    <url>/2018/12/22/ActiveMQ/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h3><p><strong>什么是消息中间件？</strong><br>消息中间件利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。对于消息中间件，常见的角色有：Producer(生产者)、Consumer(消费者)。<br>常见的消息中间件产品有：</p><ul><li>ActiveMQ: Apache的一款完全支持JMS1.1和J2EE1.4规范的JMS Provider实现。</li><li>RabbitMQ: AMQP协议的领导实现，支持多种场景。</li><li>ZeroMQ: 号称史上最快的消息队列系统。</li><li>Kafka: Apache下的一个子项目，具有高吞吐的特点。</li></ul><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>本例中将ArtiveMQ部署在虚拟机Centos服务器上。</p><p><strong>搭建</strong></p><p>首先去下载ActiveMQ: <a href="http://activemq.apache.org" target="_blank" rel="noopener">官网地址</a></p><blockquote><ol><li>打开虚拟机上的CentOS服务器，打开SecureCRT连接上服务器。</li></ol></blockquote><blockquote><ol start="2"><li>输入命令：rz将本地下载的apache-activemq-bin.tar.gz文件上传到linux服务器上</li></ol></blockquote><p>输入以下命令解压文件并赋予权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--解压</span><br><span class="line">tar zxvf apache-activemq-5.15.6-bin.tar.gz</span><br><span class="line">--赋予可读可写可执行的权限</span><br><span class="line">chmod 777 apache-activemq-5.15.6</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> apache-activemq-5.15.6/bin</span><br><span class="line">--赋予权限</span><br><span class="line">chmod 755 activemq</span><br><span class="line"></span><br><span class="line">--启动activemq</span><br><span class="line">./activemq start</span><br></pre></td></tr></table></figure><p><strong>拓展</strong></p><p>chmod是Linux下设置文件权限的命令，后面的数字代表了不同用户组的权限，一般时三个数字：</p><ul><li>第一个数字表示文件所有者的权限</li><li>第二个数字表示与文件所有者同属于一个用户组的其他用户的权限</li><li>第三个数字表示其他用户组的权限<br>权限分为三种：读(r=4)、写(r=2)、执行(r=1)。综合起来：可读可执行(rx=5=4+1)、可读可写(rw=6=4+2)、可读可写可执行(rwx=7=4+2+1)。<br><img src="/images/active1.png" srcset="/img/loading.gif" alt="ActiveMQ"><br>在浏览器上访问ip:8161地址<br><img src="/images/active2.png" srcset="/img/loading.gif" alt="ActiveMQ"><br>8161端口是ActiveMQ默认的端口，点击Manage ActiveMQ broker，需要输入用户名密码：默认都是admin<br><img src="/images/active3.png" srcset="/img/loading.gif" alt="ActiveMQ"></li></ul><hr><h3 id="JMS入门"><a href="#JMS入门" class="headerlink" title="JMS入门"></a>JMS入门</h3><p>上面我们在服务器上部署了ActiveMQ，对应实际应用中肯定需要一个入口方式操作ActiveMQ，所以我们要学习：JMS（Java Messaging Service）。</p><p>JMS是Java平台上有关面向中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。</p><p>JMS本身定义了一系列的接口规范，可以用其访问ActiveMQ发送消息服务。JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接受一些不同形式的数据，提供现有消息格式的一些级别的兼容性：</p><ul><li>TextMessage – 一个字符串对象</li><li>MapMessage – 一套名称-值对</li><li>ObjectMessage – 一个序列化的Java对象</li><li>BytesMessage – 一个字节的数据流</li><li>StreamMessage – Java原始值的数据流</li></ul><h4 id="JMS消息传递类型"><a href="#JMS消息传递类型" class="headerlink" title="JMS消息传递类型"></a>JMS消息传递类型</h4><p>JMS有两种消息传递类型，适用于不同的情况，分别是：</p><ul><li>Producer–&gt;Consumer点对点模式：一个生产者对应一个消费者。</li><li>Producer–&gt;Consumer/Consumer发布订阅模式：一个生产者可对应多个消费者。</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>先在工程中导入activemq依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;activemq-client&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.13.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h5><p>点对点模式主要建立在一个队列上面，当连接一个队列的时候，发送端不需要知道接收端是否正在接收，可以直接向ActiveMQ发送消息，发送的消息将会先进入队列中，如果有接收端监听，则会发向接受端；如果没有接收端接收，则会保存在activeMQ服务器，直到接收端接收消息。点对点消息模式可以有多个发送端，多个接收端，但是一条消息，只会被一个接收端给接收到，那个接收端先连接上ActiveMQ，则会先接收到，而后来的接收端接收不到那条消息。</p><p>先在工程中导入activemq依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;activemq-client&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.13.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><ol><li>创建QueueProducer.java 生产者类</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class QueueProducer &#123;</span><br><span class="line">    public static void main(String[] args) throws JMSException &#123;</span><br><span class="line">        //1、创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(<span class="string">"tcp://192.168.148.128:61616"</span>);</span><br><span class="line"></span><br><span class="line">        //2、获取连接</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">        //3、启动连接</span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        //4、获取session（参数1：是否启动事务；参数2：消息确认模式）</span><br><span class="line">        //      AUTO_ACKNOWLEDGE = 1  自动确认</span><br><span class="line">        //      CLIENT_ACKNOWLEDGE = 2  客户端手动确认</span><br><span class="line">        //      DUPS_OK_ACKNOWLEDGE = 3  自动批量确认</span><br><span class="line">        //      SESSION_TRANSACTED = 0  事务提交并确认</span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">        //5、创建消息队列对象</span><br><span class="line">        Queue queue = session.createQueue(<span class="string">"test-queue"</span>);</span><br><span class="line"></span><br><span class="line">        //6、创建消息生产者</span><br><span class="line">        MessageProducer producer = session.createProducer(queue);</span><br><span class="line"></span><br><span class="line">        //7、创建消息</span><br><span class="line">        TextMessage textMessage = session.createTextMessage(<span class="string">"ActiveMQ入门"</span>);</span><br><span class="line"></span><br><span class="line">        //8、发送消息</span><br><span class="line">        producer.send(textMessage);</span><br><span class="line"></span><br><span class="line">        //9、关闭资源</span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，步骤一中的连接地址根据自己的ActiveMQ服务器地址决定，但是<strong>61616是ActiveMQ默认端口</strong>，无需改变。这里我们创建了一个消息队列对象text-queue，并用TextMessage格式发送了一条消息：ActiveMQ入门。 如果我们理解运行着这个生产者类，在ActiveMQ控制台中会看到：<br><img src="/images/active4.png" srcset="/img/loading.gif" alt="ActiveMQ"></p><p>那么消费端是如何接受到这个消息的呢？</p><blockquote><ol start="2"><li>创建QueueConsumer.java 消费者类</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class QueueConsumer &#123;</span><br><span class="line">    public static void main(String[] args) throws JMSException, IOException &#123;</span><br><span class="line">        //1、创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(<span class="string">"tcp://192.168.148.128:61616"</span>);</span><br><span class="line"></span><br><span class="line">        //2、获取连接</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">        //3、启动连接</span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        //4、获取session（参数1：是否启动事务；参数2：消息确认模式）</span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">        //5、创建队列对象</span><br><span class="line">        Queue queue = session.createQueue(<span class="string">"test-queue"</span>);</span><br><span class="line"></span><br><span class="line">        //6、创建消息消费</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line"></span><br><span class="line">        //7、监听消息</span><br><span class="line">        consumer.setMessageListener(new <span class="function"><span class="title">MessageListener</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onMessage(Message message) &#123;</span><br><span class="line">                TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收到消息："</span> + textMessage.getText());</span><br><span class="line">                &#125; catch (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //8、等待键盘输入</span><br><span class="line">        System.in.read();</span><br><span class="line">        //9、关闭资源</span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上一共9个步骤，步骤一中创建连接地址要结合自己的ActiveMQ服务器地址。前6个步骤都是和生产者创建步骤相同的，只有第7个步骤是独特的，因为消费端要实现监听生产端的消息，如果生产端有消息就会打印出来。<br>运行QueueConsumer即可得到刚才发送的消息：Active入门。<br>如果我们再次运行QueueConsumer消费端，则不会再得到消息，因为点对点模式只能有一个消费端接收消息，第二个消费端是接收不到消息的。</p><h5 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h5><blockquote><ol><li>创建生产者TopicProducer.java</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class TopicProducer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JMSException &#123;</span><br><span class="line"></span><br><span class="line">        //1、创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(<span class="string">"tcp://192.168.148.128:61616"</span>);</span><br><span class="line"></span><br><span class="line">        //2、获取连接</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">        //3、启动连接</span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        //4、获取session（参数1：是否启动事务；参数2：消息确认模式）</span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">        //5、创建主题对象</span><br><span class="line">        Topic topic = session.createTopic(<span class="string">"test-topic"</span>);</span><br><span class="line"></span><br><span class="line">        //6、创建消息生产者</span><br><span class="line">        MessageProducer producer = session.createProducer(topic);</span><br><span class="line"></span><br><span class="line">        //7、创建消息</span><br><span class="line">        TextMessage textMessage = session.createTextMessage(<span class="string">"ActiveMQ---&gt;发布订阅模式消息..."</span>);</span><br><span class="line"></span><br><span class="line">        //8、发送消息</span><br><span class="line">        producer.send(textMessage);</span><br><span class="line"></span><br><span class="line">        //9、关闭资源</span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与点对点模式不同之处在与，发布/订阅模式创建的是Topic主题对象，而点对点模式创建的是Queue队列对象</p><blockquote><ol start="2"><li>创建TopicConsumer.java 消费端</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class TopicConsumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JMSException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        //1、创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(<span class="string">"tcp://192.168.148.128:61616"</span>);</span><br><span class="line"></span><br><span class="line">        //2、获取连接</span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">        //3、启动连接</span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        //4、获取session（参数1：是否启动事务；参数2：消息确认模式）</span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">        //5、创建主题对象</span><br><span class="line">        Topic topic = session.createTopic(<span class="string">"test-topic"</span>);</span><br><span class="line"></span><br><span class="line">        //6、创建消息消费者</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line"></span><br><span class="line">        //7、监听消息</span><br><span class="line">        consumer.setMessageListener(new <span class="function"><span class="title">MessageListener</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onMessage(Message message) &#123;</span><br><span class="line">                TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收到的消息："</span> + textMessage.getText());</span><br><span class="line">                &#125; catch (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        //8、等待键盘输入</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        //9、关闭资源</span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行生产端和消费端，发现消费端并不显示消息；然后先运行消费端再运行生产端就打印出了消息：ActiveMQ—&gt;发布订阅模式消息。<br>原因就是发布/订阅模式和点对点模式是不同的，发布订阅模式可以允许多个接收端接收同一个生产端发布的消息；你可以理解为只有订阅了消息，才能发布消息。</p><h3 id="Spring整合JMS"><a href="#Spring整合JMS" class="headerlink" title="Spring整合JMS"></a>Spring整合JMS</h3><p>首先要在工程中导入spring-jms依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.13.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="点对点模式-1"><a href="#点对点模式-1" class="headerlink" title="点对点模式"></a>点对点模式</h4><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><p>这里生产端和服务端是两个不同的项目。</p><blockquote><ol><li>生产端jms-producer.xml</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">"cn.demo"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的JMS服务厂商提供 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"targetConnectionFactory"</span> class=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"brokerURL"</span> value=<span class="string">"tcp://192.168.148.128:61616"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"connectionFactory"</span> class=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;!-- 目标ConnectionFactory对应真实可以产生JMS Connection的ConnectionFactory --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"targetConnectionFactory"</span> ref=<span class="string">"targetConnectionFactory"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"jmsTemplate"</span> class=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span><br><span class="line">        &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这个是队列的目的地，点对点 文本信息 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueTextDestination"</span> class=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"queue_text"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>以上了配置和之前的直接在Java代码上的配置类似，多了一个jmsTemplate模板工具类的配置，如同Spring-Data-Solr中有一个solrTemplate工具类、Spring-Data-Redis有一个redisTemplate工具类。jmsTemplate模板工具类提供了很多API供开发者操作JMS。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>创建QueueProducer.java</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class QueueProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Destination queueTextDestination;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发送文本消息</span><br><span class="line">     * @param text</span><br><span class="line">     */</span><br><span class="line">    public void sendTextMessage(final String text)&#123;</span><br><span class="line">        jmsTemplate.send(queueTextDestination, new <span class="function"><span class="title">MessageCreator</span></span>() &#123;</span><br><span class="line">            public Message createMessage(Session session) throws JMSException &#123;</span><br><span class="line">                <span class="built_in">return</span> session.createTextMessage(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了要注入JmsTemplate模板类对象，还要注入Destination对象，之前我们是通过new Queue()来创建队列对象的，而spring整合jms后是在配置文件中配置的队列对象，</p><blockquote><ol start="2"><li>消费端</li></ol></blockquote><p>创建jms-consumer-queue.xml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的JMS服务厂商提供 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"targetConnectionFactory"</span> class=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"brokerURL"</span> value=<span class="string">"tcp://192.168.148.128:61616"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring用于真正的ConnectionFactory的ConnectionFactory --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"connectionFactory"</span> class=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"targetConnectionFactory"</span> ref=<span class="string">"targetConnectionFactory"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这个是队列的目的地，点对点  文本信息 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"queueTextDestination"</span> class=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"queue_text"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 我的监听类 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"myMessageListener"</span> class=<span class="string">"cn.demo.MyMessageListener"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 消息监听容器 --&gt;</span><br><span class="line">    &lt;bean class=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"queueTextDestination"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"myMessageListener"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>这里注入了自定义的消费端监听类MyMessageListener.java:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyMessageListener implements MessageListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Message message) &#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage) message;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收到的消息："</span> + textMessage.getText());</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>在消费端工程中创建测试方法，启动监听</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = <span class="string">"classpath:applicationContext-jms-consumer-queue.xml"</span>)</span><br><span class="line">public class TestQueueC &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">testQueue</span></span>()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>在生产端工程中创建测试方法，发送消息：</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = <span class="string">"classpath:spring/applicationContext-jms-producer.xml"</span>)</span><br><span class="line">public class TestQueueP &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private QueueProducer queueProducer;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">testSend</span></span>() &#123;</span><br><span class="line">        queueProducer.sendTextMessage(<span class="string">"SpringJms-点对点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动生产端，发送消息，在消费端立即点听到消息并打印出来。和之前JMS的案例是相同的。</p><h4 id="发布-订阅模式-1"><a href="#发布-订阅模式-1" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h4><blockquote><ol><li>在上面的jms-producer.xml中添加配置：</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这个是订阅模式  文本信息 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"topicTextDestination"</span> class=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"topic_text"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>创建TopicProducer.java</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TopicProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Destination topicTextDestination;</span><br><span class="line"></span><br><span class="line">    public void sendTextMessage(final String text)&#123;</span><br><span class="line">        jmsTemplate.send(topicTextDestination, new <span class="function"><span class="title">MessageCreator</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Message createMessage(Session session) throws JMSException &#123;</span><br><span class="line">                <span class="built_in">return</span> session.createTextMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>在上面消费端工程中创建jms-topic.xml</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 真正可以产生Connection的ConnectionFactory, 由对应的JMS服务厂商提供 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"targetConnectionFactory"</span> class=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"brokerURL"</span> value=<span class="string">"tcp://192.168.148.128:61616"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring用户管理真正的ConnectionFactory的ConnectionFactory --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"connectionFactory"</span> class=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span><br><span class="line">        &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"targetConnectionFactory"</span> ref=<span class="string">"targetConnectionFactory"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这个是队列的目的地，点对点的文本信息 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"topicTextDestination"</span> class=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"topic_text"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 我的监听类 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"myMessageListener"</span> class=<span class="string">"cn.demo.MyMessageListener"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 消息监听容器 --&gt;</span><br><span class="line">    &lt;bean class=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"connectionFactory"</span> ref=<span class="string">"connectionFactory"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"destination"</span> ref=<span class="string">"topicTextDestination"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"messageListener"</span> ref=<span class="string">"myMessageListener"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>监听类还是之前的MyMessageListener.java。</p><blockquote><ol start="4"><li>在生产端创建测试类</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = <span class="string">"classpath:spring/applicationContext-jms-producer.xml"</span>)</span><br><span class="line">public class TestTopicP &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TopicProducer topicProducer;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">sendTextQueue</span></span>()&#123;</span><br><span class="line">        topicProducer.sendTextMessage(<span class="string">"Spring JMS 发布订阅信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动消费端监听，并运行生产端发布消息，在消费端立即监听到消息并打印出来数据。</p><p>到此为止我们完成了基本的ActiveMQ入门学习。</p><p>思考：在上面我们使用ActiveMQ案例中明显就感觉到消息中间件的一大优势就是采用了一种与平台无关的数据交流方式，在分布式项目中用处很广，比如基本的增、删、改、查数据都可以通过ActiveMQ进行信息传递，ActiveMQ支持多种数据类型的传递。</p><p>这样我们就解决了分布式模板间的耦合关系，模块间的消息传递不再通过调用（高耦合）方式传递消息，而是通过ActiveMQ（低耦合）异步的发送消息。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ActiveMQ - 消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2018/12/14/linux-1/"/>
    <url>/2018/12/14/linux-1/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/linux-logo.jpg" srcset="/img/loading.gif" alt="linux"></p><hr><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ shutdown -h now        立刻关机</span><br><span class="line">$ shutdown -h 5        5分钟后关机</span><br><span class="line">$ poweroff            立刻关机</span><br></pre></td></tr></table></figure><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">help</span>命令</span><br><span class="line">$ shutdown --<span class="built_in">help</span>：</span><br><span class="line">$ ifconfig  --<span class="built_in">help</span>：查看网卡信息</span><br><span class="line"> </span><br><span class="line">--man命令（命令说明书） </span><br><span class="line">$ man shutdown</span><br><span class="line">--注意：man shutdown打开命令说明书之后，使用按键q退出</span><br></pre></td></tr></table></figure><hr><h3 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h3><h4 id="目录切换-cd"><a href="#目录切换-cd" class="headerlink" title="目录切换 cd"></a>目录切换 cd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--命令：<span class="built_in">cd</span> 目录</span><br><span class="line">$ <span class="built_in">cd</span> /        切换到根目录</span><br><span class="line">$ <span class="built_in">cd</span> /usr        切换到根目录下的usr目录</span><br><span class="line">$ <span class="built_in">cd</span> ../        切换到上一级目录 或者  <span class="built_in">cd</span> ..</span><br><span class="line">$ <span class="built_in">cd</span> ~        切换到home目录</span><br><span class="line">$ <span class="built_in">cd</span> -        切换到上次访问的目录</span><br></pre></td></tr></table></figure><h4 id="目录查看-ls-al"><a href="#目录查看-ls-al" class="headerlink" title="目录查看 ls [-al]"></a>目录查看 ls [-al]</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--命令：ls [-al]</span><br><span class="line">$ ls                查看当前目录下的所有目录和文件</span><br><span class="line">$ ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）</span><br><span class="line">$ ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）</span><br><span class="line">$ ls /dir            查看指定目录下的所有目录和文件   如：ls /usr</span><br></pre></td></tr></table></figure><h4 id="目录操作-增删改查"><a href="#目录操作-增删改查" class="headerlink" title="目录操作 [增删改查]"></a>目录操作 [增删改查]</h4><h5 id="创建目录-增-mkdir"><a href="#创建目录-增-mkdir" class="headerlink" title="创建目录 [增] mkdir"></a>创建目录 [增] mkdir</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--命令：mkdir 目录</span><br><span class="line">$ mkdir xxx           在当前目录下创建一个名为xxx的目录</span><br><span class="line">$ mkdir /usr/xxx   在指定目录下创建一个名为xxx的目录</span><br></pre></td></tr></table></figure><h5 id="删除目录或文件-删-rm"><a href="#删除目录或文件-删-rm" class="headerlink" title="删除目录或文件 [删] rm"></a>删除目录或文件 [删] rm</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--命令：rm [-rf] 目录</span><br><span class="line"></span><br><span class="line">删除文件：</span><br><span class="line">$ rm 文件        删除当前目录下的文件</span><br><span class="line">$ rm -f 文件    删除当前目录的的文件（不询问）</span><br><span class="line"></span><br><span class="line">删除目录：</span><br><span class="line">$ rm -r xxx  递归删除当前目录下的xxx目录</span><br><span class="line">$ rm -rf xxx  递归删除当前目录下的xxx目录（不询问）</span><br><span class="line"></span><br><span class="line">全部删除：</span><br><span class="line">$ rm -rf *    将当前目录下的所有目录和文件全部删除</span><br><span class="line">$ rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</span><br><span class="line"></span><br><span class="line">注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</span><br></pre></td></tr></table></figure><h5 id="目录修改-改-mv和cp"><a href="#目录修改-改-mv和cp" class="headerlink" title="目录修改 [改] mv和cp"></a>目录修改 [改] mv和cp</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一、重命名目录</span><br><span class="line">    命令：mv 当前目录  新目录</span><br><span class="line">    例如：mv xxx coder    将目录xxx改为coder</span><br><span class="line">    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作</span><br><span class="line"></span><br><span class="line">二、剪切目录</span><br><span class="line">    命令：mv 目录名称 目录的新位置</span><br><span class="line">    示例：将/usr/tmp目录下的xxx目录剪切到 /usr目录下面     mv /usr/tmp/xxx /usr</span><br><span class="line">    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</span><br><span class="line"></span><br><span class="line">三、拷贝目录</span><br><span class="line">    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归</span><br><span class="line">    示例：将/usr/tmp目录下的xxx目录复制到 /usr目录下面     cp /usr/tmp/xxx  /usr</span><br><span class="line">    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用写-r递归</span><br></pre></td></tr></table></figure><h5 id="搜索目录-查-find"><a href="#搜索目录-查-find" class="headerlink" title="搜索目录 [查] find"></a>搜索目录 [查] find</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find 目录 参数 文件名称</span><br><span class="line">示例：find /usr/tmp -name <span class="string">'a*'</span>  查找/usr/tmp目录下的所有以a开头的目录或文件</span><br></pre></td></tr></table></figure><hr><h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><h4 id="文件操作-增删改查"><a href="#文件操作-增删改查" class="headerlink" title="文件操作 [增删改查]"></a>文件操作 [增删改查]</h4><h5 id="新建文件-增-touch"><a href="#新建文件-增-touch" class="headerlink" title="新建文件 [增] touch"></a>新建文件 [增] touch</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch 文件名</span><br><span class="line">示例：在当前目录创建一个名为aa.txt的文件 touch xxx.txt</span><br></pre></td></tr></table></figure><h5 id="删除文件-删-rm"><a href="#删除文件-删-rm" class="headerlink" title="删除文件 [删] rm"></a>删除文件 [删] rm</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf 文件名</span><br></pre></td></tr></table></figure><h5 id="修改文件-改-vi-vim"><a href="#修改文件-改-vi-vim" class="headerlink" title="修改文件 [改] vi/vim"></a>修改文件 [改] vi/vim</h5><p><strong>[vi编辑器的3种模式]</strong><br>基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p><ul><li><p>命令行模式command mode）<br>控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>  命令行模式下的常用命令：</p><pre><code>- 控制光标移动：↑，↓，j- 删除当前行：dd - 查找：/字符- 进入编辑模式：i o a- 进入底行模式：:</code></pre></li><li><p>编辑模式（Insert mode）<br>  只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>  编辑模式下常用命令：</p><pre><code>- ESC 退出编辑模式到命令行模式；</code></pre></li><li><p>底行模式（last line mode）<br>  将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>  底行模式下常用命令：</p><pre><code>- 退出编辑：   :q- 强制退出：   :q!- 保存并退出：  :wq</code></pre></li></ul><p><strong>打开文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vi 文件名</span><br><span class="line">示例：打开当前目录下的xxx.txt文件  vi xxx.txt 或者 vim xxx.txt</span><br><span class="line">注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。</span><br></pre></td></tr></table></figure><p><strong>编辑文件</strong></p><p>使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。<br>i:在光标所在字符前开始插入<br>a:在光标所在字符后开始插入<br>o:在光标所在行的下面另起一新行插入</p><p><strong>保存或者取消编辑</strong></p><p>保存文件：<br>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：wq     保存并退出编辑<br>取消编辑：</p><p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：q!     撤销本次修改并退出编辑</p><h5 id="文件的查看-查"><a href="#文件的查看-查" class="headerlink" title="文件的查看 [查]"></a>文件的查看 [查]</h5><p>文件的查看命令：cat/more/less/tail<br><strong>cat：看最后一屏</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容</span><br><span class="line">$ cat sudo.conf</span><br></pre></td></tr></table></figure><p><strong>more：百分比显示</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看</span><br><span class="line">$ more sudo.conf</span><br></pre></td></tr></table></figure><p><strong>less：翻页查看</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看</span><br><span class="line">$ less sudo.conf</span><br></pre></td></tr></table></figure><p><strong>tail：指定行数或者动态查看</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束  </span><br><span class="line">$ tail -10 sudo.conf</span><br></pre></td></tr></table></figure><h4 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h4><p>rwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。</p><p>示例：给xxx.txt文件权限改为可执行文件权限，xxx.txt文件的权限是-rw — —</p><p>第一位：-就代表是文件，d代表是文件夹<br>第一段（3位）：代表拥有者的权限<br>第二段（3位）：代表拥有者所在的组，组员的权限<br>第三段（最后3位）：代表的是其他用户的权限</p><p>421  421  421<br>rw-  —  —</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x xxx.txt</span><br><span class="line">或者采用8421法</span><br><span class="line">$ chmod 100 xxx.txt</span><br></pre></td></tr></table></figure><hr><h3 id="压缩文件操作"><a href="#压缩文件操作" class="headerlink" title="压缩文件操作"></a>压缩文件操作</h3><h4 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h4><p>Windows的压缩文件的扩展名  .zip/.rar<br>linux中的打包文件：xxx.tar<br>linux中的压缩文件：xxx.gz<br>linux中打包并压缩的文件：.tar.gz</p><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">命令：tar -zcvf 打包压缩后的文件名 要打包的文件</span><br><span class="line">其中：z：调用gzip压缩命令进行压缩</span><br><span class="line">  c：打包文件</span><br><span class="line">  v：显示运行过程</span><br><span class="line">  f：指定文件名</span><br><span class="line">示例：打包并压缩/usr/tmp下的所有文件压缩后的压缩包指定名称为xxx.tar</span><br><span class="line">$ tar -zcvf xxx.tar xx.txt xxx.txt </span><br><span class="line">或</span><br><span class="line">$ tar -zcvf xx.tar *</span><br></pre></td></tr></table></figure><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令：tar [-zxvf] 压缩文件    </span><br><span class="line">其中：x：代表解压</span><br><span class="line">示例：将/usr/tmp下的xxx.tar解压到当前目录下</span><br><span class="line">$ tar -zxvf xxx.tar</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：将/usr/tmp 下的xx.tar解压到根目录/usr下</span><br><span class="line">$ tar -zxvf xx.tar -C /usr -C代表指定解压的位置</span><br></pre></td></tr></table></figure><hr><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep命令是一种强大的文本搜索工具<br>使用实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep sshd  查找指定ssh服务进程 </span><br><span class="line">$ ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除grep本身 </span><br><span class="line">$ ps -ef | grep sshd -c 查找指定进程个数</span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。<br>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。<br>使用实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name <span class="string">"*.log"</span> -ls  在当前目录查找以.<span class="built_in">log</span>结尾的文件，并显示详细信息。 </span><br><span class="line">$ find /root/ -perm 600   查找/root/目录下权限为600的文件 </span><br><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">"*.log"</span>  查找当目录，以.<span class="built_in">log</span>结尾的普通文件 </span><br><span class="line">$ find . -<span class="built_in">type</span> d | sort   查找当前所有目录并排序 </span><br><span class="line">$ find . -size +100M  查找当前目录大于100M的文件</span><br></pre></td></tr></table></figure><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>locate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，<font style="color: red">先使用updatedb命令</font>，手动更新数据库。如果数据库中没有查询的数据，则会报出<font style="color: red">locate: can not stat () ‘/var/lib/mlocate/mlocate.db’: No such file or directory</font>该错误！updatedb即可！</p><p><strong><code>yum -y install mlocate</code>如果是精简版CentOS系统需要安装locate命令</strong><br>使用实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updatedb</span><br><span class="line">$ locate /etc/sh 搜索etc目录下所有以sh开头的文件 </span><br><span class="line">$ locate <span class="built_in">pwd</span> 查找和<span class="built_in">pwd</span>相关的所有文件</span><br></pre></td></tr></table></figure><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。<br>使用实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whereis ls    将和ls文件相关的文件都查找出来</span><br></pre></td></tr></table></figure><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>which命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。<br>使用实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> <span class="built_in">pwd</span>  查找<span class="built_in">pwd</span>命令所在路径 </span><br><span class="line">$ <span class="built_in">which</span> java  查找path中java的路径</span><br></pre></td></tr></table></figure><hr><h3 id="su-sudo"><a href="#su-sudo" class="headerlink" title="su/sudo"></a>su/sudo</h3><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>su用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ su <span class="built_in">test</span>:切换到<span class="built_in">test</span>用户，但是路径还是/root目录</span><br><span class="line">$ su - <span class="built_in">test</span> : 切换到<span class="built_in">test</span>用户，路径变成了/home/<span class="built_in">test</span></span><br><span class="line">$ su : 切换到root用户，但是路径还是原来的路径</span><br><span class="line">$ su - : 切换到root用户，并且路径是/root</span><br></pre></td></tr></table></figure><p>su不足：如果某个用户需要使用root权限、则必须要把root密码告诉此用户。<br>退出返回之前的用户：exit</p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>sudo是为所有想使用root权限的普通用户设计的。可以让普通用户具有临时使用root权限的权利。只需输入自己账户的密码即可。<br>进入sudo配置文件命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sudoer或者visudo</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line">允许hadoop用户以root身份执行各种应用命令，需要输入hadoop用户的密码。</span><br><span class="line">$ hadoop  ALL=(ALL)   ALL </span><br><span class="line"> </span><br><span class="line">案例：</span><br><span class="line">只允许hadoop用户以root身份执行ls 、cat命令，并且执行时候免输入密码。 </span><br><span class="line">配置文件中： </span><br><span class="line">$ hadoop  ALL=NOPASSWD:  /bin/ls, /bin/cat</span><br></pre></td></tr></table></figure><hr><h3 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ service iptables status  --查看iptables服务的状态</span><br><span class="line">$ service iptables start  --开启iptables服务</span><br><span class="line">$ service iptables stop  --停止iptables服务</span><br><span class="line">$ service iptables restart  --重启iptables服务</span><br><span class="line">$ chkconfig iptables off  --关闭iptables服务的开机自启动</span><br><span class="line">$ chkconfig iptables on  --开启iptables服务的开机自启动</span><br></pre></td></tr></table></figure><hr><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><h4 id="主机名配置"><a href="#主机名配置" class="headerlink" title="主机名配置"></a>主机名配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@loonycoder ~]<span class="comment"># vi /etc/sysconfig/network</span></span><br><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=loonycoder</span><br></pre></td></tr></table></figure><h4 id="IP-地址配置"><a href="#IP-地址配置" class="headerlink" title="IP 地址配置"></a>IP 地址配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@loonycoder ~]<span class="comment"># vi /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br></pre></td></tr></table></figure><h4 id="域名映射"><a href="#域名映射" class="headerlink" title="域名映射"></a>域名映射</h4><p>/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用。所以，你想访问一个什么样的主机名，就需要把这个主机名和它对应的ip地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@loonycoder ~]<span class="comment"># vi /etc/hosts</span></span><br><span class="line"><span class="comment">#### 在最后加上</span></span><br><span class="line">192.168.0.1  node1</span><br><span class="line">192.168.0.2  node2</span><br><span class="line">192.168.0.3  node3</span><br></pre></td></tr></table></figure><hr><h3 id="定时任务指令crontab-配置"><a href="#定时任务指令crontab-配置" class="headerlink" title="定时任务指令crontab 配置"></a>定时任务指令crontab 配置</h3><p>crontab是Unix和Linux用于设置定时任务的指令。通过crontab命令，可以在固定间隔时间,执行指定的系统指令或shell脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。<br>crontab安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install crontabs</span><br></pre></td></tr></table></figure><p>服务操作说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ service crond start   <span class="comment">## 启动服务 </span></span><br><span class="line">$ service crond stop    <span class="comment">## 关闭服务 </span></span><br><span class="line">$ service crond restart <span class="comment">## 重启服务</span></span><br></pre></td></tr></table></figure><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab [-u user] file</span><br><span class="line">$ crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure><p>参数说明：<br><strong>-u user</strong>：用来设定某个用户的crontab服务  </p><p><strong>file</strong>：file是命令文件的名字,表示将file做为crontab的任务列表文件<br>并载入crontab。</p><p><strong>-e</strong>：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前<br>用户的crontab文件。</p><p><strong>-l</strong>：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前<br>用户的crontab文件内容。</p><p><strong>-r</strong>：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab<br>文件，如果不指定用户，则默认删除当前用户的crontab文件。</p><p>命令示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ crontab file [-u user] <span class="comment">## 用指定的文件替代目前的crontab</span></span><br><span class="line">$ crontab -l [-u user]  <span class="comment">## 列出用户目前的crontab</span></span><br><span class="line">$ crontab -e [-u user]  <span class="comment">## 编辑用户目前的crontab</span></span><br></pre></td></tr></table></figure><h4 id="配置说明、实例"><a href="#配置说明、实例" class="headerlink" title="配置说明、实例"></a>配置说明、实例</h4><p>命令：*   *    *   *   *   command  </p><p>解释：分  时  日  月  周  命令</p><p>第1列表示分钟1～59 每分钟用*或者 */1表示    </p><p>第2列表示小时0～23（0表示0点）</p><p>第3列表示日期1～31  </p><p>第4列表示月份1～12  </p><p>第5列标识号星期0～6（0表示星期天）  </p><p>第6列要运行的命令</p><p>配置实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先打开定时任务所在的文件：</span></span><br><span class="line">$ crontab -e</span><br><span class="line"> </span><br><span class="line"><span class="comment">#每分钟执行一次date命令 </span></span><br><span class="line">$ */1 * * * * date &gt;&gt; /root/date.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment">#每晚的21:30重启apache。 </span></span><br><span class="line">$ 30 21 * * * service httpd restart</span><br><span class="line"> </span><br><span class="line"><span class="comment">#每月1、10、22日的4 : 45重启apache。  </span></span><br><span class="line">$ 45 4 1,10,22 * * service httpd restart</span><br><span class="line"> </span><br><span class="line"><span class="comment">#每周六、周日的1 : 10重启apache。 </span></span><br><span class="line">$ 10 1 * * 6,0 service httpd restart</span><br><span class="line"> </span><br><span class="line"><span class="comment">#每天18 : 00至23 : 00之间每隔30分钟重启apache。</span></span><br><span class="line">$ 0,30   18-23    *   *   *   service httpd restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#晚上11点到早上7点之间，每隔一小时重启apache</span></span><br><span class="line">$ *  23-7/1    *   *   *   service httpd restart</span><br></pre></td></tr></table></figure><hr><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="查看当前目录：pwd"><a href="#查看当前目录：pwd" class="headerlink" title="查看当前目录：pwd"></a>查看当前目录：pwd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span>     <span class="comment">#查看当前目录路径</span></span><br></pre></td></tr></table></figure><h4 id="查看进程：ps-ef"><a href="#查看进程：ps-ef" class="headerlink" title="查看进程：ps -ef"></a>查看进程：ps -ef</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef  <span class="comment">#查看所有正在运行的进程</span></span><br></pre></td></tr></table></figure><h4 id="结束进程：kill"><a href="#结束进程：kill" class="headerlink" title="结束进程：kill"></a>结束进程：kill</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> pid 或者 <span class="built_in">kill</span> -9 pid <span class="comment">#(强制杀死进程)           #pid:进程号</span></span><br></pre></td></tr></table></figure><h4 id="网络通信命令："><a href="#网络通信命令：" class="headerlink" title="网络通信命令："></a>网络通信命令：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ifconfig：查看网卡信息</span></span><br><span class="line"></span><br><span class="line">$ ifconfig 或 ifconfig | more</span><br><span class="line"></span><br><span class="line"><span class="comment"># ping：查看与某台机器的连接情况</span></span><br><span class="line"></span><br><span class="line">$ ping ip</span><br><span class="line"></span><br><span class="line">$ netstat -an：查看当前系统端口</span><br><span class="line"></span><br><span class="line">$ netstat -an</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索指定端口</span></span><br><span class="line"></span><br><span class="line">$ netstat -an | grep 8080</span><br></pre></td></tr></table></figure><h4 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setup</span><br></pre></td></tr></table></figure><h4 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service network restart</span><br></pre></td></tr></table></figure><h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ su -用户名</span><br></pre></td></tr></table></figure><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ chkconfig iptables off</span><br><span class="line">或</span><br><span class="line">$ iptables -L;</span><br><span class="line">$ iptables -F;</span><br><span class="line">$ service iptables stop</span><br></pre></td></tr></table></figure><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 777</span><br></pre></td></tr></table></figure><h4 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ clear</span><br><span class="line">或者</span><br><span class="line">$ ctrl + l</span><br></pre></td></tr></table></figure><h4 id="vi模式下快捷键"><a href="#vi模式下快捷键" class="headerlink" title="vi模式下快捷键"></a>vi模式下快捷键</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">esc后:</span><br><span class="line">保存并退出快捷键：<span class="built_in">shift</span>+z+z</span><br><span class="line">光标跳到最后一行快捷键：<span class="built_in">shift</span>+g</span><br><span class="line">删除一行：dd</span><br><span class="line">复制一行内容：y+y</span><br><span class="line">粘贴复制的内容：p</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux - 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis高可用解决方案总结</title>
    <link href="/2018/12/06/redis-2/"/>
    <url>/2018/12/06/redis-2/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/redis-logo.png" srcset="/img/loading.gif" alt="redis"><br>本文主要针对 Redis 常见的几种使用方式及其优缺点展开分析。</p><h3 id="常见使用方式"><a href="#常见使用方式" class="headerlink" title="常见使用方式"></a>常见使用方式</h3><p>Redis 的几种常见使用方式包括：</p><ul><li><p>Redis 单副本；</p></li><li><p>Redis 多副本（主从）；</p></li><li><p>Redis Sentinel（哨兵）；</p></li><li><p>Redis Cluster；</p></li><li><p>Redis 自研。</p></li></ul><hr><h3 id="各种使用方式的优缺点"><a href="#各种使用方式的优缺点" class="headerlink" title="各种使用方式的优缺点"></a>各种使用方式的优缺点</h3><h4 id="Redis-单副本"><a href="#Redis-单副本" class="headerlink" title="Redis 单副本"></a>Redis 单副本</h4><p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。<br><img src="/images/redis1.jpg" srcset="/img/loading.gif" alt="redis"><br><strong>优点</strong>：</p><p>架构简单，部署方便；</p><p>高性价比：缓存使用时无需备用节点（单实例可用性可以用 supervisor 或 crontab 保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；</p><p>高性能。</p><p><strong>缺点</strong>：</p><p>不保证数据的可靠性；</p><p>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；</p><p>高性能受限于单核 CPU 的处理能力（Redis 是单线程机制），CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代。</p><h4 id="Redis-多副本（主从）"><a href="#Redis-多副本（主从）" class="headerlink" title="Redis 多副本（主从）"></a>Redis 多副本（主从）</h4><p>Redis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。<br><img src="/images/redis2.jpg" srcset="/img/loading.gif" alt="redis"></p><p><strong>优点</strong>：</p><p>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；</p><p>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</p><p><strong>缺点</strong>：</p><p>故障恢复复杂，如果没有 RedisHA 系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；</p><p>主库的写能力受到单机的限制，可以考虑分片；</p><p>主库的存储能力受到单机的限制，可以考虑 Pika；</p><p>原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘 IO 和 CPU（压缩）资源消耗；发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</p><h4 id="Redis-多副本（主从）-1"><a href="#Redis-多副本（主从）-1" class="headerlink" title="Redis 多副本（主从）"></a>Redis 多副本（主从）</h4><p>Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。</p><p>其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1（n&gt;=1）的奇数个。<br><img src="/images/redis3.jpg" srcset="/img/loading.gif" alt="redis"><br><img src="/images/redis4.jpg" srcset="/img/loading.gif" alt="redis"><br><strong>优点</strong>：</p><p>Redis Sentinel 集群部署简单；</p><p>能够解决 Redis 主从模式下的高可用切换问题；</p><p>很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求；</p><p>可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。</p><p><strong>缺点</strong>：</p><p>部署相对 Redis 主从模式要复杂一些，原理理解更繁琐；</p><p>资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供服务；</p><p>Redis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。</p><p>不能解决读写分离问题，实现起来相对复杂。</p><p><strong>建议</strong>：</p><p>如果监控同一业务，可以选择一套 Sentinel 集群监控多组 Redis 数据节点的方案，反之选择一套 Sentinel 监控一组 Redis 数据节点的方案。</p><p>sentinel monitor配置中的建议设置成 Sentinel 节点的一半加 1，当 Sentinel 部署在多个 IDC 的时候，单个 IDC 部署的 Sentinel 数量不建议超过（Sentinel 数量 – quorum）。</p><p>合理设置参数，防止误切，控制切换灵敏度控制：</p><p>a. quorum</p><p>b. down-after-milliseconds 30000</p><p>c. failover-timeout 180000</p><p>d. maxclient</p><p>e. timeout</p><p>部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱。</p><p>Redis 建议使用 pipeline 和 multi-keys 操作，减少 RTT 次数，提高请求效率。</p><p>自行搞定配置中心（zookeeper），方便客户端对实例的链接访问。</p><h4 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h4><p>Redis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。</p><p>Redis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。<br><img src="/images/redis5.jpg" srcset="/img/loading.gif" alt="redis"><br><strong>优点</strong>：</p><p>无中心架构；</p><p>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；</p><p>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</p><p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；</p><p>降低运维成本，提高系统的扩展性和可用性。</p><p><strong>缺点</strong>：</p><p>Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p><p>节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。</p><p>数据通过异步复制，不保证数据的强一致性。</p><p>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p><p>Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。</p><p>Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。</p><p>Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。</p><p>Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。</p><p>不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</p><p>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p><p>避免产生 hot-key，导致主库节点成为系统的短板。</p><p>避免产生 big-key，导致网卡撑爆、慢查询等。</p><p>重试时间应该大于 cluster-node-time 时间。</p><p>Redis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。</p><h4 id="Redis-自研"><a href="#Redis-自研" class="headerlink" title="Redis 自研"></a>Redis 自研</h4><p>Redis 自研的高可用解决方案，主要体现在配置中心、故障探测和 failover 的处理机制上，通常需要根据企业业务的实际线上环境来定制化。<br><img src="/images/redis6.jpg" srcset="/img/loading.gif" alt="redis"><br><img src="/images/redis7.jpg" srcset="/img/loading.gif" alt="redis"><br>优点：</p><p>高可靠性、高可用性；</p><p>自主可控性高；</p><p>贴切业务实际需求，可缩性好，兼容性好。</p><p>缺点：</p><p>实现复杂，开发成本高；</p><p>需要建立配套的周边设施，如监控，域名服务，存储元数据信息的数据库等；</p><p>维护成本高。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库 - Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门</title>
    <link href="/2018/11/28/redis-1/"/>
    <url>/2018/11/28/redis-1/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/redis-logo.png" srcset="/img/loading.gif" alt="redis"></p><h3 id="Redis-概述"><a href="#Redis-概述" class="headerlink" title="Redis 概述"></a>Redis 概述</h3><p>在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p><hr><h3 id="NoSQL-技术"><a href="#NoSQL-技术" class="headerlink" title="NoSQL 技术"></a>NoSQL 技术</h3><p>为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种<strong>基于内存的数据库</strong>，并且提供一定的持久化功能。</p><p><strong>Redis</strong>和<strong>MongoDB</strong>是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以<strong>支持每秒十几万此的读/写操作</strong>，其性能远超数据库，并且还<strong>支持集群、分布式、主从同步等</strong>配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还<strong>支持一定的事务能力</strong>，这保证了高并发的场景下数据的安全和一致性。</p><hr><h3 id="Redis-在-Java-Web-中的应用"><a href="#Redis-在-Java-Web-中的应用" class="headerlink" title="Redis 在 Java Web 中的应用"></a>Redis 在 Java Web 中的应用</h3><p>Redis 在 Java Web 主要有两个应用场景：</p><ul><li>存储 <strong>缓存</strong> 用的数据；</li><li>需要高速读/写的场合<strong>使用它快速读/写</strong>；</li></ul><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>在日常对数据库的访问中，读操作的次数远超写操作，比例大概在 <strong>1:9</strong> 到 <strong>3:7</strong>，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会<strong>去磁盘把对应的数据索引取回来</strong>，这是一个相对较慢的过程。</p><p>如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端<strong>直接去读取内存中的数据</strong>，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们<strong>只是使用 Redis 存储一些常用和主要的数据</strong>，比如用户登录的信息等。</p><p>一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：</p><ul><li><strong>业务数据常用吗？命中率如何？</strong>如果命中率很低，就没有必要写入缓存；</li><li><strong>该业务数据是读操作多，还是写操作多？</strong>如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li><li><strong>业务数据大小如何？</strong>如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；<br>在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！使用 Redis 作为缓存的读取逻辑如下图所示：<br><img src="/images/redis8.png" srcset="/img/loading.gif" alt="redis"><br>从上图我们可以知道以下两点：</li></ul><ol><li>当<strong>第一次读取数据的时候</strong>，读取 Redis 的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入 Redis 中；</li><li>当<strong>第二次以及以后需要读取数据时</strong>，就会直接读取 Redis，读到数据后就结束了流程，这样速度就大大提高了。<br>从上面的分析可以知道，读操作的可能性是远大于写操作的，所以使用 Redis 来处理日常中需要经常读取的数据，速度提升是显而易见的，同时也降低了对数据库的依赖，使得数据库的压力大大减少。</li></ol><p>分析了读操作的逻辑，下面我们来看看<strong>写操作的流程</strong>：<br><img src="/images/redis9.png" srcset="/img/loading.gif" alt="redis"><br>从流程可以看出，更新或者写入的操作，需要多个 Redis 的操作，如果业务数据写次数远大于读次数那么就没有必要使用 Redis。</p><blockquote><p>关于使用内存存储数据，我知道谷歌好像就是<strong>把所有互联网的数据都存储在内存条</strong>的，所以才会有如此高质量、高效的搜索，但它毕竟是谷歌…</p></blockquote><h4 id="高速读-写的场合"><a href="#高速读-写的场合" class="headerlink" title="高速读/写的场合"></a>高速读/写的场合</h4><p>在如今的互联网中，越来越多的存在高并发的情况，比如天猫双11、抢红包、抢演唱会门票等，这些场合都是在某一个瞬间或者是某一个短暂的时刻有<strong>成千上万的请求</strong>到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，<strong>轻则造成用户体验极差用户量流失，重则数据库瘫痪，服务宕机</strong>，而这样的场合都是不允许的！</p><p>所以我们需要使用 Redis 来应对这样的高并发需求的场合，我们先来看看一次<strong>请求操作的流程图</strong>：<br><img src="/images/redis10.png" srcset="/img/loading.gif" alt="redis"><br>我们来进一步阐述这个过程：</p><ol><li>当一个请求到达服务器时，只是把业务数据在 Redis 上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足<strong>高速响应的需求</strong>；</li><li>但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完 Redis 的读/写之后，会去<strong>判断该高速读/写的业务是否结束</strong>，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将 Redis 的缓存的数据以批量的形式<strong>一次性写入数据库</strong>，从而完成持久化的工作。</li></ol><hr><h3 id="Redis-的安装"><a href="#Redis-的安装" class="headerlink" title="Redis 的安装"></a>Redis 的安装</h3><blockquote><p>操作系统：CentOS 7<br>redis版本：5.0</p></blockquote><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/images/redis11.png" srcset="/img/loading.gif" alt="redis"></p><h4 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/images/redis12.png" srcset="/img/loading.gif" alt="redis"><br>没有报错就代表解压成功！</p><h4 id="yum安装gcc依赖"><a href="#yum安装gcc依赖" class="headerlink" title="yum安装gcc依赖"></a>yum安装gcc依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install gcc</span><br></pre></td></tr></table></figure><p>遇到选择，输入y即可</p><h4 id="编译-amp-安装"><a href="#编译-amp-安装" class="headerlink" title="编译&amp;安装"></a>编译&amp;安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> redis-5.0.0/</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><h4 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h4><p>先切换到redis src目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> src/</span><br></pre></td></tr></table></figure><h4 id="直接启动redis"><a href="#直接启动redis" class="headerlink" title="直接启动redis"></a>直接启动redis</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-server</span><br></pre></td></tr></table></figure><p><img src="/images/redis13.png" srcset="/img/loading.gif" alt="redis"><br>如上图：redis启动成功，但是这种启动方式需要一直打开窗口，不能进行其他操作，不太方便。<br>按 ctrl + c可以关闭窗口。</p><h4 id="以后台进程方式启动redis"><a href="#以后台进程方式启动redis" class="headerlink" title="以后台进程方式启动redis"></a>以后台进程方式启动redis</h4><h5 id="第一步：修改redis-conf文件"><a href="#第一步：修改redis-conf文件" class="headerlink" title="第一步：修改redis.conf文件"></a>第一步：修改redis.conf文件</h5><p>redis.conf文件就在redis目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> redis-5.0.0/</span><br><span class="line">$ vim redis.conf</span><br></pre></td></tr></table></figure><p>将<strong>daemonize no</strong>修改为<strong>daemonize yes</strong><br><img src="/images/redis14.png" srcset="/img/loading.gif" alt="redis"><br>配置允许所有ip都可以访问redis，将bind 127.0.0.1注释掉:<br><img src="/images/redis15.png" srcset="/img/loading.gif" alt="redis"><br>并且将protected-mode改为no<br><img src="/images/redis16.png" srcset="/img/loading.gif" alt="redis"></p><h5 id="第二步：指定redis-conf文件启动"><a href="#第二步：指定redis-conf文件启动" class="headerlink" title="第二步：指定redis.conf文件启动"></a>第二步：指定redis.conf文件启动</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-server ~/redis-5.0.0/redis.conf</span><br></pre></td></tr></table></figure><p><img src="/images/redis17.png" srcset="/img/loading.gif" alt="redis"></p><h5 id="第三步：关闭redis进程"><a href="#第三步：关闭redis进程" class="headerlink" title="第三步：关闭redis进程"></a>第三步：关闭redis进程</h5><p>首先使用<code>ps -aux&brvbar;grep redis</code>查看redis进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep redis</span><br></pre></td></tr></table></figure><p><img src="/images/redis18.png" srcset="/img/loading.gif" alt="redis"><br>使用kill命令杀死进程,并检查是否成功关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 2751</span><br></pre></td></tr></table></figure><h5 id="第四步：检查是否开启了所有ip访问："><a href="#第四步：检查是否开启了所有ip访问：" class="headerlink" title="第四步：检查是否开启了所有ip访问："></a>第四步：检查是否开启了所有ip访问：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef |grep redis</span><br></pre></td></tr></table></figure><p>如果端口号前面显示的是*则说明客户端可以访问了，如果是127.0.0.1，则需要重新配置了。</p><h4 id="设置redis开机自启动"><a href="#设置redis开机自启动" class="headerlink" title="设置redis开机自启动"></a>设置redis开机自启动</h4><h5 id="在-etc目录下新建redis目录"><a href="#在-etc目录下新建redis目录" class="headerlink" title="在/etc目录下新建redis目录"></a>在/etc目录下新建redis目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc</span><br><span class="line">$ mkdir redis</span><br></pre></td></tr></table></figure><h5 id="将-root-redis-5-0-0-redis-conf文件复制一份到-etc-redis目录下，并命名为6379-conf"><a href="#将-root-redis-5-0-0-redis-conf文件复制一份到-etc-redis目录下，并命名为6379-conf" class="headerlink" title="将/root/redis-5.0.0/redis.conf文件复制一份到/etc/redis目录下，并命名为6379.conf"></a>将/root/redis-5.0.0/redis.conf文件复制一份到/etc/redis目录下，并命名为6379.conf</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp /root/redis-5.0.0/redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure><h5 id="将redis的启动脚本复制一份放到-etc-init-d目录下"><a href="#将redis的启动脚本复制一份放到-etc-init-d目录下" class="headerlink" title="将redis的启动脚本复制一份放到/etc/init.d目录下"></a>将redis的启动脚本复制一份放到/etc/init.d目录下</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp /root/redis-5.0.0/utils/redis_init_script /etc/init.d/redisd</span><br></pre></td></tr></table></figure><h5 id="设置redis开机自启动-1"><a href="#设置redis开机自启动-1" class="headerlink" title="设置redis开机自启动"></a>设置redis开机自启动</h5><p>先切换到/etc/init.d目录下，然后执行自启命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chkconfig redisd on</span><br></pre></td></tr></table></figure><p>如果redisd不支持chkconfig，使用vim编辑redisd文件，在第一行加入如下两行注释，保存退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chkconfig:   2345 90 10</span></span><br><span class="line"><span class="comment"># description:  Redis is a persistent key-value database</span></span><br></pre></td></tr></table></figure><p>注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。<br>再次执行开机自启命令，成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chkconfig redisd on</span><br></pre></td></tr></table></figure><h4 id="以服务的形式启动和关闭redis"><a href="#以服务的形式启动和关闭redis" class="headerlink" title="以服务的形式启动和关闭redis"></a>以服务的形式启动和关闭redis</h4><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service redisd start</span><br></pre></td></tr></table></figure><h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service redisd stop</span><br></pre></td></tr></table></figure><p><img src="/images/redis19.png" srcset="/img/loading.gif" alt="redis"></p><hr><h3 id="在-Java-中使用-Redis"><a href="#在-Java-中使用-Redis" class="headerlink" title="在 Java 中使用 Redis"></a>在 Java 中使用 Redis</h3><h4 id="第一步：添加-Jedis-依赖"><a href="#第一步：添加-Jedis-依赖" class="headerlink" title="第一步：添加 Jedis 依赖"></a>第一步：添加 Jedis 依赖</h4><p>想要在 Java 中使用 Redis 缓存，需要添加相关的Jar包依赖，打开Maven仓库的网站：<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a> ，搜索Jedis：<br><img src="/images/redis20.png" srcset="/img/loading.gif" alt="redis"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>写个简单的性能测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">redisTester</span></span>() &#123;</span><br><span class="line">    Jedis jedis = new Jedis(<span class="string">"localhost"</span>, 6379, 100000);</span><br><span class="line">    int i = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        long start = System.currentTimeMillis();// 开始毫秒数</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (end - start &gt;= 1000) &#123;// 当大于等于1000毫秒（相当于1秒）时，结束操作</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            jedis.set(<span class="string">"test"</span> + i, i + <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;// 关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">    // 打印1秒内对Redis的操作次数</span><br><span class="line">    System.out.println(<span class="string">"redis每秒操作："</span> + i + <span class="string">"次"</span>);</span><br><span class="line">&#125;</span><br><span class="line">-----------测试结果-----------</span><br><span class="line">redis每秒操作：99776次</span><br></pre></td></tr></table></figure><h4 id="第二步：使用-Redis-连接池"><a href="#第二步：使用-Redis-连接池" class="headerlink" title="第二步：使用 Redis 连接池"></a>第二步：使用 Redis 连接池</h4><p>跟数据库连接池相同，Java Redis也同样提供了类<code>redis.clients.jedis.JedisPool</code>来管理我们的Reids连接池对象，并且我们可以使用<code>redis.clients.jedis.JedisPoolConfig</code>来对连接池进行配置，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class="line">// 最大空闲数</span><br><span class="line">poolConfig.setMaxIdle(50);</span><br><span class="line">// 最大连接数</span><br><span class="line">poolConfig.setMaxTotal(100);</span><br><span class="line">// 最大等待毫秒数</span><br><span class="line">poolConfig.setMaxWaitMillis(20000);</span><br><span class="line">// 使用配置创建连接池</span><br><span class="line">JedisPool pool = new JedisPool(poolConfig, <span class="string">"localhost"</span>);</span><br><span class="line">// 从连接池中获取单个连接</span><br><span class="line">Jedis jedis = pool.getResource();</span><br><span class="line">// 如果需要密码</span><br><span class="line">//jedis.auth(<span class="string">"password"</span>);</span><br></pre></td></tr></table></figure><p>Redis 只能支持六种数据类型（string/hash/list/set/zset/hyperloglog）的操作，但在 Java 中我们却通常以类对象为主，所以在需要 Redis 存储的五中数据类型与 Java 对象之间进行转换，如果自己编写一些工具类，比如一个角色对象的转换，还是比较容易的，但是涉及到许多对象的时候，这其中无论工作量还是工作难度都是很大的，所以总体来说，<strong>就操作对象而言，使用 Redis 还是挺难的</strong>，好在 Spring 对这些进行了封装和支持。</p><h4 id="第三步：在-Spring-中使用-Redis"><a href="#第三步：在-Spring-中使用-Redis" class="headerlink" title="第三步：在 Spring 中使用 Redis"></a>第三步：在 Spring 中使用 Redis</h4><p>上面说到了 Redis 无法操作对象的问题，无法在那些基础类型和 Java 对象之间方便的转换，但是在 Spring 中，这些问题都可以<strong>通过使用RedisTemplate</strong>得到解决！</p><p>想要达到这样的效果，除了 Jedis 包以外还需要在 Spring 引入 spring-data-redis 包：<a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis" target="_blank" rel="noopener">https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis</a><br><img src="/images/redis21.png" srcset="/img/loading.gif" alt="redis"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>(1) 第一步：使用Spring配置JedisPoolConfig对象</strong><br>大部分的情况下，我们还是会用到连接池的，于是先用 Spring 配置一个 JedisPoolConfig 对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"poolConfig"</span> class=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span><br><span class="line">    &lt;!--最大空闲数--&gt;</span><br><span class="line">    &lt;property name=<span class="string">"maxIdle"</span> value=<span class="string">"50"</span>/&gt;</span><br><span class="line">    &lt;!--最大连接数--&gt;</span><br><span class="line">    &lt;property name=<span class="string">"maxTotal"</span> value=<span class="string">"100"</span>/&gt;</span><br><span class="line">    &lt;!--最大等待时间--&gt;</span><br><span class="line">    &lt;property name=<span class="string">"maxWaitMillis"</span> value=<span class="string">"20000"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>(2) 第二步：为连接池配置工厂模型</strong><br>好了，我们现在配置好了连接池的相关属性，那么具体使用哪种工厂实现呢？在Spring Data Redis中有四种可供我们选择的工厂模型，它们分别是：</p><ul><li>JredisConnectionFactory</li><li>JedisConnectionFactory</li><li>LettuceConnectionFactory</li><li>SrpConnectionFactory<br>我们这里就简单配置成JedisConnectionFactory：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"connectionFactory"</span> class=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>&gt;</span><br><span class="line">    &lt;!--Redis服务地址--&gt;</span><br><span class="line">    &lt;property name=<span class="string">"hostName"</span> value=<span class="string">"localhost"</span>/&gt;</span><br><span class="line">    &lt;!--端口号--&gt;</span><br><span class="line">    &lt;property name=<span class="string">"port"</span> value=<span class="string">"6379"</span>/&gt;</span><br><span class="line">    &lt;!--如果有密码则需要配置密码--&gt;</span><br><span class="line">    &lt;!--&lt;property name=<span class="string">"password"</span> value=<span class="string">"password"</span>/&gt;--&gt;</span><br><span class="line">    &lt;!--连接池配置--&gt;</span><br><span class="line">    &lt;property name=<span class="string">"poolConfig"</span> ref=<span class="string">"poolConfig"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>(3) 第三步：配置RedisTemplate</strong><br>普通的连接根本没有办法直接将对象直接存入 Redis 内存中，我们需要替代的方案：将对象序列化（可以简单的理解为继承Serializable接口）。我们可以把对象序列化之后存入Redis缓存中，然后在取出的时候又通过转换器，将序列化之后的对象反序列化回对象，这样就完成了我们的要求：<br><img src="/images/redis22.png" srcset="/img/loading.gif" alt="redis"><br>RedisTemplate可以帮助我们完成这份工作，它会找到对应的序列化器去转换Redis的键值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"redisTemplate"</span></span><br><span class="line">      class=<span class="string">"org.springframework.data.redis.core.RedisTemplate"</span></span><br><span class="line">      p:connection-factory-ref=<span class="string">"connectionFactory"</span>/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>我从《JavaEE互联网轻量级框架整合开发》中了解到，这一步需要配置单独的序列化器去支撑这一步的工作，但是自己在测试当中，发现只要我们的Pojo类实现了Serializable接口，就不会出现问题，所以我直接省略掉了配置序列化器这一步。<br><strong>(4) 第四步：编写测试</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: @loonycoder</span><br><span class="line"> * @create: 2018-11-28 下午 18:22:06</span><br><span class="line"> */</span><br><span class="line">public class Student implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给该类一个服务类用于测试</span><br><span class="line">     */</span><br><span class="line">    public void <span class="function"><span class="title">service</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"学生名字为："</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"学生年龄为："</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">getAge</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写测试类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">    ApplicationContext context =</span><br><span class="line">            new ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    RedisTemplate redisTemplate = context.getBean(RedisTemplate.class);</span><br><span class="line">    Student student = new Student();</span><br><span class="line">    student.setName(<span class="string">"loonycoder"</span>);</span><br><span class="line">    student.setAge(24);</span><br><span class="line">    redisTemplate.opsForValue().<span class="built_in">set</span>(<span class="string">"student_1"</span>, student);</span><br><span class="line">    Student student1 = (Student) redisTemplate.opsForValue().get(<span class="string">"student_1"</span>);</span><br><span class="line">    student1.service();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/redis23.png" srcset="/img/loading.gif" alt="redis"></p><h4 id="第四步：在-SpringBoot-中使用-Redis"><a href="#第四步：在-SpringBoot-中使用-Redis" class="headerlink" title="第四步：在 SpringBoot 中使用 Redis"></a>第四步：在 SpringBoot 中使用 Redis</h4><p><strong>(1)在SpringBoot中添加Redis依赖：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Radis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>(2)添加配置文件：</strong><br>在SpringBoot中使用<code>.properties</code>或者<code>.yml</code>都可以，这里给出<code>.properties</code>的例子，因为自己的<code>.yml</code>文件看上去感觉乱糟糟的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># REDIS (RedisProperties)</span></span><br><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line">spring.redis.database=0</span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line">spring.redis.port=6379</span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line">spring.redis.password=</span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line">spring.redis.timeout=0</span><br></pre></td></tr></table></figure><p><strong>(3)测试访问：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest()</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="built_in">test</span>() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 保存字符串</span><br><span class="line">        stringRedisTemplate.opsForValue().<span class="built_in">set</span>(<span class="string">"loonycoder"</span>, <span class="string">"24"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">"24"</span>, stringRedisTemplate.opsForValue().get(<span class="string">"loonycoder"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这段极为简单的测试案例演示了如何通过自动配置的<strong>StringRedisTemplate</strong>对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。原本是RedisTemplate&lt;K, V&gt;接口，StringRedisTemplate就相当于RedisTemplate&lt;String, String&gt;的实现。<br><strong>(4)存储对象：</strong><br>这一步跟上面使用Spring一样，只需要将Pojo类实现Serializable接口就可以了，这里直接贴测试代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest()</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="built_in">test</span>() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName(<span class="string">"loonycoder"</span>);</span><br><span class="line">        user.setAge(24);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().<span class="built_in">set</span>(<span class="string">"user_1"</span>, user);</span><br><span class="line">        User user1 = (User) redisTemplate.opsForValue().get(<span class="string">"user_1"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(user1.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考文章：<br><a href="https://www.cnblogs.com/ityouknow/p/5748830.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5748830.html</a><br><a href="http://blog.didispace.com/springbootredis/" target="_blank" rel="noopener">http://blog.didispace.com/springbootredis/</a></p></blockquote><hr><h3 id="在Redis中操作集合"><a href="#在Redis中操作集合" class="headerlink" title="在Redis中操作集合"></a>在Redis中操作集合</h3><blockquote><p>引用文章：<a href="https://www.jianshu.com/p/29aaac3172b5" target="_blank" rel="noopener">https://www.jianshu.com/p/29aaac3172b5</a></p></blockquote><p>直接贴上两段简单的示例代码：</p><h4 id="在Redis中操作List"><a href="#在Redis中操作List" class="headerlink" title="在Redis中操作List"></a>在Redis中操作List</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// list数据类型适合于消息队列的场景:比如12306并发量太高，而同一时间段内只能处理指定数量的数据！必须满足先进先出的原则，其余数据处于等待</span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">listPushResitTest</span></span>() &#123;</span><br><span class="line">    // leftPush依次由右边添加</span><br><span class="line">    stringRedisTemplate.opsForList().rightPush(<span class="string">"myList"</span>, <span class="string">"1"</span>);</span><br><span class="line">    stringRedisTemplate.opsForList().rightPush(<span class="string">"myList"</span>, <span class="string">"2"</span>);</span><br><span class="line">    stringRedisTemplate.opsForList().rightPush(<span class="string">"myList"</span>, <span class="string">"A"</span>);</span><br><span class="line">    stringRedisTemplate.opsForList().rightPush(<span class="string">"myList"</span>, <span class="string">"B"</span>);</span><br><span class="line">    // leftPush依次由左边添加</span><br><span class="line">    stringRedisTemplate.opsForList().leftPush(<span class="string">"myList"</span>, <span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">listGetListResitTest</span></span>() &#123;</span><br><span class="line">    // 查询类别所有元素</span><br><span class="line">    List&lt;String&gt; listAll = stringRedisTemplate.opsForList().range(<span class="string">"myList"</span>, 0, -1);</span><br><span class="line">    logger.info(<span class="string">"list all &#123;&#125;"</span>, listAll);</span><br><span class="line">    // 查询前3个元素</span><br><span class="line">    List&lt;String&gt; list = stringRedisTemplate.opsForList().range(<span class="string">"myList"</span>, 0, 3);</span><br><span class="line">    logger.info(<span class="string">"list limit &#123;&#125;"</span>, list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">listRemoveOneResitTest</span></span>() &#123;</span><br><span class="line">    // 删除先进入的B元素</span><br><span class="line">    stringRedisTemplate.opsForList().remove(<span class="string">"myList"</span>, 1, <span class="string">"B"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">listRemoveAllResitTest</span></span>() &#123;</span><br><span class="line">    // 删除所有A元素</span><br><span class="line">    stringRedisTemplate.opsForList().remove(<span class="string">"myList"</span>, 0, <span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在Redis中操作Hash"><a href="#在Redis中操作Hash" class="headerlink" title="在Redis中操作Hash"></a>在Redis中操作Hash</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">hashPutResitTest</span></span>() &#123;</span><br><span class="line">    // map的key值相同，后添加的覆盖原有的</span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">"banks:12600000"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">hashGetEntiresResitTest</span></span>() &#123;</span><br><span class="line">    // 获取map对象</span><br><span class="line">    Map&lt;Object, Object&gt; map = stringRedisTemplate.opsForHash().entries(<span class="string">"banks:12600000"</span>);</span><br><span class="line">    logger.info(<span class="string">"objects:&#123;&#125;"</span>, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">hashGeDeleteResitTest</span></span>() &#123;</span><br><span class="line">    // 根据map的key删除这个元素</span><br><span class="line">    stringRedisTemplate.opsForHash().delete(<span class="string">"banks:12600000"</span>, <span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">hashGetKeysResitTest</span></span>() &#123;</span><br><span class="line">    // 获得map的key集合</span><br><span class="line">    Set&lt;Object&gt; objects = stringRedisTemplate.opsForHash().keys(<span class="string">"banks:12600000"</span>);</span><br><span class="line">    logger.info(<span class="string">"objects:&#123;&#125;"</span>, objects);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">hashGetValueListResitTest</span></span>() &#123;</span><br><span class="line">    // 获得map的value列表</span><br><span class="line">    List&lt;Object&gt; objects = stringRedisTemplate.opsForHash().values(<span class="string">"banks:12600000"</span>);</span><br><span class="line">    logger.info(<span class="string">"objects:&#123;&#125;"</span>, objects);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">hashSize</span></span>() &#123; // 获取map对象大小</span><br><span class="line">    long size = stringRedisTemplate.opsForHash().size(<span class="string">"banks:12600000"</span>);</span><br><span class="line">    logger.info(<span class="string">"size:&#123;&#125;"</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在网上看到了关于MySQL的性能测试，读写操作大概就<strong>每秒1000以下</strong>的样子，而且这还和引擎相关，所以可以看出Redis确实能在性能方面帮助许多。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库 - Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能的HTTP服务器——Nginx</title>
    <link href="/2018/11/21/nginx/"/>
    <url>/2018/11/21/nginx/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/nginx.jpg" srcset="/img/loading.gif" alt="nginx"><br>Nginx是一款高性能HTTP服务器、反向代理服务器及电子邮件（IMAP、POP3）代理服务器，官方测试nginx能够支持5万并发连接。<br><strong>Nginx应用场景：</strong><br>1、http服务器。Nginx是一个http服务器，可以独立提供http服务。可以做网页静态服务器。<br>2、虚拟主机。可以实现在一台服务器虚拟出多个网站。<br>3、反向代理，负载均衡。当网站的并发量过大需要配置服务器集群时可以使用Nginx做反向代理。并且多台服务器可以平均分摊负载。</p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="本文章默认使用的软件："><a href="#本文章默认使用的软件：" class="headerlink" title="本文章默认使用的软件："></a>本文章默认使用的软件：</h4><ul><li>CentOS 7</li><li>Nginx-1.12.2</li><li>JDK 8.0</li><li>Tomcat 8</li></ul><h4 id="开发工具："><a href="#开发工具：" class="headerlink" title="开发工具："></a>开发工具：</h4><ul><li>VMware fusion</li><li>SecureCRT</li></ul><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>1、安装gcc的环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><p>2、PCRE（perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><p>3、Zlib（zlib提供了很多压缩和解压的方式，nginx使用http包的内容进行gzip）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><p>4、OpenSSL（一个强大的安全套接字层密码库，为nginx支持的https(即在SSL协议上传输http)协议服务）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在本地电脑下载nginx的压缩包（我这里是nginx-1.12.2.tar.gz），然后打开SecureCRT连接服务器，使用命令gz将本地的文件上传到Linux服务器上。</p><blockquote><p>注：如果在SecureCRT上输入gz显示command not found，是因为Linux虚拟机上没有安装lrsz服务。<br>执行：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y indtall lrzsz</span><br></pre></td></tr></table></figure><p>然后可以输入rz命令选择要上传的文件。默认上传到当前路径上。</p><p><strong>1、解压</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure><p><strong>2、创建Makefile文件，执行命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd nginx-1.12.2</span></span><br><span class="line">[root@localhost nginx-1.12.2]<span class="comment"># ./configure</span></span><br></pre></td></tr></table></figure><p><img src="/images/nginx1.png" srcset="/img/loading.gif" alt="nginx"><br>完成后可以看到Makefile文件：<br><img src="/images/nginx2.png" srcset="/img/loading.gif" alt="nginx"><br><strong>拓展</strong><br>Makefile是一种配置文件，Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译…。Makefile就像一个Shell脚本一样。</p><p><strong>3、编译</strong><br>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.12.2]<span class="comment"># make</span></span><br></pre></td></tr></table></figure><p><strong>4、安装</strong><br>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.12.2]<span class="comment"># make install</span></span><br></pre></td></tr></table></figure><p>到此，Nginx安装已经完成。</p><hr><h3 id="Nginx启动与访问"><a href="#Nginx启动与访问" class="headerlink" title="Nginx启动与访问"></a>Nginx启动与访问</h3><p>上面我本编译安装的Nginx其实默认被安装在CentOS7系统的/usr/local/nginx目录。<br><img src="/images/nginx3.png" srcset="/img/loading.gif" alt="nginx"></p><h4 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]<span class="comment"># cd sbin</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># ./nginx</span></span><br></pre></td></tr></table></figure><p>此时已经启动成功Nginx，可以直接在浏览器上输入虚拟机IP（可通过ip addr命令查看），即可访问到Nginx欢迎界面，如果显示未连接，可以：<br>1、先使用本机的终端工具ping虚拟机IP地址看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping ip</span><br></pre></td></tr></table></figure><p>如果ping成功，请看下一步，如果失败，请检查虚拟机是否联网。<br>2、关闭CentOS7的防火墙，开放80端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># systemctl stop firewalld.service #停止firewall</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># systemctl disable firewalld.service #禁止firewall开机启动</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br></pre></td></tr></table></figure><p>一般情况下就能访问到了：<br><img src="/images/nginx4.png" srcset="/img/loading.gif" alt="nginx"></p><h4 id="查看Nginx进程"><a href="#查看Nginx进程" class="headerlink" title="查看Nginx进程"></a>查看Nginx进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ps aux|grep nginx</span></span><br></pre></td></tr></table></figure><h4 id="关闭Nginx"><a href="#关闭Nginx" class="headerlink" title="关闭Nginx"></a>关闭Nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -s stop</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -s quit</span></span><br></pre></td></tr></table></figure><h4 id="重启Nginx"><a href="#重启Nginx" class="headerlink" title="重启Nginx"></a>重启Nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -s reload</span></span><br></pre></td></tr></table></figure><h4 id="检查Nginx配置文件是否正确"><a href="#检查Nginx配置文件是否正确" class="headerlink" title="检查Nginx配置文件是否正确"></a>检查Nginx配置文件是否正确</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -t</span></span><br></pre></td></tr></table></figure><hr><h3 id="部署静态网站"><a href="#部署静态网站" class="headerlink" title="部署静态网站"></a>部署静态网站</h3><p>经过上面的操作，我们已经正常启动了Nginx，那么如何将我们的静态项目部署到服务器的Nginx上呢？<br>为了模拟操作，我这里只部署一个index.html网页为例：</p><p>1、<strong>上传静态网站</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回到根目录下</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># cd ../</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹`my`，视为我们的项目文件夹</span></span><br><span class="line">[root@localhost nginx]<span class="comment"># mkdir my</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件夹`my`下创建一个`index.html`网页</span></span><br><span class="line">[root@localhost nginx]<span class="comment"># cd my</span></span><br><span class="line">[root@localhost my]<span class="comment"># vi index.html</span></span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Hello Nginx!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>2、<strong>修改Nginx的配置文件</strong><br>修改/usr/local/nginx/conf/nginx.conf文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost my]<span class="comment"># cd ../conf</span></span><br><span class="line">[root@localhost conf]<span class="comment"># vi nginx.conf</span></span><br></pre></td></tr></table></figure><p>在http {}这个节点下新创建一个server {}节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 81;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root my;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，我们已经将81端口绑定了/nginx文件夹下的名称为my的项目。重启Nginx，访问：192.168.148.132:81即可以访问到我们刚才新创建的网页：index.html。</p><h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p><strong>域名</strong>是由一串用“.”分隔的字符逐层的Internet上某一台计算机或计算机组的名称，用于在数据传输时表示计算机的电子方位。域名是一个IP地址的“面具”。域名的目的是便于记忆和沟通的一组服务器的地址。域名按照<strong>域名系统DNS</strong>的规则流程组成，在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。通常，域名表示互联网协议（IP）资源。<br>一个域名对应一个IP地址，一个IP地址可以被多个域名绑定。<br>为了模拟，我们可以在本地hosts文件中配置域名和IP映射关系，这样就不用走DNS服务器了。<br>因为hosts文件内容不能直接修改，需要把hosts文件拷贝出来然后修改后再替换进去就行了(我这里使用的MacOS系统)。</p><p>1、<strong>修改hosts</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /private/etc/hosts ~/Desktop/</span><br><span class="line">vi ~/Desktop/hosts</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.148.132 www.loonycoder.com</span><br></pre></td></tr></table></figure><p>然后替换原来的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/Desktop/hosts /private/etc/</span><br></pre></td></tr></table></figure><p>2、<strong>修改Nginx配置文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># vi /usr/local/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure><p>为了模拟效果，我们可以先把之前新增的server {}节点81端口改为80端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root my;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># cd ../sbin</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -s stop</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># ./nginx</span></span><br></pre></td></tr></table></figure><p>访问192.168.148.132发现还是Nginx的Welcome页面，因为nginx.conf默认配置的80端口就是指向Nginx欢迎页，且默认的server_name就是localhost。那么想实现不同的域名访问不同的资源且还必须是80端口，就需要绑定域名：<br>修改nginx.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.loonycoder.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root my;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，很简单，只需要把server_name改为我们要绑定的域名地址就好了，然后重启Nginx，在浏览器上访问<a href="http://www.loonycoder.com" target="_blank" rel="noopener">http://www.loonycoder.com</a>就展示我们之前创建的index.html，而输入192.168.148.132访问的还是Nginx的欢迎页，这就实现了域名的绑定。多个域名绑定同一个IP地址，但是不同的域名指向了不同的资源地址。</p><hr><h3 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h3><blockquote><p>什么是反向代理？<br>反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p></blockquote><blockquote><p>正向代理<br><img src="/images/nginx5.png" srcset="/img/loading.gif" alt="nginx"><br><strong>正向代理</strong>，主要针对客户端。当用户通过PC向Internet发送请求时，可以通过一个代理服务器来统一处理请求并转发给Internet，比如一个教室的所有学生机都需要通过老师的教师机才能实现联网，那么这个教师机就相当于一个代理服务器，负责将PC的网络请求转发给Internet，然后Internet将相应的数据再通过代理服务器转发给不同的PC。</p></blockquote><blockquote><p>反向代理<br><img src="/images/nginx6.png" srcset="/img/loading.gif" alt="nginx"><br><strong>反向代理</strong>的过程则刚好相反，主要针对服务器。当用户通过网络请求不同的资源，而这些资源被分布在不同的服务器上，那么不同的请求就应该指向对应不同的服务器，那么就需要一个中介：反向代理服务器。通过反向代理服务器将不同的资源请求信息发送给不同的服务器，然后服务器将不同的信心都返回给反向代理服务器，最后通过反向代理服务器将这些结果信息展示在Internet上。</p></blockquote><h4 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h4><p>这里我们以一个非常实用的案例来演示如何配置Nginx的反向代理实现不同的域名访问不同的页面。<br>1、在服务器上安装JDK8和Tomcat8<br>通过rz命令将本地的JDK和Tomcat安装包上传到服务器。因为Tomcat解压即可用，我们这里记录一下如何安装JDK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar zxvf jdk-8u191-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置JDK环境</span></span><br><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>在profile文件的结尾处添加如下环境配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/root/jdk1.8.0_191    </span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>:wq!保存并退出，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure><p>更新配置。然后输入java -version显示则说明JDK配置成功。<br>解压Tomcat，在其bin目录下执行命令./startup.sh启动Tomcat服务器，然后我们再浏览器上访问：<a href="http://192.168.148.132:8080/" target="_blank" rel="noopener">http://192.168.148.132:8080/</a>显示Tomcat的欢迎页面则配置成功。</p><p>2、拷贝项目到Tomcat服务器下<br>为了模拟，我们在tomcat/webapps/ROOT/下创建一个index.html网页：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ROOT]<span class="comment"># vi index.html</span></span><br></pre></td></tr></table></figure><p>并写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello Tomcat!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>保存并退出，再次访问<a href="http://192.168.148.132:8080/" target="_blank" rel="noopener">http://192.168.148.132:8080/</a>发现展示的即是我们刚创建的页面<br><img src="/images/nginx7.png" srcset="/img/loading.gif" alt="nginx"></p><p>3、配置反向代理<br>之前讲了<strong>反向代理</strong>的概念，那么很实用的一个例子就是，当我们想在购买的阿里云服务器上部署两个项目，一个项目是用Nginx部署的静态网站（占用80端口），另一个项目部署在Tomcat服务器上（占用8080端口）。<br>这时，我们固然是可以通过：ip:8080来访问我们的Web项目的，但是请求路径上显示了端口好久显得很别扭，为此，我们通过Nginx的反向代理就能解决：</p><ul><li><p>3.1在本地配置一个二级域名映射<br>修改本机的hosts文件，添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.148.132 site.loonycoder.com</span><br></pre></td></tr></table></figure><p>这时我们访问&lt;site.loonycoder.com&gt;默认进入nginx的欢迎页，这是正确的。<br>注意：此时的&lt;site.loonycoder.com&gt;是&lt;loonycoder.com&gt;的一个二级子域名。</p></li><li><p>3.2 修改服务器Nginx的配置文件，添加如下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream site &#123;</span><br><span class="line">        server 192.168.148.132:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name site.loonycoder.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://site;</span><br><span class="line">            index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，其中server {}节点下的proxy_pass表示反向代理的地址，其中<a href="http://site这个site其实是指向上面upstream" target="_blank" rel="noopener">http://site这个site其实是指向上面upstream</a> site {}节点的site名称，因此要保持两者名称一致。但实际上我们不采用这种方式也能实现反向代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># upstream site &#123;</span></span><br><span class="line"><span class="comment">#         server 192.168.148.132:8080;</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name site.loonycoder.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment"># proxy_pass http://site;</span></span><br><span class="line">            proxy_pass http://192.168.148.132:8080;</span><br><span class="line">            index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>两者的区别就是第一种方式通过指向的方式可以配置更多，必须实现<strong>负载均衡</strong>就需要在upstream site {}节点下配置。</p><hr><h3 id="Nginx配置负载均衡"><a href="#Nginx配置负载均衡" class="headerlink" title="Nginx配置负载均衡"></a>Nginx配置负载均衡</h3><blockquote><p>什么是负载均衡？<br><strong>负载均衡（Load Balance）</strong>，其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。<br><strong>负载均衡</strong> 是建立在现有网络结构上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽，增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。<br>1.<strong>模拟负载均衡</strong>，我们可以提供多个Tomcat服务器，采用不同的端口区分。<br>为了模拟<strong>负载均衡</strong>效果，可以copy 2份虚拟机上的Tomcat服务器，命名为tomcat-2，tomcat-3:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cp ~/apache-tomcat-8.5.33 ~/tomcat-2</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp ~/apache-tomcat-8.5.33 ~/tomcat-3</span></span><br></pre></td></tr></table></figure><p>修改端口号分别为8180，8280。我们主要修改/tomcat/conf/server.xml配置文件中的&lt;Server port=”8005”和&lt;Connector port=”8080”这两个节点的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改tomcat-2服务器的`/conf/server.xml`参数</span></span><br><span class="line">&lt;Server port=<span class="string">"8006"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</span><br><span class="line">        &lt;Connector port=<span class="string">"8180"</span> protocol=<span class="string">"HTTP/1.1"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改tomcat-3服务器的`/conf/server.xml`参数</span></span><br><span class="line">&lt;Server port=<span class="string">"8007"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</span><br><span class="line">        &lt;Connector port=<span class="string">"8280"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br></pre></td></tr></table></figure><p>如上，我们在虚拟机上配置了三个Tomcat服务器，分别使用8080，8180，8280端口。</p><p>2.<strong>配置负载均衡</strong><br>修改Nginx下的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vi /usr/local/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure><p>修改之前配置的upstream site {}节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream site &#123;</span><br><span class="line">     server 192.168.148.132:8080;</span><br><span class="line">     server 192.168.148.132:8180;</span><br><span class="line">     server 192.168.148.132:8280;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name site.loonycoder.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://site;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就给Nginx配置了3台服务器，都指向了site.loonycoder.com这个域名地址，那么访问这个地址时同时会访问这三台服务器，也就是三台服务器平均分摊访问压力。<br>为了更好的实现效果，我们可以依次修改tomcat-2和tomcat-3服务器的/webapps/ROOT/index.html网页显示数据，更容易区分每次访问的是哪台服务器。<br>然后运行这三个Tomcat服务器，在浏览器上访问：site.loonycoder.com，多次刷新页面，每次访问的都是不同的页面，且依次是配置负载均衡的三台服务器次序。<br>如果你想让某个服务器承担更大的压力，可以为其设置权重：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream site &#123;</span><br><span class="line">     server 192.168.148.132:8080;</span><br><span class="line">     server 192.168.148.132:8180 weight=2;</span><br><span class="line">     server 192.168.148.132:8280;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器化部署神器——Docker</title>
    <link href="/2018/11/14/docker/"/>
    <url>/2018/11/14/docker/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/docker1.jpg" srcset="/img/loading.gif" alt="docker"><br><strong>Docker</strong>是一种容器技术，它的存在就是为了解决容器技术本身的复杂性。Docker容器拥有很高的性能，同时同一台宿主机中可以运行更多的容器，是用户尽可能的充分利用系统资源。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>1.什么是虚拟化？<br>在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及储存等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，是用户可以比原来的组态更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制。</p></blockquote><ul><li>全虚拟化架构<br>虚拟机的监视器（hypervisor）是类似于用户的应用程序运行在主机的OS之上，如VMware的workstation，这种虚拟化产品提供了虚拟的硬件。</li></ul><blockquote><p>2.容器技术<br>容器和管理程序虚拟化（hypervisor virtualization, HV）不同，管理程序虚拟化通过中间层将一台或多台独立的机器虚拟运行在物理硬件之上，而<strong>容器</strong>是直接运行在操作系统内核之上的用户空间。因此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行在同一台宿主机上。</p></blockquote><p><strong>限制</strong><br>1、由于“客居”与操作系统，容器只能运行与底层主机相同或相似的操作系统，比如在Ubuntu服务中运行CentOS，但无法运行Windows。<br>2、相对于彻底隔离的管理程序虚拟化，容器被认为是不安全的。<br>最新的容器技术引入了OpenVZ、Solaris Zones以及Linux容器（LXC）。使用这些新技术，容器不再仅仅是一个单纯的运行环境。在自己的权限类内，容器更像一个完整宿主机。和传统虚拟化及半虚拟化想比，容器不需要模拟层（emulation layer）和管理层（hypervisor layer），而使用操作系统的系统调用接口。</p><h4 id="Docker特点"><a href="#Docker特点" class="headerlink" title="Docker特点"></a>Docker特点</h4><p>1、上手快<br>2、用户可以很容易的把自己的程序Docker化。Docker依赖于“写时复制”（copy-on-write）模型，开箱即用。<br>快速高效的开发声明周期</p><h4 id="Docker组件"><a href="#Docker组件" class="headerlink" title="Docker组件"></a>Docker组件</h4><h5 id="Docker客户端和服务器"><a href="#Docker客户端和服务器" class="headerlink" title="Docker客户端和服务器"></a>Docker客户端和服务器</h5><p>Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。<br><img src="/images/docker2.png" srcset="/img/loading.gif" alt="docker"></p><h5 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h5><p><strong>镜像</strong> 是构建Docker的基石。用户及基于镜像来运行自己的容器。镜像也是Docker声明周期中的“构建”部分。奖项是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。</p><h5 id="Registry-注册中心"><a href="#Registry-注册中心" class="headerlink" title="Registry 注册中心"></a>Registry 注册中心</h5><p>Docker用Registry来保存用户构建的镜像。Registry分为共有和私有两种。Docker公司运营公共的Registry叫做Docker Hub。</p><h5 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h5><p>Docker可以帮助你构建和部署容器，你只需要把你的程序打包放进容器即可。容器是基于镜像启动的，容器找那个可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中构建和打包阶段，而容器则是启动或执行阶段。容器基于镜像启动。<br><img src="/images/docker3.png" srcset="/img/loading.gif" alt="docker"></p><h4 id="Docker的安装与启动"><a href="#Docker的安装与启动" class="headerlink" title="Docker的安装与启动"></a>Docker的安装与启动</h4><p>前提：本例中使用了CentOS7作为服务器<br>通过以下命令在线在CentOS7中安装Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure><p><img src="/images/docker4.png" srcset="/img/loading.gif" alt="docker"></p><p><strong>查看Docker版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker -v</span></span><br><span class="line">Docker version 1.13.1, build 8633870/1.13.1</span><br></pre></td></tr></table></figure><h4 id="启动与停止Docker"><a href="#启动与停止Docker" class="headerlink" title="启动与停止Docker"></a>启动与停止Docker</h4><p>systemctl命令是系统服务管理器指令，它是service和chkconfig两个命令组合。</p><p>1.启动Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>2.停止Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>3.重启Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>4.查看Docker状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>5.开机启动Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>6.查看Docker概要信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>7.查看Docker帮助文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h4 id="Docker镜像操作"><a href="#Docker镜像操作" class="headerlink" title="Docker镜像操作"></a>Docker镜像操作</h4><p>Docker镜像由文件系统堆叠而成（是一种文件的储存形式）。最低端是一个文件引导系统，即bootfs。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要一些文件的，而这些文件就可以被称为Docker镜像。<br><img src="/images/docker5.png" srcset="/img/loading.gif" alt="docker"></p><p>1、列出镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br></pre></td></tr></table></figure><p><img src="/images/docker6.png" srcset="/img/loading.gif" alt="docker"></p><ul><li>REPOSITORY: 镜像所在的仓库名称</li><li>TAG： 镜像标签</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像的创建日期（不是获取该镜像的日期）</li><li>SIZE：镜像大小</li></ul><p>这些镜像都储存在Docker宿主机的/var/lib/docker目录下。</p><p>2、搜索镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker search 镜像名称</span></span><br></pre></td></tr></table></figure><p><img src="/images/docker7.png" srcset="/img/loading.gif" alt="docker"></p><p>3、从Docker Hub拉取镜像<br>去Docker Hub官网查找所需的Docker镜像：<a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">https://hub.docker.com/explore/</a> ，然后通过以下命令在线pull：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull 镜像名称</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker pull 镜像名称:版本</span></span><br></pre></td></tr></table></figure><p>因为官方提供的Docker镜像加速服务很慢，我们可以配置ustc的镜像。输入以下命令配置ustc镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vi /etc/docker/daemon.json</span></span><br></pre></td></tr></table></figure><p>没有就创建，向其中写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="string">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启Docker服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure><p>4、删除镜像<br>删除指定镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker rmi $IMAGE_ID  #这个$IMAGE_ID数值可以根据`docker images`命令查看</span></span><br></pre></td></tr></table></figure><p>删除所有镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker rmi `docker images -q`</span></span><br></pre></td></tr></table></figure><h4 id="Docker容器操作"><a href="#Docker容器操作" class="headerlink" title="Docker容器操作"></a>Docker容器操作</h4><p>1.查看正在运行的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br></pre></td></tr></table></figure><p>2.查看所有的容器（启动过的历史容器）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br></pre></td></tr></table></figure><p>3.查看最后一次运行的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -|</span></span><br></pre></td></tr></table></figure><p>4.查看停止的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -f status=exited</span></span><br></pre></td></tr></table></figure><p>5.删除容器<br>删除指定容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker rm $CONTAINER_ID/NAME</span></span><br></pre></td></tr></table></figure><p>删除所有容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker rm `docker ps -a -q`</span></span><br></pre></td></tr></table></figure><h4 id="创建和启动容器"><a href="#创建和启动容器" class="headerlink" title="创建和启动容器"></a>创建和启动容器</h4><p><strong>创建容器常用的参数说明</strong><br>1.创建容器命令：docker run<br>2.-i: 表示运行容器<br>3.-t: 表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。<br>4.—name: 为创建的容器命名<br>5.-v: 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录或文件映射。注意：最好做目录映射，在宿主机上修改，然后共享到容器上。<br>6.-d: 在run后面加上-d参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。<br>7.-p： 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射。</p><h5 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h5><p>创建一个交互式容器并取名为mycentos5:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@localhost ~]<span class="comment"># docker run -it --name=mycentos5 centos:7 /bin/bash</span></span><br><span class="line">[root@53f33e279914 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>此时我们可以新建一个连接，通过docker ps命令看到刚才创建的容器正在启动中：<br><img src="/images/docker8.png" srcset="/img/loading.gif" alt="docker"><br>通过exit命令可以退出当前容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@53f33e279914 /]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>此时再通过docker ps命令查看刚才启动的容器也停止了。</p><h5 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h5><p>输入以下命令创建一个名字为mycentos6的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -di --name=mycentos6 centos:7</span></span><br></pre></td></tr></table></figure><p>创建后这个容器会在后台运行，而不是直接进入到这个容器中。可以通过docker ps命令查看。<br>登录守护式容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker exec -it mycentos6 /bin/bash</span></span><br></pre></td></tr></table></figure><p>可以通过exit命令退出，但是容器不会停止。</p><h5 id="停止和启动容器"><a href="#停止和启动容器" class="headerlink" title="停止和启动容器"></a>停止和启动容器</h5><p>停止正在运行的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker stop 容器名称</span></span><br></pre></td></tr></table></figure><p>启动已运行过的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker start 容器名称</span></span><br></pre></td></tr></table></figure><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><h5 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h5><p>将文件拷贝到容器内可以用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker cp 需要拷贝的文件或目录 容器名称:容器目录</span></span><br></pre></td></tr></table></figure><p>将文件从容器中拷贝出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker cp 容器名称:容器目录 需要拷贝的文件或目录</span></span><br></pre></td></tr></table></figure><h5 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h5><p>在创建容器的时候，将宿主机的目录和容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而影响容器。格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -di -v 宿主机目录:容器目录</span></span><br></pre></td></tr></table></figure><h5 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker inspect mycentos5</span></span><br></pre></td></tr></table></figure><p><strong>部署应用</strong></p><h4 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h4><p>1.拉取MySQL镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull mysql:5.7</span></span><br></pre></td></tr></table></figure><p>2.创建MySQL容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -di --name docker_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.7</span></span><br></pre></td></tr></table></figure><p>如上我们创建一个名称为docker_mysql的MySQL5.7版本的守护式容器，且配置MySQL登录密码是root。</p><ul><li>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</li><li>-e 代表添加环境变量， MYSQL_ROOT_PASSWORD是root用户的登录密码</li></ul><p>3.进入MySQL容器，登录MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker exec -it docker_mysql /bin/bash</span></span><br></pre></td></tr></table></figure><p>登录MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>4.远程连接MySQL<br><img src="/images/docker9.png" srcset="/img/loading.gif" alt="docker"></p><h4 id="Tomcat部署"><a href="#Tomcat部署" class="headerlink" title="Tomcat部署"></a>Tomcat部署</h4><p>1.拉取Tomcat-8 &amp;&amp; JDK-8 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull tomcat:8-jre8</span></span><br></pre></td></tr></table></figure><p>2.部署Web应用<br>为了更好的演示Docker部署Tomcat的使用方式，我们可以先将需要部署的web项目发送到服务器的某个路径下，我这里在/root/目录下创建了/root/site/目录作为项目的根目录，在其中创建index.html文件并写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello Docker-Tomcat!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>3.创建Tomcat容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -di --name=docker_tomcat -p 9000:8080 -v /root/site/:/usr/local/tomcat/webapps/ROOT --privileged=true tomcat:8-jre8</span></span><br></pre></td></tr></table></figure><p>以上就创建一个Tomcat容器，其容器名称Wiedocker_tomcat，-di表示是一个守护式容器；-p 9000:8080表示此容器端口映射为9000-&gt;8080，即对外的端口是9000，映射到容器里Tomcat服务器的端口8080，–privileged是以root权限运行。<br><img src="/images/docker10.png" srcset="/img/loading.gif" alt="docker"><br>通过命令看到，当我们启动了容器，其中的Tomcat服务器也自动启动了。当然对于部署Nginx或MySQL的Docker容器，当启动容器时都会启动对应的服务。<br><strong>注意</strong><br>上面我们指定了宿主机的/root/site/目录映射到docker_tomcat容器的/usr/local/tomcat/webapps/ROOT目录，为什么是这个目录呢？<br>Docker虚拟化，它会在内部虚拟一个操作系统，是在其宿主机内核上的一层空间，所有有一定的目录结构，我们可以通过docker exec -it docker_tomcat /bin/bash命令进入到docker_tomcat容器内部，通过ls命令查看目录会发现其Tomcat服务器确实安装在docker_tomcat容器的/usr/local/tomcat目录下。<br>最后，我们在浏览器上访问：<a href="http://192.168.148.132:9000/" target="_blank" rel="noopener">http://192.168.148.132:9000/</a>，即发现页面展示了我们刚才在/root/site/目录下创建的index.html网页：<br><img src="/images/docker11.png" srcset="/img/loading.gif" alt="docker"><br>所以，如果你想要修改容器中Tomcat的端口号，直接进入容器的/usr/local/tomcat/conf/server.xml自改即可。</p><h4 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h4><p>1.拉取Nginx镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p>2.创建Nginx容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=docker_nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>测试<br><img src="/images/docker12.png" srcset="/img/loading.gif" alt="docker"><br>在浏览器上访问：<a href="http://192.168.148.132/" target="_blank" rel="noopener">http://192.168.148.132/</a>可以进入到Nginx的欢迎页。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>以上我们介绍了MySQL、Tomcat、Nginx容器的创建，对于其他的服务，如Redis等操作基本相同，不再阐述。</p><h4 id="备份与迁移"><a href="#备份与迁移" class="headerlink" title="备份与迁移"></a>备份与迁移</h4><p>1.容器保存为镜像<br>可以通过以下命令将我们已创建（配置好的）容器打包为镜像，这样我们以后就能用该镜像再次创建新的容器了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit docker_tomcat my_tomcat</span><br></pre></td></tr></table></figure><p>docker_tomcat是容器名称；my_tomcat是新的镜像名称。<br>2.镜像备份<br>通过以下命令可以将镜像打包为tar文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o my_tomcat.tar my_tomcat</span><br></pre></td></tr></table></figure><p>-o输出到的文件<br>3.镜像恢复与备份<br>当我们删除了docker_tomcat镜像后，可以通过以下命令将刚才打包备份的.tar镜像文件恢复成一个Docker镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i my_tomcat.tar</span><br></pre></td></tr></table></figure><p>-i输入的文件。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps - 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架——深入理解AOP实现原理</title>
    <link href="/2018/11/07/Spring-3/"/>
    <url>/2018/11/07/Spring-3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>阅读这篇文章前，最好有代理模式的基础，以及了解关于Spring扩展点例如BeanPostProcessor和如何使用自定义标签集成Spring，这些文章在我的博客里都能找到。当然，也最好有使用AOP的经验，这篇文章不会讲解如何使用AOP。</p></blockquote><p><img src="/images/spring_logo.jpg" srcset="/img/loading.gif" alt="Spring"></p><h3 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h3><p>说到AOP，其实这是一个<strong>面向方面的编程思想</strong> ，它解决了OOP的一些弊端，例如我们需要为<strong>多个不具有继承关系的类引入一个公共行为</strong>， 比如说日志、权限验证、事务管理等等，我们需要将这些代码<strong>重复的添加</strong>到一系列的类中，将<strong>产生大量的重复代码</strong>，如果需要修改，将在每个类中去进行修改，<strong>不便于维护</strong>，代码的<strong>侵入性极高</strong>。所以就有了AOP这样面向方面编程的编程思想，其功能可以为每个需要的类<strong>加入共同的行为</strong>，如果需要修改，只需要修改切面中的代码，改一处等于改多处，并且便于编程，写一个切面类即可达到在每个类中加入重复代码的目的。</p><p>阅读此篇文章，你将了解Spring是<strong>如何实现AOP</strong>（前置通知、后置通知、环绕通知），由于Spring中的事务管理是基于AOP的功能来做的，所以你将更好的能理解Spring是如何将事务统一管理起来的。</p><hr><h3 id="自定义标签开启AOP"><a href="#自定义标签开启AOP" class="headerlink" title="自定义标签开启AOP"></a>自定义标签开启AOP</h3><p>只要用过AOP都知道，如果需要使用AOP，需要在配置文件中写这样一段配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy /&gt;</span><br></pre></td></tr></table></figure><p>只有写了这段配置才可以开启AOP功能，那么这个自定义标签又做了什么呢？在上一篇讲解自定义标签的文章中详细讲到了，此时我们需要关注其标签头aop去寻找对应的命名空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br></pre></td></tr></table></figure><p>全局搜索命名空间<code>&lt;http\://<a href="http://www.springframework.org/schema/aop" target="_blank" rel="noopener">www.springframework.org/schema/aop</a>&gt;</code>，注意http后加一个“\” ，可以找到<strong>spring.handlers</strong>文件中对应的handler类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure><p>这样就找到了命名空间对应的handler：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AopNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Register the &#123;@link BeanDefinitionParser BeanDefinitionParsers&#125; <span class="keyword">for</span> the</span><br><span class="line">   * <span class="string">'&#123;@code config&#125;'</span>, <span class="string">'&#123;@code spring-configured&#125;'</span>, <span class="string">'&#123;@code aspectj-autoproxy&#125;'</span></span><br><span class="line">   * and <span class="string">'&#123;@code scoped-proxy&#125;'</span> tags.</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">    // In 2.0 XSD as well as <span class="keyword">in</span> 2.1 XSD.</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"config"</span>, new ConfigBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, new AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionDecorator(<span class="string">"scoped-proxy"</span>, new ScopedProxyBeanDefinitionDecorator());</span><br><span class="line"></span><br><span class="line">    // Only <span class="keyword">in</span> 2.0 XSD: moved to context namespace as of 2.1</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, new SpringConfiguredBeanDefinitionParser());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到开头配置自定义标签，我们使用了<code>aspectj-autoproxy</code>这个Parser。在init方法中，我们找到<code>aspectj-autoproxy</code>对应的Parser是<code>AspectJAutoProxyBeanDefinitionParser</code>这个类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">//我们只关注解析的主方法，parse方法</span><br><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    //注册一个类到IOC容器中</span><br><span class="line">    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">    extendBeanDefinition(element, parserContext);</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="注册AnnotationAwareAspectJAutoProxyCreator"><a href="#注册AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="注册AnnotationAwareAspectJAutoProxyCreator"></a>注册AnnotationAwareAspectJAutoProxyCreator</h3><p><code>AnnotationAwareAspectJAutoProxyCreator</code>是实现AOP功能的主要类，我们先来看看这个类的结构：<br><img src="/images/spring-aop1.png" srcset="/img/loading.gif" alt="spring"><br>此类实现了<code>BeanPostProcessor</code>，稍后将关注其后置处理Bean的方法<strong>postProcessAfterInitialization</strong>，并且实现了<code>BeanFactorAware</code>接口，此类将取得并存有一个<code>BeanFactory</code>实例对象。<br>回到主线，关注注册此类的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">    ParserContext parserContext, Element sourceElement) &#123;</span><br><span class="line">//将一个类作为Bean注册到IOC容器中</span><br><span class="line">    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">        parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">    //处理proxy-target-class与expose-proxy属性</span><br><span class="line">    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">    //注册组件并通知</span><br><span class="line">    registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，在注册这个类的过程中主要完成了3件事：</p><ol><li>注册<code>AnnotationAwareAspectJAutoProxyCreator：</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry,</span><br><span class="line">                                                                                  @Nullable Object <span class="built_in">source</span>) &#123;</span><br><span class="line">//将AnnotationAwareAspectJAutoProxyCreator这个类注册到IOC容器中</span><br><span class="line">    <span class="built_in">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, <span class="built_in">source</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry,</span><br><span class="line">                                                              @Nullable Object <span class="built_in">source</span>) &#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    //如果IOC容器中已经存在了此类型的Bean，则需要判断优先级</span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">        //获取此类的BeanDefinition信息</span><br><span class="line">        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">        //如果此Bean的ClassName与AnnotationAwareAspectJAutoProxyCreator类的</span><br><span class="line">        //ClassName不同的话，判断优先级</span><br><span class="line">        <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">            int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">            int requiredPriority = findPriorityForClass(cls);</span><br><span class="line">            //如果已存在Bean优先级小于Creator的优先级</span><br><span class="line">            <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                //将ClassName替换成Creator</span><br><span class="line">                apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //不进行注册，因为已经注册了</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果到这里，说明IOC容器中没有配置对应Creator</span><br><span class="line">    //使用Crearir的Class构造一个BeanDefinition</span><br><span class="line">    RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);</span><br><span class="line">    beanDefinition.setSource(<span class="built_in">source</span>);</span><br><span class="line">    //配置依赖属性order，将其设置为最高优先级</span><br><span class="line">    beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    //将设置好属性的BeanDefinition注册进IOC容器中</span><br><span class="line">    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">    <span class="built_in">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>处理<strong>proxy-target-class</strong>与<strong>expose-proxy</strong>属性<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, @Nullable Element sourceElement) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sourceElement != null) &#123;</span><br><span class="line">        boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">        //处理proxy-target-class属性</span><br><span class="line">        <span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line">        //处理expose-proxy属性</span><br><span class="line">        <span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其中设置属性的过程：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">        //根据之前注册的BeanName取出Creator</span><br><span class="line">        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">        //将Creator的BeanDefinition的属性proxyTargetClass设置为<span class="literal">true</span></span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"proxyTargetClass"</span>, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">        //根据之前注册的BeanName取出Creator</span><br><span class="line">        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">        //将Creator的BeanDefinition的属性exposeProxy设置为<span class="literal">true</span></span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"exposeProxy"</span>, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>proxy-target-class</strong>：在Spring的AOP中，默认的如果目标类实现了至少一个接口，将使用<strong>JDK动态代理</strong>实现AOP，否则使用<strong>CGLib动态代理</strong>实现AOP，如果希望AOP都使用CGLib实现，你就可以设置proxy-target-class属性为<strong>true</strong>，但要注意几个问题：</li></ul><p>1)<strong>无法对final的方法进行动态代理</strong>，原因很简单，CGLib使用继承实现，final方法无法重写，所以final的方法不能应用AOP。<br>2)需要配置CGLib的JAR包</p><ul><li><strong>expose-proxy</strong>：在讲解事务的那篇文章中有提到，如果一个类中的事务A方法调用了同一个类中的事务B方法，<strong>B方法将没有事务</strong>，这个道理在AOP中也是这样的，相同类下的不同方法互相调用，内部方法将无法被应用通知（无法进行AOP），此时你需要将<strong>expose-proxy属性设置为true</strong>，暴露一个代理类（此属性的原理在下面会有详细讲解），然后在A方法中需要调用B方法的话需要这样写：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Service&#123;</span><br><span class="line">    public void <span class="function"><span class="title">A</span></span>()&#123;</span><br><span class="line">        ((Service)AopContext.currentProxy()).B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">B</span></span>()&#123;</span><br><span class="line">    //<span class="keyword">do</span> something...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这样，B方法就算再A方法内也可以被AOP。其中<code>AopContext</code>是存放线程变量的类，形象的称之为<strong>AOP的上下文</strong>。</li></ul><hr><h3 id="实现AOP代理"><a href="#实现AOP代理" class="headerlink" title="实现AOP代理"></a>实现AOP代理</h3><h4 id="创建AOP代理"><a href="#创建AOP代理" class="headerlink" title="创建AOP代理"></a>创建AOP代理</h4><p>上面，自定义标签的配置完成了对<strong>Creator类的自动注册</strong>，我们可以知道，此类实现了<code>BeanPostProcessor</code>接口，将会在IOC容器初始化每个Bean时都调用此类的<strong>postProcessAfterInitialization</strong>方法，此方法即为AOP代理的入口，此方法在抽象父类<code>AbstractAutoProxyCreator</code>实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != null) &#123;</span><br><span class="line">        //先从缓存中获取Key，由要代理的Bean的Class与benaName组成</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        //判断是否是过早暴露的Bean，此概念在讲IOC解决循环依赖中有提到</span><br><span class="line">        //如果是过早暴露的Bean，则此时连依赖注入都没有完成，则不对其进行代理</span><br><span class="line">        //待其真正初始化之后再尝试代理</span><br><span class="line">        <span class="keyword">if</span> (!this.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">            //如果符合条件进行AOP代理</span><br><span class="line">            <span class="built_in">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line">    //如果先前已经处理过的，不进行处理</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="built_in">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果此Bean已经被标记为无法代理，不进行处理</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="built_in">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果Bean为AOP类的类型，或是需要跳过的类型，不进行处理</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        //标记为不代理</span><br><span class="line">        this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="built_in">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Create proxy <span class="keyword">if</span> we have advice.</span><br><span class="line">    //寻找符合此Bean的增强方法（通知方法）</span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</span><br><span class="line">    //如果寻找到的增强方法列表不为空，也就是不为DO_NOT_PROXY</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        //标记为已代理</span><br><span class="line">        this.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        //根据找到的增强方法，对此Bean进行动态代理</span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">        this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        //将代理对象作为Bean返回给IOC容器</span><br><span class="line">        <span class="built_in">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">  //如果走到这里，说明代理失败，标记为代理失败</span><br><span class="line">    this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="built_in">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文章到了这里，就已经基本完成AOP的实现了，剩下我们需要关注的就是两件事：</p><ul><li>如何寻找符合Bean的增强器</li><li>如何对Bean创建动态代理</li></ul><h4 id="寻找所有的增强器"><a href="#寻找所有的增强器" class="headerlink" title="寻找所有的增强器"></a>寻找所有的增强器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) &#123;</span><br><span class="line">    //寻找适合的Advisor</span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个<code>Advisor</code>的概念，其中Advisor<strong>封装了切点信息与advise通知方法等等信息。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">    //寻找所有适用的Advisor</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    //从所有Advisor中选出适合被当前Bean使用的Advisor</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="寻找已存在的Advisor"><a href="#寻找已存在的Advisor" class="headerlink" title="寻找已存在的Advisor"></a>寻找已存在的Advisor</h5><p>首先，执行下面的方法寻找合适的<code>Advisor</code>（此方法在子类<code>Creator</code>中得到实现）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected List&lt;Advisor&gt; <span class="function"><span class="title">findCandidateAdvisors</span></span>() &#123;</span><br><span class="line">    // Add all the Spring advisors found according to superclass rules.</span><br><span class="line">    //首先调用父类findCandidateAdvisors的方法寻找在IOC容器中的Advisor类型的Bean</span><br><span class="line">    List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();</span><br><span class="line">    // Build Advisors <span class="keyword">for</span> all AspectJ aspects <span class="keyword">in</span> the bean factory.</span><br><span class="line">    <span class="keyword">if</span> (this.aspectJAdvisorsBuilder != null) &#123;</span><br><span class="line">        //寻找注解的Advisor</span><br><span class="line">        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用父类的<strong>findCandidateAdvisors</strong>方法寻找所有的<code>Advisor</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; <span class="function"><span class="title">findCandidateAdvisors</span></span>() &#123;</span><br><span class="line">    Assert.state(this.advisorRetrievalHelper != null, <span class="string">"No BeanFactoryAdvisorRetrievalHelper available"</span>);</span><br><span class="line">    //委派Helper类去寻找</span><br><span class="line">    <span class="built_in">return</span> this.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Advisor&gt; <span class="function"><span class="title">findAdvisorBeans</span></span>() &#123;</span><br><span class="line">    // Determine list of advisor bean names, <span class="keyword">if</span> not cached already.</span><br><span class="line">    String[] advisorNames = null;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //先从缓存中取</span><br><span class="line">        advisorNames = this.cachedAdvisorBeanNames;</span><br><span class="line">        //缓存中若没有再去IOC容器中取</span><br><span class="line">        <span class="keyword">if</span> (advisorNames == null) &#123;</span><br><span class="line">            // Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">            // uninitialized to <span class="built_in">let</span> the auto-proxy creator apply to them!</span><br><span class="line">            //从IOC容器中寻找所有Advisor类型的BeanName</span><br><span class="line">            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                this.beanFactory, Advisor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            //放入缓存</span><br><span class="line">            this.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //没有找到，返回空</span><br><span class="line">    <span class="keyword">if</span> (advisorNames.length == 0) &#123;</span><br><span class="line">        <span class="built_in">return</span> new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class="line">    //遍历上面得到的所有BeanName</span><br><span class="line">    <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (this.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Skipping currently created advisor '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //根据BeanName从IOC获取Bean实例并存入List中</span><br><span class="line">                    advisors.add(this.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">                &#125;</span><br><span class="line">                //catch方法 略...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此时仅仅是<strong>只获取IOC容器中那些Advisor类型的Bean作为Advisor</strong>，而在我们注解配置AOP的方式中并不是配置Advisor类的，下面会说到如何获取所有打了注解的切面，这里只是尝试去IOC容器中找是否存在这样的类，有的话也不会漏掉。</p><h5 id="寻找所有注解的Advisor"><a href="#寻找所有注解的Advisor" class="headerlink" title="寻找所有注解的Advisor"></a>寻找所有注解的Advisor</h5><p>现在我们拿到了部分的Advisor，回到我们主类<code>AnnotationAwareAspectJAutoProxyCreatorS</code>的<strong>findCandidateAdvisors</strong> 方法，此时将委派<code>BeanFactoryAspectJAdvisorsBuilder</code>类去执行<strong>buildAspectJAdvisors</strong>方法，将继续获取被注解了的Advisor：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected List&lt;Advisor&gt; <span class="function"><span class="title">findCandidateAdvisors</span></span>() &#123;</span><br><span class="line">    // Add all the Spring advisors found according to superclass rules.</span><br><span class="line">    List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();</span><br><span class="line">    // Build Advisors <span class="keyword">for</span> all AspectJ aspects <span class="keyword">in</span> the bean factory.</span><br><span class="line">    <span class="keyword">if</span> (this.aspectJAdvisorsBuilder != null) &#123;</span><br><span class="line">        //委派BeanFactoryAspectJAdvisorsBuilder去寻找注解Advisor</span><br><span class="line">        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Advisor&gt; <span class="function"><span class="title">buildAspectJAdvisors</span></span>() &#123;</span><br><span class="line">    List&lt;String&gt; aspectNames = this.aspectBeanNames;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aspectNames == null) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            aspectNames = this.aspectBeanNames;</span><br><span class="line">            //双重加锁保证在并发情况下不会寻找两次</span><br><span class="line">            <span class="keyword">if</span> (aspectNames == null) &#123;</span><br><span class="line">                List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class="line">                aspectNames = new LinkedList&lt;&gt;();</span><br><span class="line">                //从IOC容器中获取所有的BeanName</span><br><span class="line">                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                    this.beanFactory, Object.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">                //遍历所有的BeanName</span><br><span class="line">                <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">                        <span class="built_in">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // We must be careful not to instantiate beans eagerly as <span class="keyword">in</span> this <span class="keyword">case</span> they</span><br><span class="line">                    // would be cached by the Spring container but would not have been weaved.</span><br><span class="line">                    Class&lt;?&gt; beanType = this.beanFactory.getType(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (beanType == null) &#123;</span><br><span class="line">                        <span class="built_in">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //判断此时的Bean的类上是否打了@Aspect注解</span><br><span class="line">                    <span class="keyword">if</span> (this.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                        //如果是，判断此类将是一个Advisor</span><br><span class="line">                        aspectNames.add(beanName);</span><br><span class="line">                        AspectMetadata amd = new AspectMetadata(beanType, beanName);</span><br><span class="line">                        //如果是单例，说明可以缓存下来</span><br><span class="line">                        <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">                            //封装成一个对象</span><br><span class="line">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);</span><br><span class="line">                            //委派advisorFactory工厂针对以上封装信息创建Advisor</span><br><span class="line">                            List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);</span><br><span class="line">                            //如果是单例，缓存</span><br><span class="line">                            <span class="keyword">if</span> (this.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                this.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                            &#125;</span><br><span class="line">                            //如果不是，只缓存factory，待下一次进入取出缓存的factory</span><br><span class="line">                            //然后再用advisorFactory创建一次Advisor，省去寻找Bean与创建factory的麻烦</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                this.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                            &#125;</span><br><span class="line">                            advisors.addAll(classAdvisors);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            // Per target or per this.</span><br><span class="line">                            <span class="keyword">if</span> (this.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                throw new IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">                                                                   <span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                new PrototypeAspectInstanceFactory(this.beanFactory, beanName);</span><br><span class="line">                            this.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                            advisors.addAll(this.advisorFactory.getAdvisors(factory));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                this.aspectBeanNames = aspectNames;</span><br><span class="line">                <span class="built_in">return</span> advisors;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果走到这里，说明已经找过一遍了，这里从缓存获取信息</span><br><span class="line">    <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class="line">    //遍历所有缓存的切面名</span><br><span class="line">    <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">        //根据切面名从缓存拿Advisor</span><br><span class="line">        List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName);</span><br><span class="line">        //如果可以拿到，直接获取</span><br><span class="line">        <span class="keyword">if</span> (cachedAdvisors != null) &#123;</span><br><span class="line">            advisors.addAll(cachedAdvisors);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果拿不到，说明此时缓存的是factory</span><br><span class="line">        //根据factory使用advisorFactory创建Advisor</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);</span><br><span class="line">            advisors.addAll(this.advisorFactory.getAdvisors(factory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经<strong>完成了对所有Advisor的获取</strong>，这里值得关注的是工厂（<strong>advisorFactory</strong>）是<strong>如何创建Advisor</strong>的呢？进入<code>ReflectiveAspectJAdvisorFactory</code>类的<strong>getAdvisors</strong>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) &#123;</span><br><span class="line">    //获取切面类类型</span><br><span class="line">    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">    //获取切面Name</span><br><span class="line">    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">    //验证</span><br><span class="line">    validate(aspectClass);</span><br><span class="line"></span><br><span class="line">    // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span><br><span class="line">    // so that it will only instantiate once.</span><br><span class="line">    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">        new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">    List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();</span><br><span class="line">    //遍历所有除了被打上@Pointcut注解的方法</span><br><span class="line">    <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">        //在其每个方法中获取Advisor</span><br><span class="line">        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">        <span class="keyword">if</span> (advisor != null) &#123;</span><br><span class="line">            advisors.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If it<span class="string">'s a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line"><span class="string">    if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span></span><br><span class="line"><span class="string">        Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span></span><br><span class="line"><span class="string">        advisors.add(0, instantiationAdvisor);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Find introduction fields.</span></span><br><span class="line"><span class="string">    //获取DeclareParents注解的filed</span></span><br><span class="line"><span class="string">    for (Field field : aspectClass.getDeclaredFields()) &#123;</span></span><br><span class="line"><span class="string">        Advisor advisor = getDeclareParentsAdvisor(field);</span></span><br><span class="line"><span class="string">        if (advisor != null) &#123;</span></span><br><span class="line"><span class="string">            advisors.add(advisor);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return advisors;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>我们需要关注两点：</p><ol><li><strong>getAdvisorMethods</strong>：此方法获取类上所有的<code>AdvisorMethods</code>，那么是如何进行的：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) &#123;</span><br><span class="line">    final List&lt;Method&gt; methods = new LinkedList&lt;&gt;();</span><br><span class="line">    ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;</span><br><span class="line">        // Exclude pointcuts</span><br><span class="line">        //获取方法上的注解，如果是Pointcut注解不处理</span><br><span class="line">        <span class="keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) &#123;</span><br><span class="line">            methods.add(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Collections.sort(methods, METHOD_COMPARATOR);</span><br><span class="line">    <span class="built_in">return</span> methods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们可以知道，其将<strong>不是Pointcut的注解的方法加入到方法集合中作为AdvisorMethod</strong>。</li><li><strong>getAdvisor</strong>：从上面获得的方法中，提取出<code>Advisor</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span><br><span class="line">                          int declarationOrderInAspect, String aspectName) &#123;</span><br><span class="line"></span><br><span class="line">    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line">    //切点信息的获取</span><br><span class="line">    AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">        candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">    <span class="keyword">if</span> (expressionPointcut == null) &#123;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据获得的切点信息封装增强器</span><br><span class="line">    <span class="built_in">return</span> new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">                                                          this, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们依然需要关注两个点：</li></ol><ul><li>getPointcut：<strong>切点信息的获取</strong></li><li>InstantiationModelAwarePointcutAdvisorImpl：<strong>根据切点信息封装成增强器</strong></li></ul><h5 id="获取切点信息"><a href="#获取切点信息" class="headerlink" title="获取切点信息"></a>获取切点信息</h5><p>依然是在创建Advisor的工厂中的方法<strong>getPointcut</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) &#123;</span><br><span class="line">    //获取该方法的注解</span><br><span class="line">    AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">    <span class="keyword">if</span> (aspectJAnnotation == null) &#123;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //封装信息</span><br><span class="line">    AspectJExpressionPointcut ajexp =</span><br><span class="line">        new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]);</span><br><span class="line">    //设置切点表达式</span><br><span class="line">    //例如：@Before（<span class="string">"test()"</span>）上的<span class="built_in">test</span>()</span><br><span class="line">    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class="line">    <span class="keyword">if</span> (this.beanFactory != null) &#123;</span><br><span class="line">        ajexp.setBeanFactory(this.beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ajexp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要关注的是获取方法的注解<strong>findAspectJAnnotationOnMethod</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">@Nullable</span><br><span class="line">protected static AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class="line">    //需要关注的类型</span><br><span class="line">    Class&lt;?&gt;[] classesToLookFor = new Class&lt;?&gt;[] &#123;</span><br><span class="line">        Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; c : classesToLookFor) &#123;</span><br><span class="line">        //将每个需要关注的类型都与方法进行匹配</span><br><span class="line">        AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);</span><br><span class="line">        //如果找到，返回</span><br><span class="line">        <span class="keyword">if</span> (foundAnnotation != null) &#123;</span><br><span class="line">            <span class="built_in">return</span> foundAnnotation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>findAnnotation ：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">private static &lt;A extends Annotation&gt; AspectJAnnotation&lt;A&gt; findAnnotation(Method method, Class&lt;A&gt; toLookFor) &#123;</span><br><span class="line">    //根据指定的类型寻找方法上的注解</span><br><span class="line">    A result = AnnotationUtils.findAnnotation(method, toLookFor);</span><br><span class="line">    <span class="keyword">if</span> (result != null) &#123;</span><br><span class="line">        //如果找到了，将其封装为AspectJAnnotation对象返回</span><br><span class="line">        <span class="built_in">return</span> new AspectJAnnotation&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在寻找注解的时候<strong>仅仅是获取</strong>了例如@Before(“test()”)中的<strong>test()这样的切点方法名信息</strong>，这个过程在封装AspectJAnnotation对象时在<strong>构造函数</strong>完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public AspectJAnnotation(A annotation) &#123;</span><br><span class="line">    this.annotation = annotation;</span><br><span class="line">    this.annotationType = determineAnnotationType(annotation);</span><br><span class="line">    // We know these methods exist with the same name on each object,</span><br><span class="line">    // but need to invoke them reflectively as there isn<span class="string">'t a common interface.</span></span><br><span class="line"><span class="string">    try &#123;</span></span><br><span class="line"><span class="string">        //处理注解上的pointcut信息</span></span><br><span class="line"><span class="string">        this.pointcutExpression = resolveExpression(annotation);</span></span><br><span class="line"><span class="string">        this.argumentNames = (String) annotation.getClass().getMethod("argNames").invoke(annotation);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    catch (Exception ex) &#123;</span></span><br><span class="line"><span class="string">        throw new IllegalArgumentException(annotation + " cannot be an AspectJ annotation", ex);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private String resolveExpression(A annotation) throws Exception &#123;</span><br><span class="line">    //遍历获取注解中的两个方法名：value和pointcut</span><br><span class="line">    <span class="keyword">for</span> (String methodName : EXPRESSION_PROPERTIES) &#123;</span><br><span class="line">        Method method;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取method对象</span><br><span class="line">            method = annotation.getClass().getDeclaredMethod(methodName);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (NoSuchMethodException ex) &#123;</span><br><span class="line">            method = null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method != null) &#123;</span><br><span class="line">            //获取切点方法名，也就是注解上设置的，例如@Before(<span class="string">"test()"</span>)</span><br><span class="line">            //此时获取<span class="string">"test()"</span>这样的字符串</span><br><span class="line">            String candidate = (String) method.invoke(annotation);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(candidate)) &#123;</span><br><span class="line">                <span class="built_in">return</span> candidate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalStateException(<span class="string">"Failed to resolve expression: "</span> + annotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="根据切点信息，封装成Advisor"><a href="#根据切点信息，封装成Advisor" class="headerlink" title="根据切点信息，封装成Advisor"></a>根据切点信息，封装成Advisor</h5><p>根据切点信息生成增强器，所有的增强都由<code>InstantiationModelAwarePointcutAdvisorImpl</code>这个类来封装，当然，这个类是一个<code>Advisor</code>。进入此类的构造函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,</span><br><span class="line">                                                  Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span><br><span class="line">                                                  MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) &#123;</span><br><span class="line"></span><br><span class="line">    //将获得的信息都封装到这个对象的属性上</span><br><span class="line">    this.declaredPointcut = declaredPointcut;</span><br><span class="line">    this.declaringClass = aspectJAdviceMethod.getDeclaringClass();</span><br><span class="line">    this.methodName = aspectJAdviceMethod.getName();</span><br><span class="line">    this.parameterTypes = aspectJAdviceMethod.getParameterTypes();</span><br><span class="line">    this.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class="line">    this.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class="line">    this.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class="line">    this.declarationOrder = declarationOrder;</span><br><span class="line">    this.aspectName = aspectName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">        // Static part of the pointcut is a lazy <span class="built_in">type</span>.</span><br><span class="line">        Pointcut preInstantiationPointcut = Pointcuts.union(</span><br><span class="line">            aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);</span><br><span class="line"></span><br><span class="line">        // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.</span><br><span class="line">        // If it’s not a dynamic pointcut, it may be optimized out</span><br><span class="line">        // by the Spring AOP infrastructure after the first evaluation.</span><br><span class="line">        this.pointcut = new PerTargetInstantiationModelPointcut(</span><br><span class="line">            this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class="line">        this.lazy = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        // A singleton aspect.</span><br><span class="line">        this.pointcut = this.declaredPointcut;</span><br><span class="line">        this.lazy = <span class="literal">false</span>;</span><br><span class="line">        //解析当前切点适用的Advice，并保存到instantiatedAdvice属性上</span><br><span class="line">        this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在封装的过程中只是<strong>简单的将信息放入类的属性中</strong>，而值得关注的是最后一行的<strong>instantiateAdvice</strong>方法，此方法将<strong>根据注解类型选择不同的Advise</strong>，例如@Before、@After等等都是不同的Advice，它们需要前置或是后置通知，所体现的<strong>增强的逻辑是不同的</strong>，所以就需要不同的Advice来完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) &#123;</span><br><span class="line">    //委派别的类去获取Advice</span><br><span class="line">    Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut,</span><br><span class="line">                                                         this.aspectInstanceFactory, this.declarationOrder, this.aspectName);</span><br><span class="line">    <span class="built_in">return</span> (advice != null ? advice : EMPTY_ADVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类又委派了<code>aspectJAdvisorFactory</code>去获取Advice：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span><br><span class="line">                        MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) &#123;</span><br><span class="line"></span><br><span class="line">    //根据之前的信息获取切面类类型</span><br><span class="line">    Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">    validate(candidateAspectClass);</span><br><span class="line"></span><br><span class="line">    //寻找方法上的注解</span><br><span class="line">    AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">    <span class="keyword">if</span> (aspectJAnnotation == null) &#123;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we get here, we know we have an AspectJ method.</span><br><span class="line">    // Check that it’s an AspectJ-annotated class</span><br><span class="line">    <span class="keyword">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class="line">        throw new AopConfigException(<span class="string">"Advice must be declared inside an aspect type: "</span> +</span><br><span class="line">                                     <span class="string">"Offending method '"</span> + candidateAdviceMethod + <span class="string">"' in class ["</span> +</span><br><span class="line">                                     candidateAspectClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found AspectJ method: "</span> + candidateAdviceMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractAspectJAdvice springAdvice;</span><br><span class="line"></span><br><span class="line">    //根据刚刚从方法上获得的注解，解析成枚举的类型进行swich</span><br><span class="line">    switch (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line">            //@Before注解将会走这里</span><br><span class="line">        <span class="keyword">case</span> AtBefore:</span><br><span class="line">            springAdvice = new AspectJMethodBeforeAdvice(</span><br><span class="line">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">            //@After注解</span><br><span class="line">        <span class="keyword">case</span> AtAfter:</span><br><span class="line">            springAdvice = new AspectJAfterAdvice(</span><br><span class="line">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">            //@AfterReturning</span><br><span class="line">        <span class="keyword">case</span> AtAfterReturning:</span><br><span class="line">            springAdvice = new AspectJAfterReturningAdvice(</span><br><span class="line">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class="line">                springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">            //@AfterThrowing</span><br><span class="line">        <span class="keyword">case</span> AtAfterThrowing:</span><br><span class="line">            springAdvice = new AspectJAfterThrowingAdvice(</span><br><span class="line">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class="line">                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">            //@Around</span><br><span class="line">        <span class="keyword">case</span> AtAround:</span><br><span class="line">            springAdvice = new AspectJAroundAdvice(</span><br><span class="line">                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">            //@Pointcut</span><br><span class="line">        <span class="keyword">case</span> AtPointcut:</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        default:</span><br><span class="line">            throw new UnsupportedOperationException(</span><br><span class="line">                <span class="string">"Unsupported advice type on method: "</span> + candidateAdviceMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Now to configure the advice...</span><br><span class="line">    //配置得到的Advice</span><br><span class="line">    springAdvice.setAspectName(aspectName);</span><br><span class="line">    springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">    String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line">    <span class="keyword">if</span> (argNames != null) &#123;</span><br><span class="line">        springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">    &#125;</span><br><span class="line">    springAdvice.calculateArgumentBindings();</span><br><span class="line">    <span class="built_in">return</span> springAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面我们可以知道，不同的通知对应不同的Advice，那么这些不同的advice的执行逻辑有哪些不同呢？这个疑问留着后面的执行过程会进行解答，这里只需要知道<strong>我们获取的Advisor封装了advice与其切点信息</strong>。</p><h4 id="寻找适用的增强器"><a href="#寻找适用的增强器" class="headerlink" title="寻找适用的增强器"></a>寻找适用的增强器</h4><p>我们的思路回到主线，此时我们已经<strong>寻找到所有的增强器</strong>了，现在开始从中<strong>筛选</strong>出适用的增强器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">    //寻找所有适用的Advisor</span><br><span class="line">    //这一步在4.2中进行</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    //从所有Advisor中选出适合被当前Bean使用的Advisor</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时执行<strong>findAdvisorsThatCanApply</strong>方法寻找适用的增强器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; findAdvisorsThatCanApply(</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line"></span><br><span class="line">    ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">    try &#123;</span><br><span class="line">        //委派AopUtils去做</span><br><span class="line">        <span class="built_in">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        ProxyCreationContext.setCurrentProxiedBeanName(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里委派了<code>AopUtils</code>去做事情：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">return</span> candidateAdvisors;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;&gt;();</span><br><span class="line">    //遍历之前找到的所有的Advisor</span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        //在这里会优先处理引介增强，并且判断Advisor是否适合此Bean</span><br><span class="line">        <span class="keyword">if</span> (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">            //优先加入List中</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate instanceof IntroductionAdvisor) &#123;</span><br><span class="line">            // already processed</span><br><span class="line">            //已经处理过引介增强</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //剩下的Advisor再进行判断</span><br><span class="line">        <span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">            //加入List中</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回适合的Advisor List</span><br><span class="line">    <span class="built_in">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点关注<strong>canApply</strong>方法，看看是如何判断是否适合的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123;</span><br><span class="line">    <span class="keyword">if</span> (advisor instanceof IntroductionAdvisor) &#123;</span><br><span class="line">        //调用引介增强器的ClassFilter去匹配当前Bean是否适合</span><br><span class="line">        <span class="built_in">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">        //如果是普通的Advisor，转换成PointcutAdvisor</span><br><span class="line">        //PointcutAdvisor接口定义了获取切点的方法getPointcut</span><br><span class="line">        PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line">        //根据切点信息，寻找是否适合</span><br><span class="line">        <span class="built_in">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        // It doesn<span class="string">'t have a pointcut so we assume it applies.</span></span><br><span class="line"><span class="string">        //如果没有切点，就假设它适合</span></span><br><span class="line"><span class="string">        return true;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这里我们先忽略引介增强器，关注普通的Advisor。这里进入<strong>canApply</strong>方法，根据切点信息去判断是否合适：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123;</span><br><span class="line">    Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line">    //获取切点类过滤器，如果不符合直接返回<span class="literal">false</span></span><br><span class="line">    //如果符合进入下一步判断</span><br><span class="line">    <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取切点的方法匹配器</span><br><span class="line">    MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">    //如果此时methodMatcher是一个MethodMatcher.TRUE，说明匹配任何方法，直接返回<span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">        // No need to iterate the methods <span class="keyword">if</span> we’re matching any method anyway...</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;</span><br><span class="line">    <span class="keyword">if</span> (methodMatcher instanceof IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //拿到目标类的所有父类（包括接口）</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">    //包括本类</span><br><span class="line">    classes.add(targetClass);</span><br><span class="line">    //遍历父类与本类</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">        //获取本class的方法对象</span><br><span class="line">        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">        //遍历方法</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            //两个验证器只要其中一个匹配，就返回<span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> ((introductionAwareMethodMatcher != null &amp;&amp;</span><br><span class="line">                 introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||</span><br><span class="line">                methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，就<strong>完成了适用的增强器的查找</strong>，从上面我们可以知道，当一个Bean中的任何一个方法（方法<strong>包括在父类</strong>中的方法）<strong>匹配Advisor中的切点信息</strong>，就认为当前的Advisor是<strong>匹配当前Bean</strong>的，就将此时的<strong>Advisor加入此类的Advisors列表</strong>中，注意，一个Bean中是可以有多个Advisor的，如果不能理解为什么一个Bean对应多个Advisor，你应该还没有明白Advisor的概念，Advisor中包含advice与切点信息，也就是说，一个通知方法例如前置通知@Before是对应一个Advisor的，如果一个类中既有前置通知又有后置通知，那么这个类中的Advisor是会匹配两个的。</p><h4 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h4><h5 id="获取代理类型（JDK或CGLIB）"><a href="#获取代理类型（JDK或CGLIB）" class="headerlink" title="获取代理类型（JDK或CGLIB）"></a>获取代理类型（JDK或CGLIB）</h5><p>再次回到最开始的地方，还记得4.1的<strong>wrapIfNecessary</strong>方法吗？此时我们已经寻找完符合此Bean的增强器了（<strong>getAdvicesAndAdvisorsForBean</strong>方法），就像刚刚所说，如果有两个通知匹配的话，现在增强器列表应该会有两个Advisor，也就是说增强列表不为空，将进行下一步，创建代理的过程<strong>createProxy</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,</span><br><span class="line">                             @Nullable Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line">    //复制当前Creator的一些属性例如proxyTargetClass或是exposeProxy等</span><br><span class="line">    proxyFactory.copyFrom(this);</span><br><span class="line"></span><br><span class="line">    //如果proxyTargetClass是<span class="literal">false</span>才会进入判断</span><br><span class="line">    //如果proxyTargetClass是<span class="literal">true</span>就直接用CGLib代理了，不需要判断</span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        //判断是否需要代理本类</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            //也就是说，如果需要代理本类，将使用CGLib方式代理</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果不需要，则获取所有该类的接口，设置到proxyFactory对象中</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理所有得到的适用的拦截器转换成Advisor</span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    //将Advisors加入proxyFactory对象中</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    //将原本的Bean对象（原生未代理）加入proxyFactory对象中</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    //定制代理</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(this.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置好属性之后，就调用proxyFactory对象生成代理对象</span><br><span class="line">    <span class="built_in">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上过程都在给<code>proxyFactory</code>这个对象设置属性，然后调用<code>proxyFactory</code>根据设置的一些属性生成代理对象，最后执行关键的创建代理方法<strong>getProxy</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="built_in">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected final synchronized AopProxy <span class="function"><span class="title">createAopProxy</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!this.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    //使用aopProxyFactory根据本类信息创建</span><br><span class="line">    <span class="built_in">return</span> getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>aopProxyFactory</code>是在其父类的构造函数中赋值的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="function"><span class="title">ProxyCreatorSupport</span></span>() &#123;</span><br><span class="line">    this.aopProxyFactory = new DefaultAopProxyFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入其创建方法<strong>createAopProxy</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">    //判断ProxyTargetClass属性和是否有代理接口等等判断使用何种方式做代理</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == null) &#123;</span><br><span class="line">            throw new AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                                         <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="built_in">return</span> new JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> new ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> new JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意此时config对象是我们之前设置了各种信息的proxyFactory对象，在代理的构造函数中存放了这个属性，也就是说代理对象持有一个Advisor列表。</p></blockquote><p>这段代码清晰明了，主要就是在<strong>判断使用何种方式做代理</strong>：</p><ul><li>optimize：这个属性适用于CGLib，对JDK动态代理无效。主要是控制CGLib创建的代理是否使用激进的优化策略。</li><li>proxyTargetClass：文章开头也有提到，如果属性为true，将会使用CGLib进行代理。</li><li>hasNoUserSuppliedProxyInterfaces：是否存在代理接口。</li></ul><p>总结一下JDK于CGLIB如何选择：</p><ul><li>如果目标对象实现了接口，默认情况下会采用JDK代理</li><li>如果目标对象实现了接口，但可以使用proxyTargetClass属性来强制使用CGLIB代理</li><li>如果对象没用实现接口，必须使用CGLIB代理</li></ul><h5 id="获取代理"><a href="#获取代理" class="headerlink" title="获取代理"></a>获取代理</h5><p>思路回到开头获取代理的方法中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="built_in">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们完成了<strong>createAopProxy</strong>，拿到了JDK代理对象（我们这里假设用JDK做代理）接着调用其<strong>getProxy</strong>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + this.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    //拿到被代理类的接口</span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, <span class="literal">true</span>);</span><br><span class="line">    //检查上面得到的接口是否定义了equals、hashCode方法</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    //创建代理对象</span><br><span class="line">    <span class="built_in">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此时的<code>advised</code>就是我们上面所说的<code>config</code>对象也就是封装半天信息的<code>proxyFactory</code>对象，里面存有一系列信息例如<strong>Advisor、切点之类</strong>。</p><p>这里不对动态代理进行解释，如果熟悉动态代理的看到这里应该已经懂了，其将当前对象作为实现代理的主要对象。毫无疑问，当前对象一定实现了<code>InvocationHandler</code>接口，我们需要关注的即为它的<strong>invoke</strong>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    MethodInvocation invocation;</span><br><span class="line">    Object oldProxy = null;</span><br><span class="line">    boolean setProxyContext = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    //原生对象</span><br><span class="line">    TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">    Object target = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //eqauls()方法，如果目标对象未实现此方法</span><br><span class="line">        <span class="keyword">if</span> (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">            // The target does not implement the equals(Object) method itself.</span><br><span class="line">            <span class="built_in">return</span> equals(args[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        //hashCode()方法，如果目标对象未实现此方法</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">            // The target does not implement the hashCode() method itself.</span><br><span class="line">            <span class="built_in">return</span> hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">            // There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span><br><span class="line">            <span class="built_in">return</span> AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class="line">        &#125;</span><br><span class="line">        //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">                 method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">            // Service invocations on ProxyConfig with the proxy config...</span><br><span class="line">            <span class="built_in">return</span> AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line"></span><br><span class="line">        //这里就是先前提到的如果exposeProxy属性为<span class="literal">true</span>，将会暴露一个proxy代理对象</span><br><span class="line">        //给AOP上下文对象，存在线程变量中</span><br><span class="line">        <span class="keyword">if</span> (this.advised.exposeProxy) &#123;</span><br><span class="line">            // Make invocation available <span class="keyword">if</span> necessary.</span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Get as late as possible to minimize the time we <span class="string">"own"</span> the target,</span><br><span class="line">        // <span class="keyword">in</span> <span class="keyword">case</span> it comes from a pool.</span><br><span class="line">        //获得目标对象的类</span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);</span><br><span class="line"></span><br><span class="line">        // Get the interception chain <span class="keyword">for</span> this method.</span><br><span class="line">        //获取可以应用到此方法上的Interceptor列表</span><br><span class="line">        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">        // Check whether we have any advice. If we don’t, we can fallback on direct</span><br><span class="line">        // reflective invocation of the target, and avoid creating a MethodInvocation.</span><br><span class="line">        //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">            // We can skip creating a MethodInvocation: just invoke the target directly</span><br><span class="line">            // Note that the final invoker must be an InvokerInterceptor so we know it does</span><br><span class="line">            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            // We need to create a method invocation...</span><br><span class="line">            //走到这里，说明该方法符合被通知的条件，创建MethodInvocation</span><br><span class="line">            //执行其proceed方法</span><br><span class="line">            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            // Proceed to the joinpoint through the interceptor chain.</span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Massage <span class="built_in">return</span> value <span class="keyword">if</span> necessary.</span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != null &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">            returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">            // Special <span class="keyword">case</span>: it returned <span class="string">"this"</span> and the <span class="built_in">return</span> <span class="built_in">type</span> of the method</span><br><span class="line">            // is <span class="built_in">type</span>-compatible. Note that we can<span class="string">'t help if the target sets</span></span><br><span class="line"><span class="string">            // a reference to itself in another returned object.</span></span><br><span class="line"><span class="string">            retVal = proxy;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span></span><br><span class="line"><span class="string">            throw new AopInvocationException(</span></span><br><span class="line"><span class="string">                "Null return value from advice does not match primitive return type for: " + method);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return retVal;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    finally &#123;</span></span><br><span class="line"><span class="string">        if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span></span><br><span class="line"><span class="string">            // Must have come from TargetSource.</span></span><br><span class="line"><span class="string">            targetSource.releaseTarget(target);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if (setProxyContext) &#123;</span></span><br><span class="line"><span class="string">            // Restore old proxy.</span></span><br><span class="line"><span class="string">            AopContext.setCurrentProxy(oldProxy);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>也就是说，每次调用代理对象的方法，将执行以下步骤：</p><ol><li><strong>判断是否是equals或hashCode或Advised的方法</strong>：如果是执行对应判断。</li><li><strong>判断是否需要暴露代理对象</strong>（将代理对象存入AopContext）：在文章开头就有提到这个属性，还是之前的例子，在A方法中调用B方法，此时B方法其实是原生对象的B方法，但如果B方法需要被AOP，需要执行的是代理对象的B方法，而不是原生对象的B方法，原生对象的B方法是没有被代理AOP的。所以这里需要暴露出代理对象，从AopContext上下文中取出代理对象，将其强转成对应类，执行B方法，此时的B方法即可是被AOP的方法了。值得一提的是AopContext暴露出来的代理对象是线程变量。</li><li><strong>获取当前方法对应的拦截器链</strong>：主要是使用<code>advised</code>去对当前方法进行判断<strong>是否符合切点</strong>如果符合取出对应需要执行的链。如果此时<strong>链为空</strong>，代表执行的该方法是<strong>不需要被AOP</strong>的，正常反射执行即可，如果<strong>链不为空</strong>，将链封装成<code>ReflectiveMethodInvocation</code>对象执行其<strong>proceed</strong>方法，该对象的该方法是执行AOP的核心，下面详细讲解。</li></ol><h4 id="执行AOP通知"><a href="#执行AOP通知" class="headerlink" title="执行AOP通知"></a>执行AOP通知</h4><p>到此我们创建好了代理对象，并<strong>返回出去作为一个Bean存放在IOC容器中</strong>，当我们取出此Bean并执行方法时，如果碰到了需要被AOP的方法时，会找到一个<strong>拦截器链</strong>，然后将其传入<code>ReflectiveMethodInvocation</code>对象封装，接着不会执行原方法而是执行其<strong>proceed</strong>方法，所以该方法是执行AOP通知的核心方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//此属性默认为-1</span><br><span class="line">private int currentInterceptorIndex = -1;</span><br><span class="line"></span><br><span class="line">//存放interceptors的列表</span><br><span class="line">protected final List&lt;?&gt; interceptorsAndDynamicMethodMatchers;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">    //  We start with an index of -1 and increment early.</span><br><span class="line">    //如果Interceptor执行完了，则执行joinPoint</span><br><span class="line">    <span class="keyword">if</span> (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">        <span class="built_in">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据游标获取对应的Advice</span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">    //如果要动态匹配joinPoint</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        // Evaluate dynamic method matcher here: static part will already have</span><br><span class="line">        // been evaluated and found to match.</span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        //动态匹配：运行时参数是否满足匹配条件</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123;</span><br><span class="line">            <span class="built_in">return</span> dm.interceptor.invoke(this);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            // Dynamic matching failed.</span><br><span class="line">            // Skip this interceptor and invoke the next <span class="keyword">in</span> the chain.</span><br><span class="line">            //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor</span><br><span class="line">            <span class="built_in">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        // It’s an interceptor, so we just invoke it: The pointcut will have</span><br><span class="line">        // been evaluated statically before this object was constructed.</span><br><span class="line">        //执行当前IntercetporAdvice</span><br><span class="line">        //注意此时传了this对象，是为了执行链的保持</span><br><span class="line">        <span class="built_in">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，需要解释几点：</p><ol><li><p><strong>如何判断执行结束？在开头我们说到currentInterceptorIndex</strong>属性是为-1的，<strong>interceptorsAndDynamicMethodMatchers</strong>的size是执行链的数量，刚进来的时候执行链一定大于等于1，所以其减1也不会等于-1，不会执行<strong>invokeJoinpoint</strong>方法，走到下面执行这样一行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line">        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br></pre></td></tr></table></figure><p>注意此时<strong>currentInterceptorIndex</strong>游标变成了0，也就是取执行链的第一个执行器取执行，同时游标变成0。下面会执行Advice的<strong>invoke</strong>方法，这里举例Before类型的Advice的<strong>invoke</strong>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">    this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</span><br><span class="line">    <span class="built_in">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此时<code>mi对象</code>就是上面传进来的<code>this</code>，也就是<code>ReflectiveMethodInvocation</code>对象，他在通知方法执行完成之后，又执行了<code>ReflectiveMethodInvocation</code>的<strong>proceed</strong>方法，然后第二次进入<strong>proceed</strong>时，游标已经变成了0，我们假设此时拦截器数量为一个，那么此时<strong>currentInterceptorIndex=0,interceptorsAndDynamicMethodMatchers.size() - 1 = 0：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">    <span class="built_in">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将中止执行下面的内容，直接执行<strong>invokeJoinpoint</strong>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">protected Object invokeJoinpoint() throws Throwable &#123;</span><br><span class="line">    <span class="built_in">return</span> AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里底层就是<strong>通过反射执行原方法</strong>，到此结束，也就是说其<strong>利用游标索引与循环调用proceed方法来判断当前执行链的结束</strong>，真是个聪明的方法。</p></li><li><p><strong>为什么@Before的Advice的invoke可以实现前置通知效果，同样的@After如何实现后置通知效果？在这里我们将补上上面没有详细讲解的一些Advice类 。</strong><br>1) <code>MethodBeforeAdviceInterceptor</code>前置通知：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private MethodBeforeAdvice advice;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">   * Create a new MethodBeforeAdviceInterceptor <span class="keyword">for</span> the given advice.</span><br><span class="line">   * @param advice the MethodBeforeAdvice to wrap</span><br><span class="line">   */</span><br><span class="line">    //构造器初始化保存了advice对象</span><br><span class="line">    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123;</span><br><span class="line">        Assert.notNull(advice, <span class="string">"Advice must not be null"</span>);</span><br><span class="line">        this.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</span><br><span class="line">        <span class="built_in">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)<code>AfterReturningAdviceInterceptor</code>后置通知：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private final AfterReturningAdvice advice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">   * Create a new AfterReturningAdviceInterceptor <span class="keyword">for</span> the given advice.</span><br><span class="line">   * @param advice the AfterReturningAdvice to wrap</span><br><span class="line">   */</span><br><span class="line">    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) &#123;</span><br><span class="line">        Assert.notNull(advice, <span class="string">"Advice must not be null"</span>);</span><br><span class="line">        this.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">        Object retVal = mi.proceed();</span><br><span class="line">        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">        <span class="built_in">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面两个不同的<code>Advice</code>可以看出，其<strong>invoke</strong>方法的逻辑只是<strong>顺序不同</strong>而已，但为什么可以达到前置后置通知的呢？其实前置通知很好理解，在invoke的逻辑中只要<strong>先执行我们指定的前置通知逻辑</strong>，然后<strong>继续往下执行proceed</strong>即可实现在执行原方法前加一段逻辑的功能，我们主要分析后置通知是如何实现的。还是进行一个假设，此时该方法<strong>只有一个执行链后置通知@After</strong>，那么刚开始进入proceed方法时，获取这个Advice执行invoke方法，然后<strong>又去执行proceed方法</strong>了，由上面的分析此时的游标显示执行链已经执行完毕，所以此时会<strong>直接反射执行原方法</strong>，然后<strong>proceed方法执行完毕</strong>，最后将会执行后置通知Advice的invoke方法的下一步，<strong>advice.afterReturning</strong>，也就是用户<strong>自定义的后置方法逻辑</strong>，实现了在方法最后插入一段代码逻辑的功能，如果是多个通知例如前置后置都有的话，留给读者思考，相信懂得以上逻辑之后推敲起来并不是很难。</p></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里为止，我们分析了AOP是从<strong>自定义标签开始</strong>，自定义标签注册了一个<code>Creator</code>类，而此<code>Creator</code>类是一个<code>BeanPostProcessor</code>，也就是说每个Bean都将调用Creator实现的方法。</p><p>来到了<strong>如何实现AOP代理的分析</strong>中，在此方法中判断Bean是否需要被代理，然后进一步判断此Bean是否可以获得增强器，在这个过程中会去拿所有的Advisor，然后在所有的Advisor列表中筛选出适用的增强器，如果适用的增强器Advisor为空证明此Bean不用被代理，如果不为空则会进入创建代理的流程。</p><p>所以我们开始分析<strong>创建代理是怎样的过程</strong> ，在什么情况下会进行JDK动态代理，在什么情况下会进行CGLIB动态代理，然后创建代理结束之后。</p><p>必不可少的也需要分析是<strong>如何执行AOP通知</strong>的，其核心类是<code>ReflectiveMethodInvocation</code>的<strong>proceed</strong>方法，轮询执行拦截器，并且不同的Advice根据其特有的逻辑执行调用顺序，来完成AOP通知的功能。</p>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架 - Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架——深入剖析核心IoC源码</title>
    <link href="/2018/10/30/Spring-2/"/>
    <url>/2018/10/30/Spring-2/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/spring_logo.jpg" srcset="/img/loading.gif" alt="Spring"></p><p>原文转自：<a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">https://javadoop.com/post/spring-ioc</a></p><p>因为有幸看到这篇让我读了约三个半小时的文章，简直价值千金，所以稍作修改，以此记录。<br>为了保持文章的严谨性，如有错误，望及时指出，十分希望听到读者的声音。</p><hr><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>先看下最基本的启动 Spring 容器的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"classpath:Application.xml"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p></blockquote><p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。<br>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code>其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext 。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：<br><img src="/images/spring-ioc1.png" srcset="/img/loading.gif" alt="spring"></p><blockquote><p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。<br>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p></blockquote><p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的<br><strong>FileSystemXmlApplicationContext</strong>和<strong>AnnotationConfigApplicationContext</strong>这两个类。</p><ol><li><p><strong>FileSystemXmlApplicationContext</strong>的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p></li><li><p><strong>AnnotationConfigApplicationContext</strong>是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p></li></ol><p>不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p><p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p><p>首先，定义一个接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageService &#123;</span><br><span class="line">    String getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义接口实现类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MessageServiceImpl implements MessageService &#123;</span><br><span class="line">    public String <span class="function"><span class="title">getMessage</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 Application.xml 或 Application-xxx.xml 就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span> default-autowire=<span class="string">"byName"</span>&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"messageService"</span> class=<span class="string">"com.loonycoder.service.MessageServiceImpl"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>这样，我们就可以跑起来了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 用我们的配置文件来启动一个 ApplicationContext</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"classpath:Application.xml"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"context 启动成功"</span>);</span><br><span class="line"></span><br><span class="line">        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span><br><span class="line">        MessageService messageService = context.getBean(MessageService.class);</span><br><span class="line">        // 这句将输出: hello world</span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p><hr><h3 id="BeanFactory-简介"><a href="#BeanFactory-简介" class="headerlink" title="BeanFactory 简介"></a>BeanFactory 简介</h3><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p><p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：<br><img src="/images/spring-ioc2.png" srcset="/img/loading.gif" alt="spring"><br>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p><ul><li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li><li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li><li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li><li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li><li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。<br>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</li></ul><hr><h3 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h3><p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p><p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123;</span><br><span class="line">  private Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span><br><span class="line">  public ClassPathXmlApplicationContext(ApplicationContext parent) &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</span><br><span class="line">      throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">    super(parent);</span><br><span class="line">    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); // 核心方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p><p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class="line">      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class="line">      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class="line">      // 这块待会会展开说</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class="line">         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class="line"></span><br><span class="line">         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class="line">         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class="line">         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class="line">         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         // 从方法名就可以知道，典型的模板方法(钩子方法)，</span><br><span class="line">         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         // 重点，重点，重点</span><br><span class="line">         // 初始化所有的 singleton beans</span><br><span class="line">         //（lazy-init 的除外）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 最后，广播事件，ApplicationContext 初始化完成</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         // Reset <span class="string">'active'</span> flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         // 把异常往外抛</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         // Reset common introspection caches <span class="keyword">in</span> Spring<span class="string">'s core, since we</span></span><br><span class="line"><span class="string">         // might not ever need metadata for singleton beans anymore...</span></span><br><span class="line"><span class="string">         resetCommonCaches();</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>下面，我们开始一步步来肢解这个 refresh() 方法。</p><hr><h4 id="创建-Bean-容器，加载并注册-Bean"><a href="#创建-Bean-容器，加载并注册-Bean" class="headerlink" title="创建 Bean 容器，加载并注册 Bean"></a>创建 Bean 容器，加载并注册 Bean</h4><p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p><p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p><p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p><p>// AbstractApplicationContext.java</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory <span class="function"><span class="title">obtainFreshBeanFactory</span></span>() &#123;</span><br><span class="line">   // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   // 返回刚刚创建的 BeanFactory</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractRefreshableApplicationContext.java 120</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">   // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span><br><span class="line">   // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span><br><span class="line">   // ApplicationContext 是否有 BeanFactory</span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">      // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      // 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">      // 下面这两个方法很重要，别跟丢了，具体细节之后说</span><br><span class="line">      // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      // 加载 Bean 到 BeanFactory 中</span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">         this.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (IOException ex) &#123;</span><br><span class="line">      throw new ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p></blockquote><p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：<br><img src="/images/spring-ioc2.png" srcset="/img/loading.gif" alt="spring"></p><p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p><blockquote><p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？<br>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。<br>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。</p></blockquote><p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p><p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p><p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p><blockquote><p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p></blockquote><p><strong>BeanDefinition 接口定义</strong><br>我们来看下 BeanDefinition 的接口定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   // 我们可以看到，默认只提供 sington 和 prototype 两种，</span><br><span class="line">   // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span><br><span class="line">   // 不过，它们属于基于 web 的扩展。</span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   // 比较不重要，直接跳过吧</span><br><span class="line">   int ROLE_APPLICATION = 0;</span><br><span class="line">   int ROLE_SUPPORT = 1;</span><br><span class="line">   int ROLE_INFRASTRUCTURE = 2;</span><br><span class="line"></span><br><span class="line">   // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span><br><span class="line">   // 一句话就是：继承父 Bean 的配置信息而已</span><br><span class="line">   void setParentName(String parentName);</span><br><span class="line"></span><br><span class="line">   // 获取父 Bean</span><br><span class="line">   String getParentName();</span><br><span class="line"></span><br><span class="line">   // 设置 Bean 的类名称，将来是要通过反射来生成实例的</span><br><span class="line">   void setBeanClassName(String beanClassName);</span><br><span class="line"></span><br><span class="line">   // 获取 Bean 的类名称</span><br><span class="line">   String getBeanClassName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   // 设置 bean 的 scope</span><br><span class="line">   void setScope(String scope);</span><br><span class="line"></span><br><span class="line">   String getScope();</span><br><span class="line"></span><br><span class="line">   // 设置是否懒加载</span><br><span class="line">   void setLazyInit(boolean lazyInit);</span><br><span class="line"></span><br><span class="line">   boolean isLazyInit();</span><br><span class="line"></span><br><span class="line">   // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span><br><span class="line">   // 是 depends-on=<span class="string">""</span> 属性设置的值。</span><br><span class="line">   void setDependsOn(String... dependsOn);</span><br><span class="line"></span><br><span class="line">   // 返回该 Bean 的所有依赖</span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span><br><span class="line">   // 如果根据名称注入，即使这边设置了 <span class="literal">false</span>，也是可以的</span><br><span class="line">   void setAutowireCandidate(boolean autowireCandidate);</span><br><span class="line"></span><br><span class="line">   // 该 Bean 是否可以注入到其他 Bean 中</span><br><span class="line">   boolean isAutowireCandidate();</span><br><span class="line"></span><br><span class="line">   // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 <span class="literal">true</span> 的 bean</span><br><span class="line">   void setPrimary(boolean primary);</span><br><span class="line"></span><br><span class="line">   // 是否是 primary 的</span><br><span class="line">   boolean isPrimary();</span><br><span class="line"></span><br><span class="line">   // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span><br><span class="line">   // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span><br><span class="line">   void setFactoryBeanName(String factoryBeanName);</span><br><span class="line">   // 获取工厂名称</span><br><span class="line">   String getFactoryBeanName();</span><br><span class="line">   // 指定工厂类中的 工厂方法名称</span><br><span class="line">   void setFactoryMethodName(String factoryMethodName);</span><br><span class="line">   // 获取工厂类中的 工厂方法名称</span><br><span class="line">   String getFactoryMethodName();</span><br><span class="line"></span><br><span class="line">   // 构造器参数</span><br><span class="line">   ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class="line"></span><br><span class="line">   // Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span><br><span class="line">   MutablePropertyValues getPropertyValues();</span><br><span class="line"></span><br><span class="line">   // 是否 singleton</span><br><span class="line">   boolean isSingleton();</span><br><span class="line"></span><br><span class="line">   // 是否 prototype</span><br><span class="line">   boolean isPrototype();</span><br><span class="line"></span><br><span class="line">   // 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span><br><span class="line">   // 常用于作为 父bean 用于继承，其实也很少用......</span><br><span class="line">   boolean isAbstract();</span><br><span class="line"></span><br><span class="line">   int getRole();</span><br><span class="line">   String getDescription();</span><br><span class="line">   String getResourceDescription();</span><br><span class="line">   BeanDefinition getOriginatingBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。<br>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p></blockquote><p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br></pre></td></tr></table></figure><p>虽然只有两个方法，但路还很长啊。。。</p><p><strong>customizeBeanFactory</strong></p><p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">   <span class="keyword">if</span> (this.allowBeanDefinitionOverriding != null) &#123;</span><br><span class="line">      // 是否允许 Bean 定义覆盖</span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (this.allowCircularReferences != null) &#123;</span><br><span class="line">      // 是否允许 Bean 间的循环依赖</span><br><span class="line">      beanFactory.setAllowCircularReferences(this.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p><p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p><p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p><p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p><p><strong>加载Bean:loadBeanDefinitions</strong></p><p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p><p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p><p>// AbstractXmlApplicationContext.java 80</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span><br><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">   // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">   // Configure the bean definition reader with this context<span class="string">'s</span></span><br><span class="line"><span class="string">   // resource loading environment.</span></span><br><span class="line"><span class="string">   beanDefinitionReader.setEnvironment(this.getEnvironment());</span></span><br><span class="line"><span class="string">   beanDefinitionReader.setResourceLoader(this);</span></span><br><span class="line"><span class="string">   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span></span><br><span class="line"><span class="string">   // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span></span><br><span class="line"><span class="string">   initBeanDefinitionReader(beanDefinitionReader);</span></span><br><span class="line"><span class="string">   // 重点来了，继续往下</span></span><br><span class="line"><span class="string">   loadBeanDefinitions(beanDefinitionReader);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p><p>// AbstractXmlApplicationContext.java 120</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != null) &#123;</span><br><span class="line">      // 往下看</span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != null) &#123;</span><br><span class="line">      // 2</span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">   int counter = 0;</span><br><span class="line">   // 注意这里是个 <span class="keyword">for</span> 循环，也就是每个文件是一个 resource</span><br><span class="line">   <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      // 继续往下看</span><br><span class="line">      counter += loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   // 最后返回 counter，表示总共加载了多少的 BeanDefinition</span><br><span class="line">   <span class="built_in">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// XmlBeanDefinitionReader 303</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="built_in">return</span> loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// XmlBeanDefinitionReader 314</span><br><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">   &#125;</span><br><span class="line">   // 用一个 ThreadLocal 来存放配置文件资源</span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == null) &#123;</span><br><span class="line">      currentResources = new HashSet&lt;EncodedResource&gt;(4);</span><br><span class="line">      this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      throw new BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">      InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">      try &#123;</span><br><span class="line">         InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         // 核心部分是这里，往下面看</span><br><span class="line">         <span class="built_in">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      finally &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (IOException ex) &#123;</span><br><span class="line">      throw new BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">         this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 还在这个文件中，第 388 行</span><br><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      // 这里就不看了，将 xml 文件转换为 Document 对象</span><br><span class="line">      Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">      // 继续</span><br><span class="line">      <span class="built_in">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (...</span><br><span class="line">&#125;</span><br><span class="line">// 还在这个文件中，第 505 行</span><br><span class="line">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">   int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">   // 这里</span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="built_in">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line">// DefaultBeanDefinitionDocumentReader 90</span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">   this.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">   Element root = doc.getDocumentElement();</span><br><span class="line">   // 从 xml 根节点开始解析文件</span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p><p><strong>doRegisterBeanDefinitions：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// DefaultBeanDefinitionDocumentReader 116</span><br><span class="line">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">   // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，</span><br><span class="line">   // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，</span><br><span class="line">   // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了</span><br><span class="line">   BeanDefinitionParserDelegate parent = this.delegate;</span><br><span class="line">   this.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      // 这块说的是根节点 &lt;beans ... profile=<span class="string">"dev"</span> /&gt; 中的 profile 是否是当前环境需要的，</span><br><span class="line">      // 如果当前环境配置的 profile 不包含此 profile，那就直接 <span class="built_in">return</span> 了，不对此 &lt;beans /&gt; 解析</span><br><span class="line">      // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区</span><br><span class="line">      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">         <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line">                     <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   preProcessXml(root); // 钩子</span><br><span class="line">   // 往下看</span><br><span class="line">   parseBeanDefinitions(root, this.delegate);</span><br><span class="line">   postProcessXml(root); // 钩子</span><br><span class="line"></span><br><span class="line">   this.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p><p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p><p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;<span class="built_in">alias</span> /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span><br><span class="line">// 其他的属于 custom 的</span><br><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node instanceof Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               // 解析 default namespace 下面的几个元素</span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               // 解析其他 namespace 的元素</span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p><p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt;、&lt;beans /&gt;</code>这几个。</p><blockquote><p>这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.springframework.org/schema/beans </span><br></pre></td></tr></table></figure><p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 xmlns 就是咯。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">      xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">      xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">         http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span><br><span class="line">      default-autowire=<span class="string">"byName"</span>&gt; </span><br></pre></td></tr></table></figure><p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code> &lt;mvc /&gt;、&lt;task /&gt;、&lt;context /&gt;、&lt;aop /&gt;</code>等。<br>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。<br>假如读者想分析 <code>&lt;context:property-placeholder location="classpath:xx.properties" /&gt;</code>的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">     xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">     xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">     xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">     xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">          http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">          http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">          http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">          http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">          http://www.springframework.org/schema/mvc   </span></span><br><span class="line"><span class="string">          http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span></span><br><span class="line"><span class="string">      "</span></span><br><span class="line">     default-autowire=<span class="string">"byName"</span>&gt;</span><br><span class="line">   &lt;/bean&gt; </span><br></pre></td></tr></table></figure><p>同理，以后你要是碰到 <code>&lt;<dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。<br>回过神来，看看处理 default 标签的方法：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      // 处理 &lt;import /&gt; 标签</span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      // 处理 &lt;<span class="built_in">alias</span> /&gt; 标签定义</span><br><span class="line">      // &lt;<span class="built_in">alias</span> name=<span class="string">"fromName"</span> <span class="built_in">alias</span>=<span class="string">"toName"</span>/&gt;</span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧</span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <bean /> 标签出来说。</p><p><strong>processBeanDefinition 解析 bean 标签</strong><br>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p><p>// DefaultBeanDefinitionDocumentReader 298</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看</span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"></span><br><span class="line">   // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bdHolder != null) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      try &#123;</span><br><span class="line">         // Register the final decorated instance.</span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      // Send registration event.</span><br><span class="line">      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看怎么解析之前，我们先看下 <code>&lt;bean /&gt;</code> 标签中可以定义哪些属性：</p><table><thead><tr><th align="center">Property</th><th align="center"></th></tr></thead><tbody><tr><td align="center">class</td><td align="center">类的全限定名</td></tr><tr><td align="center">name</td><td align="center">可指定 id、name(用逗号、分号、空格分隔)</td></tr><tr><td align="center">scope</td><td align="center">作用域</td></tr><tr><td align="center">constructor arguments</td><td align="center">指定构造参数</td></tr><tr><td align="center">properties</td><td align="center">设置属性的值</td></tr><tr><td align="center">autowiring mode</td><td align="center">no(默认值)、byName、byType、 constructor</td></tr><tr><td align="center">lazy-initialization mode</td><td align="center">是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td></tr><tr><td align="center">initialization method</td><td align="center">bean 属性设置完成后，会调用这个方法</td></tr><tr><td align="center">destruction method</td><td align="center">bean 销毁后的回调方法</td></tr></tbody></table><p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p><p>简单地说就是像下面这样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"exampleBean"</span> name=<span class="string">"name1, name2, name3"</span> class=<span class="string">"com.loonycoder.ExampleBean"</span></span><br><span class="line">      scope=<span class="string">"singleton"</span> lazy-init=<span class="string">"true"</span> init-method=<span class="string">"init"</span> destroy-method=<span class="string">"cleanup"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 可以用下面三种形式指定构造参数 --&gt;</span><br><span class="line">    &lt;constructor-arg <span class="built_in">type</span>=<span class="string">"int"</span> value=<span class="string">"7500000"</span>/&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">"years"</span> value=<span class="string">"7500000"</span>/&gt;</span><br><span class="line">    &lt;constructor-arg index=<span class="string">"0"</span> value=<span class="string">"7500000"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- property 的几种情况 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"beanOne"</span>&gt;</span><br><span class="line">        &lt;ref bean=<span class="string">"anotherExampleBean"</span>/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"beanTwo"</span> ref=<span class="string">"yetAnotherBean"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"integerProperty"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;、&lt;replaced-method /&gt;、&lt;meta /&gt;、&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p><p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p><p>// BeanDefinitionParserDelegate 428</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">    <span class="built_in">return</span> parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class="line">   String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">   // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span><br><span class="line">   // 当然，如果你不定义 name 属性的话，就是空的了</span><br><span class="line">   // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String beanName = id;</span><br><span class="line">   // 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(0);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">               <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (containingBean == null) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span><br><span class="line">   // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。</span><br><span class="line">   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line">   // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != null) &#123;</span><br><span class="line">      // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span><br><span class="line">      // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            <span class="keyword">if</span> (containingBean != null) &#123;// 按照我们的思路，这里 containingBean 是 null 的</span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, this.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               // 如果我们不定义 id 和 name，那么我们引言里的那个例子：</span><br><span class="line">               //   1. beanName 为：com.loonycoder.service.MessageServiceImpl<span class="comment">#0</span></span><br><span class="line">               //   2. beanClassName 为：com.loonycoder.service.MessageServiceImpl</span><br><span class="line"></span><br><span class="line">               beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"></span><br><span class="line">               String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != null &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  // 把 beanClassName 设置为 Bean 的别名</span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                     <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      // 返回 BeanDefinitionHolder</span><br><span class="line">      <span class="built_in">return</span> new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">      Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line"></span><br><span class="line">   this.parseState.push(new BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">   String className = null;</span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      String parent = null;</span><br><span class="line">      <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">         parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">      &#125;</span><br><span class="line">      // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span><br><span class="line">      AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">      // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span><br><span class="line">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span><br><span class="line">       * 解析出来以后的信息都放到 bd 的属性中</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      // 解析 &lt;meta /&gt;</span><br><span class="line">      parseMetaElements(ele, bd);</span><br><span class="line">      // 解析 &lt;lookup-method /&gt;</span><br><span class="line">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">      // 解析 &lt;replaced-method /&gt;</span><br><span class="line">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    // 解析 &lt;constructor-arg /&gt;</span><br><span class="line">      parseConstructorArgElements(ele, bd);</span><br><span class="line">      // 解析 &lt;property /&gt;</span><br><span class="line">      parsePropertyElements(ele, bd);</span><br><span class="line">      // 解析 &lt;qualifier /&gt;</span><br><span class="line">      parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">      bd.setResource(this.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">      <span class="built_in">return</span> bd;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (ClassNotFoundException ex) &#123;</span><br><span class="line">      error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (NoClassDefFoundError err) &#123;</span><br><span class="line">      error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">      this.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p><p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   <span class="keyword">if</span> (bdHolder != null) &#123;</span><br><span class="line">      // 如果有自定义属性的话，进行相应的解析，先忽略</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      try &#123;</span><br><span class="line">         // 我们把这步叫做 注册Bean 吧</span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      // 注册完成后，发送事件，本文不展开说这个</span><br><span class="line">      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDefinitionHolder implements BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">  private final BeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line">  private final String beanName;</span><br><span class="line"></span><br><span class="line">  private final String[] aliases;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p><p>下面，我们开始说说注册 Bean 吧。</p><p><strong>注册 Bean</strong><br>// BeanDefinitionReaderUtils 143</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanDefinition(</span><br><span class="line">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   // 注册这个 Bean</span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != null) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String <span class="built_in">alias</span> : aliases) &#123;</span><br><span class="line">         // <span class="built_in">alias</span> -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span><br><span class="line">         // 获取的时候，会先将 <span class="built_in">alias</span> 转换为 beanName，然后再查找</span><br><span class="line">         registry.registerAlias(beanName, <span class="built_in">alias</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p><p>// DefaultListableBeanFactory 793</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">   Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         throw new BeanDefinitionStoreException(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">   // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span><br><span class="line">   oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">   // 处理重复名称的 Bean 定义的情况</span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != null) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         // 如果不允许覆盖的话，抛异常</span><br><span class="line">         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         // <span class="built_in">log</span>...用框架定义的 Bean 覆盖用户自定义的 Bean </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         // <span class="built_in">log</span>...用新的 Bean 覆盖旧的 Bean</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         // <span class="built_in">log</span>...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 <span class="literal">true</span> 的 Bean</span><br><span class="line">      &#125;</span><br><span class="line">      // 覆盖</span><br><span class="line">      this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      // 判断是否已经有其他的 Bean 开始初始化了.</span><br><span class="line">      // 注意，<span class="string">"注册Bean"</span> 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span><br><span class="line">      // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span><br><span class="line">      <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">         // Cannot modify startup-time collection elements anymore (<span class="keyword">for</span> stable iteration)</span><br><span class="line">         synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">            this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">            updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            this.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            <span class="keyword">if</span> (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               this.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         // 最正常的应该是进到这个分支。</span><br><span class="line"></span><br><span class="line">         // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span><br><span class="line">         this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span><br><span class="line">         this.beanDefinitionNames.add(beanName);</span><br><span class="line">         // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span><br><span class="line">         // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span><br><span class="line">         // 手动指的是通过调用以下方法注册的 bean ：</span><br><span class="line">         //     registerSingleton(String beanName, Object singletonObject)</span><br><span class="line">         // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面<span class="string">"手动"</span>注册一些 Bean，</span><br><span class="line">         // 如 <span class="string">"environment"</span>、<span class="string">"systemProperties"</span> 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span><br><span class="line">         this.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      // 这个不重要，在预初始化的时候会用到，不必管它。</span><br><span class="line">      this.frozenBeanDefinitionNames = null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != null || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p><p>——— 分割线 ———</p><p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p><h4 id="Bean-容器实例化完成后"><a href="#Bean-容器实例化完成后" class="headerlink" title="Bean 容器实例化完成后"></a>Bean 容器实例化完成后</h4><p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p><p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class="line">      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class="line">      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class="line">      // 这块待会会展开说</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class="line">         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class="line"></span><br><span class="line">         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class="line">         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class="line">         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class="line">         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span><br><span class="line">         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         // 重点，重点，重点</span><br><span class="line">         // 初始化所有的 singleton beans</span><br><span class="line">         //（lazy-init 的除外）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         // 最后，广播事件，ApplicationContext 初始化完成，不展开</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         // Reset <span class="string">'active'</span> flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         // 把异常往外抛</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         // Reset common introspection caches <span class="keyword">in</span> Spring<span class="string">'s core, since we</span></span><br><span class="line"><span class="string">         // might not ever need metadata for singleton beans anymore...</span></span><br><span class="line"><span class="string">         resetCommonCaches();</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h4><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p><p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Configure the factory<span class="string">'s standard context characteristics,</span></span><br><span class="line"><span class="string"> * such as the context'</span>s ClassLoader and post-processors.</span><br><span class="line"> * @param beanFactory the BeanFactory to configure</span><br><span class="line"> */</span><br><span class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">   // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span><br><span class="line">   // 这里设置为加载当前 ApplicationContext 类的类加载器</span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line">   // 设置 BeanExpressionResolver</span><br><span class="line">   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">   // </span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   // 添加一个 BeanPostProcessor，这个 processor 比较简单：</span><br><span class="line">   // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span><br><span class="line">   // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span><br><span class="line">   // 注意：它不仅仅回调 ApplicationContextAware，</span><br><span class="line">   //   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line"></span><br><span class="line">   // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span><br><span class="line">   // Spring 会通过其他方式来处理这些依赖。</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span><br><span class="line">    * 之前我们说过，<span class="string">"当前 ApplicationContext 持有一个 BeanFactory"</span>，这里解释了第一行。</span><br><span class="line">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span><br><span class="line">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span><br><span class="line">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span><br><span class="line">    */</span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line"></span><br><span class="line">   // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span><br><span class="line">   // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line"></span><br><span class="line">   // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span><br><span class="line">   // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      // Set a temporary ClassLoader <span class="keyword">for</span> <span class="built_in">type</span> matching.</span><br><span class="line">      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 从下面几行代码我们可以知道，Spring 往往很 <span class="string">"智能"</span> 就是因为它会帮我们默认注册一些有用的 bean，</span><br><span class="line">    * 我们也可以选择覆盖</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   // 如果没有定义 <span class="string">"environment"</span> 这个 bean，那么 Spring 会 <span class="string">"手动"</span> 注册一个</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   // 如果没有定义 <span class="string">"systemProperties"</span> 这个 bean，那么 Spring 会 <span class="string">"手动"</span> 注册一个</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   // 如果没有定义 <span class="string">"systemEnvironment"</span> 这个 bean，那么 Spring 会 <span class="string">"手动"</span> 注册一个</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p><h4 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h4><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p><p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p><p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p><p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。<br>// AbstractApplicationContext.java 834</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 初始化剩余的 singleton beans</span><br><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line"></span><br><span class="line">   // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span><br><span class="line">   // 什么，看代码这里没有初始化 Bean 啊！</span><br><span class="line">   // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Register a default embedded value resolver <span class="keyword">if</span> no bean post-processor</span><br><span class="line">   // (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">   // at this point, primarily <span class="keyword">for</span> resolution <span class="keyword">in</span> annotation attribute values.</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(new <span class="function"><span class="title">StringValueResolver</span></span>() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public String resolveStringValue(String strVal) &#123;</span><br><span class="line">            <span class="built_in">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 先初始化 LoadTimeWeaverAware 类型的 Bean</span><br><span class="line">   // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Stop using the temporary ClassLoader <span class="keyword">for</span> <span class="built_in">type</span> matching.</span><br><span class="line">   beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">   // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span><br><span class="line">   // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   // 开始初始化</span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p><p><strong>preInstantiateSingletons</strong><br>// DefaultListableBeanFactory 728</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">   <span class="keyword">if</span> (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">      this.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + this);</span><br><span class="line">   &#125;</span><br><span class="line">   // this.beanDefinitionNames 保存了所有的 beanNames</span><br><span class="line">   List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"></span><br><span class="line">      // 合并父 Bean 中的配置，注意 &lt;bean id=<span class="string">""</span> class=<span class="string">""</span> parent=<span class="string">""</span> /&gt; 中的 parent，用的不多吧，</span><br><span class="line">      // 考虑到这可能会影响大家的理解，我在附录中解释了一下 <span class="string">"Bean 继承"</span>，不了解的请到附录中看一下</span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">      // 非抽象、非懒加载的 singletons。如果配置了 <span class="string">'abstract = true'</span>，那是不需要初始化的</span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span><br><span class="line">            final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span><br><span class="line">            boolean isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">               isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public Boolean <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                     <span class="built_in">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line"></span><br><span class="line">               getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span><br><span class="line">   // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public Object <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                  <span class="built_in">return</span> null;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p><p><strong>getBean</strong><br>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p><p>// AbstractBeanFactory 196</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">   <span class="built_in">return</span> doGetBean(name, null, null, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span><br><span class="line">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span><br><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">protected &lt;T&gt; T doGetBean(</span><br><span class="line">      final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">      throws BeansException &#123;</span><br><span class="line">   // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span><br><span class="line">   // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span><br><span class="line">   final String beanName = transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">   // 注意跟着这个，这个是返回值</span><br><span class="line">   Object bean; </span><br><span class="line"></span><br><span class="line">   // 检查下是不是已经创建过了</span><br><span class="line">   Object sharedInstance = getSingleton(beanName);</span><br><span class="line"></span><br><span class="line">   // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span><br><span class="line">   // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(<span class="string">"..."</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span><br><span class="line">      // 如果是 FactoryBean 的话，返回它创建的那个实例对象</span><br><span class="line">      // (FactoryBean 知识，读者若不清楚请移步附录)</span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span><br><span class="line">         // 往往是因为陷入了循环引用</span><br><span class="line">         throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 检查一下这个 BeanDefinition 在容器中是否存在</span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span><br><span class="line">         String nameToLookup = originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (args != null) &#123;</span><br><span class="line">            // 返回父容器的查询结果</span><br><span class="line">            <span class="built_in">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            // No args -&gt; delegate to standard getBean method.</span><br><span class="line">            <span class="built_in">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         // typeCheckOnly 为 <span class="literal">false</span>，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * 稍稍总结一下：</span><br><span class="line">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span><br><span class="line">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span><br><span class="line">       */</span><br><span class="line">      try &#123;</span><br><span class="line">         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         // 先初始化依赖的所有 Bean，这个很好理解。</span><br><span class="line">         // 注意，这里的依赖指的是 depends-on 中定义的依赖</span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != null) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"'Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               // 注册一下依赖关系</span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               // 先初始化被依赖项</span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 如果是 singleton scope 的，创建 singleton 的实例</span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public Object getObject() throws BeansException &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                     // 执行创建 Bean，详情后面再说</span><br><span class="line">                     <span class="built_in">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  catch (BeansException ex) &#123;</span><br><span class="line">                     destroySingleton(beanName);</span><br><span class="line">                     throw ex;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 如果是 prototype scope 的，创建 prototype 的实例</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            // It’s a prototype -&gt; create a new instance.</span><br><span class="line">            Object prototypeInstance = null;</span><br><span class="line">            try &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               // 执行创建 Bean</span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == null) &#123;</span><br><span class="line">               throw new IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">               Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public Object getObject() throws BeansException &#123;</span><br><span class="line">                     beforePrototypeCreation(beanName);</span><br><span class="line">                     try &#123;</span><br><span class="line">                        // 执行创建 Bean</span><br><span class="line">                        <span class="built_in">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     finally &#123;</span><br><span class="line">                        afterPrototypeCreation(beanName);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IllegalStateException ex) &#123;</span><br><span class="line">               throw new BeanCreationException(beanName,</span><br><span class="line">                     <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                     <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span><br><span class="line">   <span class="keyword">if</span> (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         <span class="built_in">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;</span><br></pre></td></tr></table></figure><p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p><p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p><p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MessageServiceImpl implements MessageService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getMessage</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> userService.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"messageService"</span> class=<span class="string">"com.loonycoder.service.MessageServiceImpl"</span> /&gt;</span><br></pre></td></tr></table></figure><p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p><p>好了，读者要知道这么回事就可以了，继续向前。</p><p>// AbstractAutowireCapableBeanFactory 447</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Central method of this class: creates a bean instance,</span><br><span class="line"> * populates the bean instance, applies post-processors, etc.</span><br><span class="line"> * @see <span class="comment">#doCreateBean</span></span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">   // 确保 BeanDefinition 中的 Class 被加载</span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class="line">      mbdToUse = new RootBeanDefinition(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; </span><br><span class="line">   // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span><br><span class="line">   // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span><br><span class="line">   try &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span><br><span class="line">      // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过</span><br><span class="line">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != null) &#123;</span><br><span class="line">         <span class="built_in">return</span> bean; </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   // 重头戏，创建 bean</span><br><span class="line">   Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建Bean</strong><br>我们继续往里看 doCreateBean 这个方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Actually create the specified bean. Pre-creation processing has already happened</span><br><span class="line"> * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks.</span><br><span class="line"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span><br><span class="line"> * factory method, and autowiring a constructor.</span><br><span class="line"> * @param beanName the name of the bean</span><br><span class="line"> * @param mbd the merged bean definition <span class="keyword">for</span> the bean</span><br><span class="line"> * @param args explicit arguments to use <span class="keyword">for</span> constructor or factory method invocation</span><br><span class="line"> * @<span class="built_in">return</span> a new instance of the bean</span><br><span class="line"> * @throws BeanCreationException <span class="keyword">if</span> the bean could not be created</span><br><span class="line"> * @see <span class="comment">#instantiateBean</span></span><br><span class="line"> * @see <span class="comment">#instantiateUsingFactoryMethod</span></span><br><span class="line"> * @see <span class="comment">#autowireConstructor</span></span><br><span class="line"> */</span><br><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</span><br><span class="line">      throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   // Instantiate the bean.</span><br><span class="line">   BeanWrapper instanceWrapper = null;</span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == null) &#123;</span><br><span class="line">      // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 <span class="string">"bean 实例"</span></span><br><span class="line">   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class="line">   // 类型</span><br><span class="line">   Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</span><br><span class="line">   mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">   // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span><br><span class="line">   synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">   // even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">   // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span><br><span class="line">   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">               <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public Object getObject() throws BeansException &#123;</span><br><span class="line">            <span class="built_in">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Initialize the bean instance.</span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   try &#123;</span><br><span class="line">      // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="keyword">if</span> (exposedObject != null) &#123;</span><br><span class="line">         // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span><br><span class="line">         // 这里就是处理 bean 初始化完成后的各种回调</span><br><span class="line">         exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         throw (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         throw new BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      // </span><br><span class="line">      Object earlySingletonReference = getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != null) &#123;</span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                     <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                     <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                     <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                     <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Register bean as disposable.</span><br><span class="line">   try &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      throw new BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p><p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 </p><p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p><p><strong>创建 Bean 实例</strong><br>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123;</span><br><span class="line">   // 确保已经加载了此 class</span><br><span class="line">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">   // 校验一下这个类的访问权限</span><br><span class="line">   <span class="keyword">if</span> (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getFactoryMethodName() != null)  &#123;</span><br><span class="line">      // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean</span><br><span class="line">      <span class="built_in">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 如果不是第一次创建，比如第二次创建 prototype bean。</span><br><span class="line">   // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span><br><span class="line">   boolean resolved = <span class="literal">false</span>;</span><br><span class="line">   boolean autowireNecessary = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (args == null) &#123;</span><br><span class="line">      synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">            resolved = <span class="literal">true</span>;</span><br><span class="line">            autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">      <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">         // 构造函数依赖注入</span><br><span class="line">         <span class="built_in">return</span> autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         // 无参构造函数</span><br><span class="line">         <span class="built_in">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 判断是否采用有参构造函数</span><br><span class="line">   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">   <span class="keyword">if</span> (ctors != null ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">      // 构造函数依赖注入</span><br><span class="line">      <span class="built_in">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 调用无参构造函数</span><br><span class="line">   <span class="built_in">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      Object beanInstance;</span><br><span class="line">      final BeanFactory parent = this;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class="line">         beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">               <span class="built_in">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         // 实例化</span><br><span class="line">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">      &#125;</span><br><span class="line">      // 包装一下，返回</span><br><span class="line">      BeanWrapper bw = new BeanWrapperImpl(beanInstance);</span><br><span class="line">      initBeanWrapper(bw);</span><br><span class="line">      <span class="built_in">return</span> bw;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      throw new BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，关键的地方在于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure><p>这里会进行实际的实例化过程，我们进去看看:</p><p>// SimpleInstantiationStrategy 59</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123;</span><br><span class="line"></span><br><span class="line">   // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span><br><span class="line">   // 方法覆写 请参见附录<span class="string">"方法注入"</span>中对 lookup-method 和 replaced-method 的介绍</span><br><span class="line">   <span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">      Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">      synchronized (bd.constructorArgumentLock) &#123;</span><br><span class="line">         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">         <span class="keyword">if</span> (constructorToUse == null) &#123;</span><br><span class="line">            final Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">            <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">               throw new BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class="line">                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">                     @Override</span><br><span class="line">                     public Constructor&lt;?&gt; run() throws Exception &#123;</span><br><span class="line">                        <span class="built_in">return</span> clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">               &#125;</span><br><span class="line">               bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">               throw new BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 利用构造方法进行实例化</span><br><span class="line">      <span class="built_in">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span><br><span class="line">      // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持</span><br><span class="line">      <span class="built_in">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bean 属性注入</strong><br>看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。</p><p>// AbstractAutowireCapableBeanFactory 1203</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line">   // bean 实例的所有属性都在这里了</span><br><span class="line">   PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bw == null) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">         throw new BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         // Skip property population phase <span class="keyword">for</span> null instance.</span><br><span class="line">         <span class="built_in">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span><br><span class="line">   // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span><br><span class="line">   // 我也没找到有实际的使用，所以我们暂且忽略这块吧</span><br><span class="line">   boolean continueWithPropertyPopulation = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            // 如果返回 <span class="literal">false</span>，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">               <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="built_in">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">      // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 通过类型装配。复杂一些</span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">         <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">               // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span><br><span class="line">               // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span><br><span class="line">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvs == null) &#123;</span><br><span class="line">                  <span class="built_in">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 设置 bean 实例的属性值</span><br><span class="line">   applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>initializeBean</strong><br>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">   <span class="keyword">if</span> (System.getSecurityManager() != null) &#123;</span><br><span class="line">      AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public Object <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Object wrappedBean = bean;</span><br><span class="line">   <span class="keyword">if</span> (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">      // BeanPostProcessor 的 postProcessBeforeInitialization 回调</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      // 处理 bean 中定义的 init-method，</span><br><span class="line">      // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      throw new BeanCreationException(</span><br><span class="line">            (mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">            beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">      // BeanPostProcessor 的 postProcessAfterInitialization 回调</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="id和name"><a href="#id和name" class="headerlink" title="id和name"></a>id和name</h4><p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p><p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.getBean(<span class="string">"beanName or alias"</span>);</span><br></pre></td></tr></table></figure><p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"messageService"</span> name=<span class="string">"m1, m2, m3"</span> class=<span class="string">"com.loonycoder.service.MessageServiceImpl"</span>&gt;</span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"m1, m2, m3"</span> class=<span class="string">"com.loonycoder.service.MessageServiceImpl"</span> /&gt;</span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=<span class="string">"com.loonycoder.service.MessageServiceImpl"</span>&gt;</span><br></pre></td></tr></table></figure><p>beanName 为：com.loonycoder.service.MessageServiceImpl#0，</p><p>别名 1 个，为： com.loonycoder.service.MessageServiceImpl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"messageService"</span> class=<span class="string">"com.loonycoder.service.MessageServiceImpl"</span>&gt;</span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 messageService，没有别名。</p><h4 id="配置是否允许-Bean-覆盖、是否允许循环依赖"><a href="#配置是否允许-Bean-覆盖、是否允许循环依赖" class="headerlink" title="配置是否允许 Bean 覆盖、是否允许循环依赖"></a>配置是否允许 Bean 覆盖、是否允许循环依赖</h4><p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p><p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p><p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p><p>添加这两个属性的作者 Juergen Hoeller 在这个 jira 的讨论中说明了怎么配置这两个属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class NoBeanOverridingContextLoader extends ContextLoader &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) &#123;</span><br><span class="line">    super.customizeContext(servletContext, applicationContext);</span><br><span class="line">    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;</span><br><span class="line">    arac.setAllowBeanDefinitionOverriding(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected ContextLoader <span class="function"><span class="title">createContextLoader</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new NoBeanOverridingContextLoader();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;com.loonycoder.MyContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><h4 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h4><p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans profile=<span class="string">"development"</span></span><br><span class="line">    xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:jdbc=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"..."</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jdbc:embedded-database id=<span class="string">"dataSource"</span>&gt;</span><br><span class="line">        &lt;jdbc:script location=<span class="string">"classpath:com/loonycoder/config/sql/schema.sql"</span>/&gt;</span><br><span class="line">        &lt;jdbc:script location=<span class="string">"classpath:com/oonycoder/config/sql/test-data.sql"</span>/&gt;</span><br><span class="line">    &lt;/jdbc:embedded-database&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans profile=<span class="string">"production"</span></span><br><span class="line">    xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:jee=<span class="string">"http://www.springframework.org/schema/jee"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"..."</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jee:jndi-lookup id=<span class="string">"dataSource"</span> jndi-name=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>应该不必做过多解释了吧，看每个文件第一行的 profile=””。</p><p>当然，我们也可以在一个配置文件中使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:jdbc=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span><br><span class="line">    xmlns:jee=<span class="string">"http://www.springframework.org/schema/jee"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"..."</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beans profile=<span class="string">"development"</span>&gt;</span><br><span class="line">        &lt;jdbc:embedded-database id=<span class="string">"dataSource"</span>&gt;</span><br><span class="line">            &lt;jdbc:script location=<span class="string">"classpath:com/loonycoder/config/sql/schema.sql"</span>/&gt;</span><br><span class="line">            &lt;jdbc:script location=<span class="string">"classpath:com/loonycoder/config/sql/test-data.sql"</span>/&gt;</span><br><span class="line">        &lt;/jdbc:embedded-database&gt;</span><br><span class="line">    &lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beans profile=<span class="string">"production"</span>&gt;</span><br><span class="line">        &lt;jee:jndi-lookup id=<span class="string">"dataSource"</span> jndi-name=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span><br><span class="line">    &lt;/beans&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>理解起来也很简单吧。</p><p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p><p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p><p>最简单的方式莫过于在程序启动的时候指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=<span class="string">"profile1,profile2"</span></span><br></pre></td></tr></table></figure><blockquote><p>profile 可以激活多个</p></blockquote><p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">"development"</span>);</span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class="line">ctx.refresh(); // 重启</span><br></pre></td></tr></table></figure><p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dspring.profiles.active=prod -jar JavaDoop.jar</span><br></pre></td></tr></table></figure><h4 id="工厂模式生成-Bean"><a href="#工厂模式生成-Bean" class="headerlink" title="工厂模式生成 Bean"></a>工厂模式生成 Bean</h4><p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p><p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p><p>静态工厂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"clientService"</span></span><br><span class="line">    class=<span class="string">"examples.ClientService"</span></span><br><span class="line">    factory-method=<span class="string">"createInstance"</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClientService &#123;</span><br><span class="line">    private static ClientService clientService = new ClientService();</span><br><span class="line">    private <span class="function"><span class="title">ClientService</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 静态方法</span><br><span class="line">    public static ClientService <span class="function"><span class="title">createInstance</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例工厂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"serviceLocator"</span> class=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"clientService"</span></span><br><span class="line">    factory-bean=<span class="string">"serviceLocator"</span></span><br><span class="line">    factory-method=<span class="string">"createClientServiceInstance"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"accountService"</span></span><br><span class="line">    factory-bean=<span class="string">"serviceLocator"</span></span><br><span class="line">    factory-method=<span class="string">"createAccountServiceInstance"</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    private static AccountService accountService = new AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService <span class="function"><span class="title">createClientServiceInstance</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AccountService <span class="function"><span class="title">createAccountServiceInstance</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line">    Class&lt;T&gt; getObjectType();</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123; </span><br><span class="line">    private Car car ;</span><br><span class="line">    private void setCar(Car car)&#123; this.car = car;  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;&#123;</span><br><span class="line">    private String make; </span><br><span class="line">    private int year ;</span><br><span class="line"></span><br><span class="line">    public void setMake(String m)&#123; this.make =m ; &#125;</span><br><span class="line"></span><br><span class="line">    public void setYear(int y)&#123; this.year = y; &#125;</span><br><span class="line"></span><br><span class="line">    public Car <span class="function"><span class="title">getObject</span></span>()&#123; </span><br><span class="line">      // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span><br><span class="line">      CarBuilder cb = CarBuilder.car();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(year!=0) cb.setYear(this.year);</span><br><span class="line">      <span class="keyword">if</span>(StringUtils.hasText(this.make)) cb.setMake( this.make ); </span><br><span class="line">      <span class="built_in">return</span> cb.factory(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;Car&gt; <span class="function"><span class="title">getObjectType</span></span>() &#123; <span class="built_in">return</span> Car.class ; &#125; </span><br><span class="line"></span><br><span class="line">    public boolean <span class="function"><span class="title">isSingleton</span></span>() &#123; <span class="built_in">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看装配的时候是怎么配置的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class = <span class="string">"com.loonycoder.MyCarFactoryBean"</span> id = <span class="string">"car"</span>&gt;</span><br><span class="line">  &lt;property name = <span class="string">"make"</span> value =<span class="string">"Honda"</span>/&gt;</span><br><span class="line">  &lt;property name = <span class="string">"year"</span> value =<span class="string">"1994"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean class = <span class="string">"com.loonycoder.Person"</span> id = <span class="string">"josh"</span>&gt;</span><br><span class="line">  &lt;property name = <span class="string">"car"</span> ref = <span class="string">"car"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p><p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration </span><br><span class="line">public class CarConfiguration &#123; </span><br><span class="line"></span><br><span class="line">    @Bean </span><br><span class="line">    public MyCarFactoryBean <span class="function"><span class="title">carFactoryBean</span></span>()&#123; </span><br><span class="line">      MyCarFactoryBean cfb = new MyCarFactoryBean();</span><br><span class="line">      cfb.setMake(<span class="string">"Honda"</span>);</span><br><span class="line">      cfb.setYear(1994);</span><br><span class="line">      <span class="built_in">return</span> cfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Person <span class="function"><span class="title">aPerson</span></span>()&#123; </span><br><span class="line">    Person person = new Person();</span><br><span class="line">      // 注意这里的不同</span><br><span class="line">    person.setCar(carFactoryBean().getObject());</span><br><span class="line">    <span class="built_in">return</span> person; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p><h4 id="初始化-Bean-的回调"><a href="#初始化-Bean-的回调" class="headerlink" title="初始化 Bean 的回调"></a>初始化 Bean 的回调</h4><p>有以下四种方案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"exampleInitBean"</span> class=<span class="string">"examples.ExampleBean"</span> init-method=<span class="string">"init"</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherExampleBean implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">afterPropertiesSet</span></span>() &#123;</span><br><span class="line">        // <span class="keyword">do</span> some initialization work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean(initMethod = <span class="string">"init"</span>)</span><br><span class="line">public Foo <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new Foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostConstruct</span><br><span class="line">public void <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="销毁-Bean-的回调"><a href="#销毁-Bean-的回调" class="headerlink" title="销毁 Bean 的回调"></a>销毁 Bean 的回调</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"exampleInitBean"</span> class=<span class="string">"examples.ExampleBean"</span> destroy-method=<span class="string">"cleanup"</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherExampleBean implements DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">destroy</span></span>() &#123;</span><br><span class="line">        // <span class="keyword">do</span> some destruction work (like releasing pooled connections)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean(destroyMethod = <span class="string">"cleanup"</span>)</span><br><span class="line">public Bar <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new Bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PreDestroy</span><br><span class="line">public void <span class="function"><span class="title">cleanup</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h4><p>既然文中说到了这个，顺便提一下好了。</p><p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p><p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"conversionService"</span></span><br><span class="line">  class=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">"converters"</span>&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">      &lt;bean class=<span class="string">"com.loonycoder.learning.utils.StringToEnumConverterFactory"</span>/&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p><p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p><p>来看一个很简单的例子，这样比什么都管用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Date convert(String <span class="built_in">source</span>) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="built_in">return</span> DateUtils.parseDate(<span class="built_in">source</span>, <span class="string">"yyyy-MM-dd"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, <span class="string">"yyyy-MM-dd HH:mm"</span>, <span class="string">"HH:mm:ss"</span>, <span class="string">"HH:mm"</span>);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p><h4 id="Bean-继承"><a href="#Bean-继承" class="headerlink" title="Bean 继承"></a>Bean 继承</h4><p>在初始化 Bean 的地方，我们说过了这个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure><p>这里涉及到的就是 <code>&lt;bean parent="" /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p><p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p><p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p><p>看如下一个例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"inheritedTestBean"</span> abstract=<span class="string">"true"</span> class=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"parent"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"age"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"inheritsWithDifferentClass"</span> class=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span><br><span class="line">        parent=<span class="string">"inheritedTestBean"</span> init-method=<span class="string">"initialize"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"override"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>parent bean 设置了 <code>abstract="true"</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p><p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p><p>当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p><p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"inheritedTestBeanWithoutClass"</span> abstract=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"parent"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"age"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h4><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p><p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p><p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p><p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p><p><strong>lookup-method</strong><br>我们来看一下 Spring Reference 中提供的一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package fiona.apple;</span><br><span class="line"></span><br><span class="line">// no more Spring imports!</span><br><span class="line"></span><br><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"></span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        // grab a new instance of the appropriate Command interface</span><br><span class="line">        Command <span class="built_in">command</span> = createCommand();</span><br><span class="line">        // <span class="built_in">set</span> the state on the (hopefully brand new) Command instance</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="built_in">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // okay... but <span class="built_in">where</span> is the implementation of this method?</span><br><span class="line">    protected abstract Command createCommand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"myCommand"</span> class=<span class="string">"fiona.apple.AsyncCommand"</span> scope=<span class="string">"prototype"</span>&gt;</span><br><span class="line">    &lt;!-- inject dependencies here as required --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"commandManager"</span> class=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span><br><span class="line">    &lt;lookup-method name=<span class="string">"createCommand"</span> bean=<span class="string">"myCommand"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>Spring 采用 <strong>CGLIB</strong> 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p><p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"></span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        MyCommand <span class="built_in">command</span> = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="built_in">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Lookup(<span class="string">"myCommand"</span>)</span><br><span class="line">    protected abstract Command createCommand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package="com.loonycoder" /&gt;</code></p></blockquote><p>甚至，我们可以像下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"></span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        MyCommand <span class="built_in">command</span> = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="built_in">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Lookup</span><br><span class="line">    protected abstract MyCommand createCommand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p></blockquote><p><strong>replaced-method</strong><br>记住它的功能，就是替换掉 bean 中的一些方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyValueCalculator &#123;</span><br><span class="line"></span><br><span class="line">    public String computeValue(String input) &#123;</span><br><span class="line">        // some real code...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // some other methods...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法覆写，注意要实现 MethodReplacer 接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer &#123;</span><br><span class="line"></span><br><span class="line">    public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123;</span><br><span class="line">        // get the input value, work with it, and <span class="built_in">return</span> a computed result</span><br><span class="line">        String input = (String) args[0];</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置也很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"myValueCalculator"</span> class=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span><br><span class="line">    &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span><br><span class="line">    &lt;replaced-method name=<span class="string">"computeValue"</span> replacer=<span class="string">"replacementComputeValue"</span>&gt;</span><br><span class="line">        &lt;arg-type&gt;String&lt;/arg-type&gt;</span><br><span class="line">    &lt;/replaced-method&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"replacementComputeValue"</span> class=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p></blockquote><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p><p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p><p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p><p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p><p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p><p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p><p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>按理说，总结应该写在附录前面，我就不讲究了。</p><p>在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。</p><p>本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。</p><p>（全文完）</p>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架 - Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架——Spring框架概述及工作原理</title>
    <link href="/2018/10/22/Spring-1/"/>
    <url>/2018/10/22/Spring-1/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/spring_logo.jpg" srcset="/img/loading.gif" alt="Spring"></p><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过Pojo为基础的编程模型促进良好的编程习惯。</p><hr><h3 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h3><p><font style="color: red"><b>1、 IoC(Inversion of Control): 控制反转<b></font><br>概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系 </p><p>核心：bean工厂。在Spring中，bean工厂创建的各个实例称作bean。  </p><p>作用：IoC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><p>优点：IoC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IoC容器支持加载服务时的饿汉式初始化和懒加载。</p><p>动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，根据xml里面的Spring的配置文件来动态的创建对象，和调用对象里的方法的。 </p><p>DI：(全称：Dependency Injection)依赖注入，IoC的另一种表现方式，组件以一种预先定义好的方式来接受容器注入的资源。</p><p><font style="color: red"><b>2、AOP(Aspect-Oriented Programming): 面向方面编程<b></font> </p><pre><code>可以为某一类对象进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的模块）从而达到对一个模块扩充的功能。这些都是通过配置类达到的。 </code></pre><p>优点：AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码；利用AOP可以对业务逻辑的各个部分进行隔离，使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>经典应用：事务管理、性能监视、安全检查、缓存 、日志等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/aop </span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span><br><span class="line">    &lt;!-- 1 创建目标类 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"userServiceId"</span> class=<span class="string">"com.loonycoder.service.UserServiceImpl"</span>&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!-- 2 创建切面类（通知） --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"myAspectId"</span> class=<span class="string">"com.loonycoder.service.MyAspect"</span>&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!-- 3 aop编程 </span><br><span class="line">        3.1 导入命名空间</span><br><span class="line">        3.2 使用 &lt;aop:config&gt;进行配置</span><br><span class="line">                proxy-target-class=<span class="string">"true"</span> 声明时使用cglib代理</span><br><span class="line">            &lt;aop:pointcut&gt; 切入点 ，从目标对象获得具体方法</span><br><span class="line">            &lt;aop:advisor&gt; 特殊的切面，只有一个通知 和 一个切入点</span><br><span class="line">                advice-ref 通知引用</span><br><span class="line">                pointcut-ref 切入点引用</span><br><span class="line">        3.3 切入点表达式</span><br><span class="line">            execution(* com.loonycoder.service.*.*(..))</span><br><span class="line">            选择方法         返回值任意   包             类名任意   方法名任意   参数任意</span><br><span class="line"> </span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;aop:config proxy-target-class=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;aop:pointcut expression=<span class="string">"execution(* com.loonycoder.service.*.*(..))"</span> id=<span class="string">"myPointCut"</span>/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">"myAspectId"</span> pointcut-ref=<span class="string">"myPointCut"</span>/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>代理的两种方式——静态代理和动态代理静态代理：  </p><ul><li>针对每个具体类分别编写代理类；  </li><li>针对一个接口编写一个代理类；<br>动态代理：<br>针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类</li></ul><p>3、三种注入方式</p><ol><li><p>setter属性注入，通过构建实体类属性的setting方法注入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 相当于User user = new User(); --&gt;</span><br><span class="line">        &lt;bean id=<span class="string">"user"</span> class=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">            &lt;property name=<span class="string">"name"</span> value=<span class="string">"张三"</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=<span class="string">"age"</span> value=<span class="string">"18"</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=<span class="string">"sex"</span> value=<span class="string">"男"</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>constructor构造方法注入，通过构建实体类相应构造方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 相当于User user = new User();--&gt;</span><br><span class="line">&lt;!-- index属性指的是参数索引，从0开始 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"user"</span> class=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">    &lt;constructor-arg <span class="built_in">type</span>=<span class="string">"java.lang.String"</span> index=<span class="string">"0"</span> value=<span class="string">"张三"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg <span class="built_in">type</span>=<span class="string">"java.lang.Integer"</span> index=<span class="string">"1"</span> value=<span class="string">"18"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg <span class="built_in">type</span>=<span class="string">"java.lang.String"</span> index=<span class="string">"2"</span> value=<span class="string">"男"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>另外还有一种是Interface接口注入，因为此种方式使用的极少，所以在此就不进行介绍了。</p></li></ol><p>4、单例和多例<br>1)当scope=”singleton”时，容器一加载就创建实体类</p><p><strong>注意：只有在单例的时候，这个配置才有效</strong></p><ul><li>lazy-init=”true” 延迟加载，在使用对象时创建实体对象 </li><li>lazy-init=”false” 不延迟加载，容器启动立即创建</li></ul><p>2)当scope=”prototype”时，获取使用对象时创建对象</p><p>5、Spring目的<br><font style="color: red"><b>就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象）</b></font><br>Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。<br>Spring里用的最经典的一个设计模式就是：模板方法模式。Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了也就基本上掌握了Spring。</p><h3 id="三、组成体系"><a href="#三、组成体系" class="headerlink" title="三、组成体系"></a>三、组成体系</h3><p><img src="/images/spring-framework.gif" srcset="/img/loading.gif" alt="spring"></p><p>图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。<br><strong>1. Data Access/Integration（数据访问／集成）</strong></p><p>数据访问/集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。</p><ul><li>JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了在开发过程中对数据库操作的编码。</li><li>ORM 模块：对流行的对象关系映射 API，包括 JPA、JDO、Hibernate 和 iBatis 提供了的集成层。</li><li>OXM 模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。</li><li>JMS 模块：指 Java 消息服务，包含的功能为生产和消费的信息。</li><li>Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。</li></ul><p><strong>2. Web 模块</strong></p><p>Spring 的 Web 层包括 Web、Servlet、Struts 和 Portlet 组件，具体介绍如下。</p><ul><li>Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。</li><li>Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web 应用程序。</li><li>Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。</li><li>Portlet 模块：提供了在 Portlet 环境中使用 MV C实现，类似 Web-Servlet 模块的功能。</li></ul><p><strong>3. Core Container（核心容器）</strong></p><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成，具体介绍如下。</p><ul><li>Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。</li><li>Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。</li><li>Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。</li><li>Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。</li></ul><p><strong>4. 其他模块</strong></p><p>Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下。</p><ul><li>AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。</li><li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li><li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li>Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架 - Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis的多表查询</title>
    <link href="/2018/10/15/Mybatis-3/"/>
    <url>/2018/10/15/Mybatis-3/</url>
    
    <content type="html"><![CDATA[<h3 id="场景-一对多"><a href="#场景-一对多" class="headerlink" title="场景(一对多)"></a>场景(一对多)</h3><p>用户和账户<br>一个用户可以有多个账户<br>一个账户只能属于一个用户（多个账户也可以属于同一个用户）</p><p>需要实现：<br>查询账户时，可以查询到归属的用户信息。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><h5 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h5><p>建立用户表和账户表：让用户表和账户表之间具备一对多的关系（需要在账户表中添加外键）<br>建表语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL auto_increment,</span><br><span class="line">  `username` varchar(32) NOT NULL COMMENT <span class="string">'用户名称'</span>,</span><br><span class="line">  `birthday` datetime default NULL COMMENT <span class="string">'生日'</span>,</span><br><span class="line">  `sex` char(1) default NULL COMMENT <span class="string">'性别'</span>,</span><br><span class="line">  `address` varchar(256) default NULL COMMENT <span class="string">'地址'</span>,</span><br><span class="line">  PRIMARY KEY  (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,<span class="string">'张三'</span>,<span class="string">'2018-02-27 17:47:08'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(2,<span class="string">'李四'</span>,<span class="string">'2018-03-02 15:09:37'</span>,<span class="string">'女'</span>,<span class="string">'深圳'</span>),(3,<span class="string">'王五'</span>,<span class="string">'2018-03-04 11:34:34'</span>,<span class="string">'女'</span>,<span class="string">'上海'</span>),(4,<span class="string">'赵六'</span>,<span class="string">'2018-03-04 12:04:06'</span>,<span class="string">'男'</span>,<span class="string">'成都'</span>),(4,<span class="string">'刘七'</span>,<span class="string">'2018-03-07 17:37:26'</span>,<span class="string">'男'</span>,<span class="string">'西安'</span>),(48,<span class="string">'孙八'</span>,<span class="string">'2018-03-08 11:44:00'</span>,<span class="string">'女'</span>,<span class="string">'杭州'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `account`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `account` (</span><br><span class="line">  `ID` int(11) NOT NULL COMMENT <span class="string">'编号'</span>,</span><br><span class="line">  `UID` int(11) default NULL COMMENT <span class="string">'用户编号'</span>,</span><br><span class="line">  `MONEY` double default NULL COMMENT <span class="string">'金额'</span>,</span><br><span class="line">  PRIMARY KEY  (`ID`),</span><br><span class="line">  KEY `FK_Reference_8` (`UID`),</span><br><span class="line">  CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert  into `account`(`ID`,`UID`,`MONEY`) values (1,1,1000),(2,3,1000),(3,5,2000);</span><br></pre></td></tr></table></figure><h5 id="建实体类"><a href="#建实体类" class="headerlink" title="建实体类"></a>建实体类</h5><p>用户实体类和账户实体类：让用户和账户的实体类能体现出一对多的关系<br>由于我们之前新建过用户的实体类，所以我们在这里只新建一个账户实体类即可，和用户实体类一样放在com.loonycoder.domain包下<br>此处在从表实体类中引用主表的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Account implements Serializable &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private Integer uid;</span><br><span class="line">    private Double money;</span><br><span class="line"></span><br><span class="line">    //从表实体应该包含一个主表实体的对象引用</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    public User <span class="function"><span class="title">getUser</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUser(User user) &#123;</span><br><span class="line">        this.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getUid</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUid(Integer uid) &#123;</span><br><span class="line">        this.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double <span class="function"><span class="title">getMoney</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMoney(Double money) &#123;</span><br><span class="line">        this.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", uid="</span> + uid +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们新建一个Account的Mapper接口类，并提供查询所有账户的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.domain.Account;</span><br><span class="line">import com.loonycoder.domain.AccountUser;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IAccountMapper &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有账户</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    List&lt;Account&gt; selectAll();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有账户，并且包含账户对应的用户下的姓名和地址信息</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    List&lt;AccountUser&gt; selectAccountUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>用户的配置文件和账户的配置文件<br>用户的配置文件用之前的就可以了，我们在此只新建账户的配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IAccountMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--定义封装account和user的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"accountUserMap"</span> <span class="built_in">type</span>=<span class="string">"account"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"aid"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"uid"</span> column=<span class="string">"uid"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"money"</span> column=<span class="string">"money"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;!--一对一的关系映射，配置封装user的内容--&gt;</span><br><span class="line">        &lt;association property=<span class="string">"user"</span> column=<span class="string">"uid"</span> javaType=<span class="string">"user"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/association&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultMap=<span class="string">"accountUserMap"</span>&gt;</span><br><span class="line">        select u.*,a.id as aid,a.uid,a.money from account a,user u <span class="built_in">where</span> u.id = a.uid;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>当然我们还需要修改一下SqlMapConfig.xml中的别名和mapper映射配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line">&lt;!--mybatis的主配置文件--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--引用外部配置文件配置数据源信息，下面的取值部分需要用<span class="variable">$&#123;&#125;</span>方式取值--&gt;</span><br><span class="line">    &lt;properties resource=<span class="string">"jdbcConfig.properties"</span>&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;!--配置别名 <span class="built_in">type</span>属性指定实体类，<span class="built_in">alias</span>指定别名--&gt;</span><br><span class="line">    &lt;typeAliases &gt;</span><br><span class="line">        &lt;!--package标签可以指定具体到某个包下所有类都使用别名，默认别名是类的名字，不区分大小写--&gt;</span><br><span class="line">        &lt;package name=<span class="string">"com.loonycoder.domain"</span>&gt;&lt;/package&gt;</span><br><span class="line">        &lt;!--&lt;typeAlias <span class="built_in">type</span>=<span class="string">"com.loonycoder.domain.User"</span> <span class="built_in">alias</span>=<span class="string">"user"</span>&gt;&lt;/typeAlias&gt;--&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">    &lt;!--配置环境--&gt;</span><br><span class="line">    &lt;environments default=<span class="string">"mysql"</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">"mysql"</span>&gt;</span><br><span class="line">            &lt;!--配置事务--&gt;</span><br><span class="line">            &lt;transactionManager <span class="built_in">type</span>=<span class="string">"JDBC"</span>&gt;&lt;/transactionManager&gt;</span><br><span class="line">            &lt;!--配置数据源（连接池）--&gt;</span><br><span class="line">            &lt;dataSource <span class="built_in">type</span>=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">"driver"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.driver&#125;</span>"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"url"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.url&#125;</span>"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"username"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.username&#125;</span>"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"password"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.password&#125;</span>"</span> /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IUserMapper.xml"</span> /&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IAccountMapper.xml"</span> /&gt;</span><br><span class="line">        &lt;!--&lt;mapper class=<span class="string">"com.loonycoder.dao.IUserMapper"</span> /&gt;--&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h5 id="新建测试类执行"><a href="#新建测试类执行" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">selectAllAccount</span></span>()&#123;</span><br><span class="line">    List&lt;Account&gt; accts = accountMapper.selectAll();</span><br><span class="line">    <span class="keyword">for</span> (Account acct : accts) &#123;</span><br><span class="line">        System.out.println(<span class="string">"每个账户下的用户信息"</span>);</span><br><span class="line">        System.out.println(acct);</span><br><span class="line">        System.out.println(acct.getUser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/images/mybatis1.png" srcset="/img/loading.gif" alt="result"></p><hr><h3 id="场景-多对一"><a href="#场景-多对一" class="headerlink" title="场景(多对一)"></a>场景(多对一)</h3><p>需要实现：</p><ul><li>查询用户时，可以同时查询出用户下的所有账户信息</li></ul><h5 id="修改实体类"><a href="#修改实体类" class="headerlink" title="修改实体类"></a>修改实体类</h5><p>我们修改User实体类，让主表包含从表的集合引用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String userName;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private String sex;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    private List&lt;Account&gt; accounts;</span><br><span class="line"></span><br><span class="line">    public List&lt;Account&gt; <span class="function"><span class="title">getAccounts</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class="line">        this.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getUserName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date <span class="function"><span class="title">getBirthday</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getSex</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getAddress</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", userName='"</span> + userName + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                ", birthday=" + birthday +</span></span><br><span class="line"><span class="string">                ", sex='</span><span class="string">" + sex + '\'' +</span></span><br><span class="line"><span class="string">                "</span>, address=<span class="string">'" + address + '</span>\<span class="string">''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><p>User接口类我们不做修改，直接用原来的查询所有用户的方法即可，我们只需要改动映射配置文件。<br>修改IUserMapper.xml内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IUserMapper"</span>&gt;</span><br><span class="line">    &lt;!--配置列名和实体类属性对应关系 <span class="built_in">type</span>属性不区分大小写--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userMap"</span> <span class="built_in">type</span>=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        &lt;!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名--&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!--定义User的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userAccountMap"</span> <span class="built_in">type</span>=<span class="string">"user"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;!--配置user对象中accounts集合的映射--&gt;</span><br><span class="line">        &lt;!--ofType指的是集合的泛型--&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"accounts"</span> ofType=<span class="string">"account"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"id"</span> column=<span class="string">"aid"</span>&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property=<span class="string">"uid"</span> column=<span class="string">"uid"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"money"</span> column=<span class="string">"money"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class="line">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class="line">    &lt;!--此处使用左外连接查询--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultMap=<span class="string">"userAccountMap"</span>&gt;</span><br><span class="line">        select * from user u left outer join account a on u.id = a.uid;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">"saveUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        insert into user (username,sex,birthday,address) values (<span class="comment">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id=<span class="string">"deleteUser"</span> parameterType=<span class="string">"java.lang.Integer"</span>&gt;</span><br><span class="line">        delete from user <span class="built_in">where</span> id = <span class="comment">#&#123;uid&#125;;</span></span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=<span class="string">"updateUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        update user <span class="built_in">set</span> username = <span class="comment">#&#123;userName&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;select id=<span class="string">"selectUserByCondition"</span> resultMap=<span class="string">"userMap"</span> parameterType=<span class="string">"user"</span>&gt;</span><br><span class="line">          select * from user</span><br><span class="line">          &lt;<span class="built_in">where</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"sex != null and sex != '' "</span>&gt;</span><br><span class="line">                and sex = <span class="comment">#&#123;sex&#125;</span></span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">          &lt;/<span class="built_in">where</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h5 id="新建测试类执行-1"><a href="#新建测试类执行-1" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void selectTest() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">    //5.使用代理对象执行方法</span><br><span class="line">    List&lt;User&gt; users= userDao.selectAll();</span><br><span class="line">    <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">        System.out.println(<span class="string">"每个用户下账户的信息："</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(user.getAccounts());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/images/mybatis2.png" srcset="/img/loading.gif" alt="result"></p><hr><h3 id="场景-多对多"><a href="#场景-多对多" class="headerlink" title="场景(多对多)"></a>场景(多对多)</h3><p>用户和角色<br>一个用户有多个角色<br>一个角色有多个用户<br>需要实现：</p><ul><li>当我们查询用户时，可以同时得到用户的角色信息</li><li>当我们查询角色时，可以同时得到角色所属的用户信息</li></ul><h5 id="新建角色表和中间表"><a href="#新建角色表和中间表" class="headerlink" title="新建角色表和中间表"></a>新建角色表和中间表</h5><p>建表语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `role`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `role` (</span><br><span class="line">  `ID` int(11) NOT NULL COMMENT <span class="string">'编号'</span>,</span><br><span class="line">  `ROLE_NAME` varchar(30) default NULL COMMENT <span class="string">'角色名称'</span>,</span><br><span class="line">  `ROLE_DESC` varchar(60) default NULL COMMENT <span class="string">'角色描述'</span>,</span><br><span class="line">  PRIMARY KEY  (`ID`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert  into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,<span class="string">'董事长'</span>,<span class="string">'管理整个公司'</span>),(2,<span class="string">'总裁'</span>,<span class="string">'管理整个公司'</span>),(3,<span class="string">'部门经理'</span>,<span class="string">'管理某个部门'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `user_role`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user_role` (</span><br><span class="line">  `UID` int(11) NOT NULL COMMENT <span class="string">'用户编号'</span>,</span><br><span class="line">  `RID` int(11) NOT NULL COMMENT <span class="string">'角色编号'</span>,</span><br><span class="line">  PRIMARY KEY  (`UID`,`RID`),</span><br><span class="line">  KEY `FK_Reference_10` (`RID`),</span><br><span class="line">  CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`),</span><br><span class="line">  CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">insert  into `user_role`(`UID`,`RID`) values (1,1),(3,1),(3,2);</span><br></pre></td></tr></table></figure><h5 id="新建角色实体类"><a href="#新建角色实体类" class="headerlink" title="新建角色实体类"></a>新建角色实体类</h5><p>此处注意也要让用户和角色体现出多对多关系：需要各自包含对方的一个集合引用。</p><p>新建角色实体类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Role implements Serializable &#123;</span><br><span class="line">    private Integer roleId;</span><br><span class="line">    private String roleName;</span><br><span class="line">    private String roleDesc;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getRoleId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> roleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoleId(Integer roleId) &#123;</span><br><span class="line">        this.roleId = roleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getRoleName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> roleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoleName(String roleName) &#123;</span><br><span class="line">        this.roleName = roleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getRoleDesc</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> roleDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoleDesc(String roleDesc) &#123;</span><br><span class="line">        this.roleDesc = roleDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Role&#123;"</span> +</span><br><span class="line">                <span class="string">"roleId="</span> + roleId +</span><br><span class="line">                <span class="string">", roleName='"</span> + roleName + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                ", roleDesc='</span><span class="string">" + roleDesc + '\'' +</span></span><br><span class="line"><span class="string">                '&#125;';</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="新建实体类接口"><a href="#新建实体类接口" class="headerlink" title="新建实体类接口"></a>新建实体类接口</h5><p>新建RoleMapper接口类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.domain.Role;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IRoleMapper &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有角色信息</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public List&lt;Role&gt; selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="新建角色实体配置文件"><a href="#新建角色实体配置文件" class="headerlink" title="新建角色实体配置文件"></a>新建角色实体配置文件</h5><p>一、新建IRoleMapper.xml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IRoleMapper"</span>&gt;</span><br><span class="line">    &lt;!--定义role表的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"roleMap"</span> <span class="built_in">type</span>=<span class="string">"role"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"roleId"</span> column=<span class="string">"rid"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"roleName"</span> column=<span class="string">"role_name"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"roleDesc"</span> column=<span class="string">"role_desc"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"users"</span> ofType=<span class="string">"user"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--查询所有角色信息--&gt;</span><br><span class="line">    &lt;!--使用两次左外连接查询--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultMap=<span class="string">"roleMap"</span>&gt;</span><br><span class="line">        select u.*,r.id as rid,r.role_name,r.role_desc from role r</span><br><span class="line">        left outer join user_role ur on r.id = ur.rid</span><br><span class="line">        left outer join user u on u.id = ur.uid</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>二、在SqlMapConfig.xml中添加映射配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IUserMapper.xml"</span> /&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IAccountMapper.xml"</span> /&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IRoleMapper.xml"</span> /&gt;</span><br><span class="line">        &lt;!--&lt;mapper class=<span class="string">"com.loonycoder.dao.IUserMapper"</span> /&gt;--&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br></pre></td></tr></table></figure><h5 id="新建测试类执行-2"><a href="#新建测试类执行-2" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">selectRoleAll</span></span>()&#123;</span><br><span class="line">    List&lt;Role&gt; roles = roleMapper.selectAll();</span><br><span class="line">    <span class="keyword">for</span> (Role role:roles) &#123;</span><br><span class="line">        System.out.println(<span class="string">"每个角色的用户信息："</span>);</span><br><span class="line">        System.out.println(role);</span><br><span class="line">        System.out.println(role.getUsers());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行结果-2"><a href="#执行结果-2" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/images/mybatis3.png" srcset="/img/loading.gif" alt="result"></p><hr><h5 id="根据用户查询角色"><a href="#根据用户查询角色" class="headerlink" title="根据用户查询角色"></a>根据用户查询角色</h5><p>同理，我们修改用户实体类，添加多对多的关系映射：一个用户具备多个角色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String userName;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private String sex;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    多对多关系映射：一个用户具备多个角色</span><br><span class="line">    private List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line">    public List&lt;Role&gt; <span class="function"><span class="title">getRoles</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoles(List&lt;Role&gt; roles) &#123;</span><br><span class="line">        this.roles = roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;Account&gt; accounts;</span><br><span class="line"></span><br><span class="line">    public List&lt;Account&gt; <span class="function"><span class="title">getAccounts</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class="line">        this.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getUserName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date <span class="function"><span class="title">getBirthday</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getSex</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getAddress</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", userName='"</span> + userName + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                ", birthday=" + birthday +</span></span><br><span class="line"><span class="string">                ", sex='</span><span class="string">" + sex + '\'' +</span></span><br><span class="line"><span class="string">                "</span>, address=<span class="string">'" + address + '</span>\<span class="string">''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，修改用户实体映射配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IUserMapper"</span>&gt;</span><br><span class="line">    &lt;!--配置列名和实体类属性对应关系 <span class="built_in">type</span>属性不区分大小写--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userMap"</span> <span class="built_in">type</span>=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        &lt;!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名--&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!--定义User的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userAccountMap"</span> <span class="built_in">type</span>=<span class="string">"user"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;!--配置user对象中accounts集合的映射--&gt;</span><br><span class="line">        &lt;!--ofType指的是集合的泛型--&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"accounts"</span> ofType=<span class="string">"account"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"id"</span> column=<span class="string">"aid"</span>&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property=<span class="string">"uid"</span> column=<span class="string">"uid"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"money"</span> column=<span class="string">"money"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--配置user的userRoleMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userRoleMap"</span> <span class="built_in">type</span>=<span class="string">"user"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"roles"</span> ofType=<span class="string">"role"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"roleId"</span> column=<span class="string">"rid"</span>&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property=<span class="string">"roleName"</span> column=<span class="string">"role_name"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"roleDesc"</span> column=<span class="string">"role_desc"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class="line">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class="line">    &lt;!--此处使用左外连接查询--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultMap=<span class="string">"userAccountMap"</span>&gt;</span><br><span class="line">        select * from user u left outer join account a on u.id = a.uid;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"selectUserRoleAll"</span> resultMap=<span class="string">"userRoleMap"</span>&gt;</span><br><span class="line">        select u.*,r.id as rid,r.role_name,r.role_desc from user u</span><br><span class="line">        left outer join user_role ur on u.id = ur.uid</span><br><span class="line">        left outer join role r on r.id = ur.rid</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">"saveUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        insert into user (username,sex,birthday,address) values (<span class="comment">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id=<span class="string">"deleteUser"</span> parameterType=<span class="string">"java.lang.Integer"</span>&gt;</span><br><span class="line">        delete from user <span class="built_in">where</span> id = <span class="comment">#&#123;uid&#125;;</span></span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=<span class="string">"updateUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        update user <span class="built_in">set</span> username = <span class="comment">#&#123;userName&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;select id=<span class="string">"selectUserByCondition"</span> resultMap=<span class="string">"userMap"</span> parameterType=<span class="string">"user"</span>&gt;</span><br><span class="line">          select * from user</span><br><span class="line">          &lt;<span class="built_in">where</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"sex != null and sex != '' "</span>&gt;</span><br><span class="line">                and sex = <span class="comment">#&#123;sex&#125;</span></span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">          &lt;/<span class="built_in">where</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>在UserMapper接口中添加查询方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 查询用户及用户下所有的角色信息</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public List&lt;User&gt; selectUserRoleAll();</span><br></pre></td></tr></table></figure><p>新建测试方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">selectUserRoleAll</span></span>()&#123;</span><br><span class="line">    List&lt;User&gt; users = userDao.selectUserRoleAll();</span><br><span class="line">    <span class="keyword">for</span> (User user:users) &#123;</span><br><span class="line">        System.out.println(<span class="string">"每个用户的角色信息："</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(user.getRoles());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="/images/mybatis4.png" srcset="/img/loading.gif" alt="result"></p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java框架 - 数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis的增删改查操作</title>
    <link href="/2018/10/06/Mybatis-2/"/>
    <url>/2018/10/06/Mybatis-2/</url>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>基于我们之前创建的Mybatis项目即可，我在此采用的依旧是基于xml的开发方式。</p><hr><h3 id="Mybatis的查询操作"><a href="#Mybatis的查询操作" class="headerlink" title="Mybatis的查询操作"></a>Mybatis的查询操作</h3><h4 id="在mapper接口中新增查询方法"><a href="#在mapper接口中新增查询方法" class="headerlink" title="在mapper接口中新增查询方法"></a>在mapper接口中新增查询方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.domain.User;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IUserMapper &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询用户</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public List&lt;User&gt; selectAll();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在IUserMapper-xml中添加查询sql语句"><a href="#在IUserMapper-xml中添加查询sql语句" class="headerlink" title="在IUserMapper.xml中添加查询sql语句"></a>在IUserMapper.xml中添加查询sql语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IUserMapper"</span>&gt;</span><br><span class="line">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class="line">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        select * from user;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h4 id="新建测试类执行"><a href="#新建测试类执行" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h4><p>由于读取配置文件、创建SqlSessionFactory工厂等步骤复用性较高，我们在这里进行了抽取。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.loonycoder.dao.IUserMapper;</span><br><span class="line">import com.loonycoder.domain.User;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class MybatisTest &#123;</span><br><span class="line"></span><br><span class="line">    private InputStream inputStream;</span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    private SqlSession session;</span><br><span class="line">    private IUserMapper userDao;</span><br><span class="line"></span><br><span class="line">    //before注解代表在测试方法执行前执行</span><br><span class="line">    @Before</span><br><span class="line">    public void init() throws Exception&#123;</span><br><span class="line">        //1.读取配置文件</span><br><span class="line">        inputStream = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        //2.创建SqlSessionFactory工厂</span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class="line">        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        //3.使用工厂创建SqlSession对象</span><br><span class="line">        session = sqlSessionFactory.openSession();</span><br><span class="line">        //4.使用SqlSession创建dao接口的代理对象</span><br><span class="line">        userDao = session.getMapper(IUserMapper.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //after注解代表在测试方法执行后执行</span><br><span class="line">    @After</span><br><span class="line">    public void destroy() throws Exception&#123;</span><br><span class="line">        //6.释放资源</span><br><span class="line">        session.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void selectTest() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        //5.使用代理对象执行方法</span><br><span class="line">        List&lt;User&gt; users= userDao.selectAll();</span><br><span class="line">        <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="/images/execResult1.png" srcset="/img/loading.gif" alt="执行结果"></p><hr><h3 id="Mybatis的保存操作"><a href="#Mybatis的保存操作" class="headerlink" title="Mybatis的保存操作"></a>Mybatis的保存操作</h3><h4 id="在mapper接口中新增保存方法"><a href="#在mapper接口中新增保存方法" class="headerlink" title="在mapper接口中新增保存方法"></a>在mapper接口中新增保存方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 保存用户</span><br><span class="line"> * @param user</span><br><span class="line"> */</span><br><span class="line">public void saveUser(User user);</span><br></pre></td></tr></table></figure><h4 id="在IUserMapper-xml中添加保存sql语句"><a href="#在IUserMapper-xml中添加保存sql语句" class="headerlink" title="在IUserMapper.xml中添加保存sql语句"></a>在IUserMapper.xml中添加保存sql语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"saveUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        insert into user (username,sex,birthday,address) values (<span class="comment">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：<br>#{}为mybatis的固定用法，用于取值。如果User实体类中的属性是自动生成的get/set，则直接写属性名称即可。<br>其次，参数一定要一一对应上</strong></p><h4 id="新建测试类执行-1"><a href="#新建测试类执行-1" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">insertTest</span></span>()&#123;</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setUserName(<span class="string">"Lisa"</span>);</span><br><span class="line">    user.setBirthday(new Date());</span><br><span class="line">    user.setAddress(<span class="string">"广东"</span>);</span><br><span class="line">    user.setSex(<span class="string">"女"</span>);</span><br><span class="line">    userDao.saveUser(user);</span><br><span class="line">    session.commit();//记得手动提交事务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：一定要手动提交事务，否则虽然不会报错，但是不会入表！！！</strong></p><h4 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="/images/execResult2.png" srcset="/img/loading.gif" alt="执行结果"></p><hr><h3 id="Mybatis的删除操作"><a href="#Mybatis的删除操作" class="headerlink" title="Mybatis的删除操作"></a>Mybatis的删除操作</h3><h4 id="在mapper接口中新增删除方法"><a href="#在mapper接口中新增删除方法" class="headerlink" title="在mapper接口中新增删除方法"></a>在mapper接口中新增删除方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 删除用户</span><br><span class="line">    * @param userId</span><br><span class="line">    */</span><br><span class="line">   public void deleteUser(Integer userId);</span><br></pre></td></tr></table></figure><h4 id="在IUserMapper-xml中添加删除sql语句"><a href="#在IUserMapper-xml中添加删除sql语句" class="headerlink" title="在IUserMapper.xml中添加删除sql语句"></a>在IUserMapper.xml中添加删除sql语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=<span class="string">"deleteUser"</span> parameterType=<span class="string">"java.lang.Integer"</span>&gt;</span><br><span class="line">        delete from user <span class="built_in">where</span> id = <span class="comment">#&#123;uid&#125;;</span></span><br><span class="line">    &lt;/delete&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：因为该方法只有一个参数，所以我们在sql中标注的uid部分其实是可以随便写的，因为mybatis只会找到这一个参数</strong></p><h4 id="新建测试类执行-2"><a href="#新建测试类执行-2" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void <span class="function"><span class="title">deleteTest</span></span>()&#123;</span><br><span class="line">       userDao.deleteUser(53);</span><br><span class="line">       session.commit();//记得手动提交事务</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果-2"><a href="#执行结果-2" class="headerlink" title="执行结果"></a>执行结果</h4><p>删除前：<br><img src="/images/execBefore.png" srcset="/img/loading.gif" alt="执行结果"><br>删除后：<br><img src="/images/execAfter.png" srcset="/img/loading.gif" alt="执行结果"></p><hr><h3 id="Mybatis的修改操作"><a href="#Mybatis的修改操作" class="headerlink" title="Mybatis的修改操作"></a>Mybatis的修改操作</h3><h4 id="在mapper接口中新增修改方法"><a href="#在mapper接口中新增修改方法" class="headerlink" title="在mapper接口中新增修改方法"></a>在mapper接口中新增修改方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 修改用户</span><br><span class="line"> * @param user</span><br><span class="line"> */</span><br><span class="line">public void updateUser(User user);</span><br></pre></td></tr></table></figure><h4 id="在IUserMapper-xml中添加修改sql语句"><a href="#在IUserMapper-xml中添加修改sql语句" class="headerlink" title="在IUserMapper.xml中添加修改sql语句"></a>在IUserMapper.xml中添加修改sql语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">"updateUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">    update user <span class="built_in">set</span> username = <span class="comment">#&#123;username&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><h4 id="新建测试类执行-3"><a href="#新建测试类执行-3" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">updateTest</span></span>()&#123;</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setId(41);</span><br><span class="line">    user.setUserName(<span class="string">"张三丰"</span>);</span><br><span class="line">    session.commit();//记得手动提交事务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果-3"><a href="#执行结果-3" class="headerlink" title="执行结果"></a>执行结果</h4><p>修改前：<br><img src="/images/execAfter.png" srcset="/img/loading.gif" alt="执行结果"><br>修改后：<br><img src="/images/execAfter1.png" srcset="/img/loading.gif" alt="执行结果"></p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java框架 - 数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis入门及搭建</title>
    <link href="/2018/09/30/Mybatis-1/"/>
    <url>/2018/09/30/Mybatis-1/</url>
    
    <content type="html"><![CDATA[<p>上大学的时候自学过一段时间mybatis框架，感觉很好用。<br>但是在工作中并没有用到，于是翻出之前的视频重新复习了一下。</p><hr><h3 id="Mybatis的配置方式开发"><a href="#Mybatis的配置方式开发" class="headerlink" title="Mybatis的配置方式开发"></a>Mybatis的配置方式开发</h3><h4 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h4><p>因为Mybatis是持久层框架，所以在此之前我们要做一些准备工作，首先我们要在Mysql中建好表并插入数据。<br>建表及导入sql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL auto_increment,</span><br><span class="line">  `username` varchar(32) NOT NULL COMMENT <span class="string">'用户名称'</span>,</span><br><span class="line">  `birthday` datetime default NULL COMMENT <span class="string">'生日'</span>,</span><br><span class="line">  `sex` char(1) default NULL COMMENT <span class="string">'性别'</span>,</span><br><span class="line">  `address` varchar(256) default NULL COMMENT <span class="string">'地址'</span>,</span><br><span class="line">  PRIMARY KEY  (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,<span class="string">'张三'</span>,<span class="string">'2018-02-27 17:47:08'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(2,<span class="string">'李四'</span>,<span class="string">'2018-03-02 15:09:37'</span>,<span class="string">'女'</span>,<span class="string">'深圳'</span>),(3,<span class="string">'王五'</span>,<span class="string">'2018-03-04 11:34:34'</span>,<span class="string">'女'</span>,<span class="string">'成都'</span>),(4,<span class="string">'赵六'</span>,<span class="string">'2018-03-04 12:04:06'</span>,<span class="string">'男'</span>,<span class="string">'上海'</span>),(5,<span class="string">'loonycoder'</span>,<span class="string">'2018-03-07 17:37:26'</span>,<span class="string">'男'</span>,<span class="string">'西安'</span>),(6,<span class="string">'望月'</span>,<span class="string">'2018-03-08 11:44:00'</span>,<span class="string">'女'</span>,<span class="string">'杭州'</span>);</span><br></pre></td></tr></table></figure><p>如图：<br><img src="/images/table.png" srcset="/img/loading.gif" alt="建表"></p><h4 id="二、新建项目"><a href="#二、新建项目" class="headerlink" title="二、新建项目"></a>二、新建项目</h4><p>我们这里要新建一个maven项目。<br><img src="/images/1.png" srcset="/img/loading.gif" alt="创建Maven项目"></p><p><img src="/images/2.png" srcset="/img/loading.gif" alt="创建Maven项目"></p><p><img src="/images/3.png" srcset="/img/loading.gif" alt="创建Maven项目"></p><p>创建完成之后，我们打开pom.xml文件引入依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.loonycoder&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;MybatisDemo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.4&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="三、创建表对象的映射实体类"><a href="#三、创建表对象的映射实体类" class="headerlink" title="三、创建表对象的映射实体类"></a>三、创建表对象的映射实体类</h4><p>因为mybatis是一个ORM（Object Relational Mapping）框架，所以我们要准备一个和表字段一一对应的实体类。</p><p><strong>注意</strong>：<br><strong>表中的字段名和实体类中的字段名字一定要一致！</strong><br><strong>实体类一定要实现Serializable接口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String username;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getUsername</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date <span class="function"><span class="title">getBirthday</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getAddress</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", username='"</span> + username + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                ", birthday=" + birthday +</span></span><br><span class="line"><span class="string">                ", address='</span><span class="string">" + address + '\'' +</span></span><br><span class="line"><span class="string">                '&#125;';</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="四、新建dao接口"><a href="#四、新建dao接口" class="headerlink" title="四、新建dao接口"></a>四、新建dao接口</h4><p>这里直接上代码，我在此新建了一个查询所有的方法，此处记住方法名和返回值类型，后续会用到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.domain.User;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IUserDao &#123;</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="五、创建mybatis的主配置文件"><a href="#五、创建mybatis的主配置文件" class="headerlink" title="五、创建mybatis的主配置文件"></a>五、创建mybatis的主配置文件</h4><p>该配置文件需要放在/resources目录下，配置文件的名称在具有规范性的前提下是随意起的，我这里采用了默认的规范(我发现很多人都这么起)</p><p>SqlMapConfig.xml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line">&lt;!--mybatis的主配置文件--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--配置环境--&gt;</span><br><span class="line">    &lt;environments default=<span class="string">"mysql"</span>&gt;</span><br><span class="line">        &lt;!--配置mysql的环境--&gt;</span><br><span class="line">        &lt;environment id=<span class="string">"mysql"</span>&gt;</span><br><span class="line">            &lt;!--配置事务类型--&gt;</span><br><span class="line">            &lt;transactionManager <span class="built_in">type</span>=<span class="string">"JDBC"</span>&gt;&lt;/transactionManager&gt;</span><br><span class="line">            &lt;!--配置数据源(连接池)--&gt;</span><br><span class="line">            &lt;dataSource <span class="built_in">type</span>=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">"driver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/MybatisDemo/"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"password"</span> value=<span class="string">"20141016"</span> /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IUserDao.xml"</span> /&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>配置数据源的时候，把url、username、password 修改成你自己的数据库链接、用户名和密码即可。</p><p>注意：<br><strong>下方的mapper部分的配置我接下来会讲，后续按照你自己配置的路径配置即可。</strong></p><hr><h4 id="六、配置mapper文件"><a href="#六、配置mapper文件" class="headerlink" title="六、配置mapper文件"></a>六、配置mapper文件</h4><p>前面虽然配置了mybatis主配置文件，但是我们在实际操作中如果存在多个对象的dao接口，主配置文件需要怎么准确找到该接口呢？<br>我们就需要为每个dao配置一个独立的配置文件<br>我习惯上把文件命名成 <strong>xxxMapper.xml</strong>，这里命名成xxxDao.xml是为了方便理解。<br>文件存放目录为/resources目录下，与实体对象dao接口的包同级。<br><img src="/images/mapperxml.png" srcset="/img/loading.gif" alt="xml文件配置"></p><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!--namespace需要配置dao的全限定类名--&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IUserDao"</span>&gt;</span><br><span class="line">    &lt;!--配置查询所有--&gt;</span><br><span class="line">    &lt;!--id一定要是方法的名称--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"findAll"</span> resultType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        select * from user;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="七、引入log4j"><a href="#七、引入log4j" class="headerlink" title="七、引入log4j"></a>七、引入log4j</h4><p>这个是可选操作，为了后期记录日志，我们可以采用log4j去实现。此处只是了解。<br>将log4j.properties文件放在/resources目录下即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set root category priority to INFO and its only appender to CONSOLE.</span></span><br><span class="line"><span class="comment">#log4j.rootCategory=INFO,CONSOLE             debug  info  warn  error  fatal</span></span><br><span class="line">log4j.rootCategory=debug, CONSOLE, LOGFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span></span><br><span class="line">log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE</span><br><span class="line"></span><br><span class="line"><span class="comment"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span></span><br><span class="line">log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n</span><br><span class="line"></span><br><span class="line"><span class="comment"># LOGFILE is set to be a File appender using a PatternLayout.</span></span><br><span class="line">log.appender.LOGFILE=org.apache.log4j.FileAppender</span><br><span class="line">log.appender.LOGFILE.FILE=/usr/gmx/LearnWorkspace</span><br><span class="line">log.appender.LOGFILE.Append=<span class="literal">true</span></span><br><span class="line">log.appender.LOGFILE.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n</span><br></pre></td></tr></table></figure><hr><h4 id="八、测试案例"><a href="#八、测试案例" class="headerlink" title="八、测试案例"></a>八、测试案例</h4><p>如此，我们的mybatis就搭建完成了，我们接下来测试一下。<br>在/test/java目录下新建一个test类<br>如图：<br><img src="/images/test.png" srcset="/img/loading.gif" alt="test类"></p><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.loonycoder.dao.IUserDao;</span><br><span class="line">import com.loonycoder.domain.User;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class MybatisTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        //1.读取配置文件</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        //2.创建SqlSessionFactory工厂</span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        //3.使用工厂创建SqlSession对象</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        //4.使用SqlSession创建dao接口的代理对象</span><br><span class="line">        IUserDao userDao = session.getMapper(IUserDao.class);</span><br><span class="line">        //5.使用代理对象执行方法</span><br><span class="line">        List&lt;User&gt; users= userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        //6.释放资源</span><br><span class="line">        session.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/testResult.png" srcset="/img/loading.gif" alt="运行结果"></p><hr><h3 id="Mybaits的注解方式开发"><a href="#Mybaits的注解方式开发" class="headerlink" title="Mybaits的注解方式开发"></a>Mybaits的注解方式开发</h3><p>Mybatis也为我们提供了基于注解的开发方式<br>基于注解开发意味着脱离xml配置，所以我们在上述项目中可以直接移除com/loonycoder/dao/IUserDao.xml文件<br>同时需要修改SqlMapConfig.xml中的映射配置文件部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line">&lt;!--mybatis的主配置文件--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--配置环境--&gt;</span><br><span class="line">    &lt;environments default=<span class="string">"mysql"</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">"mysql"</span>&gt;</span><br><span class="line">            &lt;!--配置事务--&gt;</span><br><span class="line">            &lt;transactionManager <span class="built_in">type</span>=<span class="string">"JDBC"</span>&gt;&lt;/transactionManager&gt;</span><br><span class="line">            &lt;!--配置数据源（连接池）--&gt;</span><br><span class="line">            &lt;dataSource <span class="built_in">type</span>=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">"driver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span> /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--此处做了修改，之前的属性是resource，现在改为class，并且指定到dao接口的全限定类名--&gt;</span><br><span class="line">        &lt;mapper class=<span class="string">"com.loonycoder.dao.IUserDao"</span> /&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>同时需要在dao接口的方法上添加注解@Select</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.domain.User;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IUserDao &#123;</span><br><span class="line">    @Select(<span class="string">"select * from user"</span>)</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/testResult.png" srcset="/img/loading.gif" alt="运行结果"></p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java框架 - 数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shiro会话管理</title>
    <link href="/2018/09/23/Shiro/"/>
    <url>/2018/09/23/Shiro/</url>
    
    <content type="html"><![CDATA[<h3 id="Shiro在线会话管理"><a href="#Shiro在线会话管理" class="headerlink" title="Shiro在线会话管理"></a>Shiro在线会话管理</h3><p>参考文章：</p><ul><li><a href="https://www.iteye.com/blog/jinnianshilongnian-2047643" target="_blank" rel="noopener">跟我学Shrio-在线会话</a></li><li><a href="https://mrbird.cc/Spring-Boot-Shiro%20session.html" target="_blank" rel="noopener">Spring Boot Shiro在线会话管理</a></li></ul><p>实现效果预览：<br><img src="/images/shiro1.png" srcset="/img/loading.gif" alt="实现效果预览"></p><p>Shiro提供一个对象org.apache.shiro.session.mgt.eis.SessionDAO，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。</p><p><img src="/images/shiro2.png" srcset="/img/loading.gif" alt="目录"></p><p>下面我们实现两个功能：</p><ul><li>获取在线会话列表</li><li>实现强制下线功能</li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><h5 id="ShiroConfig"><a href="#ShiroConfig" class="headerlink" title="ShiroConfig"></a>ShiroConfig</h5><p>这里我使用的是Redis来储存Shiro的Session信息，修改SessionDAO配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RedisSessionDAO <span class="function"><span class="title">redisSessionDAO</span></span>() &#123;</span><br><span class="line">    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();</span><br><span class="line">    redisSessionDAO.setRedisManager(redisManager());</span><br><span class="line">    <span class="built_in">return</span> redisSessionDAO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ConfigurationProperties(prefix = <span class="string">"redis.shiro"</span>)</span><br><span class="line">public RedisManager <span class="function"><span class="title">redisManager</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new RedisManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要将SessionDAO注入到SessionManager中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SessionManager <span class="function"><span class="title">sessionManager</span></span>() &#123;</span><br><span class="line">    DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();</span><br><span class="line">    defaultWebSessionManager.setCacheManager(cacheManager());</span><br><span class="line">    defaultWebSessionManager.setSessionDAO(sessionDAO());</span><br><span class="line">    <span class="built_in">return</span> sessionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将SessionManager注入到SecurityManager中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SecurityManager <span class="function"><span class="title">securityManager</span></span>() &#123;</span><br><span class="line">    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class="line">    securityManager.setRealm(realm());</span><br><span class="line"></span><br><span class="line">    //自定义sessionManager</span><br><span class="line">    securityManager.setSessionManager(sessionManager());</span><br><span class="line">    //自定义缓存实现</span><br><span class="line">    securityManager.setCacheManager(cacheManager());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> securityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取在线会话列表"><a href="#获取在线会话列表" class="headerlink" title="获取在线会话列表"></a>获取在线会话列表</h4><h5 id="OnlineUser-java"><a href="#OnlineUser-java" class="headerlink" title="OnlineUser.java"></a>OnlineUser.java</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class OnlineUser implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private String id; //sessionId</span><br><span class="line"></span><br><span class="line">    private String uid; //用户ID</span><br><span class="line"></span><br><span class="line">    private String username; //用户名</span><br><span class="line"></span><br><span class="line">    private String host; //主机地址</span><br><span class="line"></span><br><span class="line">    private String address; //地理位置</span><br><span class="line"></span><br><span class="line">    @DateTimeFormat(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    @JsonFormat(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    private Date startTime; //用户开始访问时间</span><br><span class="line"></span><br><span class="line">    @DateTimeFormat(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    @JsonFormat(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    private Date endTime; //用户最后访问时间</span><br><span class="line"></span><br><span class="line">    private Long timeout; //超时时间</span><br><span class="line"></span><br><span class="line">    private String status; //状态</span><br><span class="line"></span><br><span class="line">    public void setHost(String host) &#123;</span><br><span class="line">        this.host = host.equals(<span class="string">"0:0:0:0:0:0:0:1"</span>) ? <span class="string">"127.0.0.1"</span> : host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>编写获取在线会话列表的service层实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public List&lt;OnlineUser&gt; <span class="function"><span class="title">list</span></span>() &#123;</span><br><span class="line">    List&lt;OnlineUser&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    Collection&lt;Session&gt; sessions = sessionDAO.getActiveSessions(); //获取在线会话的集合</span><br><span class="line">    <span class="keyword">for</span> (Session session : sessions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (session != null) &#123;</span><br><span class="line">            OnlineUser onlineUser = new OnlineUser();</span><br><span class="line">            SimplePrincipalCollection principalCollection;</span><br><span class="line">            User user;</span><br><span class="line">            //判断此session是否还在登录状态</span><br><span class="line">            <span class="keyword">if</span> (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) &#123;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                //如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据</span><br><span class="line">                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);</span><br><span class="line">                user = (User) principalCollection.getPrimaryPrincipal();</span><br><span class="line">                onlineUser.setUid(user.getId().toString());</span><br><span class="line">                onlineUser.setUsername(user.getUsername());</span><br><span class="line">            &#125;</span><br><span class="line">            onlineUser.setId(session.getId().toString());</span><br><span class="line">            onlineUser.setHost(session.getHost());</span><br><span class="line">            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));</span><br><span class="line">            onlineUser.setStartTime(session.getStartTimestamp());</span><br><span class="line">            onlineUser.setEndTime(session.getLastAccessTime());</span><br><span class="line">            long timeout = session.getTimeout();</span><br><span class="line">            onlineUser.setTimeout(timeout);</span><br><span class="line">            onlineUser.setStatus(timeout == 0L ? <span class="string">"0"</span> : <span class="string">"1"</span>); //0在线 1下线</span><br><span class="line">            list.add(onlineUser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getActiveSessions()将获取到所有有效的Session集合，通过DefaultSubjectContext.PRINCIPALS_SESSION_KEY可以判断当前系统Subject中的session key和sessions列表中的session是否匹配，不匹配则session无效。<br>session.getHost()顾名思义就是获取Host主机地址即IP地址。<br>AddressUtil.getAddress(session.getHost())是通过IP地址查询其详细的地理位置，使用了ip2region开源库。</p><h5 id="根据IP查询地址位置"><a href="#根据IP查询地址位置" class="headerlink" title="根据IP查询地址位置"></a>根据IP查询地址位置</h5><p>开源地址：<a href="https://github.com/lionsoul2014/ip2region" target="_blank" rel="noopener">https://github.com/lionsoul2014/ip2region</a><br>引入ip2region的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.lionsoul&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ip2region&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>拷贝ip2region.db文件（开源仓库中找）到项目的resources/config/下<br>参考官方实例代码写工具类AddressUtil.java<br>官方实例：<a href="https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java" target="_blank" rel="noopener">https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class AddressUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static String getAddress(String ip) &#123;</span><br><span class="line">        //db</span><br><span class="line">        String dbPath = AddressUtil.class.getResource(<span class="string">"/config/ip2region.db"</span>).getPath();</span><br><span class="line"></span><br><span class="line">        File file = new File(dbPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            throw new GlobalException(<span class="string">"缺少 ip2region.db库"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            DbConfig config = new DbConfig();</span><br><span class="line">            DbSearcher searcher = new DbSearcher(config, file.getPath());</span><br><span class="line">            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            //define the method</span><br><span class="line">            Method method = null;</span><br><span class="line">            switch (algorithm) &#123;</span><br><span class="line">                <span class="keyword">case</span> DbSearcher.BTREE_ALGORITHM:</span><br><span class="line">                    method = searcher.getClass().getMethod(<span class="string">"btreeSearch"</span>, String.class);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DbSearcher.BINARY_ALGORITHM:</span><br><span class="line">                    method = searcher.getClass().getMethod(<span class="string">"binarySearch"</span>, String.class);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DbSearcher.MEMORY_ALGORITYM:</span><br><span class="line">                    method = searcher.getClass().getMethod(<span class="string">"memorySearch"</span>, String.class);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DataBlock dataBlock = null;</span><br><span class="line">            <span class="keyword">if</span> (!Util.isIpAddress(ip)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Error: Invalid ip address"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dataBlock = (DataBlock) method.invoke(searcher, ip);</span><br><span class="line">            reader.close();</span><br><span class="line">            searcher.close();</span><br><span class="line">            <span class="built_in">return</span> dataBlock.getRegion();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结"><a href="#结" class="headerlink" title="结"></a>结</h5><p>当前端请求/online/list接口时，将List<OnlineUser>结合数据返回给前端渲染即可。</p><h4 id="实现强制下线功能"><a href="#实现强制下线功能" class="headerlink" title="实现强制下线功能"></a>实现强制下线功能</h4><h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">"/forceLogout"</span>)</span><br><span class="line">public ResponseCode forceLogout(String id) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        sessionService.forceLogout(id);</span><br><span class="line">        <span class="built_in">return</span> ResponseCode.SUCCESS();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="built_in">return</span> ResponseCode.ERROR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个id是sessionID</p><h5 id="service实现"><a href="#service实现" class="headerlink" title="service实现"></a>service实现</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void forceLogout(String id) &#123;</span><br><span class="line">    Session session = sessionDAO.readSession(id);</span><br><span class="line">    session.setTimeout(0L);</span><br><span class="line">    session.stop();</span><br><span class="line">    sessionDAO.delete(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>权限框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue路由</title>
    <link href="/2018/09/15/Vue4/"/>
    <url>/2018/09/15/Vue4/</url>
    
    <content type="html"><![CDATA[<h3 id="Vue路由"><a href="#Vue路由" class="headerlink" title="Vue路由"></a>Vue路由</h3><h4 id="什么是Vue路由？"><a href="#什么是Vue路由？" class="headerlink" title="什么是Vue路由？"></a>什么是Vue路由？</h4><ul><li><strong>后端路由：</strong>即请求的URL地址都对应后端的接口，请求URL响应对应的服务器的资源。</li><li><strong>前端路由：</strong>对于单页面程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以单页面程序中的页面跳转主要通过hash实现。</li></ul><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><h5 id="导入类库"><a href="#导入类库" class="headerlink" title="导入类库"></a>导入类库</h5><p>首先需要导入vue-router组件类库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue-router.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当导入类库后，window全局对象中就存在了一个路由的构造函数： VueRouter；就像导入Vue类库后存在一个Vue的构造函数一样，我们能够通过new VueRouter的方式实例化路由对象。<br>如果你使用了new VueRouter({});构造函数来实例化了一个路由对象，你会发现浏览器路径中会出现#/路径，这个路径就是前面讲到的URL中的hash，他并不会向后端发送任何请求，而仅仅是作页面跳转，如果你#/后拼接了一个不存在的路径，自然也不会进行跳转，页面也不会发送任何请求。<br><strong>实例：</strong><br><img src="/images/vue15.png" srcset="/img/loading.gif" alt="vue"></p><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>上面我们讲到了使用new VueRouter({})的方式实例化一个路由对象，其中包含几个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 给路由对象创建一个容器，包裹在父组件`app`内</span><br><span class="line">        相当于一个占位符，路由规则匹配到的组件内容就会展示到`&lt;router-view&gt;&lt;/router-view&gt;`中</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- ===============分割线===================== --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- JavaScript --&gt;</span><br><span class="line">//创建login组件</span><br><span class="line">var login = &#123;</span><br><span class="line">    template: <span class="string">'login组件'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建register组件</span><br><span class="line">var register = &#123;</span><br><span class="line">    template: <span class="string">'register组件'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Router实例</span><br><span class="line">var 路由对象名称 = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123; path: <span class="string">'/监听URL路径'</span>, component: login(组件名称) &#125;,</span><br><span class="line">        &#123; path: <span class="string">'/监听URL路径'</span>, component: register(组件名称) &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Vue实例</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">'app'</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    router: 路由对象名称   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>1、routes 表示这个路由对象中的 路由匹配规则，可以存在多个规则（注意：这里是routes而不是routers）</li><li>2、属性一：path 表示监听哪个路由连接地址，即你想跳转都哪个路径上，应在这里注册实现跳转到对应的组件上</li><li>3、属性二：component 表示如果路由匹配了前面的path，则展示component属性对应的那个组件</li><li>4、component的属性值必须是一个组件的模板对象，不能是组件的引用名称</li><li>5、经过1-4的步骤基本完成了路由对象的创建，下面要将这个路由对象注入到Vue实例中，使用router: 组件对象名称实现</li><li>6、创建对应需要监听的组件，如上我们创建了login和register组件，与之前讲的不同是这里是一个var 组件名称其值是一个组件对象，和之前的Vue.component方式相似，但是这里仅仅是一个组件对象，并没有注册到Vue实例中，因为没有组件名称，所以不能在HTML中使用&lt;login&gt;&lt;/login&gt; ，注意这里的login是组件对象的名称。</li></ul><p><strong>步骤：</strong></p><ul><li>1、创建router实例new VueRouter，完成相关属性的定义；</li><li>2、将这个路由对象注册到Vue实例中，使用router: 路由对象名称的方式；</li><li>3、创建第一步中定义的组件名称对应的组件，直接在&lt;script&gt;中定义var组件对象名称即可，在template中定义具体的HTML视图，或是通过template: ‘#id’引用外部视图也行。</li><li>4、在Vue实例控制域app中，创建&lt;router-view&gt;&lt;/router-view&gt;，相当于router容器，你想在页面上展示几个组件就应该在页面中创建几个容器。</li></ul><p>如上，我们可以写具体的跳转链接了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app&gt;</span></span><br><span class="line"><span class="string">    &lt;a href="</span><span class="comment">#/login"&gt;登录&lt;/a&gt;</span></span><br><span class="line">    &lt;a href=<span class="string">"#/register"</span>&gt;注册&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如上，当我们点击登录或注册，Vue-router就会监听都对应的URL地址，然后在path规则中刚好匹配到规则login，那么就会跳转到对应的组件component: login的login组件中。<br>可能你会疑惑了，为什么这里的href需要写为#/login而不是/login或login，你尝试一下就知道了，因为vue-router监听URL地址是基于hash的，不加#/就会找不到路径。<br>如果你觉得每次都加#/麻烦的话，Vue-router页提供了一个Tag:&lt;router-link to=”URL地址”&gt;&lt;/router-link&gt;，其在浏览器中会被解析为&lt;a&gt;标签。</p><p><strong>实例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">        &lt;a href=<span class="string">"#/login"</span>&gt;登录&lt;/a&gt;</span><br><span class="line">        &lt;router-link to=<span class="string">"register"</span>&gt;注册&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue-router.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">        var login = &#123;</span><br><span class="line">            template: <span class="string">'&lt;h2&gt;登录组件&lt;/h2&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var register = &#123;</span><br><span class="line">            template: <span class="string">'&lt;h2&gt;注册组件&lt;/h2&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var routerObj = new VueRouter(&#123;</span><br><span class="line">            routes: [</span><br><span class="line">                &#123; path: <span class="string">'/login'</span>, component: login &#125;,</span><br><span class="line">                &#123; path: <span class="string">'/register'</span>, component: register &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;&#125;,</span><br><span class="line">            methods: &#123;&#125;,</span><br><span class="line">            router: routerObj</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>但是上面的实例中，我们发现默认进入的根路径中仅有一个父组件名称，一般我们的登录页面应该直接显示登录框，所以vue-router提供了重定向的动能{path: ‘’, redirect: ‘’}，即在router: []中监听根路径，如果监听都访问的是根路径就重定向到登录URL就好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var routerObj = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123; path: <span class="string">'/'</span>, redirect: <span class="string">'/login'</span> &#125;,</span><br><span class="line">        &#123; path: <span class="string">'/login'</span>, component: login &#125;,</span><br><span class="line">        &#123; path: <span class="string">'/register'</span>, component: register &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="路由参数传递"><a href="#路由参数传递" class="headerlink" title="路由参数传递"></a>路由参数传递</h4><p>在进行页面跳转，即路由的时候，我们可能需要在发送URL时传递一些参数，常见的就如<a href="http://www.loonycoder.com/api?id=1&amp;name=&#39;loonycoder&#39;" target="_blank" rel="noopener">http://www.loonycoder.com/api?id=1&amp;name=&#39;loonycoder&#39;</a>这种格式。<br>那么在URL中传递的参数，vue-router提供了一种获取方式：this.$route。<br>那么什么时候能获取到传递的参数呢？ 回顾前面讲到的Vue声明周期函数，那么在自定义组件中自然也存在生命周期函数，所以最早操作组件data和methods中数据的阶段就是created这个声明周期函数的阶段。<br>实例：<br><img src="/images/vue16.png" srcset="/img/loading.gif" alt="vue"><br><img src="/images/vue17.png" srcset="/img/loading.gif" alt="vue"></p><p>上面打印的值中，我们能看到，我们再VueRouter中创建的path匹配规则，实际在HTML中会被渲染为相关的正则表达式，来实现路径的匹配。<br>其次，我们还能发现，在URL中拼接的参数id在this.$route对象的query属性中，我们通过this.$route.query.id即可获得传递的id值：2。</p><h4 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><p>路由嵌套，顾名思义即在父级路由内部存在子路由。例如：</p><blockquote><p>根路径：<a href="http://www.loonycoder.com" target="_blank" rel="noopener">http://www.loonycoder.com</a><br>父级路由地址：<a href="http://www.loonycoder.com/api" target="_blank" rel="noopener">http://www.loonycoder.com/api</a><br>子级路由地址：<a href="http://www.loonycoder.com/api/login" target="_blank" rel="noopener">http://www.loonycoder.com/api/login</a></p></blockquote><p><strong>实例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;router-link to=<span class="string">"/account"</span>&gt;Account&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;这是Account组件&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;router-link to=<span class="string">"/account/login"</span>&gt;登录&lt;/router-link&gt;</span><br><span class="line">            &lt;router-link to=<span class="string">"/account/register"</span>&gt;注册&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">            &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue-router.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">        var account = &#123;</span><br><span class="line">            template: <span class="string">'#tmp'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var login = &#123;</span><br><span class="line">            template: <span class="string">'&lt;h2&gt;登录组件&lt;/h2&gt;'</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var register = &#123;</span><br><span class="line">            template: <span class="string">'&lt;h2&gt;注册组件&lt;/h2&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var routerObj = new VueRouter(&#123;</span><br><span class="line">            routes: [</span><br><span class="line">                &#123; </span><br><span class="line">                    path: <span class="string">'/account'</span>, </span><br><span class="line">                    component: account,</span><br><span class="line">                    children: [</span><br><span class="line">                        &#123; path: <span class="string">'login'</span>, component: login &#125;,</span><br><span class="line">                        &#123; path: <span class="string">'register'</span>, component: register &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;&#125;,</span><br><span class="line">            methods: &#123;&#125;,</span><br><span class="line">            router: routerObj</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如上，我们使用了routes: []中的另外一个属性：children，顾名思义就是表示这个父规则/account下存在一些子规则，且在URL中应该体现出来：<br><img src="/images/vue18.png" srcset="/img/loading.gif" alt="vue"></p><p><strong>注意：</strong><br>在children中定义的子组件的path规则不能加/，即如上的，直接写path: login即可，这样请求account/login地址时，vue-router会找/account规则下的login规则，且不加/vue-router才会自动将login视为account下的子路径，并自动拼接account/，否则不会自动拼接，那么也无法完成路由的嵌套。</p><h4 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h4><p>我们常见的后台开发页面，经常遇到上、左、中的布局方式；那么以前我们可能使用iframe实现页面间的跳转，但是现在我们学习的路由要比其更加的方便好用。<br><strong>命名视图</strong>的思想就是为每一个页面展示的视图都起一个名字，目的是为了为每个&lt;router-view&gt;&lt;/router-view&gt;容器刚好匹配一个指定的视图。使用方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view name=<span class="string">"left"</span>&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view name=<span class="string">"main"</span>&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line">routes: [</span><br><span class="line">    &#123; </span><br><span class="line">        path: <span class="string">'/'</span>, components: &#123;</span><br><span class="line">            <span class="string">'default'</span>: header</span><br><span class="line">            <span class="string">'left'</span>: left</span><br><span class="line">            <span class="string">'main'</span>: main</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解释：</strong><br>其中的path是根路径/，而使用components代替之前的component，目的就是可匹配其下的多个规则；default表示默认的视图组件是header这个组件，即会匹配到第一个&lt;router-view&gt;视图容器中；下面的两个组件会根据name名称需要对应的组件。<br>实现上、左、中的布局：<br><strong>思路：</strong><br>1、我们需要创建三个组件，名称分别为：header、left、main；并且在app中创建三个&lt;router-view&gt;&lt;/router-view&gt;路由容器。<br>2、采用<strong>命名视图</strong>的方式为每个视图都起一个名字：&lt;router-view name=”left”&gt;&lt;/router-view&gt; …<br>3、注册路由实例。<br>实例：<br><img src="/images/vue19.png" srcset="/img/loading.gif" alt="vue"><br><img src="/images/vue20.png" srcset="/img/loading.gif" alt="vue"></p>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件</title>
    <link href="/2018/09/07/Vue3/"/>
    <url>/2018/09/07/Vue3/</url>
    
    <content type="html"><![CDATA[<h4 id="Vue创建组件"><a href="#Vue创建组件" class="headerlink" title="Vue创建组件"></a>Vue创建组件</h4><h5 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h5><p>什么是组件？组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样地方功能，就可以去调用对应的组件即可。<br>组件化和模块化的区别：</p><ul><li>模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的只能单一；</li><li>组件化：是从UI界面的角度进行划分的；前端的组件化，方便了UI组件的重用；</li></ul><h5 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h5><p><strong>方式一</strong><br>1、使用Vue.extend来创建全局的Vue组件<br>2、通过template属性来指定组件要展示的HTML结构<br>3、通过Vue.component()定义全局组件<br>4、在HTML指定位置通过Tag标签的形式应用你的组件，组件的名称即是tag标签的名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">&lt;!-- 组件的名称即为对应tag标签的名称 --&gt;</span><br><span class="line">&lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 创建组件</span><br><span class="line">var com1 = Vue.extend(&#123;</span><br><span class="line">template: <span class="string">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 使用Vue.component(<span class="string">'组件的名称'</span>, 创建出来的组件模板对象)，定义全局组件</span><br><span class="line">Vue.component(<span class="string">'mycom1'</span>, com1);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>用Vue.component()定义组件名称的时候有两种命名方式：1、驼峰命名：Xxx；2、xxx。注意，使用驼峰命名时，tag标签不能使用驼峰名称，应将相应的大写字母替换为-加小写字母，例如：Vue.component(‘myCom’, com1)，那么tag标签应为： &lt;my-com&gt; &lt;/my-com&gt;</li></ul><p><strong>方式二</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 组件的名称即为对应tag标签的名称 --&gt;</span><br><span class="line">&lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">// 使用Vue.component(<span class="string">'组件的名称'</span>, 创建出来的组件模板对象)，定义全局组件</span><br><span class="line">Vue.component(<span class="string">'mycom1'</span>, Vue.extend(&#123;</span><br><span class="line">template: <span class="string">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class="line">&#125;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>方式二就像是方式一的简化版，但是注意：<br>在template中定义的内容只能存在一个根节点元素，即上面例子中template中不能出现和 &lt;h3&gt;平级的标签。<br>比如下面这种写法就是<strong>错误的</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'mycom1'</span>, Vue.extend(&#123;</span><br><span class="line">template: <span class="string">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;'</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>解决办法就是，外层嵌套一个根标签就行了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'mycom1'</span>, Vue.extend(&#123;</span><br><span class="line">template: <span class="string">'&lt;div&gt;&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;'</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p><strong>方式三</strong><br>1、JavaScript中仍使用Vue.component来定义全局组件，和方式二相似，但是里面不再是template: ‘HTML结构’了，而是引用一个外部标签的id值，即template:’id’。<br>2、在被Vue实例控制的app外面，定义&lt;template id=”id”&gt;你的HTML结构&lt;/template&gt;<br>这种方式的好处就是是就组件代码都是定义在HTML结构中的，有智能代码提示；而JavaScript中定义组件仅是写一个引用。<br>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">&lt;!-- 页面引用 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">&lt;!-- 比如仅存在一个根节点元素 --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;&lt;/h1&gt;&gt;</span><br><span class="line">&lt;h2&gt;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">//JavaScript部分</span><br><span class="line">Vue.component(<span class="string">'mycom'</span>, &#123;</span><br><span class="line">template: <span class="string">'#tmp'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>定义私</strong>有组件<br>除了上面讲到的定义全局组件，我们也可以定义私有组件，使用components: {}函数。<br>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;tem&gt;&lt;/tem&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">    &lt;h3&gt;这是私有组件&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        tem: &#123;</span><br><span class="line">            template: <span class="string">'#tmp'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="组件元素"><a href="#组件元素" class="headerlink" title="组件元素"></a>组件元素</h5><p><strong>组件的</strong>data<br>在组件中，同样可以有自己的data数据，但是用法和Vue实例中的data用法有所不同：<br>1、组件中的data必须是一个方法，即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function"><span class="title">function</span></span>()&#123; &#125;</span><br></pre></td></tr></table></figure><p>2、组件中的data方法必须返回一个Object对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">Vue.component(<span class="string">'mycom1'</span>, Vue.extend(&#123;</span><br><span class="line">data: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"><span class="built_in">return</span> &#123;</span><br><span class="line">msg: <span class="string">'这是组件的data'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">template: <span class="string">'&lt;h3&gt;这是使用Vue.extend 创建的组件-- &#123;&#123;msg&#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组件的</strong>切换<br>在遇到登录注册表单时，通常我们需要对两个按钮进行切换实现显示不同的表单，那么Vue中的组件切换正符合了这个功能要求。</p><p><strong>方式一</strong></p><p>可以使用Vue提供的v-if和v-else来实现两个组件间的切换，但是，仅支持切换两个组件</p><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> @click.prevent=<span class="string">"flag=true"</span>&gt;登录&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> @click.prevent=<span class="string">"flag=false"</span>&gt;注册&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">    &lt;login v-if=<span class="string">"flag"</span>&gt;&lt;/login&gt;</span><br><span class="line">    &lt;register v-else=<span class="string">"flag"</span>&gt;&lt;/register&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=<span class="string">"login"</span>&gt;</span><br><span class="line">    &lt;h3&gt;这是登录表单&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=<span class="string">"register"</span>&gt;</span><br><span class="line">&lt;h3&gt;这是注册表单&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">// 创建登录组件</span><br><span class="line">Vue.component(<span class="string">'login'</span>, &#123;</span><br><span class="line">template: <span class="string">'#login'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 创建注册组件</span><br><span class="line">Vue.component(<span class="string">'register'</span>, &#123;</span><br><span class="line">template: <span class="string">'#register'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">    flag: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>定义flag参数，当flag=true就显示组件，当flar=false就隐藏组件</p><p><strong>方式二</strong></p><p>Vue提供了component来展示对应名称的组件。其中component是一个占位符，:is属性，可以用来指定要展示的组件名称</p><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> @click.prevent=<span class="string">"comName='login'"</span>&gt;登录&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> @click.prevent=<span class="string">"comName='register'"</span>&gt;注册&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">    &lt;component :is=<span class="string">"comName"</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=<span class="string">"login"</span>&gt;</span><br><span class="line">    &lt;h3&gt;这是登录表单&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=<span class="string">"register"</span>&gt;</span><br><span class="line">&lt;h3&gt;这是注册表单&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">// 创建登录组件</span><br><span class="line">Vue.component(<span class="string">'login'</span>, &#123;</span><br><span class="line">template: <span class="string">'#login'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 创建注册组件</span><br><span class="line">Vue.component(<span class="string">'register'</span>, &#123;</span><br><span class="line">template: <span class="string">'#register'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">    comName: <span class="string">'login'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>即使用Vue提供的component，它能够实现自动对组件进行展示和隐藏，通过:is=’组件名称’。</p><h5 id="父子组件间传值"><a href="#父子组件间传值" class="headerlink" title="父子组件间传值"></a>父子组件间传值</h5><p><strong>父组件</strong>给子组件传值</p><p>父组件给子组件传值，即实现在子组件中调用父组件中的methods或是获取父组件中的data.</p><p><strong>传参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1&gt;&lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        msg: <span class="string">'这是父组件data值'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">"这是父组件的show方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">        com1: &#123;</span><br><span class="line">        template: <span class="string">'&lt;h2&gt;这是子组件&lt;/h2&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如上，当我们直接在子组件中引用父组件data中定义的msg数据，将上面的修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com1: &#123;</span><br><span class="line">template: <span class="string">'&lt;h2&gt;这是子组件--&#123;&#123;msg&#125;&#125;&lt;/h2&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就会报错。所以就证实了默认在子组件中不能访问父组件中的data或methods。<br>为了解决子组件获取父组件数据，Vue提供了以下方式获取：</p><ul><li>1、父组件在引用子组件的时候，通过属性绑定的方式v-bind:，把需要传递给子组件的数据以属性绑定的形式传递到子组件内部，供子组件使用。</li><li>2、在子组件中，通过props: []获取到父组件传递过来的数据；这样就完成了父组件向子组件传值</li></ul><p><strong>实例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1 :fatoson=<span class="string">"msg"</span>&gt;&lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        msg: <span class="string">'这是父组件data值'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">        com1: &#123;</span><br><span class="line">        template: <span class="string">'&lt;h2&gt;这是子组件--&#123;&#123;fatoson&#125;&#125;&lt;/h2&gt;'</span>,</span><br><span class="line">        props: [<span class="string">'fatoson'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如上，我们在子组件实例中使用了v-bind绑定了一个参数fatoson，其值是：msg即在父组件data中定义的值；那么就相当于父组件的一个data数据被Vue绑定到了子组件实例中，且父组件data值的别名是fatoson，那么在子组件中通过props: []属性就能获取到这个别名，然后就实现了父组件向子组件传值。需要注意以下：</p><ul><li>1、我们可以将为子组件绑定的参数名称是父组件值的别名。即此时msg相当于fatoson。</li><li>2、注意命名中若是驼峰命名，在HTML中必须用-替换。</li><li>3、注意props是Vue为父组将向子组件传值提供的一个参数，且他是唯一的数组类型的。</li><li>4、注意子组件通过props获取到的父组件的值是只读的，即不能修改。</li></ul><p><strong>传方法</strong><br>上面讲了父组件给子组件传递普通的参数，下面我们将了解到父组件怎样给子组件传递方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1 @open=<span class="string">"show"</span>&gt;&lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"myclick"</span> value=<span class="string">"子组件按钮，点击触发父组件方法"</span>/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        msg: <span class="string">'这是父组件data值'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">"这是父组件的show方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">        com1: &#123;</span><br><span class="line">        template: <span class="string">'#tmp'</span>,</span><br><span class="line">        props: [<span class="string">'fatoson'</span>],</span><br><span class="line">        methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">myclick</span></span>()&#123;</span><br><span class="line">        this.<span class="variable">$emit</span>(<span class="string">'open'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>1、这里子组件的template数据引用外部的&lt;template&gt;&lt;/template&gt;中的HTML代码。</li><li>2、与传值思路相同，传递方法也需要在子组件实例中使用v-on即@来绑定方法，方法别名@open，方法的值是show是在父组件中定义的方法名。</li><li>3、与传值思路相同，传值使用了props来接受传递的参数，那么传方法提供了$emit()元素</li></ul><p><strong>综合</strong><br>上面讲的父组件向子组件传递方法，那么既然是方法就肯定能传递方法参数。我们只需要在父组件方法中指定值名称即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@子组件接收的方法别名=<span class="string">"父组件中的方法(父组件中的参数值或data)"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1 @open=<span class="string">"show(fatosonval)"</span>&gt;&lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"myclick"</span> value=<span class="string">"子组件按钮，点击触发父组件方法"</span>/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        fatosonval: &#123;</span><br><span class="line">        id: <span class="string">'1'</span>,</span><br><span class="line">        name: <span class="string">'Loonycoder'</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        show(data)&#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">        com1: &#123;</span><br><span class="line">        template: <span class="string">'#tmp'</span>,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">myclick</span></span>()&#123;</span><br><span class="line">        this.<span class="variable">$emit</span>(<span class="string">'open'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件</strong>给父组件传值<br>即实现在父组件中调用子组件中的方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1 @open=<span class="string">"show"</span>&gt;&lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"myclick"</span> value=<span class="string">"子组件按钮，点击触发父组件方法"</span>/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        fatosonval: null</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        show(data)&#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">        com1: &#123;</span><br><span class="line">        template: <span class="string">'#tmp'</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">        sonval: &#123; name: <span class="string">'Loonycoder'</span>, age: 24 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">myclick</span></span>()&#123;</span><br><span class="line">        this.<span class="variable">$emit</span>(<span class="string">'open'</span>, this.sonval);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>之前我们实现父组件向子组件传值的时候，需要在@open()中指定父组件中的data，而子组件给父组件传值的时候就不需要再指定了，而是直接在调用子组件中的open（这是父组件方法的别名），将子组件的值写进$emit(‘方法别名’, data参数)中即可。</p><h5 id="Vue获取DOM元素和组件"><a href="#Vue获取DOM元素和组件" class="headerlink" title="Vue获取DOM元素和组件"></a>Vue获取DOM元素和组件</h5><p>首先我们需要明白的就是Vue并不提倡我们操作DOM元素，Vue的宗旨就是让我们只关心业务逻辑。<br>那么通常我们需要获取一个如&lt;h2&gt;&lt;/h2&gt;中的值，采用原生JS通常需要先为tag标签定义一个id属性，然后通过JS代码document.getElementById(‘id’).innterText来获取到&lt;h2&gt;中的文本数据，而Vue也实现了操作原生DOM的功能：</p><ul><li>在需要获取的HTML标签中指定<code>ref</code>属性，其值可自定义。</li><li>在Vue实例中，使用<code>this.$refs.指定的值</code>来获取DOM对象，进行操作。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 ref=<span class="string">"h2"</span>&gt;这是h2的文本数据&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">console.log(this.<span class="variable">$refs</span>.h2.innerText);</span><br></pre></td></tr></table></figure></li></ul><p><strong>通过$refs还能轻易获取子组件中的data和methods数据</strong><br>首先需要为子组件引用实例定义ref=”com1”属性，然后在Vue实例中通过this.$refs.com1即可获取子组件中的所有对象，即还能获取到子组件中的data和methods<br>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1 ref=<span class="string">"com1"</span>&gt;&lt;/com1&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"show"</span> value=<span class="string">"获取元素"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h2 ref=<span class="string">"h2"</span>&gt;这是父组件&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">                // console.log(this.<span class="variable">$refs</span>.h2.innerText);</span><br><span class="line">                // console.log(this.<span class="variable">$refs</span>.com1); //获取子组件中的所有实例对象</span><br><span class="line">                // console.log(this.<span class="variable">$refs</span>.com1.sonval); //获取子组件中定义的data值</span><br><span class="line">                console.log(this.<span class="variable">$refs</span>.com1.sonshow()); //调用子组件中定义的方法</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">            com1: &#123;</span><br><span class="line">                template: <span class="string">'#tmp'</span>,</span><br><span class="line">                <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">                    <span class="built_in">return</span> &#123;</span><br><span class="line">                        sonval: &#123; name: <span class="string">'Loonycoder'</span>, age: 24 &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    <span class="function"><span class="title">sonshow</span></span>() &#123;</span><br><span class="line">                        console.log(<span class="string">'子组件的方法'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue过滤器和Vue-resource</title>
    <link href="/2018/08/30/Vue2/"/>
    <url>/2018/08/30/Vue2/</url>
    
    <content type="html"><![CDATA[<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>之前我们学习了Vue的 <strong>vue基本指令</strong> 进阶学习，我们需要了解Vue的过滤器：Vue.js允许你自定义过滤器，可被用作一些常见元素的格式化。过滤器可以用在两个地方：mustache插值和v-bind表达式。<br>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 过滤器名称 | <span class="keyword">function</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>定义：</strong><br>Vue提供了两种方式创建过滤器：</p><ul><li>1、全局过滤器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'过滤器名称'</span>, <span class="function"><span class="title">function</span></span>()&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li>2、私有过滤器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Vue()(&#123;</span><br><span class="line">    el: <span class="string">''</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line">        过滤器名称: <span class="function"><span class="title">function</span></span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;&#123;&#123; msg | myFilters(<span class="string">'时光'</span>) &#125;&#125;&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">Vue.filter(<span class="string">'myFilters'</span>, <span class="keyword">function</span>(data, pattern)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pattern == <span class="string">'时光'</span>)&#123;</span><br><span class="line">        var old = data.substring(0,4);</span><br><span class="line">        <span class="built_in">return</span> old + <span class="string">',时光路口。'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>解释：</strong><br>如上：Vue提供的全局过滤器，直接使用Vue调用，而不是定义在Vue实例中</p><ul><li>Vue.filter()中第一个参数是过滤器名称，第二个参数是function(){}</li><li>function(){}中还有两个参数，第一个参数是原始的值，第二个参数是你想给过滤器方法传递的值。</li></ul><h4 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;&#123;&#123; msg | myFilters(<span class="string">'望月'</span>) &#125;&#125;&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">var vm2 = new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app2'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">'loonycoder！'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line"></span><br><span class="line">        myFilters: <span class="keyword">function</span>(data, pattern) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pattern == <span class="string">'望月'</span>)&#123;</span><br><span class="line">                var old = data.substring(0,4);</span><br><span class="line">                <span class="built_in">return</span> old + <span class="string">',loonycoder'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>私有过滤器和全局过滤器用法基本相同，仅仅是作用于不同而已。</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p>在我们搜索商品时，在一些网站中我们直接回车后立即进行搜索，而不是点击搜索按钮才会搜索，那么这个功能怎么实现呢？<br>那么我们就需要了解Vue中提供的<strong>按键修饰符</strong><br>用法： @keyup.按键别名 = “要调用的方法名”</p><p><strong>按键别名</strong></p><blockquote><p>.enter<br>.tab<br>.esc<br>.delete<br>…</p></blockquote><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> @keyup.enter=<span class="string">"open"</span>&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">open</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"弹出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义按键修饰符</strong><br>如果Vue提供的按键修饰符不能满足你的需求，你也可以使用Vue提供的自定义按键修饰符来实现，因为每个键盘的按键都对应了一个键盘码值，比如F2对应的键盘码值是：113：<br>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> @keyup.f2=<span class="string">"open"</span>&gt;</span><br><span class="line"></span><br><span class="line">Vue.config.keyCodes.f2 = 113;   </span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">open</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"弹出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取文本焦点"><a href="#获取文本焦点" class="headerlink" title="获取文本焦点"></a>获取文本焦点</h4><p>获取文本焦点使用了focus属性，那么我们需要定义一个v-focus指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">    <span class="built_in">bind</span>: <span class="keyword">function</span>(el) &#123;&#125;,</span><br><span class="line">    inserted: <span class="keyword">function</span>(el) &#123;&#125;,</span><br><span class="line">    updated: <span class="keyword">function</span>(el) &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上，使用Vue.directive()实现定义全局指令，需要注意以下几点：</p><ul><li>1、在directive()方法中包含两个参数：<blockquote><p>参数1：指令的名称，注意，在定义的时候指令名称不需要加v-前缀，但是在使用的时候需要加v-前缀。<br>参数2：是一个对象，这个对象包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作。</p></blockquote></li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 使用的时候使用： v-focus</span><br></pre></td></tr></table></figure><ul><li>2、在directive()函数的第二个参数中（对象）中又包含了三个实例方法：<blockquote><p>bind: 当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次；但是需要知道元素绑定了这个指令，若涉及对DOM操作的，并不会立即执行，因为元素不会立即插入到DOM中。所以涉及对元素进行DOM相关操作的，不要定义到这个方法中。<br>inserted: 当元素插入到DOM的时候，会立即执行，并只触发一次。<br>updated: 当VNode更新的时候，会指定updated，可能触发多次。</p></blockquote></li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">    <span class="built_in">bind</span>: <span class="keyword">function</span>(el) &#123;</span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-focus /&gt;</span><br></pre></td></tr></table></figure><p>如上，其中bind函数的第一个参数永远是el，它表示绑定的那个元素，是一个原生的JS对象；这里我们调用了JS的focus方法</p><h5 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h5><p>指令定义函数提供了几个钩子函数（可选）：</p><blockquote><p>bind<br>inserted<br>update<br>componentUpdated: 所在组件的VNode及其孩子的VNode全部更新的时候调用<br>unbind: 只调用一次，指令与元素解除绑定时调用</p></blockquote><p><strong>钩子函数参数</strong><br>在上面使用directive()函数的时候我们已经介绍了一些常用的钩子函数，那么既然是函数，就可能需要进行传参，那么为了实现钩子函数传参，Vue提供了几个参数属性来实现对钩子函数参数的一些操作：</p><ul><li>el: 指令所绑定的元素，可以用来直接操作DOM。</li><li>binding: 一个对象，包含以下属性：<ul><li>name: 指令名，不包含v-前缀</li><li>value: 指令的绑定值，如v-focus=”1 + 1”，那么value=2。</li><li>expression: 绑定值的字符串形式，如v-focus=”1+1”，那么experssion的值是1+1。</li><li>…</li></ul></li><li>…</li></ul><p><strong>示例：</strong><br>实现在文本框中输入的数据颜色要为蓝色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-color=<span class="string">"'blue'"</span>&gt;</span><br><span class="line"></span><br><span class="line">// 自定义设置颜色的指令</span><br><span class="line">Vue.directive(<span class="string">'color'</span>, &#123;</span><br><span class="line">    <span class="built_in">bind</span>: <span class="keyword">function</span>(el, binding)&#123;</span><br><span class="line">        el.style.color = binding.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中因为设计要获取值的操作，所以使用binding这个对象钩子函数参数来使用接收，那么：<br>1、这个el就表示当前这个input文本框对象<br>2、这个binding就表示v-color=”‘blue’”指令传递的参数blue（因为使用’’单引号即不是字符串）<br>3、binding-value就是获取到v-color指令绑定的参数值是：blue，通过el.style.color表示设置这个文本框样式中的颜色属性</p><h5 id="定义私有指令"><a href="#定义私有指令" class="headerlink" title="定义私有指令"></a>定义私有指令</h5><p>使用<strong>私有指令</strong>和<strong>全局指令</strong>的用法基本相同，我们参考上面讲过的<strong>私有过滤器</strong>和<strong>全局过滤器</strong>就能猜想到<strong>私有指令</strong>的用法：<br><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-fontsize=<span class="string">"'50px'"</span>&gt;私有指令&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">''</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    filters: &#123;&#125;,</span><br><span class="line">    directives: &#123;</span><br><span class="line">        <span class="string">'fontsize'</span>: &#123;</span><br><span class="line">            <span class="built_in">bind</span>: <span class="keyword">function</span>(el, binding)&#123;</span><br><span class="line">                el.style.fontSize = binding.value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>自定义指令的简写形式</strong><br>对于仅仅使用bind和update钩子函数的操作，可以进行下列的简写形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-fontsize=<span class="string">"'50px'"</span>&gt;私有指令&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">''</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    filters: &#123;&#125;,</span><br><span class="line">    directives: &#123;</span><br><span class="line">        <span class="string">'fontsize'</span>: <span class="keyword">function</span>(el, binding)&#123;</span><br><span class="line">            el.style.fontSize = binding.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h4><p>实现将列表数据渲染到表格中，并实现添加功能案例（包含上面讲到的所有技术的<strong>实例</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">    table &#123;</span><br><span class="line">        min-height: 25px;</span><br><span class="line">        line-height: 25px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border-collapse: collapse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table,</span><br><span class="line">    table tr th,</span><br><span class="line">    table tr td &#123;</span><br><span class="line">        border: 1px solid <span class="comment">#0094ff;</span></span><br><span class="line">        padding: 11px;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        id:</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"id"</span> v-focus v-color=<span class="string">"'blue'"</span>&gt; username:</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"username"</span> @keyup.enter=<span class="string">"add"</span>&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"添加"</span> @click=<span class="string">"add"</span>&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;th&gt;id&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;name&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;date&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;fun&lt;/th&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/thead&gt;</span><br><span class="line">            &lt;tbody&gt;</span><br><span class="line">                &lt;tr v-for=<span class="string">"user in list"</span> :key=<span class="string">"user.id"</span>&gt;</span><br><span class="line">                    &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;&#123;&#123;user.username&#125;&#125;&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;&#123;&#123;user.time | dataFormat(<span class="string">''</span>) &#125;&#125;&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;&lt;a href=<span class="string">"#"</span> @click=<span class="string">"del(user.id)"</span>&gt;删除&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/tbody&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">        &lt;p&gt;未使用过滤器：&#123;&#123; new Date() &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;使用全局过滤器：&#123;&#123; new Date() | dataFormat(<span class="string">''</span>) &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app2"</span>&gt;</span><br><span class="line">        使用私有过滤器：&#123;&#123; dt | dataFormat(<span class="string">''</span>)&#125;&#125;</span><br><span class="line">        &lt;p v-fontsize=<span class="string">"'50px'"</span>&gt;私有指令&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    // 自定义文本框获取焦点指令</span><br><span class="line">    // Vue.directive()定义全局指令，包含两个参数：</span><br><span class="line">    // 参数1：指令的名称，注意，在定义的时候指令的名称不需要加v-前缀，但是在使用的时候需要加v-focus</span><br><span class="line">    // 参数2：是一个对象，这个对象中包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作</span><br><span class="line">    Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">        // 注意，在下面的函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数是一个原生JS对象</span><br><span class="line">        <span class="built_in">bind</span>: <span class="keyword">function</span>(el) &#123; //每当指令绑定到元素上的时候，会立即执行这个<span class="built_in">bind</span>函数，只执行一次</span><br><span class="line">            // 注意：在元素绑定了指令时，还没有插入到DOM中去，这时候调用focus方法是没有作用的，因为一个元素，只有插入到DOM之后，才能获取焦点</span><br><span class="line">            // el.focus()</span><br><span class="line">        &#125;,</span><br><span class="line">        inserted: <span class="keyword">function</span>(el) &#123; // inserted表示元素插入到DOM中的时候，会执行,触发一次</span><br><span class="line">            el.focus()</span><br><span class="line">        &#125;,</span><br><span class="line">        updated: <span class="keyword">function</span>(el) &#123; // 当VNode更新的是否，会执行updated，可触发多次</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 自定义设置颜色的指令</span><br><span class="line">    Vue.directive(<span class="string">'color'</span>, &#123;</span><br><span class="line">        <span class="built_in">bind</span>: <span class="keyword">function</span>(el, binding) &#123;</span><br><span class="line">            el.style.color = binding.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 自定义按键</span><br><span class="line">    Vue.config.keyCodes.f2 = 113;</span><br><span class="line"></span><br><span class="line">    // 演示私有过滤器</span><br><span class="line">    var vm2 = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app2'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            dt: new Date(),</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">open</span></span>() &#123;</span><br><span class="line">                alert(<span class="string">"弹出"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        filters: &#123;</span><br><span class="line">            dataFormat: <span class="keyword">function</span>(data, pattern) &#123;</span><br><span class="line">                // 获取当前日期</span><br><span class="line">                var dt = new Date(data);</span><br><span class="line"></span><br><span class="line">                // 获取年月日</span><br><span class="line">                var y = dt.getFullYear();</span><br><span class="line">                var m = dt.getMonth() + 1;</span><br><span class="line">                var d = dt.getDate();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pattern.toLowerCase() == <span class="string">'yyyy-mm-dd'</span>) &#123;</span><br><span class="line">                    <span class="built_in">return</span> `<span class="variable">$&#123;y&#125;</span>-<span class="variable">$&#123;m&#125;</span>-<span class="variable">$&#123;d&#125;</span>`;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    var hh = dt.getHours();</span><br><span class="line">                    var mm = dt.getMinutes();</span><br><span class="line">                    var ss = dt.getSeconds();</span><br><span class="line"></span><br><span class="line">                    // es6中提供的 yyyy-mm-dd hh:mm:ss 的简写形式</span><br><span class="line">                    <span class="built_in">return</span> `<span class="variable">$&#123;y&#125;</span>-<span class="variable">$&#123;m&#125;</span>-<span class="variable">$&#123;d&#125;</span> <span class="variable">$&#123;hh&#125;</span>:<span class="variable">$&#123;mm&#125;</span>:<span class="variable">$&#123;ss&#125;</span>` + <span class="string">'--&gt;私有'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 自定义私有指令（简写形式）</span><br><span class="line">        directives: &#123;</span><br><span class="line">            <span class="string">'fontsize'</span>: <span class="keyword">function</span>(el, binding) &#123;</span><br><span class="line">                el.style.fontSize = binding.value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 全局过滤器</span><br><span class="line">    Vue.filter(<span class="string">'dataFormat'</span>, <span class="keyword">function</span>(data, pattern) &#123;</span><br><span class="line">        // 获取当前日期</span><br><span class="line">        var dt = new Date(data);</span><br><span class="line"></span><br><span class="line">        // 获取年月日</span><br><span class="line">        var y = dt.getFullYear();</span><br><span class="line">        var m = dt.getMonth() + 1;</span><br><span class="line">        var d = dt.getDate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.toLowerCase() == <span class="string">'yyyy-mm-dd'</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> `<span class="variable">$&#123;y&#125;</span>-<span class="variable">$&#123;m&#125;</span>-<span class="variable">$&#123;d&#125;</span>`;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var hh = dt.getHours();</span><br><span class="line">            var mm = dt.getMinutes();</span><br><span class="line">            var ss = dt.getSeconds();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> `<span class="variable">$&#123;y&#125;</span>-<span class="variable">$&#123;m&#125;</span>-<span class="variable">$&#123;d&#125;</span> <span class="variable">$&#123;hh&#125;</span>:<span class="variable">$&#123;mm&#125;</span>:<span class="variable">$&#123;ss&#125;</span>`;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建Vue实例</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            id: <span class="string">''</span>,</span><br><span class="line">            username: <span class="string">''</span>,</span><br><span class="line">            list: [</span><br><span class="line">                &#123; id: 1, username: <span class="string">'望月'</span>, time: new Date() &#125;,</span><br><span class="line">                &#123; id: 2, username: <span class="string">'loonycoder'</span>, time: new Date() &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">                var user = &#123; id: this.id, username: this.username, time: new Date() &#125;;</span><br><span class="line">                this.list.push(user);</span><br><span class="line">            &#125;,</span><br><span class="line">            del(id) &#123;</span><br><span class="line">                // some()是操作数组的方法，作用是循环数组，并当<span class="built_in">return</span> <span class="literal">true</span>是就终止循环</span><br><span class="line">                // 其中的user理解为循环list元素的别名，i表示索引</span><br><span class="line">                this.list.some((user, i) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (user.id == id) &#123;</span><br><span class="line">                        this.list.splice(i, 1);</span><br><span class="line">                        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h4><ul><li>什么是声明周期：从Vue实例创建、运行、到销毁期间，伴随着发生的事件的过程成为生命周期。</li><li>生命周期钩子：就是声明周期事件的别名。</li><li>主要的声明周期函数分类</li></ul><blockquote><p>创建期间的声明周期函数：</p><ul><li>beforeCreate: 实例刚在内存中被创建，此时，还没有初始化好data和methods属性。</li><li>created: 实例已经在内存中创建好，此时data和methods已经创建好，但还没有编译模板。</li><li>beforeMount: 此时已经完成了模板的编译，但是还没有挂载到页面上。</li><li>mounted: 此时，已经将编译好的模板，挂载到了页面指定的容器中。<br>运行期间的声明周期函数:</li><li>beforeUpdate: 状态更新之前执行此函数，此时的data数据是最新的，但是此时还没有开始渲染DOM节点</li><li>updated: 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据都是最新的，界面已经被重新渲染好了。<br>销毁期间的生命周期函数</li><li>beforeDestory: 实例销毁之前调用，在这一步，实例仍然可以使用。</li><li>destroyed: Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器都会被移除，所所有的子实例也会被销毁。</li></ul></blockquote><h5 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h5><p>此函数执行的时候，data和methods中的数据还没有初始化。<br><img src="/images/vue7.png" srcset="/img/loading.gif" alt="beforeCreate"><br><img src="/images/vue8.png" srcset="/img/loading.gif" alt="beforeCreate"></p><h5 id="created"><a href="#created" class="headerlink" title="created"></a>created</h5><p>此函数中，data和methods都已经初始化好了，如果需要调用methods中的方法或操作data中的值最早就在created函数中操作。<br><img src="/images/vue9.png" srcset="/img/loading.gif" alt="created"><br><img src="/images/vue10.png" srcset="/img/loading.gif" alt="created"></p><h5 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h5><p>此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去。<br><img src="/images/vue11.png" srcset="/img/loading.gif" alt="beforeMount"><br><img src="/images/vue12.png" srcset="/img/loading.gif" alt="beforeMount"></p><h5 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h5><p>只要执行完了mounted，表示整个Vue实例已经初始化完毕了，此时组件已经进入了运行阶段。<br><img src="/images/vue13.png" srcset="/img/loading.gif" alt="mounted"></p><h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><p><img src="/images/vue14.png" srcset="/img/loading.gif" alt="图示"></p><hr><h3 id="vue-resource实现请求提交"><a href="#vue-resource实现请求提交" class="headerlink" title="vue-resource实现请求提交"></a>vue-resource实现请求提交</h3><p>作为一个后端开发者，我们需要的数据都应该是从数据库中取出来的，目前JSP页面越来越不常用，而更常用HTML页面，那么就体现出来类似Vue这种框架的好处了。<br>下面我们就了解一下怎样使用Vue实现发送AJAX的请求：</p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>首先使用Vue实现发送AJAX请求，我们需要导入一个包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue-resource.js</span><br></pre></td></tr></table></figure><p><strong>Methods</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$http</span>.get(<span class="string">'url'</span>, [options]).<span class="keyword">then</span>(successCallback, errorCallback);</span><br><span class="line"></span><br><span class="line">this.<span class="variable">$http</span>.post(<span class="string">'url'</span>, [body], [options]).<span class="keyword">then</span>(successCallback, errorCallback);</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>this表示的是当前Vue实例对象，而vue-resource.js提供了$http属性用来调用其内置的请求方法，并且vue-resource.js是基于vue.js的。<br>options是指可选的请求参数，就是你发送请求想要传递的参数。</li><li>then可以实现发送完请求后，通过其获取请求成功响应的数据</li><li>then中包含两个参数successCallback和errorCallback，这两个都是对象，我们可以通过其进行对相应数据的操作。</li></ul><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">"getInfo"</span>&gt;点击我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">getInfo</span></span>()&#123;</span><br><span class="line">            this.<span class="variable">$http</span>.get(<span class="string">'url'</span>).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">                console.log(result.body);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>解释：</strong><br>当我们请求成功后，可以通过then来获取请求成功响应的数据，而可以通过.data或.body来获取响应data，而我们通常使用result.body来获取具体响应的参数。注意其中的result =&gt; {}是ES6中的写法。</p><h5 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h5><p><strong>注意：</strong> post请求常用于类似提交表单的功能，而对于提交表单，存在一个表单提交格式，默认是：application/x-wwww-form-urlencoded ；而通过Vue发起的post请求，默认没有表单格式，所以，有的服务器就处理不了。<br>那么我们可以通过post方法的第三个参数：{ emulateJSON: true }来设置提交内容类型为普通表单数据格式。</p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$http</span>.post(<span class="string">'url'</span>, &#123;&#125;, &#123; emulateJSON: <span class="literal">true</span> &#125;).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">    console.log(result.body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其他请求方法与上面的雷同，具体方法请参考官方文档。</p><h4 id="请求接口根域名配置"><a href="#请求接口根域名配置" class="headerlink" title="请求接口根域名配置"></a>请求接口根域名配置</h4><p>由于我们个人的项目可能是部署到本地的Tomcat服务器上的，可能不会涉及请求接口的域名配置，那么我们先看一个案例：<br>发送post请求到服务器接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">        this.<span class="variable">$http</span>.post(<span class="string">'http://tycoding.cn/api/add'</span>, &#123;&#125;, &#123;emulateJSON: <span class="literal">true</span>&#125;).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，当我们发送请求的时候，URL路径需要写上域名地址<a href="http://www.loonycoder.com" target="_blank" rel="noopener">http://www.loonycoder.com</a>，然后才是请求路径/api/add，那么我们每次发送ajax请求都会需要写这个域名地址，就会显得比较麻烦，所以Vue-resource给我们提供了一种设置默认请求<strong>根域名</strong>的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.root = <span class="string">'http://www.loonycoder.com'</span>;</span><br></pre></td></tr></table></figure><p>如上，就是一个全局的请求根域名配置。</p><p><strong>注意</strong><br>仅了解了上面的配置可能请求还会404，那么我们需要知道：</p><blockquote><p>如果我们通过了全局配置请求接口的根域名，那么每次发送HTTP请求时，请求的URL路径应该以相对域名开头，即前面不能带/： * 如果this.$http.post(‘/xxx’)请求URL带了/，那么Vue就不会启用上面的全局请求根域名配置，就会404.</p></blockquote><ul><li>如果前面不带/即：this.$http.post(‘xxx’)，那么就会启用上面的全局请求根域名配置进行URL的拼接。</li></ul><h5 id="全局配置表单提交格式选项"><a href="#全局配置表单提交格式选项" class="headerlink" title="全局配置表单提交格式选项"></a>全局配置表单提交格式选项</h5><p>上面讲到了如果使用post请求提交表单，那么你应该指定{emulateJSON: true}参数，那么每次进行post请求都指定又会显得很麻烦，那么vue-resource也给我们提供了一个全局配置的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.emulateJSON = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这样我们就不需要再post请求中再配置第三个参数了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">        this.<span class="variable">$http</span>.post(<span class="string">'http://tycoding.cn/api/add'</span>, &#123;&#125;).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p>请求后台并即时渲染表格数据的案例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- html段 --&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"username"</span>&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"添加"</span> @click=<span class="string">"add"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;编号&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;用户名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">        &lt;tr v-for=<span class="string">"user in list"</span> :key=<span class="string">"user.id"</span>&gt;</span><br><span class="line">            &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&#123;&#123;user.username&#125;&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;a href=<span class="string">"#"</span> @click.pervent=<span class="string">"del(user.id)"</span>&gt;删除&lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- javascript段 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">// 设置全局根域名</span><br><span class="line">Vue.http.options.root = <span class="string">'http://tycoding.cn/'</span>;</span><br><span class="line"></span><br><span class="line">//设置全局表单提交格式</span><br><span class="line">Vue.http.options.emulateJSON = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">// 实例化Vue</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">''</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        username: <span class="string">''</span>,</span><br><span class="line">        list: []</span><br><span class="line">    &#125;,</span><br><span class="line">    created: &#123;</span><br><span class="line">        // 因为进入列表页面就需要在列表中显示出数据，那么就需要实现加载页面时自动加载findAll方法</span><br><span class="line">        // 而之前我们已经知道了，Vue的声明周期中，最早可以操作methods和data中的数据的阶段是：created生命周期函数阶段。</span><br><span class="line">        // 那么在这里调用findAll方法即可</span><br><span class="line">        this.findAll();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        // 查询所有列表数据</span><br><span class="line">        <span class="function"><span class="title">findAll</span></span>()&#123;</span><br><span class="line">            this.<span class="variable">$http</span>.get(<span class="string">'api/findAll'</span>).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">                this.list = result.body;</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 添加功能</span><br><span class="line">        <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">            this.<span class="variable">$http</span>.post(<span class="string">'api/add'</span>, &#123;username: this.username&#125;).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(result.body.status == 0)&#123;</span><br><span class="line">                    // 如果状态码为0就表示请求成功，这个状态码的值根据实际定</span><br><span class="line">                    // 请求成功，即添加了一条新的数据，那么需要重新刷新列表（不然新数据不能及时的更新到页面上）</span><br><span class="line">                    this.findAll()</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    alert(<span class="string">'添加失败'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        //删除功能</span><br><span class="line">        del(id)&#123;</span><br><span class="line">            this.<span class="variable">$http</span>.get(<span class="string">'api/del'</span> + id).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(result.body.status == 0)&#123;</span><br><span class="line">                    //请求成功</span><br><span class="line">                    //刷新列表</span><br><span class="line">                    this.findAll();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    alert(<span class="string">'删除失败'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如上我们已经完成了常见的几个功能，后面我们将会介绍基于SpringMVC框架，实现与Vue整合并重写增删改查功能。</p><p><strong>注意：</strong></p><ul><li>1、首先我们需要配置根域名，且具体的AJAX请求URL不能添加’/‘；如果是基于本地的Tomcat服务器的项目，可能不需要配置根域名，具体视情况而定</li><li>2、实现查询所有列表数据功能，思路是：1、发送AJAX请求数据；2、将响应的数据赋值给data中的list集合this.list = result.body。注意响应数据是存放到body中的，具体请F12查看浏览器请求头信息和响应头信息。</li><li>3、上面获取了数据库中的列表数据，我们需要渲染到页面上，那么点击进入列表页面，列表页面中应该立即显示数据库中的所有数据，即findAll方法应该在初始化页面的同时自动去调用，并将数据赋值给list列表。而我们之前讲过操作methods和data中参数的最早时机是created声明周期函数阶段，那么我们直接在created函数中调用findAll方法即可实现自动加载。</li><li>4、添加功能的思路：<ul><li>1、在data中先声明需要添加的参数；</li><li>2、在表单中用v-model绑定需要添加的参数；</li><li>3、点击添加功能按钮，绑定@click事件，在methods中写对应的方法；</li><li>4、发送AJAX请求，并在URL中拼接需要添加的数据（通过this.username）获取绑定的参数；</li><li>5、如果是post请求，还需要设置表单提交格式{emulateJSON: true}，而我们使用了全局配置就不需要再在post参数中指定了；</li><li>6、如果添加成功，就调用findAll方法重新刷新列表</li></ul></li><li>5、删除功能需要在绑定@click事件的时候将id传入。并且我们需要使用@click&middot;pervent来阻止&lt;a&gt;标签的默认跳转。</li><li>6、上面仅是提供演示，具体操作由实际情况而定。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Vue</title>
    <link href="/2018/08/24/Vue1/"/>
    <url>/2018/08/24/Vue1/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Vue-js"><a href="#什么是Vue-js" class="headerlink" title="什么是Vue.js"></a>什么是Vue.js</h3><ul><li>Vue.js是目前很火的前端框架；与Angualr.js和React.js并称为前端三大主流框架。</li><li>Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，</li><li>在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。</li></ul><hr><h3 id="后端的MVC和前端的MVVM之间的区别"><a href="#后端的MVC和前端的MVVM之间的区别" class="headerlink" title="后端的MVC和前端的MVVM之间的区别"></a>后端的MVC和前端的MVVM之间的区别</h3><ul><li><p>MVC是后端的分层开发概念</p></li><li><p>MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）</p></li><li><p>Model： 页面需要展示的数据</p></li><li><p>View: 视图、HTML</p></li><li><p>VM: 数据（Model）和视图（View）之间的调度者</p></li></ul><p><strong>图解</strong><br><img src="/images/vue1.png" srcset="/img/loading.gif" alt="vue图解"></p><hr><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;!-- 插值表达式 --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123;     // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'Hello Vue!'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><p>1、首先需要引入Vue.js<br>2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到<br>3、创建Vue实例，这个实例其实就是MVVM中的vm调度者<br>4、el: 表示当时Vue实例的控制区域；data: 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。<br>5、在指定Vue实例区域下，展示我们已经声明的元素msg，使用：即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）</p><hr><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h4><p>在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在vue.js还没有加载完毕时，视图层不会将识别为Vue中的插值表达式，而是作为字符串显示到页面上。<br>为了解决这个问题，Vue.js提供了v-cloak指令，可以解决插值表达式闪烁的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>扩展</strong></p><p>解决插值表达式闪烁问题，除了v-cloak指令，Vue还提供了v-text指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-text=<span class="string">"msg"</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>v-cloak与v-text的区别</strong><br>v-text默认会覆盖掉元素中原有的内容<br>v-cloak不会覆盖掉原有的内容<br><img src="/images/vue2.png" srcset="/img/loading.gif" alt="vue2"></p><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h4><p><strong>在上面，我们了解了v-text输出Vue元素，但是如果我们需要显示的数据是一段HTML代码，v-text和都将无能为力，<br>为此，Vue提供了专门渲染HTML数据的指令：v-html</strong></p><p><img src="/images/vue3.png" srcset="/img/loading.gif" alt="vue3"></p><p>上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用）这样可以吗？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"msg"</span>/&gt;</span><br></pre></td></tr></table></figure><p>回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。<br>为了解决上述问题，Vue提供了v-bind:指令来绑定一些HTML属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> v-bind:value=<span class="string">"msg"</span>&gt;</span><br></pre></td></tr></table></figure><p>如上，被v-bind:绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外v-bind:还有一个简易写法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"msg"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> v-bind:value=<span class="string">"msg"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> :value=<span class="string">"msg"</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'戳我'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>效果如图：<br><img src="/images/vue4.png" srcset="/img/loading.gif" alt="vue4"></p><h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h4><p>Vue提供了事件绑定机制的指令：v-on:；用其我们可以用来绑定一些常见的触发事件：click、mouseover …</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> :value=<span class="string">"msg"</span> v-on:click=<span class="string">"show"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> :value=<span class="string">"msg"</span> v-on:mouseover=<span class="string">"show"</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'戳我'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            show: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                alert(<span class="string">"hello"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其中methods是Vue内置的对象，用于存放一些自定义的方法函数</p><p><strong>拓展</strong></p><p>使用js内置的函数setInterval(定时器)，实现跑马灯效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"开始"</span> @click=<span class="string">"action"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"停止"</span> @click=<span class="string">"stop"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'嘻嘻，哈哈'</span>,</span><br><span class="line">            intervalId: null</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">action</span></span>()&#123;</span><br><span class="line">                <span class="keyword">if</span>(this.intervalId != null) <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">                // 定时器</span><br><span class="line">                this.intervalId = setInterval(() =&gt; &#123;</span><br><span class="line">                    // 截取首字符</span><br><span class="line">                    var start = this.msg.substring(0, 1);</span><br><span class="line">                    // 截取第一个字符后的所有字符</span><br><span class="line">                    var end = this.msg.substring(1);</span><br><span class="line">                    // 将后面的字符拼接到前面，实现循环的效果</span><br><span class="line">                    this.msg = end + start;</span><br><span class="line">                &#125;,400)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">                // 停止定时器</span><br><span class="line">                clearInterval(this.intervalId)</span><br><span class="line">                // 每次清除定时器后需要将intervalId重新设置为null</span><br><span class="line">                this.intervalId = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><p>1、v-on:也有简写形式：@，用法如上。<br>2、在视图层取VM中的数据我们可以使用或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：this.数据属性名（其中的this表示当前VM实例对象）。<br>3、methodName:function(){}在ES6中有一个简便的写法：methodName(){}。 4、setInterval()和clearInterval()是js中内置的函数，用法如上。<br>5、正常我们调用函数会写：name(function(){})，而ES6也提供了一个方式：methodName(() =&gt; {})，这种用法的好处就解决了this指向问题，因为如果元素定义在了函数内部，那么其中的this就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的=&gt;。</p><p>效果如图：<br><img src="/images/vue5.png" srcset="/img/loading.gif" alt="vue5"></p><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><blockquote><p>.stop 阻止冒泡<br>.prevent 阻止默认事件<br>.capture 添加时间侦听器时使用时间捕获模式<br>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调<br>.once 事件只触发一次</p></blockquote><p>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div @click=<span class="string">"divClick"</span>&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"戳我"</span> @click.stop=<span class="string">"btnClick"</span>&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"戳我"</span> @click.prevent=<span class="string">"btnClick"</span>&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'嘻嘻，哈哈'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">divClick</span></span>() &#123;</span><br><span class="line">                console.log(<span class="string">"这是div的点击事件"</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">btnClick</span></span>() &#123;</span><br><span class="line">                console.log(<span class="string">"这是btn的点击事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><ul><li>唯一的双向绑定指令：v-model</li><li>单向绑定指令：v-bing</li></ul><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"msg"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'hello!'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="Vue中的样式"><a href="#Vue中的样式" class="headerlink" title="Vue中的样式"></a>Vue中的样式</h3><h4 id="外联样式"><a href="#外联样式" class="headerlink" title="外联样式"></a>外联样式</h4><ul><li><p>数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 :class=<span class="string">"['italic','color']"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>其中的italic、color是自定义的类名，需在外部定义CSS样式</p></li><li><p>数组中嵌套对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 :class=<span class="string">"['italic',&#123;'color': flag&#125;]"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>其中的flag是Vue绑定的变量，在data进行声明</p></li><li><p>直接使用对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 :class=<span class="string">"&#123;italic:true, color:flag&#125;"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure></li></ul><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .italic &#123;</span><br><span class="line">        font-style: italic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .color &#123;</span><br><span class="line">        color: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;h2 :class=<span class="string">"['italic','color']"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line">    &lt;h2 :class=<span class="string">"['italic', &#123;'color':flag&#125;]"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line">    &lt;h2 :class=<span class="string">"&#123;italic:false, color:flag&#125;"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            flag: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><ul><li><p>将样式对象定义到data中，并在:style中引用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 :style=<span class="string">"styleObj"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    styleObj: &#123; <span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'font-weight'</span>: <span class="string">'200px'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在:style中通过数组，引用多个data上的样式对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 :style=<span class="string">"[styleObj, styleObj2]"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    styleObj: &#123; <span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'font-weight'</span>: <span class="string">'200px'</span>&#125;,</span><br><span class="line">    styleObj2: &#123; <span class="string">'font-style'</span>: <span class="string">'italic'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;h2 :style=<span class="string">"styleObj"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line">    &lt;h2 :style=<span class="string">"[styleObj, styleObj2]"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            styleObj: &#123; <span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'font-weight'</span>: <span class="string">'200px'</span> &#125;,</span><br><span class="line">            styleObj2: &#123; <span class="string">'font-style'</span>: <span class="string">'italic'</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><p>Vue提供了遍历集合、数组的指令：v-for；用法: v-for=”别名 in 集合名”</p><h4 id="迭代数组"><a href="#迭代数组" class="headerlink" title="迭代数组"></a>迭代数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=<span class="string">"item, i in list"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    list: [1,2,3,4]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中的i是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义</strong></p><h4 id="迭代对象数组"><a href="#迭代对象数组" class="headerlink" title="迭代对象数组"></a>迭代对象数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=<span class="string">"item in list2"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    list2: [</span><br><span class="line">            &#123; id:1, name: <span class="string">'嘻嘻'</span> &#125;,</span><br><span class="line">            &#123; id:2, name: <span class="string">'哈哈'</span> &#125;</span><br><span class="line">        ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代对象数组，通过 的方式，这个属性名就是对象数组中定义的元素属性名</strong></p><h4 id="迭代对象"><a href="#迭代对象" class="headerlink" title="迭代对象"></a>迭代对象</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=<span class="string">"(val, key) in user"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">            id: 1,</span><br><span class="line">            name: <span class="string">'LoonyCoder'</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代对象，迭代得到的是对象的value值和key值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。</strong></p><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p v-for=<span class="string">"item, i in list"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p v-for=<span class="string">"item in list2"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p v-for=<span class="string">"(val, key) in user"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            list: [1,2,3,4], </span><br><span class="line">            list2: [</span><br><span class="line">                &#123; id:1, name: <span class="string">'嘻嘻'</span> &#125;,</span><br><span class="line">                &#123; id:2, name: <span class="string">'哈哈'</span> &#125;</span><br><span class="line">            ],</span><br><span class="line">            user: &#123;</span><br><span class="line">                id: 1,</span><br><span class="line">                name: <span class="string">'LoonyCoder'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在vue2.0+版本里，当使用v-for渲染数据，必须制定对应的key值（这里的key是一个属性，不是前面迭代的key值）。</p><p><strong>用法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=<span class="string">"item in user"</span> :key=<span class="string">"item.id"</span>&gt;</span><br></pre></td></tr></table></figure><p>其中:key就说明了key属性必须是通过v-bind绑定的元素，而:key=””中指定的值必须是string/number类型的值，比如此处使用的是item.id中ID是number值，并且是唯一的。<br><strong>目的：</strong><br>避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。</p><h4 id="v-show和v-if"><a href="#v-show和v-if" class="headerlink" title="v-show和v-if"></a>v-show和v-if</h4><p>Vue提供了两个指令来实现元素显示状态的切换：v-if v-show<br><strong>区别</strong></p><ul><li>v-if的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。</li><li>v-show的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的display:none样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。</li></ul><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"flag=!flag"</span> value=<span class="string">"toggle"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h3 v-if=<span class="string">"flag"</span>&gt;这是v-if控制的元素&lt;/h3&gt;</span><br><span class="line">    &lt;h3 v-show=<span class="string">"flag"</span>&gt;这是v-show控制的元素&lt;/h3&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            flag: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/images/vue6.png" srcset="/img/loading.gif" alt="vue6"></p>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习之各种排序算法</title>
    <link href="/2018/08/16/Algorithm/"/>
    <url>/2018/08/16/Algorithm/</url>
    
    <content type="html"><![CDATA[<h3 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>算法有时间和空间的<strong>复杂度</strong>，这是可以衡量的。<strong>时间复杂度</strong>–运行它花了多少时间；<strong>空间复杂度</strong>–运行它需要多少内存。<br><strong>常数时间</strong>操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做<strong>常数操作</strong>。常数时间的操作记为<strong>O(1)</strong></p><h5 id="大O表示"><a href="#大O表示" class="headerlink" title="大O表示"></a>大O表示</h5><p>比如我们称算法 B 有与n²成比例的时间需求，我们说B是 <strong>O(n²)</strong>的(读作big O(n²))<br>具体而言，在<strong>常数操作</strong>数量的表达式中，<strong>只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分若记为f(N)</strong>，那么在<strong>最差情况下，算法流程的指标（时间复杂度</strong>）为 O(f(N))。**<br>比如符合 aN² + bN + C 操作的事件复杂度就是 <strong>O(n²)</strong></p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><strong>遍历算法：</strong><br>比如有 1,2,3,4,5 这几个数，我们需要遍历得到这些数，那么每次遍历的时间复杂度称为<strong>O(N)</strong>的话，那么一共有M个数，就称遍历算法的事件复杂度是: O(M * N)。（区分 O(1) 表示常数操作，这里的 O(N) 表示时间复杂度）。<br><strong>二分查找算法</strong><br>比如有 1,2,3,4,5 二分查找算法，就是实现将已有数列分为Right Left 两列（不一定相等），然后依次从Right、Left中查找，如果找到了就不用找另一侧（比如在Right中查找，再将Right分为right left两列进行查找）。这种算法比遍历算法要简单。<br>那么因为每次查找都是先将数列分为两列，再进行查找，那么一个数列一共可以分 logN 次，所以二分查找算法的事件复杂度就是 log(M * logN)</p><h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>当解决一个问题的时候，将它划分为更小的问题且用相同的方法进行解决。这种特殊的处理称为<strong>递归</strong>。递归的关键是：最终你能到达一个较小的问题，且这个小问题是很容易解决的。<br>故：<strong>调用自己的方法称为递归方法</strong>。调用是递归调用。<br>设计一个递归方案，应该考虑哪些问题？<br>方案的那个部分的工作能让你直接完成？<br>哪些较小问题已经有了解决方案。<br>该递归过程何时结束？<br>若递归方法没有设计<strong>终止情形</strong>，将<strong>永远执行</strong>，这种情形称为<strong>无穷递归</strong>。<br>总结来说：<strong>递归函数</strong>就是自己调用自己的函数。系统帮你压栈，将当前函数的所有信息储存到栈内存中，当调用<strong>子过程</strong>时，只储存每次子过程调用具体的变量值。若递归结束，调用栈顶的函数信息并还原函数的原始状态。</p><h5 id="跟踪递归方法"><a href="#跟踪递归方法" class="headerlink" title="跟踪递归方法"></a>跟踪递归方法</h5><p>通常而言，跟中一个递归算法过程是比较复杂的，如果你按照一定的准则设计递归方法，一般是无需跟踪它们。这里我一个<strong>倒计时</strong>递归举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Code_Recursive &#123;</span><br><span class="line"></span><br><span class="line">    public static void countDown(int <span class="built_in">integer</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">integer</span> &gt;= 1) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">integer</span>);</span><br><span class="line">            countDown(<span class="built_in">integer</span> - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        countDown(3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将打印出来3、2、1 倒计时数字，使用的正是递归的方法。它符合了以下设计准则：</p><ul><li>这个倒计时打印（显示）的工作是可以直接完成的。</li><li>该递归方法最终是化小为打印一个数字，这是可以直接 sys 解决的。</li><li>该递归方法执行到integer参数为1时就结束递归。</li></ul><p><strong>实现过程</strong><br><img src="/images/math1.png" srcset="/img/loading.gif" alt="math"><br>可以看到，图中是countDown(3)的递归调用过程，其中出现了多个countDown方法的副本，但其实我们就写了一个递归方法。<br>也就是说对方法的每次调用（递归或非递归）Java都记录方法执行的当前状态，包含它的参数和局部变量的值，以及当前指令的位置。每个记录称为一个活动记录，它提供运行期间方法状态的快照。记录放入程序栈中。栈按照时间先后组织这些记录，所以当前正在执行的方法的记录位于栈顶。Java可以暂停递归方法的运行，并用新的变量值再次调用它。</p><h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p><strong>master公式</strong><br><img src="/images/math2.png" srcset="/img/loading.gif" alt="math"></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>时间复杂度：O(N² )<br>在一个一维数组中，冒泡排序就是实现数组中相邻两个索引位置值的大小比较，若条件符合就不动，如果条件不符合就将两个索引位置的值进行交换。且外层循环决定了外层一共需要循环多少次，且决定了外层循环一次内层需要循环多少次，外层一次循环才能排序好一个值（最大最小），下次循环就忽略掉这个极值从剩余的数据中得出极值，然后依次这样。<br><img src="/images/math3.png" srcset="/img/loading.gif" alt="math"><br>实现代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Code_00_BubbleSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void bubbleSort(int[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; 2 || arr == null) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    swap(arr, j, j + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中我们对数组arr[3,2,0,7,4]进行从大到小的排序，在bubbleSort方法中，外层循环arr.length-1次，内层每次循环arr.length-1次。</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>时间复杂度：O(N²)<br>选择排序，首先我们需要一个minIndex，记录最小值，然后将当前索引位置的值与后面索引位置的值依次比较,如果符合条件，就将此索引赋值给minIndex，再进行交换值（因为此时极限值minIndex改变了）。<br>可以看到这种方式比上面的冒泡排序简单很多。<br><img src="/images/math4.png" srcset="/img/loading.gif" alt="math"><br>实现代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Code_01_SelectionSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void selectionSort(int[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; 2 || arr == null) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归选择排序"><a href="#递归选择排序" class="headerlink" title="递归选择排序"></a>递归选择排序</h4><p>时间复杂度：O(N²)<br>根据前面讲到的递归算法的设计，我们首先要明白：</p><ul><li>递归方案的哪些工作是可以直接完成的？<ul><li>1.动态替换minIndex的值；</li><li>2.交换minIndex和当前索引；</li></ul></li><li>递归化到最小问题是什么？<ul><li>得到一个索引比minIndex索引对应的值要小，替换minIndex，并进行swap操作。</li></ul></li><li>递归何时结束？<ul><li>当循环到索引值和arr.length相等就停止递归。</li></ul></li></ul><p>带着上面的思考问题，我们可以进行如下设计<br><img src="/images/math5.png" srcset="/img/loading.gif" alt="math"><br>想要通过递归实现选择排序，要知道<strong>递归</strong>是重复调用自己的过程。那么：</p><ul><li>首先你把sort函数理解为一个外层圈子，而其中的for()循环是内层的圈子，内层的圈子循环完毕一次（n~arr.length），就得到一个最小值。</li><li>需要规定<strong>minIndex</strong>记录最小值的索引位置，这个值和外层的圈子有关，如果排序好的最小值不用管，直接从外层圈子范围开始循环内层圈子，所以定义for(int i=n)。</li><li>如果满足内层圈子循环中arr[minIndex] &gt; arr[i]说明此索引值比当前的minIndex还要小，那么就替换minIndex。</li><li>内层圈子每<strong>完全循环完毕</strong>（n~arr.length），就swap替换对应索引位置的值。</li><li>最后，因sort(arr, n + 1)，当n+1等于arr.length，就停止递归。</li></ul><p>实现代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Code_01_Recursive_SelectionSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void sort(int[] arr, int n) &#123;</span><br><span class="line">        int minIndex = n;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; 2 || arr == null || n &gt;= arr.length) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = n; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[i]) &#123;</span><br><span class="line">                minIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, n, minIndex);</span><br><span class="line">        sort(arr, n + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        sort(arr, 0);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>时间复杂度：O(N²)<br>从无需集合的1位置开始，比较其01位置的值，如比较01、20、30、40……相当于整体是根据一个有序集合（索引），将无序集合（要排序的集合）往有序集合的区间中插入。<br><img src="/images/math6.png" srcset="/img/loading.gif" alt="math"></p><p>实现代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Code_02_InsertionSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void insertionSort(int[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; 2 || arr == null) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;</span><br><span class="line">                System.out.println(<span class="string">"arr["</span> + j + <span class="string">"], arr["</span> + (j + 1) + <span class="string">"]"</span>);</span><br><span class="line">                swap(arr, j, j + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        insertionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归插入排序"><a href="#递归插入排序" class="headerlink" title="递归插入排序"></a>递归插入排序</h4><p>实现代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Code_02_Recursive_InsertionSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void sort(int[] arr, int n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; 2 || arr == null || n &gt;= arr.length) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = n; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;</span><br><span class="line">                swap(arr, j, j + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr, n + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;3, 2, 0, 7, 4&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        sort(arr, 1);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构 - 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础（二）</title>
    <link href="/2018/08/08/JavaBasic2/"/>
    <url>/2018/08/08/JavaBasic2/</url>
    
    <content type="html"><![CDATA[<p>###对象与类</p><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>比如Student s = new Student()实例化一个对象，其实经历了如下几个过程：<br>将Student.class加载到内存中<br>在栈内存中给s开辟内存空间。<br>在堆内存给Student类申请一个内存空间。<br>给成员变量进行默认初始化，0 null false…<br>自定义给成员变量初始化赋值<br>初始化完毕，把堆内存地址赋值给栈内存的s变量</p><h4 id="Main方法剖析"><a href="#Main方法剖析" class="headerlink" title="Main方法剖析"></a>Main方法剖析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>public: 公共的，访问权限最大，因为main方法是被JVM调用的。</li><li>static：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。</li><li>void: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。</li><li>main: 常见的方法入口，很多语言的入口方法都是main方法。</li><li>String[] args: 字符串数组，是作为命令行参数调用的。</li></ul><h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><p><strong>static关键字特点：（可以修饰成员变量，也可修饰成员方法）</strong></p><ul><li>随着类的加载而加载</li><li>优先于对象存在</li><li>被类中的所有对象共享</li><li>可直接通过类名调用</li></ul><p><strong>拓展</strong></p><p>静态方法中没有this关键字，因为this代表当前方法对象，但static优于对象存在，所以在对象还未创建完毕static修饰的方法就被调用，此时this代表的对象还未创建。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String底层定义为public final class String，说明String是常量，一旦被创建就不能修改。可以查看如Integer LongString这些类的源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class Integer &#123;&#125;</span><br><span class="line">public final class Long &#123;&#125;</span><br><span class="line">public final class String &#123;&#125;</span><br></pre></td></tr></table></figure><p>这些<strong>基本类型</strong>，在初始化值、赋值时都是先从<strong>常量池</strong>中取数据，如果常量池中没有该数据，就new对象初始化为新数据。<br>比如常见的一个面试题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ab"</span>;</span><br><span class="line">s = <span class="string">"abc"</span>;</span><br><span class="line">String ss = <span class="string">"ab"</span>;</span><br><span class="line">ss = new String(<span class="string">"ab"</span>);</span><br></pre></td></tr></table></figure><p>这个s和ss各自创建了几个对象？答案：s创建两个对象；ss创建一个对象。因为s的常量池中有值ab，而重新赋值s = “abc”这个abc在s的常量池中不存在，所以new String()创建了一个新对象。ss同理分析。可以通过如下方式验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String ss = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(ss.hashCode());</span><br><span class="line">ss = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(ss.hashCode());</span><br></pre></td></tr></table></figure><p><a href="/images/String1.png">stack</a></p><h5 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h5><p>String是不可变的字符串，StringBuffer是线程安全的可变字符串，用StringBuffer做字符串的拼接可以避免资源的浪费，因为String每次拼接新的字符串都是创建一个新的String对象。</p><p><strong>String转换为StringBuffer</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//方式一</span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">StringBuffer sb = new StringBuffer(s);</span><br><span class="line">//方式二</span><br><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">sb.append(s);</span><br></pre></td></tr></table></figure><p><strong>StringBuffer转换成String</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//方式一</span><br><span class="line">StringBuffer sb = new StringBuffer(<span class="string">"hello"</span>);</span><br><span class="line">String s = new String(sb);</span><br><span class="line">//方式二</span><br><span class="line">String s = sb.toString();</span><br></pre></td></tr></table></figure><h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><blockquote><p>String, StringBuffer, StringBuilder 的区别？</p></blockquote><ul><li>String的内容不可变，StringBuffer和StringBuilder的内容都可变。</li><li>StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。</li></ul><blockquote><p>StringBuffer和数组的区别？</p></blockquote><ul><li>二者都是一个容器，装其他数据</li><li>但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。</li></ul><blockquote><p>String和StringBuffer作为参数传递</p></blockquote><ul><li>String可理解为特殊的引用类型，和基本类型一样，参数传递不会改变原数据内容。</li><li>StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class StringBufferDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = <span class="string">"hello"</span>;</span><br><span class="line">        String s2 = <span class="string">"world"</span>;</span><br><span class="line">        System.out.println(s1 + <span class="string">"---"</span> + s2);// hello---world</span><br><span class="line">        change(s1, s2);</span><br><span class="line">        System.out.println(s1 + <span class="string">"---"</span> + s2);// hello---world</span><br><span class="line"></span><br><span class="line">        StringBuffer sb1 = new StringBuffer(<span class="string">"hello"</span>);</span><br><span class="line">        StringBuffer sb2 = new StringBuffer(<span class="string">"world"</span>);</span><br><span class="line">        System.out.println(sb1 + <span class="string">"---"</span> + sb2);// hello---world</span><br><span class="line">        change(sb1, sb2);</span><br><span class="line">        System.out.println(sb1 + <span class="string">"---"</span> + sb2);// hello---worldworld</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(StringBuffer sb1, StringBuffer sb2) &#123;</span><br><span class="line">        sb1 = sb2;</span><br><span class="line">        sb2.append(sb1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(String s1, String s2) &#123;</span><br><span class="line">        s1 = s2;</span><br><span class="line">        s2 = s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java中的参数传递：</p><ul><li>基本类型：形式参数的改变对实际参数没有影响。</li><li>引用类型：形式参数的改变直接影响实际参数。</li></ul><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01_Object &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = 20;</span><br><span class="line">        change(a, b);</span><br><span class="line">        System.out.println(<span class="string">"main: a:"</span> + a + <span class="string">", b:"</span> + b); //10, 20</span><br><span class="line">        int[] arr = &#123;1, 2, 3&#125;;</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(<span class="string">"main: "</span> + arr[0]); //2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void change(int a, int b) &#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = a + b;</span><br><span class="line">        System.out.println(<span class="string">"change: a:"</span> + a + <span class="string">", b:"</span> + b); //20, 40</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void change(int[] arr) &#123;</span><br><span class="line">        arr[0] = arr[1];</span><br><span class="line">        System.out.println(<span class="string">"change"</span> + arr[0]); //2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引入概念</strong>：<br>在Java中<strong>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。所有的Java对象都储存在堆内存中</strong>。例如：Date t = new Date()其中的t就是一个对象变量，new Date()是在堆内存中开辟了一个空间，而t指向new Date()的堆内存地址。<br>因此，在上述代码中a b都是基本类型，而int[]是一个引用类型，那<strong>基本类型形式参数改变对实际参数没有影响；对象类型形式参数改变直接影响实际参数。</strong></p><p><a href="/images/stack.png">stack</a></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>Java程序语言总是采用按值调用</strong>，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。</li><li>一个方法可以改变一个对象的引用状态</li><li>一个方法不能让对象参数引用一个新对象</li></ul><p>比如：下列是无意义的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(Employee x, Employee y) &#123;</span><br><span class="line">    Employee temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用swap(e1, e2)时并不会改变e1和e2的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</p><ul><li><strong>基本类型</strong>（包括Integer String Long）传递的参数是参数<strong>值</strong>的拷贝</li></ul><p>特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如IntgerCache LongCache，如果常量池中没有就重新new对象，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s = <span class="string">"123"</span>;</span><br><span class="line">    System.out.println(<span class="string">"main: "</span> + s.hashCode()); //48690</span><br><span class="line">    change(s);</span><br><span class="line">    change2(s);</span><br><span class="line">&#125;</span><br><span class="line">private static void change(String s) &#123;</span><br><span class="line">    s = <span class="string">"123"</span>;</span><br><span class="line">    System.out.println(<span class="string">"change: "</span> + s.hashCode()); //48690</span><br><span class="line">&#125;</span><br><span class="line">private static change2(String s) &#123;</span><br><span class="line">    s = <span class="string">"456"</span>;</span><br><span class="line">    System.out.println(<span class="string">"change2: "</span> + s.hashCode()); //51669</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>引用类型</strong>传递的参数是原对象在<strong>堆内存的地址</strong>的拷贝</li></ul><p>对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。</p><h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><p>成员变量和局部变量的区别：</p><ul><li>在类中的位置不同：<ul><li>成员变量：在类中方法外</li><li>局部变量：在方法定义中或方法声明上</li></ul></li><li>在内存中的位置不同：<ul><li>成员变量：在堆内存</li><li>局部变量：在栈内存</li></ul></li><li>声明周期不同：<ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失。</li><li>局部变量：随着方法的调用而存在，随着方法调用完毕而消失</li></ul></li><li>初始化值不同：<ul><li>成员变量：有默认初始化值</li><li>局部变量：没有默认初始化值，必须定义、赋值后才能使用</li></ul></li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>在Java中，当需要调用构造方法时，<strong>若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义</strong>。举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2_Construct &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo2Student student = new Demo2Student();</span><br><span class="line">        student.show();</span><br><span class="line">        // Demo2School school = new Demo2School(); //error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo2Student &#123;</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"this student show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo2School &#123;</span><br><span class="line">    private int size = 1000;</span><br><span class="line">    public Demo2School(int size) &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>final可以修改类、方法、变量。</p><p><strong>特点</strong>：</p><ul><li>final可以修饰类，该类不能被继承。</li><li>final可以修饰方法，该方法不能被重写。</li><li>final可以修饰变量，该变量不能被重新赋值。</li></ul><p><strong>面试题</strong>：final修饰局部变量的问题</p><ul><li>基本类型：被final修饰的基本类型的值不能被改变</li><li>引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。</li></ul><p><strong>初始化时机</strong><br>被final修饰的变量必须在构造方法完毕前被初始化，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    final int WIDTH = 12;</span><br><span class="line">    //final int HEIGHT; //error</span><br><span class="line">    final int AREA;</span><br><span class="line">    &#123;</span><br><span class="line">        AREA = 120;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>1、Java支持单继承不支持多继承，但Java支持多层继承<br>2、子类只能继承父类非私有成员（成员变量、成员方法）<br>3、子类不能继承父类的构造方法，但可以通过super关键字访问父类的构造方法。</p><h5 id="子类和父类的关系"><a href="#子类和父类的关系" class="headerlink" title="子类和父类的关系"></a>子类和父类的关系</h5><p><strong>子类中的所有构造方法都默认访问父类的无参构造方法</strong>。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是super()。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Demo04_Extends &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo04Son son = new Demo04Son();</span><br><span class="line">        son.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo04Son extends Demo04Parent&#123;</span><br><span class="line">    private int num = 10;</span><br><span class="line">    public <span class="function"><span class="title">Demo04Son</span></span>() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        int num = 100;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(this.num);</span><br><span class="line">        System.out.println(super.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo04Parent &#123;</span><br><span class="line">    public int num = 1;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">Demo04Parent</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"这是父类的无参构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="this-super"><a href="#this-super" class="headerlink" title="this-super"></a>this-super</h5><p>this和super关键字的区别和使用场景？<br>区别：</p><ul><li>this: 代表当前类的对象引用</li><li>super: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）<br>场景：</li><li>this.成员变量/方法</li><li>super.成员变量/方法</li><li>this(…) super(…)</li></ul><h5 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Demo04_Extends2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo04Zi zi = new Demo04Zi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Demo04Fu &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(<span class="string">"Fu 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Fu 构造代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="function"><span class="title">Demo04Fu</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Fu 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Demo04Zi extends Demo04Fu&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(<span class="string">"Zi 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Zi 构造代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="function"><span class="title">Demo04Zi</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Zi 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fu 静态代码块</span><br><span class="line">Zi 静态代码块</span><br><span class="line">Fu 构造代码块</span><br><span class="line">Fu 构造方法</span><br><span class="line">Zi 构造代码块</span><br><span class="line">Zi 构造方法</span><br></pre></td></tr></table></figure><h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p><strong>调用对象方法的执行过程：</strong><br><a href="/images/DomaticBind.png">DomaticBind</a><br>1.编译器首先查看对象的声明类型和方法名。如调用change(a)方法，由于存在多个change()方法，JVM会先列举该类以及其超类中访问属性为public且名为change的方法。<br>2.接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个方法表<strong>（method table）</strong>，JVM会直接从这个方法表中寻找名为change的方法中存在一个与提供的参数类型匹配的方法，这个过程称为<strong>重载解析</strong>。<br>3.如果是private、static、final方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为<strong>静态绑定</strong>。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现<strong>动态绑定</strong>。<br>4.当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。</p><h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接(int) double这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。</p><ul><li><strong>向上转型</strong>：将一个子类的引用赋值给一个超类变量。</li><li><strong>向下转型</strong>：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。</li></ul><p><strong>注意</strong></p><ul><li>只能在继承层次内进行类型转换。</li><li>在将超类转换成子类之前，应该使用instanceof进行检查。</li></ul><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。</p><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类可以访问内部类的成员，必须创建对象</li><li>直接访问内部类的成员：Outer.Inner in = new Outer().new Inner()</li></ul><p><strong>局部内部类</strong><br>局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。</p><blockquote><p>局部内部类访问局部变量注意事项?<br>​局部内部类访问局部变量必须用final修饰。因为<strong>局部内部类的声明周期比局部变量长</strong>，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InnerClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer();</span><br><span class="line">        outer.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        int num2 = 10;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            private void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">                System.out.println(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = new Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用不会报错，但并没有加final修饰。这个类编译后会生成InnerClass.class和Outer.class两个文件，我们来看下Outer.class:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    <span class="function"><span class="title">Outer</span></span>() &#123;&#125;</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        final int num2 = 10;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            <span class="function"><span class="title">Inner</span></span>() &#123;&#125;</span><br><span class="line">            private void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">                System.out.println(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = new Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的num2被自动加上了final修饰（这是因为JDK1.8的原因），所以如果你再添上num2 = 1000就会报错。</p><blockquote><p>解决办法<br>上面说过了应该将num2用final修饰。其原因就是Inner类的生命周期要比num2的声明周期长，当show()方法调用完毕后num2就已经消失了，但此时Inner类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用final修饰，这个变量成为常量，在初始化内部类的时候，final num2就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础（一）</title>
    <link href="/2018/08/01/JavaBasic1/"/>
    <url>/2018/08/01/JavaBasic1/</url>
    
    <content type="html"><![CDATA[<p>记录一些Java基础的知识点，为了自己查阅资料的时候方便一些。</p><hr><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="JDK和JRE的区别？"><a href="#JDK和JRE的区别？" class="headerlink" title="JDK和JRE的区别？"></a>JDK和JRE的区别？</h4><p>1、jre即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库<br>2、jdk是Java开发工具包，例如：tools.jar</p><hr><h4 id="和-equals的区别"><a href="#和-equals的区别" class="headerlink" title="== 和 equals的区别"></a>== 和 equals的区别</h4><p>1、==是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址<br>2、equals是超类Object就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。equals方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。<br>Object类equals方法源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    <span class="built_in">return</span> (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，举个栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class EqualsTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User a = new User();</span><br><span class="line">        User b = new User();</span><br><span class="line">        System.out.println(a == b); //<span class="literal">false</span></span><br><span class="line">        System.out.println(a.equals(b)); //<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (this == o) <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o instanceof User)) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="built_in">return</span> age == user.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int <span class="function"><span class="title">hashCode</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> Objects.hash(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="两个对象的hashCode-相同，则equals-一定为true？"><a href="#两个对象的hashCode-相同，则equals-一定为true？" class="headerlink" title="两个对象的hashCode()相同，则equals()一定为true？"></a>两个对象的hashCode()相同，则equals()一定为true？</h4><p><strong>如果两个对象相等(equals()为true)，那么他们的hashCode()一定相同</strong><br><strong>如果两个对象的hashCode()相同，他们的equals()方法不一定相同</strong></p><p>JVM虚拟机通过hashCode()方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过hashCode()获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用equals()与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用equals()方法比较的次数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class EqualsTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User a = new User();</span><br><span class="line">        User b = new User();</span><br><span class="line">        System.out.println(a == b); //<span class="literal">false</span></span><br><span class="line">        System.out.println(a.equals(b)); //<span class="literal">false</span></span><br><span class="line">        System.out.println(a.hashCode() == b.hashCode()); //<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h4><p>可修饰类、类属性、类方法。<br>1、被final修饰的类不能被继承<br>2、final修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class FinalTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final User USER = new User();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User u2 = new User();</span><br><span class="line">//        user = u2; // ERROR</span><br><span class="line">        USER.age = 23;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    int age = 12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。</p><hr><h4 id="String属于基本数据类型吗？"><a href="#String属于基本数据类型吗？" class="headerlink" title="String属于基本数据类型吗？"></a>String属于基本数据类型吗？</h4><p><strong>不，String属于特殊的引用类型</strong></p><p>Java中基本数据类型有：int、short、long、char、boolean、float、double、byte</p><p>1、String是特殊的引用类型并且是final的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。<br>2、String s = “a”; s += “b”;，这段代码执行前后，字符串常量池中将出现a和ab两个字符串常量，而原本s变量的引用指向了常量池中ab。<br>3、String s = new String(“ab”)，这段代码一共创建了几个对象？一个或两个。如果字符串常量池中有了ab这个字符串(比如在此之前已经使用了String str = “ab”)，那么新的s对象引用其实仅仅是指向了字符串常量中的ab，并没有创建新的字符串对象。但是，每次调用new都会在堆内存开辟空间，创建一个String对象，这是肯定的。</p><p>栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = <span class="string">"abc"</span>;</span><br><span class="line">        String b = <span class="string">"abc"</span>;</span><br><span class="line">        String c = new String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(a == b); //<span class="literal">true</span></span><br><span class="line">        System.out.println(a.equals(b)); //<span class="literal">true</span></span><br><span class="line">        System.out.println(a.equals(c)); //<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String和StringBuffer和StringBuilder的区别</strong><br>1、String是不可变字符串，StringBuffer和StringBuilder是可变字符串。如果经常改变字符串的原始数据，最好使用StringBuffer代替。<br>2、String默认重写了equals方法和hashCode()方法；而StringBuffer没有重写equals方法，使用new StringBuffer(“”)会直接在堆内存中开辟空间储存对象。因此将StringBuffer对象储存仅Java集合中可能会出现问题。<br>3、StringBuffer是线程安全的，效率低；StringBuilder是线程不安全的，效率高。</p><hr><h4 id="static关键字？是否可覆盖？"><a href="#static关键字？是否可覆盖？" class="headerlink" title="static关键字？是否可覆盖？"></a>static关键字？是否可覆盖？</h4><p>static关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。</p><p>static标记的方法只能访问static变量或方法<br>非static标记的方法可以访问static或非static标记的变量或方法</p><hr><h4 id="自动拆、装箱"><a href="#自动拆、装箱" class="headerlink" title="自动拆、装箱"></a>自动拆、装箱</h4><p>因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。<br>具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)</p><table><thead><tr><th align="center">基本数据类型</th><th align="center">引用数据类型</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">char</td><td align="center">Char</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr></tbody></table><p>栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer i1 = 100;</span><br><span class="line">    Integer i2 = 100;</span><br><span class="line">    Integer i3 = 200;</span><br><span class="line">    Integer i4 = 200;</span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>Java中实现基本数据类型和引用类型之间的拆装箱一般都是用过valueOf()方法实现的。例如我们看下Integer类的valueOf()方法源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="built_in">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="built_in">return</span> new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：当声明一个新的整数型变量，编译时通过Integer类的valueOf()进行拆装箱计算，这个方法会首先比较这个整数值是否在IntegerCache的范围内，如果在就返回IntegerCache类中的数值；如果不在就直接new Integer。那么我们看下IntegerCache类源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, 127);</span><br><span class="line">                // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        <span class="keyword">for</span>(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">IntegerCache</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在[-128, 127]之间，就直接返回IntegerCache中储存的常量值，否则就直接new一个新的Integer来保存这个常量值。所以上面才会出现false的结果。<br>同理：其他的数据类型例如：long、short等都具有对应的LongCache、ShortCache等类。</p><hr><h4 id="Overriding和Overloaded"><a href="#Overriding和Overloaded" class="headerlink" title="Overriding和Overloaded"></a>Overriding和Overloaded</h4><p>方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。<br>Overriding: 子类中定义了和父类中名称、参数列表相同的方法<br>Overloaded: 方法名相同，参数列表不同</p><hr><h4 id="Java支持多继承吗？"><a href="#Java支持多继承吗？" class="headerlink" title="Java支持多继承吗？"></a>Java支持多继承吗？</h4><p>不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过多层继承实现。<br>类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。<br>从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。</p><hr><h4 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h4><ul><li>接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li><li>接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )</li><li>类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )</li><li>抽象类可以是不提供接口方法实现的情况下实现接口</li><li>接口中声明的变量默认都是final的；但抽象类可以包含非final的变量</li><li>接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public</li><li>接口是绝对抽象的，不可以被实例化；</li></ul><hr><h4 id="引用传递和值传递"><a href="#引用传递和值传递" class="headerlink" title="引用传递和值传递"></a>引用传递和值传递</h4><p><strong>Java中采用值传递的方式</strong><br>栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TransferTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 1;</span><br><span class="line">        Integer b = 2;</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        int[] arr = &#123;1, 2&#125;;</span><br><span class="line">        swap(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr) &#123;</span><br><span class="line">        arr[0] = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int a, Integer b) &#123;</span><br><span class="line">        a = 10;</span><br><span class="line">        b = 20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。<br>所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。</p><hr><h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><p><img src="/images/io.png" srcset="/img/loading.gif" alt="IO流"></p><p><strong>1、Java中有几种类型的流？</strong><br>字符流和字节流。字节流继承InputStream和OutputStream；字符流继承自InputStreamReader和OutputStreamWriter。</p><p><strong>2、谈谈Java IO中的方法阻塞</strong><br>Java中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。</p><p><strong>3、字符流和字节流的区别？</strong><br>数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。<br>而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。<br>字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。</p><p><strong>4、NIO</strong><br>传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read()等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept()时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。<br>而对于NIO，它是非阻塞式，核心类：</p><ul><li>Buffer： 为所有的原始类型提供Buffer缓冲支持</li><li>Charset： 字符集编码解码解决方案</li><li>Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接。</li></ul><hr><h4 id="说说List、Set、Map三者的区别"><a href="#说说List、Set、Map三者的区别" class="headerlink" title="说说List、Set、Map三者的区别"></a>说说List、Set、Map三者的区别</h4><ul><li>List: List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素</li><li>Set: 不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素</li><li>Map: 使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。</li></ul><hr><h4 id="Array和ArrayList有什么区别？"><a href="#Array和ArrayList有什么区别？" class="headerlink" title="Array和ArrayList有什么区别？"></a>Array和ArrayList有什么区别？</h4><ul><li>Array可以包含基本类型和对象类型；ArrayList只能包含对象类型</li><li>Array大小是固定的；ArrayList大小是动态变化的</li><li>ArrayList提供了诸如addAll()、removeAll()、iterator()方法等</li><li>对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。</li></ul><hr><h4 id="ArrayList和LinkedList的区别？"><a href="#ArrayList和LinkedList的区别？" class="headerlink" title="ArrayList和LinkedList的区别？"></a>ArrayList和LinkedList的区别？</h4><p>1、<strong>是否保证线程安全</strong>： ArrayList和LinkedList都是不同步的，也就是不保证线程安全<br>2、<strong>底层数据结构</strong>： ArrayList底层使用的是Object数组；LinkedList底层使用的是 双向链表 结构<br>3、<strong>插入和删除是否受元素位置影响？</strong> ArrayList采用数组储存，所以插入和删除元素都受元素位置的影响；LinkedList 采用链表储存，所以插入、删除元素都不受元素位置影响。<br>4、<strong>是否支持快速随机访问？</strong> LinkedList因为使用链表储存，无法通过元素索引快速访问；而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。<br>5、<strong>内存空间占用</strong>： ArrayList的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而LinkedList的空间花费体现在他的每一个元素都需要消耗比ArrayList更多的空间（因为要储存直接后继和直接前驱以及数据）。</p><hr><p><strong>什么是迭代器</strong><br><em>Iterator</em>接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法<em>iterator()</em>。迭代器在迭代的过程中可以删除底层集合的元素。</p><p><strong>Iterator和ListIterator的区别？</strong></p><ul><li>Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List</li><li>Iterator对集合只能向前遍历（next()）；而*ListIterator可以向前遍历（next()），也可以向后遍历（previous()）</li><li>ListIterator实现了Iterator接口</li></ul><p><strong>RandomAccess接口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//ArrayList</span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">//RandomAccess</span><br><span class="line">public interface RandomAccess &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//LinkedList</span><br><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>源码中ArrayList类实现了RandomAccess接口，LinkedList类中却没有实现这个接口，但是RandomAccess接口中却什么也没有定义。可以看RandomAccess接口上的注释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that</span><br><span class="line"> * they support fast (generally constant time) random access.  The primary</span><br><span class="line"> * purpose of this interface is to allow generic algorithms to alter their</span><br><span class="line"> * behavior to provide good performance when applied to either random or</span><br><span class="line"> * sequential access lists.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看Collections类中的binarySearch方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt;</span><br><span class="line">int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="built_in">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt;</span><br><span class="line">int indexedBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = list.size()-1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">        Comparable&lt;? super T&gt; midVal = list.get(mid);</span><br><span class="line">        int cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; 0)</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; 0)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> mid; // key found</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -(low + 1);  // key not found</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt;</span><br><span class="line">int iteratorBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</span><br><span class="line">&#123;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = list.size()-1;</span><br><span class="line">    ListIterator&lt;? extends Comparable&lt;? super T&gt;&gt; i = list.listIterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">        Comparable&lt;? super T&gt; midVal = get(i, mid);</span><br><span class="line">        int cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; 0)</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; 0)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> mid; // key found</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -(low + 1);  // key not found</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binarySearch()方法是从List中查找指定元素，其中首先判断传入的List时候实现了RandomAccess接口，如果实现了就调用indexedBinarySearch()方法，否则就调用iteratorBinarySearch()方法。再看这两个方法的源码：<br>如果传入的List实现了RandomAccess接口，采用普通for循环遍历<br>若传入的List未实现RandomAccess接口，采用iterator遍历</p><p><strong>链表</strong></p><p><strong>链表（Linked List）</strong>由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针</p><blockquote><p>单向链表<br>单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。</p></blockquote><ul><li><p>单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找<br><img src="/images/linktable1.png" srcset="/img/loading.gif" alt="单向链表"></p></li><li><p>单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可<br><img src="/images/linktable2.png" srcset="/img/loading.gif" alt="单向链表"></p></li><li><p>删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可<br><img src="/images/linktable3.png" srcset="/img/loading.gif" alt="单向链表"></p></li></ul><blockquote><p>双向链表<br><strong>双向链表</strong> 包含两个指针，prev指向前一个节点，next指向后一个节点。<br><img src="/images/linktable4.png" srcset="/img/loading.gif" alt="双向链表"></p></blockquote><blockquote><p>双向循环链表<br><strong>双向循环链表</strong> 最后一个节点的<em>next</em>指向<em>head</em>，而<em>head</em>的<em>prev</em>指向最后一个节点，形成一个环。<br><img src="/images/linktable5.png" srcset="/img/loading.gif" alt="双向循环链表"></p></blockquote><hr><h4 id="ArrayList和Vector和LinkedList的区别？"><a href="#ArrayList和Vector和LinkedList的区别？" class="headerlink" title="ArrayList和Vector和LinkedList的区别？"></a>ArrayList和Vector和LinkedList的区别？</h4><ul><li><strong>ArrayList</strong>: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高</li><li><strong>Vector</strong>: 底层数据结构是数组，查询快，增删慢。线程安全，效率低</li><li><strong>LinkedList</strong>: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高</li></ul><hr><h4 id="谈谈ArrayList的扩容机制"><a href="#谈谈ArrayList的扩容机制" class="headerlink" title="谈谈ArrayList的扩容机制"></a>谈谈ArrayList的扩容机制</h4><p>Java中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，ArrayList的出现就解决了这一问题。<br>ArrayList的扩容机制表现在add()方法上，先看add()方法的源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取最小容量</span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="built_in">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否需要扩容</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当向ArrayList对象中添加新元素时，首先会调用ensureCapacityInternal(size)方法，size为最小扩容量；ensureCapacityInternal()方法会首先调用calculateCapacity来确定需要的最小容量；最后调用ensureExplicitCapacity()方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用grow()方法扩容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // 获取ArrayList中elementDaata数组的长度</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    // 扩容至原来的1.5倍</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    // 判断新的数组容量够不够</span><br><span class="line">    // 够了就直接使用这个长度创建新数组</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        // 不够就将数组的长度设置为需要的长度</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    // 检查此时的最大值是否溢出</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // 调用Arrays.copyOf()将elementData数组数据拷贝到新数组</span><br><span class="line">    // 并将elementData指向新数组newCapacity的内存地址</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>： ArrayList扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。</p><hr><h4 id="HashMap和HashTable的区别？"><a href="#HashMap和HashTable的区别？" class="headerlink" title="HashMap和HashTable的区别？"></a>HashMap和HashTable的区别？</h4><p>1、HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度<br>2、线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰。<br>3、效率: HashMap线程不安全效率高，HashTable线程安全效率低。<br>3、对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null<br>5、底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制。</p><hr><h4 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别?"></a>HashMap和HashSet区别?</h4><p><strong>HashSet底层采用HashMap实现</strong><br>HashMap|HashSet<br>:–|:–<br>实现了Map接口|实现了Set接口<br>储存键值堆|仅储存对象<br>调用put()向Map中添加元素|调用add()向Set中添加元素<br>HashMap使用Key计算HashCode|HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以用equals判断对象的相等性</p><hr><h4 id="HashSet如何检查重复？"><a href="#HashSet如何检查重复？" class="headerlink" title="HashSet如何检查重复？"></a>HashSet如何检查重复？</h4><p>在前面讲hashCode和equals时就提到了，HashSet集合同样适用。向HashSet中存入一个元素，HashSet首先会根据对象的hashCode值判断当期集合中此hashCode对应的位置有没有值，如果没有就直接添加，如果有就再调用equals方法比较两个对象是否相同，相同就不再储存（保证了Set集合不重复的特性），否则就散列到其他位置储存。</p><hr><h4 id="HashMap底层实现？"><a href="#HashMap底层实现？" class="headerlink" title="HashMap底层实现？"></a>HashMap底层实现？</h4><p>Map在Java中的实现由很多，HashMap便是其中之一，随着JDK版本的更新，HashMap的实现也在不断更新：</p><ul><li>&lt;=JDK1.7: Table数组 + Entry链表</li><li><blockquote><p>=JDK1.8: Table数组 + Entry链表/红黑树</p></blockquote></li></ul><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p><strong>Hash（哈希、散列）</strong>，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。<br>Hash函数的一种实现：<br>直接取余法： f(x) = x mod max<br>位运算法： f(x) = x &amp; max<br>HashMap采用 位运算法，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">7 &amp; 33 = 1</span><br><span class="line">    </span><br><span class="line">    000111</span><br><span class="line">  &amp; 100001</span><br><span class="line">  --------</span><br><span class="line">    000001 = 1</span><br></pre></td></tr></table></figure><hr><h4 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h4><p>假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到HashMap集合中，若将多个K-V数据存入put，HashMap根据元素key计算到对应的hashCode值，如果计算得到多个不同的key对应的hashCode值相同（即要储存到同一位置），此时这种现象就称为 Hash冲突。<br>HashMap默认采用了 链地址法 解决Hash冲突问题，即通过类似单链表的方式将 冲突的元素 串起来，搜索时遍历这个链表即可。注意： 如果冲突的Hash越来越多，这个链就会越来越长。</p><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src="/images/hash1.png" srcset="/img/loading.gif" alt="hash冲突与实现原理"><br>这里我们需要了解两个名词：<br>Table: 哈希桶数组（哈希表），存放Node元素，底层是一个Node[] table<br>Node: 节点元素，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（K-V）<br>HashMap内部的一些关键属性需要了解：<br>DEFAULT_INITIAL_CAPACITY: Tabale数组的初始化长度，默认是1 &lt;&lt; 4，2^4 = 16<br>MAXIMUM_CAPACITY: Table数组最高长度，默认为1 &lt;&lt; 30，2^30 = 1073741824<br>DEFAULT_LOAD_FACTOR: 负载因子，当总元素数 &gt; 数组长度 * 负载因子时，Table数组将扩容，默认是0.75<br>TREEIFY_THRESHOLD: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8<br>UNTREEIFY_THRESHOLD: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6<br>MIN_TREEIFY_CAPACITY: 最小树化阀值，当Table中所有元素超过该值，才会进行树化<br>size: 当前HashMap实际存在的键值对数量<br>threshold: HashMap所能容纳的最大数据量的Node（键值对）个数。Node[] table初始化长度length是16，loadFactor负载因子默认是0.75，threshold = length * loadFactor<br>loadFactor: 负载因子，默认是0.17<br>modCount: 记录HashMap内部结构发生变化的次数<br>HashMap内部存在一个NodeTable数组，这个数组的初始化长度是DEFAULT_INITIAL_CAPACITY，他是一个单向链表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int <span class="built_in">hash</span>; //key的Hash值</span><br><span class="line">    final K key; //key</span><br><span class="line">    V value; //value</span><br><span class="line">    Node&lt;K,V&gt; next; //下一个节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考单链表的结构，Table中每个Node节点包含两个部分，Node元素作为节点的header，next指向下一个节点。<strong>这种链式结构的存在正是为了解决Hash冲突</strong></p><p>栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"loonycoder"</span>, <span class="string">"18"</span>);</span><br></pre></td></tr></table></figure><p>HashMap将根据”loonycoder”这个Key得到其hashCode值，然后经过Hash算法定位到其在HashMap储存的位置，如果两个不同的key定位到了同一个位置，此时就发生了Hash冲突。<br>在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过TREEIFY_THRESHOLD阀值后，会将链表转换为红黑树的实现TreeNode:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">    boolean red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发生<strong>Hash冲突</strong>时，根据HashMap默认采用的 <strong>链地址法</strong>，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。但是 随着Hash冲突越来越多，这个<strong>链将越来越长</strong>，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。<br><img src="http://cdn.tycoding.cn/JDK1.8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" srcset="/img/loading.gif" alt="地址链法"></p><p><strong>总结</strong><br>到此，我们总结一下HashMap的实现原理：</p><ul><li>HashMap根据key的hashCode值存储元素。put新元素会遍历链表，根据新元素的key计算hashCode得到散列位置，如果该位置有值再调用equals判断value是否相同，相同就散列到其他位置储存。</li><li>HashMap在put新元素时如果遇到key对应的hashCode相同，可能会产生Hash冲突问题。HashMap的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。</li><li>如果发生Hash冲突的元素很多，这个 <strong>链</strong> 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（TreeNode）存储元素。</li></ul><hr><h4 id="Collection和Collections的区别？"><a href="#Collection和Collections的区别？" class="headerlink" title="Collection和Collections的区别？"></a>Collection和Collections的区别？</h4><ul><li>Collection是集合类的上级接口，继承他的接口主要有Set和List</li><li>Collections仅是针对集合类封装的一个工具类，在java.util包下</li></ul><hr><h4 id="Comparable和Comparator的区别？"><a href="#Comparable和Comparator的区别？" class="headerlink" title="Comparable和Comparator的区别？"></a>Comparable和Comparator的区别？</h4><ul><li>Comparable接口来自java.lang包，提供compareTo(Object obj) 方法排序</li><li>Comparator接口来自java.util包，提供compare(Object obj1, Object obj2)方法排序<br>当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。</li></ul><h4 id="Java集合框架总结"><a href="#Java集合框架总结" class="headerlink" title="Java集合框架总结"></a>Java集合框架总结</h4><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p><img src="/images/collection1.png" srcset="/img/loading.gif" alt="Collection"></p><p><strong>List</strong></p><p>ArrayList: Object数组，线程不安全，查询快，增删慢，效率高<br>Vector: Object数组，线程安全，查询快，增删慢，效率低<br>LinkedList: 双向链表，线程不安全，查询慢，增删快，效率高</p><p><strong>Set</strong></p><p>HashSet: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素<br>LinkedHashSet: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现<br>TreeSet 有序、唯一，红黑树</p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p><img src="/images/map1.png" srcset="/img/loading.gif" alt="Map"></p><ul><li>HashMap: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。</li><li>LinkedHashMap: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li><li>HashTable: 数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题<br>TreeMap: 红黑树</li></ul><hr><h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h3><h4 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h4><ul><li>进程是程序的一次执行过程，是系统运行程序的基本单位</li><li>线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，<br>在Java中，启用一个main方法就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。</li></ul><hr><h4 id="从JVM角度分析进程和线程的关系？"><a href="#从JVM角度分析进程和线程的关系？" class="headerlink" title="从JVM角度分析进程和线程的关系？"></a>从JVM角度分析进程和线程的关系？</h4><p>根据JVM的内存划分，对于线程而言：多个线程共享进程的堆、方法区资源，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。</p><p>也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。</p><h5 id="为什么方法区和堆是线程共享区？"><a href="#为什么方法区和堆是线程共享区？" class="headerlink" title="为什么方法区和堆是线程共享区？"></a>为什么方法区和堆是线程共享区？</h5><ul><li><strong>方法区（Method Area）</strong> 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 运行时常量池 ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。</li><li><strong>堆（Heap）</strong> 堆内存储存了对象实例（比如new关键字创建的实例对象），它是JVM中内存区最大的一块区域。<br>所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。</li></ul><h5 id="为什么虚拟机栈和本地方法栈是线程独占区？"><a href="#为什么虚拟机栈和本地方法栈是线程独占区？" class="headerlink" title="为什么虚拟机栈和本地方法栈是线程独占区？"></a>为什么虚拟机栈和本地方法栈是线程独占区？</h5><ul><li><strong>虚拟机栈</strong>： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。</li><li><strong>本地方法栈</strong>： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。</li></ul><h5 id="程序计数器是什么？"><a href="#程序计数器是什么？" class="headerlink" title="程序计数器是什么？"></a>程序计数器是什么？</h5><p><strong>程序计数器（Program Counter Register）</strong>：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。</p><hr><h4 id="说说并行和并发的区别？"><a href="#说说并行和并发的区别？" class="headerlink" title="说说并行和并发的区别？"></a>说说并行和并发的区别？</h4><ul><li><strong>并行</strong>： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li><li><strong>并发</strong>： 单位时间内，多个任务同时执行。</li></ul><hr><h4 id="使用多线程可能带来什么问题？"><a href="#使用多线程可能带来什么问题？" class="headerlink" title="使用多线程可能带来什么问题？"></a>使用多线程可能带来什么问题？</h4><p>并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题</p><hr><h4 id="说说线程的生命周期和状态？"><a href="#说说线程的生命周期和状态？" class="headerlink" title="说说线程的生命周期和状态？"></a>说说线程的生命周期和状态？</h4><table><thead><tr><th align="left">状态名称</th><th align="left">状态说明</th></tr></thead><tbody><tr><td align="left">new</td><td align="left">初始状态，线程被创建，但还没有调用start()方法</td></tr><tr><td align="left">runnable</td><td align="left">运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”</td></tr><tr><td align="left">blocked</td><td align="left">阻塞状态，表示线程阻塞于锁</td></tr><tr><td align="left">waiting</td><td align="left">等待状态，线程需要等待当前线程或其他线程执行完成</td></tr><tr><td align="left">time_waiting</td><td align="left">超时等待状态，他可以实现在指定时间后自动返回</td></tr><tr><td align="left">terminated</td><td align="left">终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><p>对应，程序会因为不同代码的执行产生不同的状态，如下图：<br><img src="/images/thread2.png" srcset="/img/loading.gif" alt="线程图"><br>如上，线程创建后将进入NEW（初始）状态，调用start()开始运行，当线程执行wait()方法后，线程将进入WAITING（等待）状态，可以通过wait(long)或join(long)等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED（阻塞）状态。</p><hr><h4 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h4><p>简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用<strong>随机分配时间片并轮转</strong>的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 <strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><hr><h4 id="什么是死锁？如何避免"><a href="#什么是死锁？如何避免" class="headerlink" title="什么是死锁？如何避免?"></a>什么是死锁？如何避免?</h4><p>举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。<br><img src="/images/deadlock.png" srcset="/img/loading.gif" alt="死锁"><br>栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    private static Object resource1 = new Object();//资源 1</span><br><span class="line">    private static Object resource2 = new Object();//资源 2</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                synchronized (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                synchronized (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure><p>线程1以resource1作为同步监视器，即可以轻松获取resource1同时也锁定了resource1，此时调用sleep让线程1等待1秒钟；此时线程2开始执行，他以resource2作为同步监视器同时也锁定了resource2，此时调用sleep让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取resource2时发现resource2已经被线程2锁定了，同理线程2结束等待后想要获取resource1时发现resource1已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。<br>因此产生死锁需要具备以下四个条件：</p><p>1、互斥条件：该资源任意一个时刻只能由一个线程占用<br>2、请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放<br>3、不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源<br>4、循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。</p><p>避免死锁就要破坏这四个条件中任意一个：<br>1、破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥<br>2、破坏请求与保持条件：一次性申请所有资源<br>3、破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用</p><p>解决方案: 修改线程2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    synchronized (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">        synchronized (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"线程 2"</span>).start();</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 1,5,main]get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure><hr><h4 id="说说sleep-方法和wait-方法的区别？"><a href="#说说sleep-方法和wait-方法的区别？" class="headerlink" title="说说sleep()方法和wait()方法的区别？"></a>说说sleep()方法和wait()方法的区别？</h4><p>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong></p><ul><li>两者都可以暂停线程的执行</li><li>wait()通常用于线程间交互/通信，sleep()通常用户暂停执行</li><li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li></ul><hr><h4 id="调用start-方法会执行run-方法，为什么不能直接调用run-方法？"><a href="#调用start-方法会执行run-方法，为什么不能直接调用run-方法？" class="headerlink" title="调用start()方法会执行run()方法，为什么不能直接调用run()方法？"></a>调用start()方法会执行run()方法，为什么不能直接调用run()方法？</h4><p>new一个Thread，线程进入了新建状态；调用start()方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这才是真正的多线程工作。而直接执行run()方法，会吧run()方法当做一个main线程下的一个普通方法去执行，并不会在某个线程中执行他。<br><strong>总结：调用start方法可以启动线程并使线程进入就绪状态，而run()方法只是Thread的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行</strong></p><hr><h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><p>synchronized关键字解决多个线程之间访问资源的同步性，synchronized关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。<br>synchronized关键字最主要的三种使用方式：</p><ul><li><p><strong>修饰实例方法</strong>： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象</span><br><span class="line">public synchronized void <span class="function"><span class="title">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>修饰静态方法</strong>： 给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)</span><br><span class="line">public synchronized static void <span class="function"><span class="title">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁</p></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
