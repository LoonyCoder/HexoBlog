<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="Life Is So Short , Just Coding.">
  <meta name="author" content="LoonyCoder">
  <meta name="keywords" content="隐约雷鸣，阴霾天空，但盼风雨来，能留你于此">
  <title>轻量级控制反转和面向切面的容器框架——Spring（四） ~ 望月Plenilune</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>望月Plenilune</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/images/post_banner.jpg')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期一, 八月 12日 2019, 3:48 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    3.3k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      13 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <p><img src="/images/spring_logo.jpg" srcset="/img/loading.gif" alt="spring"></p>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前整理过一些关于Spring框架零散的知识点，一直没时间整理，恰好最近又拜读了<strong>应癫</strong>老师的课程，所以赶紧梳理一下关于Spring的相关知识。</p>
<hr>
<h3 id="Spring-IoC源码深度剖析"><a href="#Spring-IoC源码深度剖析" class="headerlink" title="Spring IoC源码深度剖析"></a>Spring IoC源码深度剖析</h3><ul>
<li>好处：提⾼培养代码架构思维、深⼊理解框架</li>
<li>原则<ul>
<li>定焦原则：抓主线</li>
<li>宏观原则：站在上帝视⻆，关注源码结构和业务流程（淡化具体某⾏代码的编写细节）</li>
</ul>
</li>
<li>读源码的⽅法和技巧<ul>
<li>断点（观察调⽤栈）</li>
<li>反调（Find Usages）</li>
<li>经验（spring框架中doXXX，做具体处理的地⽅）</li>
</ul>
</li>
<li>Spring源码构建<ul>
<li>下载源码（github）</li>
<li>安装gradle 5.6.3（类似于maven）idea 2019.1 jdk 11.0.5</li>
<li>导⼊（耗费⼀定时间）</li>
<li>编译⼯程（顺序：core-oxm-context-beans-aspects-aop）</li>
<li>⼯程—&gt;tasks—&gt;compileTestJava</li>
</ul>
</li>
</ul>
<h4 id="Spring-IoC容器初始化主题流程"><a href="#Spring-IoC容器初始化主题流程" class="headerlink" title="Spring IoC容器初始化主题流程"></a>Spring IoC容器初始化主题流程</h4><h5 id="Spring-IoC的容器体系"><a href="#Spring-IoC的容器体系" class="headerlink" title="Spring IoC的容器体系"></a>Spring IoC的容器体系</h5><p>IoC容器是Spring的核⼼模块，是抽象了对象管理、依赖关系管理的框架解决⽅案。Spring 提供了很多<br>的容器，其中 BeanFactory 是顶层容器（根容器），不能被实例化，它定义了所有 IoC 容器 必须遵从<br>的⼀套原则，具体的容器实现可以增加额外的功能，⽐如我们常⽤到的<code>ApplicationContext</code>，其下更具<br>体的实现如 <code>ClassPathXmlApplicationContext</code> 包含了解析 xml 等⼀系列的内容，<br><code>AnnotationConfigApplicationContext</code> 则是包含了注解解析等⼀系列的内容。Spring IoC 容器继承体系<br>⾮常聪明，需要使⽤哪个层次⽤哪个层次即可，不必使⽤功能⼤⽽全的。<br>BeanFactory 顶级接⼝⽅法栈如下</p>
<p><img src="/images/spring/s33.png" srcset="/img/loading.gif" alt="spring"></p>
<p>BeanFactory 容器继承体系</p>
<p><img src="/images/spring/s34.png" srcset="/img/loading.gif" alt="spring"></p>
<p>通过其接⼝设计，我们可以看到我们⼀贯使⽤的 <code>ApplicationContext</code> 除了继承<code>BeanFactory</code>的⼦接⼝，<br>还继承了<code>ResourceLoader</code>、<code>MessageSource</code>等接⼝，因此其提供的功能也就更丰富了。<br>下⾯我们以 <code>ClasspathXmlApplicationContext</code> 为例，深⼊源码说明 IoC 容器的初始化流程。</p>
<h5 id="Bean生命周期关键时机点"><a href="#Bean生命周期关键时机点" class="headerlink" title="Bean生命周期关键时机点"></a>Bean生命周期关键时机点</h5><p>思路：创建⼀个类 loonycoderBean ，让其实现⼏个特殊的接⼝，并分别在接⼝实现的构造器、接⼝⽅法中<br>断点，观察线程调⽤栈，分析出 Bean 对象创建和管理关键点的触发时机。</p>
<p>loonycoderBean类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class loonycoderBean implements InitializingBean&#123;</span><br><span class="line">/**</span><br><span class="line">* 构造函数</span><br><span class="line">*/</span><br><span class="line">	public <span class="function"><span class="title">loonycoderBean</span></span>()&#123;</span><br><span class="line">		System.out.println(<span class="string">"loonycoderBean 构造器..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	* InitializingBean 接⼝实现</span><br><span class="line">	*/</span><br><span class="line">	public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">		System.out.println(<span class="string">"loonycoderBean afterPropertiesSet..."</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanPostProcessor 接⼝实现类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line">	public <span class="function"><span class="title">MyBeanPostProcessor</span></span>() &#123;</span><br><span class="line">		System.out.println(<span class="string">"BeanPostProcessor 实现类构造函数..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public Object postProcessBeforeInitialization(Object bean, String beanName)</span><br><span class="line">	throws BeansException &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">"loonycoderBean"</span>.equals(beanName)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"BeanPostProcessor 实现类 postProcessBeforeInitialization ⽅法被调⽤中......"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> bean; </span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public Object postProcessAfterInitialization(Object bean, String beanName)</span><br><span class="line">	throws BeansException &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">"loonycoderBean"</span>.equals(beanName)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"BeanPostProcessor 实现类 postProcessAfterInitialization ⽅法被调⽤中......"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> bean; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactoryPostProcessor 接⼝实现类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">	public <span class="function"><span class="title">MyBeanFactoryPostProcessor</span></span>() &#123;</span><br><span class="line">		System.out.println(<span class="string">"BeanFactoryPostProcessor的实现类构造函数..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanFactory(ConfigurableListableBeanFactory</span><br><span class="line">	beanFactory) throws BeansException &#123;</span><br><span class="line">		System.out.println(<span class="string">"BeanFactoryPostProcessor的实现⽅法调⽤中......"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applicationContext.xml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">	xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">	xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">	http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">	https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">	"</span>&gt;</span><br><span class="line">	&lt;bean id=<span class="string">"loonycoderBean"</span> class=<span class="string">"com.loonycoder.loonycoderBean"</span>/&gt;</span><br><span class="line">	&lt;bean id=<span class="string">"myBeanFactoryPostProcessor"</span></span><br><span class="line">	class=<span class="string">"com.loonycoder.MyBeanFactoryPostProcessor"</span>/&gt;</span><br><span class="line">	&lt;bean id=<span class="string">"myBeanPostProcessor"</span> class=<span class="string">"com.loonycoder.MyBeanPostProcessor"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>IoC 容器源码分析⽤例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testIoC</span></span>() &#123;</span><br><span class="line">	ApplicationContext applicationContext = new ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">	loonycoderBean loonycoderBean = applicationContext.getBean(loonycoderBean.class);</span><br><span class="line">	System.out.println(loonycoderBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>分析 Bean 的创建是在容器初始化时还是在 getBean 时</li>
</ol>
<p><img src="/images/spring/s35.png" srcset="/img/loading.gif" alt="spring"></p>
<p>根据断点调试，我们发现，在未设置延迟加载的前提下，Bean 的创建是在容器初始化过程中完成的。</p>
<ol start="2">
<li>分析构造函数调⽤情况</li>
</ol>
<p><img src="/images/spring/s36.png" srcset="/img/loading.gif" alt="spring"></p>
<p>通过如上观察，我们发现构造函数的调⽤时机在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<br><code>finishBeanFactoryInitialization(beanFactory)</code>处</p>
<ol start="3">
<li>分析 InitializingBean 之 afterPropertiesSet 初始化⽅法调⽤情况</li>
</ol>
<p><img src="/images/spring/s37.png" srcset="/img/loading.gif" alt="spring"></p>
<p>通过如上观察，我们发现 <code>InitializingBean</code>中 <code>afterPropertiesSet()</code> ⽅法的调⽤时机也是在<br><code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>finishBeanFactoryInitialization(beanFactory)</code></p>
<ol start="4">
<li>分析BeanFactoryPostProcessor 初始化和调⽤情况</li>
</ol>
<p>分别在构造函数、<code>postProcessBeanFactory()</code> ⽅法处打断点，观察调⽤栈，发现<code>BeanFactoryPostProcessor</code> 初始化在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>invokeBeanFactoryPostProcessors(beanFactory)</code>;<br><code>postProcessBeanFactory()</code> 调⽤在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>invokeBeanFactoryPostProcessors(beanFactory)</code>;</p>
<ol start="5">
<li>分析 BeanPostProcessor 初始化和调⽤情况</li>
</ol>
<p>分别在构造函数、<code>postProcessBeanFactory()</code> ⽅法处打断点，观察调⽤栈，发现<code>BeanPostProcessor</code> 初始化在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>registerBeanPostProcessors(beanFactory)</code>;<br><code>postProcessBeforeInitialization()</code>调⽤在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>finishBeanFactoryInitialization(beanFactory)</code>;<br><code>postProcessAfterInitialization()</code> 调⽤在<code>AbstractApplicationContext</code>类<code>refresh()</code>⽅法的<code>finishBeanFactoryInitialization(beanFactory)</code>;</p>
<ol start="6">
<li>总结</li>
</ol>
<p>根据上⾯的调试分析，我们发现 Bean对象创建的⼏个关键时机点代码层级的调⽤都在<code>AbstractApplicationContext</code>⽅ 类的 <code>refresh()</code>⽅ ⽅法中，可⻅这个⽅法对于Spring IoC容器初始化来说相当<br>关键，汇总如下：</p>
<table>
<thead>
<tr>
<th align="left">关键点</th>
<th align="left">触发代码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">构造器</td>
<td align="left">refresh#finishBeanFactoryInitialization(beanFactory)(beanFactory)</td>
</tr>
<tr>
<td align="left">BeanFactoryPostProcessor初始化</td>
<td align="left">refresh#invokeBeanFactoryPostProcessors(beanFactory)</td>
</tr>
<tr>
<td align="left">BeanFactoryPostProcessor ⽅法调⽤</td>
<td align="left">refresh#invokeBeanFactoryPostProcessors(beanFactory)</td>
</tr>
<tr>
<td align="left">BeanPostProcessor 初始化</td>
<td align="left">registerBeanPostProcessors(beanFactory)</td>
</tr>
<tr>
<td align="left">BeanPostProcessor ⽅法调⽤</td>
<td align="left">refresh#finishBeanFactoryInitialization(beanFactory)</td>
</tr>
</tbody></table>
<h5 id="Spring-IoC容器初始化主流程"><a href="#Spring-IoC容器初始化主流程" class="headerlink" title="Spring IoC容器初始化主流程"></a>Spring IoC容器初始化主流程</h5><p>由上分析可知，Spring IoC 容器初始化的关键环节就在 <code>AbstractApplicationContext#refresh()</code> ⽅法中<br>，我们查看 <code>refresh()</code> ⽅法来俯瞰容器创建的主体流程，主体流程下的具体⼦流程我们后⾯再来讨论。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">		synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">		// 第⼀步：刷新前的预处理</span><br><span class="line">		prepareRefresh();</span><br><span class="line">		/*</span><br><span class="line">		第⼆步：</span><br><span class="line">		获取BeanFactory；默认实现是DefaultListableBeanFactory</span><br><span class="line">		加载BeanDefition 并注册到 BeanDefitionRegistry</span><br><span class="line">		*/</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory =</span><br><span class="line">		obtainFreshBeanFactory();</span><br><span class="line">		// 第三步：BeanFactory的预准备⼯作（BeanFactory进⾏⼀些设置，⽐如context的类加</span><br><span class="line">		载器等）</span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line">		try &#123;</span><br><span class="line">			// 第四步：BeanFactory准备⼯作完成后进⾏的后置处理⼯作</span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line">			// 第五步：实例化并调⽤实现了BeanFactoryPostProcessor接⼝的Bean</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">			// 第六步：注册BeanPostProcessor（Bean的后置处理器），在创建bean的前后等执</span><br><span class="line">			⾏</span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line">			// 第七步：初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；</span><br><span class="line">			initMessageSource();</span><br><span class="line">			// 第⼋步：初始化事件派发器</span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line">			// 第九步：⼦类重写这个⽅法，在容器刷新的时候可以⾃定义逻辑</span><br><span class="line">			onRefresh();</span><br><span class="line">			// 第⼗步：注册应⽤的监听器。就是注册实现了ApplicationListener接⼝的监听器</span><br><span class="line">			bean</span><br><span class="line">			registerListeners();</span><br><span class="line">			/*</span><br><span class="line">			第⼗⼀步：</span><br><span class="line">			初始化所有剩下的⾮懒加载的单例bean</span><br><span class="line">			初始化创建⾮懒加载⽅式的单例Bean实例（未设置属性）</span><br><span class="line">			填充属性</span><br><span class="line">			初始化⽅法调⽤（⽐如调⽤afterPropertiesSet⽅法、init-method⽅法）</span><br><span class="line">			调⽤BeanPostProcessor（后置处理器）对实例bean进⾏后置处</span><br><span class="line">			*/</span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">			/*</span><br><span class="line">			第⼗⼆步：</span><br><span class="line">			完成context的刷新。主要是调⽤LifecycleProcessor的onRefresh()⽅法，并且发布事</span><br><span class="line">			件 （ContextRefreshedEvent）</span><br><span class="line">			*/</span><br><span class="line">			finishRefresh();</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	......</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanFactory创建流程"><a href="#BeanFactory创建流程" class="headerlink" title="BeanFactory创建流程"></a>BeanFactory创建流程</h4><h5 id="获取BeanFactory子流程"><a href="#获取BeanFactory子流程" class="headerlink" title="获取BeanFactory子流程"></a>获取BeanFactory子流程</h5><p>时序图如下</p>
<p><img src="/images/spring/s38.png" srcset="/img/loading.gif" alt="spring"></p>
<h5 id="BeanDefinition加载解析及注册子流程"><a href="#BeanDefinition加载解析及注册子流程" class="headerlink" title="BeanDefinition加载解析及注册子流程"></a>BeanDefinition加载解析及注册子流程</h5><ol>
<li>该⼦流程涉及到如下⼏个关键步骤</li>
</ol>
<p><strong>Resource定位</strong>：指对BeanDefinition的资源定位过程。通俗讲就是找到定义Javabean信息的XML⽂件，并将其封装成Resource对象。<br><strong>BeanDefinition载⼊</strong> ：把⽤户定义好的Javabean表示为IoC容器内部的数据结构，这个容器内部的数据结构就是BeanDefinition。<br><strong>注册BeanDefinition到 IoC 容器</strong></p>
<ol start="2">
<li>过程分析</li>
</ol>
<p><strong>Step 1</strong>：⼦流程⼊⼝在 <code>AbstractRefreshableApplicationContext#refreshBeanFactory</code> ⽅法中</p>
<p><img src="/images/spring/s39.png" srcset="/img/loading.gif" alt="spring"></p>
<p><strong>Step 2</strong>：依次调⽤多个类的 loadBeanDefinitions ⽅法 —&gt; AbstractXmlApplicationContext —&gt; AbstractBeanDefinitionReader —&gt; XmlBeanDefinitionReader ⼀直执⾏到 XmlBeanDefinitionReader 的 <code>doLoadBeanDefinitions</code> ⽅法。</p>
<p><img src="/images/spring/s40.png" srcset="/img/loading.gif" alt="spring"></p>
<p><strong>Step 3</strong>：我们重点观察XmlBeanDefinitionReader 类的 <code>registerBeanDefinitions</code> ⽅法，期间产⽣了多<br>次重载调⽤，我们定位到最后⼀个。</p>
<p><img src="/images/spring/s41.png" srcset="/img/loading.gif" alt="spring"></p>
<p>此处我们关注两个地⽅：⼀个<code>createRederContext</code>⽅法，⼀个是DefaultBeanDefinitionDocumentReader类的<code>registerBeanDefinitions</code>⽅法，先进⼊<code>createRederContext</code> ⽅法看看。</p>
<p><img src="/images/spring/s42.png" srcset="/img/loading.gif" alt="spring"></p>
<p>我们可以看到，此处 Spring ⾸先完成了 NamespaceHandlerResolver 的初始化。<br>我们再进⼊ <code>registerBeanDefinitions</code> ⽅法中追踪，调⽤了<code>DefaultBeanDefinitionDocumentReader#registerBeanDefinitions</code> ⽅法。</p>
<p><img src="/images/spring/s43.png" srcset="/img/loading.gif" alt="spring"></p>
<p>进⼊ <code>doRegisterBeanDefinitions</code> ⽅法</p>
<p><img src="/images/spring/s44.png" srcset="/img/loading.gif" alt="spring"></p>
<p>进⼊ <code>parseBeanDefinitions</code> ⽅法</p>
<p><img src="/images/spring/s45.png" srcset="/img/loading.gif" alt="spring"></p>
<p>进⼊ <code>parseDefaultElement</code> ⽅法</p>
<p><img src="/images/spring/s46.png" srcset="/img/loading.gif" alt="spring"></p>
<p>进⼊ <code>processBeanDefinition</code> ⽅法</p>
<p><img src="/images/spring/s47.png" srcset="/img/loading.gif" alt="spring"></p>
<p>⾄此，注册流程结束，我们发现，所谓的注册就是把封装的 XML 中定义的 Bean信息封装为 BeanDefinition 对象之后放⼊⼀个Map中，BeanFactory 是以 Map 的结构组织这些 BeanDefinition 的。</p>
<p><img src="/images/spring/s48.png" srcset="/img/loading.gif" alt="spring"></p>
<p>可以在DefaultListableBeanFactory中看到此Map的定义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** Map of bean definition objects, keyed by bean name. */</span><br><span class="line">private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>时序图</li>
</ol>
<p><img src="/images/spring/s49.png" srcset="/img/loading.gif" alt="spring"></p>
<h4 id="Bean创建流程"><a href="#Bean创建流程" class="headerlink" title="Bean创建流程"></a>Bean创建流程</h4><ul>
<li>通过最开始的关键时机点分析，我们知道Bean创建⼦流程⼊⼝在<code>AbstractApplicationContext#refresh()</code>⽅法的<code>finishBeanFactoryInitialization(beanFactory)</code> 处</li>
</ul>
<p><img src="/images/spring/s50.png" srcset="/img/loading.gif" alt="spring"></p>
<ul>
<li>进⼊finishBeanFactoryInitialization</li>
</ul>
<p><img src="/images/spring/s51.png" srcset="/img/loading.gif" alt="spring"></p>
<ul>
<li>继续进⼊DefaultListableBeanFactory类的preInstantiateSingletons⽅法，我们找到下⾯部分的代码，看到⼯⼚Bean或者普通Bean，最终都是通过getBean的⽅法获取实例</li>
</ul>
<p><img src="/images/spring/s52.png" srcset="/img/loading.gif" alt="spring"></p>
<ul>
<li>继续跟踪下去，我们进⼊到了AbstractBeanFactory类的doGetBean⽅法，这个⽅法中的代码很多，我们直接找到核⼼部分</li>
</ul>
<p><img src="/images/spring/s53.png" srcset="/img/loading.gif" alt="spring"></p>
<ul>
<li>接着进⼊到AbstractAutowireCapableBeanFactory类的⽅法，找到以下代码部分</li>
</ul>
<p><img src="/images/spring/s54.png" srcset="/img/loading.gif" alt="spring"></p>
<ul>
<li>进⼊doCreateBean⽅法看看，该⽅法我们关注两块重点区域<ul>
<li>创建Bean实例，此时尚未设置属性<br><img src="/images/spring/s55.png" srcset="/img/loading.gif" alt="spring"></li>
<li>给Bean填充属性，调⽤初始化⽅法，应⽤BeanPostProcessor后置处理器<br><img src="/images/spring/s56.png" srcset="/img/loading.gif" alt="spring"></li>
</ul>
</li>
</ul>
<h4 id="lazy-init延迟加载机制原理"><a href="#lazy-init延迟加载机制原理" class="headerlink" title="lazy-init延迟加载机制原理"></a>lazy-init延迟加载机制原理</h4><ul>
<li>lazy-init 延迟加载机制分析</li>
</ul>
<p>普通 Bean 的初始化是在容器启动初始化阶段执⾏的，⽽被<code>lazy-init=true</code>修饰的 bean 则是在从容器⾥第⼀次进⾏<code>context.getBean()</code> 时进⾏触发。Spring 启动的时候会把所有bean信息(包括XML和注解)解析转化成Spring能够识别的BeanDefinition并存到Hashmap⾥供下⾯的初始化时⽤，然后对每个BeanDefinition 进⾏处理，如果是懒加载的则在容器初始化阶段不处理，其他的则在容器初始化阶段进⾏初始化并依赖注⼊。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">	// 所有beanDefinition集合</span><br><span class="line">	List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line">	// 触发所有⾮懒加载单例bean的初始化</span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		// 获取bean 定义</span><br><span class="line">		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		// 判断是否是懒加载单例bean，如果是单例的并且不是懒加载的则在容器创建时初始化</span><br><span class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">			// 判断是否是 FactoryBean</span><br><span class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">					final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;)</span><br><span class="line">					getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					boolean isEagerInit;</span><br><span class="line">					<span class="keyword">if</span> (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">							@Override</span><br><span class="line">							public Boolean <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">								<span class="built_in">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;, getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">				 &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					/*</span><br><span class="line">					如果是普通bean则进⾏初始化并依赖注⼊，此 getBean(beanName)接下来触发的逻辑</span><br><span class="line">					和</span><br><span class="line">					懒加载时 context.getBean(<span class="string">"beanName"</span>) 所触发的逻辑是⼀样的</span><br><span class="line">					*/</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				 &#125;</span><br><span class="line">		 	&#125;</span><br><span class="line">	 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结<ul>
<li>对于被修饰为lazy-init的bean Spring 容器初始化阶段不会进⾏ init 并且依赖注⼊，当第⼀次进⾏getBean时候才进⾏初始化并依赖注⼊</li>
<li>对于⾮懒加载的bean，getBean的时候会从缓存⾥头获取，因为容器初始化阶段 Bean 已经初始化完成并缓存了起来</li>
</ul>
</li>
</ul>
<h4 id="Spring-IoC循环依赖问题"><a href="#Spring-IoC循环依赖问题" class="headerlink" title="Spring IoC循环依赖问题"></a>Spring IoC循环依赖问题</h4><h5 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h5><p>循环依赖其实就是循环引⽤，也就是两个或者两个以上的 Bean 互相持有对⽅，最终形成闭环。⽐如A依赖于B，B依赖于C，C⼜依赖于A。</p>
<p><img src="/images/spring/s57.png" srcset="/img/loading.gif" alt="spring"></p>
<p>注意，这⾥不是函数的循环调⽤，是对象的相互依赖关系。循环调⽤其实就是⼀个死循环，除⾮有终结条件。</p>
<p>Spring中循环依赖场景有：</p>
<ul>
<li>构造器的循环依赖（构造器注⼊）</li>
<li>Field 属性的循环依赖（set注⼊）<br>其中，构造器的循环依赖问题⽆法解决，只能拋出 BeanCurrentlyInCreationException 异常，在解决属性循环依赖时，spring采⽤的是提前暴露对象的⽅法。</li>
</ul>
<h5 id="循环依赖处理机制"><a href="#循环依赖处理机制" class="headerlink" title="循环依赖处理机制"></a>循环依赖处理机制</h5><ul>
<li>单例 bean 构造器参数循环依赖（⽆法解决）</li>
<li>prototype 原型 bean循环依赖（⽆法解决）<br>对于原型bean的初始化过程中不论是通过构造器参数循环依赖还是通过setXxx⽅法产⽣循环依赖，Spring都 会直接报错处理。</li>
</ul>
<p>AbstractBeanFactory.doGetBean()⽅法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">	throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected boolean isPrototypeCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">	Object curVal = this.prototypesCurrentlyInCreation.get();</span><br><span class="line">	<span class="built_in">return</span> (curVal != null &amp;&amp; (curVal.equals(beanName) || (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取bean之前如果这个原型bean正在被创建则直接抛出异常。原型bean在创建之前会进⾏标记这个beanName正在被创建，等创建结束之后会删除标记。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	//创建原型bean之前添加标记</span><br><span class="line">	beforePrototypeCreation(beanName);</span><br><span class="line">	//创建原型bean</span><br><span class="line">	prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">	//创建原型bean之后删除标记</span><br><span class="line">	afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：Spring 不⽀持原型 bean 的循环依赖。</p>
<ul>
<li>单例bean通过setXxx或者@Autowired进⾏循环依赖<br>Spring 的循环依赖的理论依据基于 Java 的引⽤传递，当获得对象的引⽤时，对象的属性是可以延后设置的，但是构造器必须是在获取引⽤之前<br>Spring通过setXxx或者@Autowired⽅法解决循环依赖其实是通过提前暴露⼀个ObjectFactory对象来完成的，简单来说ClassA在调⽤构造器完成对象初始化之后，在调⽤ClassA的setClassB⽅法之前就把ClassA实例化的对象通过ObjectFactory提前暴露到Spring容器中。<ul>
<li>Spring容器初始化ClassA通过构造器初始化对象后提前暴露到Spring容器。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">		<span class="string">"'to allow for resolving potential circular references"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	//将初始化后的对象提前已ObjectFactory对象注⼊到容器中</span><br><span class="line">	addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public Object getObject() throws BeansException &#123;</span><br><span class="line">			<span class="built_in">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ClassA调⽤setClassB⽅法，Spring⾸先尝试从容器中获取ClassB，此时ClassB不存在Spring容器中。</li>
<li>Spring容器初始化ClassB，同时也会将ClassB提前暴露到Spring容器中</li>
<li>ClassB调⽤setClassA⽅法，Spring从容器中获取ClassA ，因为第⼀步中已经提前暴露了</li>
<li>ClassA，因此可以获取到ClassA实例<ul>
<li>ClassA通过spring容器获取到ClassB，完成了对象初始化操作。</li>
</ul>
</li>
<li>这样ClassA和ClassB都完成了对象初始化操作，解决了循环依赖问题。</li>
</ul>
</li>
</ul>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/Java%E6%A1%86%E6%9E%B6">Java框架</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6">Spring全家桶</a>
                
                  <a class="hover-with-bg" href="/tags/IoC">IoC</a>
                
                  <a class="hover-with-bg" href="/tags/AOP">AOP</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      

    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://github.com/Loonycoder" target="_blank" rel="nofollow noopener"><b>望月</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/Loonycoder" target="_blank" rel="nofollow noopener"> <b>LoonyCoder</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>访问量: 
          <span id="busuanzi_value_site_pv"></span> &nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>访客数: 
            <span id="busuanzi_value_site_uv"></span> &nbsp;
  
  <br>



    
  <!-- 备案信息 -->
  <a href="http://beian.miit.gov.cn/" target="_blank"
     rel="nofollow noopener">京ICP证20008174号</a>
  
    <a
      href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=20008174"
      rel="nofollow noopener"
      class="police-beian"
      target="_blank"
    >
      <span class="police-beian-sep">&nbsp;|&nbsp;</span>
      
        <img src="/img/police_beian.png" />
      
      <span>京公网安备20008174号</span>
    </a>
  



    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  <script src="/js/post.js" ></script>
  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
    <script>
      $(document).ready(function () {
        tocbot.init({
          tocSelector: '#tocbot',
          contentSelector: '.post-content',
          headingSelector: 'h1,h2,h3,h4,h5,h6',
          linkClass: 'tocbot-link',
          activeLinkClass: 'tocbot-active-link',
          listClass: 'tocbot-list',
          isCollapsedClass: 'tocbot-is-collapsed',
          collapsibleClass: 'tocbot-is-collapsible',
          scrollSmooth: true,
        });
      });
    </script>
  



  <script src="/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "轻量级控制反转和面向切面的容器框架——Spring（四）&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "❡"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  








</body>
</html>
