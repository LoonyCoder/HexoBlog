<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="Life Is So Short , Just Coding.">
  <meta name="author" content="LoonyCoder">
  <meta name="keywords" content="隐约雷鸣，阴霾天空，但盼风雨来，能留你于此">
  <title>Java多线程状态切换及基本操作 ~ 望月Plenilune</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>望月Plenilune</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/images/post_banner.jpg')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期日, 四月 28日 2019, 10:21 晚上
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    3.7k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      15 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>上篇文章我们讲了Java多线程的基础知识，本文将拓展讲解一下Java多线程状态及状态之间的切换问题，以及常用的基本操作。</p>
<hr>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><h5 id="什么是线程调度"><a href="#什么是线程调度" class="headerlink" title="什么是线程调度"></a>什么是线程调度</h5><p>线程调度就是系统为线程分配执行时间的过程。</p>
<h5 id="线程调度的方式"><a href="#线程调度的方式" class="headerlink" title="线程调度的方式"></a>线程调度的方式</h5><p>根据线程调度的控制权是由系统控制或者线程本身来控制划分为：协同式的线程调度和抢占式的线程调度。</p>
<ol>
<li>协同式线程调度：线程之间的系统执行时间，由线程本身进行进行控制。这种线程调度方式就像接力赛，一个执行完毕后交由下一个接力。如当前线程执行完毕后，通知系统调度到其他线程执行。</li>
</ol>
<ul>
<li>协同的好处：线程的切换是可预知的。线程之间不存在同步的问题。</li>
<li>协同的坏处：协同调度的致命缺点是当某个线程执行有问题的时候，会导致整个运行阻塞和系统崩溃。</li>
</ul>
<ol start="2">
<li>抢占式线程调度：线程之间的系统执行时间，是由系统进行控制。而抢占式的线程调度对线程的不可预知，系统定期的中断当前正在执行的线程，将CPU执行权切换到下一个等待的线程。所以任何一个线程都不能独占CPU。正因为这种定期的线程切换导致线程之间存在不同的问题。当线程执行过程中，某个线程出现问题的时候，由线程对CPU不具有独占性。因此不会造成阻塞。</li>
</ol>
<blockquote>
<p>我们所使用的操作系统都是是用抢占性的线程调度。如果使用协同式的线程调度情况下，如果我们再使用某个软件出现问题时候，操作系统处于阻塞状态，导致整个操作系统崩溃，我们肯定会抓狂。</p>
</blockquote>
<ol start="3">
<li>JAVA线程调度：Java线程调度就是抢占式调度。</li>
</ol>
<h4 id="Java线程的实现方式"><a href="#Java线程的实现方式" class="headerlink" title="Java线程的实现方式"></a>Java线程的实现方式</h4><p>JAVA提供了3中创建线程的方式：</p>
<ul>
<li><p>Thread<br>继承Thread类重写run方法，这种创建线程的方式在我们的编程中很少使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static class TheadExtends extends Thread&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"TheadExtends"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Runnable<br>既然JAVA提供了Thread创建线程的方式，为什么还要提供Runnable接口的方式进行创建线程？因为JAVA是单继承，不能多继承。因此就有了Runnable接口的方式来进行创建线程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static class RunnableImpl implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"RunnableImpl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Callable<br>Callable接口与Runnable接口的区别在于Callable在线程调用完毕后有返回结果，而Runnable没有，而对于一些业务处理比较耗时并且无需立即返回处理结果的情况下，我们都会通过asynchronous+Future的方式处理，而对于这种业务情景我们可以通过Callable进行处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadImplement &#123;</span><br><span class="line"></span><br><span class="line">    private static class CallableImpl implements Callable&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            <span class="built_in">return</span> <span class="string">"Callable"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        </span><br><span class="line">        CallableImpl callableImpl=new CallableImpl();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(callableImpl);</span><br><span class="line">        Thread  CallableThread= new Thread(futureTask);</span><br><span class="line">        CallableThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="JAVA线程状态转换"><a href="#JAVA线程状态转换" class="headerlink" title="JAVA线程状态转换"></a>JAVA线程状态转换</h4><h5 id="Java线程状态转换图"><a href="#Java线程状态转换图" class="headerlink" title="Java线程状态转换图"></a>Java线程状态转换图</h5><p><img src="/images/thread/thread3.png" srcset="/img/loading.gif" alt="线程状态转换图"></p>
<h5 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h5><p>JAVA线程状态包括：</p>
<ul>
<li><p><code>New</code>：新创建一个线程是处于该状态。</p>
</li>
<li><p><code>Runnable</code>：线程的调度是由操作系统可以决定，因此Runnable是包含Ready和Running。当我们调用了<code>start()</code>方法后，当前的线程处于一个Ready的状态，等待操作系统线程调用到当前线程分配CPU执行时间，若当前线程获得CPU执行时间时，线程就处于一个Running的状态。而在Running状态的情况下，我们可以调用<code>yield()</code>方法，放弃当前线程的CPU执行。而调用yield后当前线程处于一个Ready的状态，这种状态下操作系统在线程调度的时候分配CPU执行时间给当前的线程。</p>
</li>
<li><p><code>Blocked</code>：阻塞状态下代表着当前的线程被挂起。而这挂起的原因的线程在等待一个锁。如我们在一个方法或者代码块中使用Synchronized时，同一时间有2个线程进入该方法的时候，先获取到锁的线程执行。而没有获得锁的线程就处于这种阻塞状态。</p>
</li>
<li><p><code>WAITING</code>：等待状态下，当前线程不被执行和操作系统不会给该线程进行线程调度。而当前线程处于等待其他线程唤醒。只有被唤醒后，操作系统才会给该线程进行线程调度。这种线程的等待的主要作用是为了线程之间的协作。一般情况下通过Synchronized获得锁后，调用锁的wait的方法进入等待状态，而调用wait方法后，当前的线程会释放锁，而另外一个线程获得锁后，通过<code>notifyall()/notify()</code>进行唤醒处于等待的线程。</p>
</li>
<li><p><code>TIMED_WAITING</code>：处于这种有限期的等待的情况下，在限期内当前线程不会被执行和操作系统不会给该线程进行线程调度。在限期过后，操作系统才给该线程进行线程调度。</p>
</li>
<li><p><code>TERMINATED</code>：该状态下线程处于终止，而这种终止引起的原因分为正常的执行完毕的终止和非正常情况下的终止，而非正常情况下可能是线程执行异常或者调用<code>interrupt()</code>中止线程引起。</p>
</li>
</ul>
<h4 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h4><h5 id="多线程编程的好处"><a href="#多线程编程的好处" class="headerlink" title="多线程编程的好处"></a>多线程编程的好处</h5><ul>
<li>充分利用CPU的资源。</li>
<li>加快请求响应</li>
<li>异步化</li>
</ul>
<h5 id="多线程带来的问题"><a href="#多线程带来的问题" class="headerlink" title="多线程带来的问题"></a>多线程带来的问题</h5><ul>
<li>设计更复杂<ul>
<li>线程之间是共享进程资源，存在资源冲突。</li>
<li>线程之间的协作往往是非常复杂。若不能正确的使用锁的机制，通常会造成数据错误，整个业务功能出现问题。</li>
</ul>
</li>
<li>上下文切换的开销</li>
<li>增加资源消耗，多线程变成是一种空间换时间的方式。线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈，若开启过多的线程时会导致程序占用过多的内存和机器崩溃。</li>
</ul>
<h4 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h4><p><strong>interrupt</strong></p>
<ul>
<li><p>JAVA提倡通过协作的方式结束线程，而不是使用强制停止的方式进行结束线程如<code>stop()</code>，<code>resume()</code>,<code>suspend()</code>已不建议使用，<code>stop()</code>会导致线程不会正确释放资源，<code>suspend()</code>容易导致死锁。那么怎样协同的方式结束线程呢？就是同过Thread的<code>interrupt()</code>方法进行协作中断线程。而调用interrupt方法是在线程中设置一个中断的标志位，中断标志默认为false。被中断的线程通过循环的方式监听这个标志位确定当前线程需要中断。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    public static class SafeEndRunnable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">            System.out.println(<span class="string">"flag = "</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"running"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"is end ,flag = "</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SafeEndRunnable safeEndRunnable = new SafeEndRunnable();</span><br><span class="line">        Thread t1 = new Thread(safeEndRunnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(1);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">Thread-0running</span><br><span class="line">Thread-0running</span><br><span class="line">Thread-0running</span><br><span class="line">Thread-0running</span><br><span class="line">Thread-0is end ,flag = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>相关方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">方法类型</th>
<th align="left">Demo</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">isInterrupted</td>
<td align="left">对象方法</td>
<td align="left"><code>Thread.currentThread().isInterrupted()</code></td>
<td align="left">判断当前线程是否处于中断状态</td>
</tr>
<tr>
<td align="left">interrupt</td>
<td align="left">对象方法</td>
<td align="left"><code>Thread.currentThread().interrupt()</code></td>
<td align="left">设置标志位为true</td>
</tr>
<tr>
<td align="left">interrupted</td>
<td align="left">静态方法</td>
<td align="left"><code>Thread.interrupted()</code></td>
<td align="left">判断当前线程是否处于中断状态并且设置中断状态为false</td>
</tr>
</tbody></table>
<ul>
<li>在进行协作处理线程结束的时候清除标志位。在我们的被中断的线程中如果使用到了sleep方法时，如果中断线程调用时，该线程处于sleep时，会抛出InterruptedException，如果使用进行try/catch捕捉该异常的时候会清除标志位。所以我们需要再调用被中断的线程的<code>interrupt()</code>方法。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static class SafeEndThread implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"running"</span>);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">"flag = "</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"is end ,flag = "</span>+Thread.currentThread().isInterrupted());          </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SafeEndThread safeEndThread = new SafeEndThread();</span><br><span class="line">        Thread t2 = new Thread(safeEndThread);</span><br><span class="line">        t2.start(); </span><br><span class="line">        Thread.sleep(1);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">输出：</span><br><span class="line">Thread-0running</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">Thread-0is end ,flag = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>yield</strong></p>
<p>yield的主要作用的是让出CPU的执行时间，需要注意的时候，调用yield虽然让出了CPU的执行时间，但是会参与下一次的CPU执行时间的竞争中，如果当前线程重新获得CPU执行时间，那么当前的线程再次执行。如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public static class ThreadYieldRunnable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"running"</span>+i);</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadYieldRunnable threadYieldRunnable= new ThreadYieldRunnable();</span><br><span class="line">        Thread t1 = new Thread(threadYieldRunnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"t1.yield"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Thread-0running0</span><br><span class="line">Thread-0running1</span><br><span class="line">t1.yield</span><br><span class="line">Thread-0running2</span><br><span class="line">Thread-0running3</span><br><span class="line">Thread-0running4</span><br><span class="line">Thread-0running5</span><br><span class="line">Thread-0running6</span><br><span class="line">Thread-0running7</span><br><span class="line">Thread-0running8</span><br><span class="line">Thread-0running9</span><br><span class="line">Thread-0running10</span><br><span class="line">Thread-0running11</span><br><span class="line">Thread-0running12</span><br><span class="line">Thread-0running13</span><br><span class="line">Thread-0running14</span><br><span class="line">Thread-0running15</span><br><span class="line">Thread-0running16</span><br><span class="line">Thread-0running17</span><br><span class="line">Thread-0running18</span><br><span class="line">Thread-0running19</span><br></pre></td></tr></table></figure>

<h4 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h4><p>锁的主要作用是保护临界区资源，在多线程访问临界区时互斥。那么在线程访问共享的资源时，JAVA提供了以下保存线程之间的线程共享资源。</p>
<p><strong>Synchronized</strong></p>
<ul>
<li><p>Synchronized的实现方式</p>
<table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">锁对象</th>
<th align="left">Demo</th>
</tr>
</thead>
<tbody><tr>
<td align="left">对象同步</td>
<td align="left">当前对象</td>
<td align="left"><code>synchronized void demo()</code></td>
</tr>
<tr>
<td align="left">静态同步</td>
<td align="left">当前类</td>
<td align="left"><code>static synchronized void demo()</code></td>
</tr>
<tr>
<td align="left">代码块</td>
<td align="left">当前对象、其他对象、类</td>
<td align="left"><code>Demo demo = new Demo(); synchronized (demo) {}<br>synchronized (this){}<br>synchronized(Demo.class) {}</code></td>
</tr>
</tbody></table>
</li>
<li><p>Synchronized的综述</p>
<ol>
<li>Synchronized主要作用实现同步。而这种同步是通过互斥锁来保证多线程访问时实现同步。即在同一时间内只有一个线程可以访问临界区的资源，同时保证了共享资源的可预见性和原子性。</li>
<li>Synchronized的使用：可以在方法定义中使用，也可以使用同步代码块的形式使用。在使用Synchronized的时候，尽量使用代码块的形式，将同步的操作控制在最小的粒度中。如果使用在Synchronized在方法定义中，那么该方法中不存在锁竞争的部分会被同步。如果该方法高并发情况下，可能会导致多线程等待从而引起应用dump掉。</li>
</ol>
</li>
<li><p>Synchronized死锁<br>死锁引起的原因是由于两个线程之间，相互持有对象的锁和相互等待对象释放锁。在使用Synchronized的时候不允许出现死锁的情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object lock1 = new Object();</span><br><span class="line">    Object lock2 = new Object();</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread1 get locke1"</span>);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread1 get locke2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread2 get locke2"</span>);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread2 get locke1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用常量池对象作为锁对象<br>Java为我们提供了String、Integer、Long常量池，因此我们再使用这些常量池的对象作为锁对象的时候，会存在锁隐患。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class ConstLock implements Runnable &#123;</span><br><span class="line">    private Object  lock ;</span><br><span class="line">    </span><br><span class="line">    public ConstLock(Object lock) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"sayHello"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConstLock constLock1 = new ConstLock(<span class="string">"lock"</span>);</span><br><span class="line">        ConstLock constLock2 = new ConstLock(<span class="string">"lock"</span>);</span><br><span class="line">        Thread t1 = new Thread(constLock1,<span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = new Thread(constLock2,<span class="string">"Thread2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConstLock constLock1 = new ConstLock(21);</span><br><span class="line">        ConstLock constLock2 = new ConstLock(21);</span><br><span class="line">        Thread t1 = new Thread(constLock1,<span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = new Thread(constLock2,<span class="string">"Thread2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConstLock constLock1 = new ConstLock(21l);</span><br><span class="line">        ConstLock constLock2 = new ConstLock(21l);</span><br><span class="line">        Thread t1 = new Thread(constLock1,<span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = new Thread(constLock2,<span class="string">"Thread2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Thread1sayHello</span><br><span class="line">Thread1sayHello</span><br><span class="line">Thread1sayHello</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>volatile关键字</strong></p>
<p>volatile是JAVA中提供的一种轻量级的同步机制。而这种轻量级的同步机制是通过线程之间的通讯来保证。而不是通过锁的机制进行处理。因此不会对执行的线程造成阻塞。</p>
<ul>
<li><p>线程通讯过程<br><img src="/images/thread/thread4.png" srcset="/img/loading.gif" alt="线程通讯过程"></p>
</li>
<li><p>volatile主要作用</p>
<ol>
<li>确保了所有的线程对volatile修饰的变量具有可见性。</li>
<li>禁止操作系统指令重排序，如果变量没有被volatile表示禁止指令重排优化的情况下。操作系统默认会对不相关的执行指令进行重排序提高执行的效率。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Reorder &#123;</span><br><span class="line"></span><br><span class="line">    public static int x = 0;</span><br><span class="line">    public static int y = 0;</span><br><span class="line">    public static int a = 0;</span><br><span class="line">    public static int b = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread(()-&gt;&#123;</span><br><span class="line">            a = 1;</span><br><span class="line">            x = b;</span><br><span class="line">        &#125;) ;</span><br><span class="line">        Thread thread2 = new Thread(()-&gt;&#123;</span><br><span class="line">            b = 1;</span><br><span class="line">            y = a;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p>如没有禁止指令重排序就会出现:x=1;y=0、x=0;y=1、x=1;y=1、x=0;y=0四种结果。</p>
<p><img src="/images/thread/thread5.png" srcset="/img/loading.gif" alt="结果"></p>
<ul>
<li><p>volatile原子性</p>
<ul>
<li>原子性表示一个操作或者多个操作的情况下，要么全部执行成功，要么全部执行失败。</li>
<li>volatile在符合条件以下条件的情况下具有原子性：<ol>
<li>对volatile修饰的变量的操作不依赖变量本身，如i++这种复合操作不具有原子性。代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        Thread thread = new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                <span class="keyword">for</span> (int i = 0; i &lt; 10000; i++)</span><br><span class="line">                    counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>确保只有一个线程修改变量的值的情况。</li>
</ol>
</li>
</ul>
</li>
<li><p>volatile适用场景</p>
<ol>
<li>禁止系统重排序的情况</li>
<li>只有一个线程写，多个线程读的情况。</li>
</ol>
</li>
</ul>
<p><strong>ThreadLocal</strong></p>
<p>ThreadLocal是一个线程本地存储，而每个线程有自己独立的副本。也就是说每个线程可以存放各自变量到线程本地存储中，并且线程之间各自访问各自的线程本地存储。当线程结束后，线程的本地存储会被垃圾回收。如果线程本地存储中的变量被其他引用到的情况下，是不会被回收。我们可以把ThreadLocal看作一个Map&lt;Thread,Object&gt;。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        protected Integer <span class="function"><span class="title">initialValue</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> 1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">startThread</span></span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            Thread t1 = new Thread(new ThreadLocalRunnable(i));</span><br><span class="line">            t1.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    @AllArgsConstructor</span><br><span class="line">    public static class ThreadLocalRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private int id;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  id="</span> + id);</span><br><span class="line">            int beforeId = threadLocal.get();</span><br><span class="line">            int afterId = beforeId + id;</span><br><span class="line">            threadLocal.set(afterId);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  after id ="</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new UseThreadLocal().startThread();</span><br><span class="line">    &#125;</span><br><span class="line">输出：</span><br><span class="line">Thread-0  id=0</span><br><span class="line">Thread-0  after id =1</span><br><span class="line">Thread-1  id=1</span><br><span class="line">Thread-1  after id =2</span><br></pre></td></tr></table></figure>






            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/Java">Java</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/%E7%BA%BF%E7%A8%8B">线程</a>
                
                  <a class="hover-with-bg" href="/tags/%E5%B9%B6%E5%8F%91">并发</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      

    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://github.com/Loonycoder" target="_blank" rel="nofollow noopener"><b>望月</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/Loonycoder" target="_blank" rel="nofollow noopener"> <b>LoonyCoder</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>访问量: 
          <span id="busuanzi_value_site_pv"></span> &nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>访客数: 
            <span id="busuanzi_value_site_uv"></span> &nbsp;
  
  <br>



    
  <!-- 备案信息 -->
  <a href="http://beian.miit.gov.cn/" target="_blank"
     rel="nofollow noopener">京ICP证20008174号</a>
  
    <a
      href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=20008174"
      rel="nofollow noopener"
      class="police-beian"
      target="_blank"
    >
      <span class="police-beian-sep">&nbsp;|&nbsp;</span>
      
        <img src="/img/police_beian.png" />
      
      <span>京公网安备20008174号</span>
    </a>
  



    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  <script src="/js/post.js" ></script>
  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
    <script>
      $(document).ready(function () {
        tocbot.init({
          tocSelector: '#tocbot',
          contentSelector: '.post-content',
          headingSelector: 'h1,h2,h3,h4,h5,h6',
          linkClass: 'tocbot-link',
          activeLinkClass: 'tocbot-active-link',
          listClass: 'tocbot-list',
          isCollapsedClass: 'tocbot-is-collapsed',
          collapsibleClass: 'tocbot-is-collapsible',
          scrollSmooth: true,
        });
      });
    </script>
  



  <script src="/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Java多线程状态切换及基本操作&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "❡"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  








</body>
</html>
