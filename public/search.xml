<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>容器化部署神器——Docker</title>
    <url>/2020/01/11/docker/</url>
    <content><![CDATA[<p><img src="/images/docker1.jpg" alt="docker"><br><strong>Docker</strong>是一种容器技术，它的存在就是为了解决容器技术本身的复杂性。Docker容器拥有很高的性能，同时同一台宿主机中可以运行更多的容器，是用户尽可能的充分利用系统资源。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>1.什么是虚拟化？<br>在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及储存等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，是用户可以比原来的组态更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制。</p>
</blockquote>
<ul>
<li>全虚拟化架构<br>虚拟机的监视器（hypervisor）是类似于用户的应用程序运行在主机的OS之上，如VMware的workstation，这种虚拟化产品提供了虚拟的硬件。</li>
</ul>
<blockquote>
<p>2.容器技术<br>容器和管理程序虚拟化（hypervisor virtualization, HV）不同，管理程序虚拟化通过中间层将一台或多台独立的机器虚拟运行在物理硬件之上，而<strong>容器</strong>是直接运行在操作系统内核之上的用户空间。因此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行在同一台宿主机上。</p>
</blockquote>
<p><strong>限制</strong><br>1、由于“客居”与操作系统，容器只能运行与底层主机相同或相似的操作系统，比如在Ubuntu服务中运行CentOS，但无法运行Windows。<br>2、相对于彻底隔离的管理程序虚拟化，容器被认为是不安全的。<br>最新的容器技术引入了OpenVZ、Solaris Zones以及Linux容器（LXC）。使用这些新技术，容器不再仅仅是一个单纯的运行环境。在自己的权限类内，容器更像一个完整宿主机。和传统虚拟化及半虚拟化想比，容器不需要模拟层（emulation layer）和管理层（hypervisor layer），而使用操作系统的系统调用接口。</p>
<h4 id="Docker特点"><a href="#Docker特点" class="headerlink" title="Docker特点"></a>Docker特点</h4><p>1、上手快<br>2、用户可以很容易的把自己的程序Docker化。Docker依赖于“写时复制”（copy-on-write）模型，开箱即用。<br>快速高效的开发声明周期</p>
<h4 id="Docker组件"><a href="#Docker组件" class="headerlink" title="Docker组件"></a>Docker组件</h4><h5 id="Docker客户端和服务器"><a href="#Docker客户端和服务器" class="headerlink" title="Docker客户端和服务器"></a>Docker客户端和服务器</h5><p>Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。<br><img src="/images/docker2.png" alt="docker"></p>
<h5 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h5><p><strong>镜像</strong> 是构建Docker的基石。用户及基于镜像来运行自己的容器。镜像也是Docker声明周期中的“构建”部分。奖项是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。</p>
<h5 id="Registry-注册中心"><a href="#Registry-注册中心" class="headerlink" title="Registry 注册中心"></a>Registry 注册中心</h5><p>Docker用Registry来保存用户构建的镜像。Registry分为共有和私有两种。Docker公司运营公共的Registry叫做Docker Hub。</p>
<h5 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h5><p>Docker可以帮助你构建和部署容器，你只需要把你的程序打包放进容器即可。容器是基于镜像启动的，容器找那个可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中构建和打包阶段，而容器则是启动或执行阶段。容器基于镜像启动。<br><img src="/images/docker3.png" alt="docker"></p>
<h4 id="Docker的安装与启动"><a href="#Docker的安装与启动" class="headerlink" title="Docker的安装与启动"></a>Docker的安装与启动</h4><p>前提：本例中使用了CentOS7作为服务器<br>通过以下命令在线在CentOS7中安装Docker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure>
<p><img src="/images/docker4.png" alt="docker"></p>
<p><strong>查看Docker版本</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker -v</span></span><br><span class="line">Docker version 1.13.1, build 8633870/1.13.1</span><br></pre></td></tr></table></figure>

<h4 id="启动与停止Docker"><a href="#启动与停止Docker" class="headerlink" title="启动与停止Docker"></a>启动与停止Docker</h4><p>systemctl命令是系统服务管理器指令，它是service和chkconfig两个命令组合。</p>
<p>1.启动Docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<p>2.停止Docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
<p>3.重启Docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>4.查看Docker状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>
<p>5.开机启动Docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
<p>6.查看Docker概要信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p>7.查看Docker帮助文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker -<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h4 id="Docker镜像操作"><a href="#Docker镜像操作" class="headerlink" title="Docker镜像操作"></a>Docker镜像操作</h4><p>Docker镜像由文件系统堆叠而成（是一种文件的储存形式）。最低端是一个文件引导系统，即bootfs。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要一些文件的，而这些文件就可以被称为Docker镜像。<br><img src="/images/docker5.png" alt="docker"></p>
<p>1、列出镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/docker6.png" alt="docker"></p>
<ul>
<li>REPOSITORY: 镜像所在的仓库名称</li>
<li>TAG： 镜像标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像的创建日期（不是获取该镜像的日期）</li>
<li>SIZE：镜像大小</li>
</ul>
<p>这些镜像都储存在Docker宿主机的/var/lib/docker目录下。</p>
<p>2、搜索镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker search 镜像名称</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/docker7.png" alt="docker"></p>
<p>3、从Docker Hub拉取镜像<br>去Docker Hub官网查找所需的Docker镜像：<a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">https://hub.docker.com/explore/</a> ，然后通过以下命令在线pull：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull 镜像名称</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker pull 镜像名称:版本</span></span><br></pre></td></tr></table></figure>
<p>因为官方提供的Docker镜像加速服务很慢，我们可以配置ustc的镜像。输入以下命令配置ustc镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vi /etc/docker/daemon.json</span></span><br></pre></td></tr></table></figure>
<p>没有就创建，向其中写入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="string">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启Docker服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p>4、删除镜像<br>删除指定镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker rmi $IMAGE_ID  #这个$IMAGE_ID数值可以根据`docker images`命令查看</span></span><br></pre></td></tr></table></figure>
<p>删除所有镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker rmi `docker images -q`</span></span><br></pre></td></tr></table></figure>

<h4 id="Docker容器操作"><a href="#Docker容器操作" class="headerlink" title="Docker容器操作"></a>Docker容器操作</h4><p>1.查看正在运行的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br></pre></td></tr></table></figure>
<p>2.查看所有的容器（启动过的历史容器）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br></pre></td></tr></table></figure>
<p>3.查看最后一次运行的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -|</span></span><br></pre></td></tr></table></figure>
<p>4.查看停止的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -f status=exited</span></span><br></pre></td></tr></table></figure>
<p>5.删除容器<br>删除指定容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker rm $CONTAINER_ID/NAME</span></span><br></pre></td></tr></table></figure>
<p>删除所有容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker rm `docker ps -a -q`</span></span><br></pre></td></tr></table></figure>

<h4 id="创建和启动容器"><a href="#创建和启动容器" class="headerlink" title="创建和启动容器"></a>创建和启动容器</h4><p><strong>创建容器常用的参数说明</strong><br>1.创建容器命令：docker run<br>2.-i: 表示运行容器<br>3.-t: 表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。<br>4.—name: 为创建的容器命名<br>5.-v: 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录或文件映射。注意：最好做目录映射，在宿主机上修改，然后共享到容器上。<br>6.-d: 在run后面加上-d参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。<br>7.-p： 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射。</p>
<h5 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h5><p>创建一个交互式容器并取名为mycentos5:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@localhost ~]<span class="comment"># docker run -it --name=mycentos5 centos:7 /bin/bash</span></span><br><span class="line">[root@53f33e279914 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>此时我们可以新建一个连接，通过docker ps命令看到刚才创建的容器正在启动中：<br><img src="/images/docker8.png" alt="docker"><br>通过exit命令可以退出当前容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@53f33e279914 /]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>此时再通过docker ps命令查看刚才启动的容器也停止了。</p>
<h5 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h5><p>输入以下命令创建一个名字为mycentos6的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -di --name=mycentos6 centos:7</span></span><br></pre></td></tr></table></figure>
<p>创建后这个容器会在后台运行，而不是直接进入到这个容器中。可以通过docker ps命令查看。<br>登录守护式容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker exec -it mycentos6 /bin/bash</span></span><br></pre></td></tr></table></figure>
<p>可以通过exit命令退出，但是容器不会停止。</p>
<h5 id="停止和启动容器"><a href="#停止和启动容器" class="headerlink" title="停止和启动容器"></a>停止和启动容器</h5><p>停止正在运行的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker stop 容器名称</span></span><br></pre></td></tr></table></figure>
<p>启动已运行过的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker start 容器名称</span></span><br></pre></td></tr></table></figure>

<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><h5 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h5><p>将文件拷贝到容器内可以用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker cp 需要拷贝的文件或目录 容器名称:容器目录</span></span><br></pre></td></tr></table></figure>
<p>将文件从容器中拷贝出来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker cp 容器名称:容器目录 需要拷贝的文件或目录</span></span><br></pre></td></tr></table></figure>
<h5 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h5><p>在创建容器的时候，将宿主机的目录和容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而影响容器。格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -di -v 宿主机目录:容器目录</span></span><br></pre></td></tr></table></figure>
<h5 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker inspect mycentos5</span></span><br></pre></td></tr></table></figure>

<p><strong>部署应用</strong></p>
<h4 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h4><p>1.拉取MySQL镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull mysql:5.7</span></span><br></pre></td></tr></table></figure>
<p>2.创建MySQL容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -di --name docker_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.7</span></span><br></pre></td></tr></table></figure>
<p>如上我们创建一个名称为docker_mysql的MySQL5.7版本的守护式容器，且配置MySQL登录密码是root。</p>
<ul>
<li>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</li>
<li>-e 代表添加环境变量， MYSQL_ROOT_PASSWORD是root用户的登录密码</li>
</ul>
<p>3.进入MySQL容器，登录MySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker exec -it docker_mysql /bin/bash</span></span><br></pre></td></tr></table></figure>
<p>登录MySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>4.远程连接MySQL<br><img src="/images/docker9.png" alt="docker"></p>
<h4 id="Tomcat部署"><a href="#Tomcat部署" class="headerlink" title="Tomcat部署"></a>Tomcat部署</h4><p>1.拉取Tomcat-8 &amp;&amp; JDK-8 镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull tomcat:8-jre8</span></span><br></pre></td></tr></table></figure>
<p>2.部署Web应用<br>为了更好的演示Docker部署Tomcat的使用方式，我们可以先将需要部署的web项目发送到服务器的某个路径下，我这里在/root/目录下创建了/root/site/目录作为项目的根目录，在其中创建index.html文件并写入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello Docker-Tomcat!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>3.创建Tomcat容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -di --name=docker_tomcat -p 9000:8080 -v /root/site/:/usr/local/tomcat/webapps/ROOT --privileged=true tomcat:8-jre8</span></span><br></pre></td></tr></table></figure>
<p>以上就创建一个Tomcat容器，其容器名称Wiedocker_tomcat，-di表示是一个守护式容器；-p 9000:8080表示此容器端口映射为9000-&gt;8080，即对外的端口是9000，映射到容器里Tomcat服务器的端口8080，–privileged是以root权限运行。<br><img src="/images/docker10.png" alt="docker"><br>通过命令看到，当我们启动了容器，其中的Tomcat服务器也自动启动了。当然对于部署Nginx或MySQL的Docker容器，当启动容器时都会启动对应的服务。<br><strong>注意</strong><br>上面我们指定了宿主机的/root/site/目录映射到docker_tomcat容器的/usr/local/tomcat/webapps/ROOT目录，为什么是这个目录呢？<br>Docker虚拟化，它会在内部虚拟一个操作系统，是在其宿主机内核上的一层空间，所有有一定的目录结构，我们可以通过docker exec -it docker_tomcat /bin/bash命令进入到docker_tomcat容器内部，通过ls命令查看目录会发现其Tomcat服务器确实安装在docker_tomcat容器的/usr/local/tomcat目录下。<br>最后，我们在浏览器上访问：<a href="http://192.168.148.132:9000/" target="_blank" rel="noopener">http://192.168.148.132:9000/</a>，即发现页面展示了我们刚才在/root/site/目录下创建的index.html网页：<br><img src="/images/docker11.png" alt="docker"><br>所以，如果你想要修改容器中Tomcat的端口号，直接进入容器的/usr/local/tomcat/conf/server.xml自改即可。</p>
<h4 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h4><p>1.拉取Nginx镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>
<p>2.创建Nginx容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=docker_nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p>测试<br><img src="/images/docker12.png" alt="docker"><br>在浏览器上访问：<a href="http://192.168.148.132/" target="_blank" rel="noopener">http://192.168.148.132/</a>可以进入到Nginx的欢迎页。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>以上我们介绍了MySQL、Tomcat、Nginx容器的创建，对于其他的服务，如Redis等操作基本相同，不再阐述。</p>
<h4 id="备份与迁移"><a href="#备份与迁移" class="headerlink" title="备份与迁移"></a>备份与迁移</h4><p>1.容器保存为镜像<br>可以通过以下命令将我们已创建（配置好的）容器打包为镜像，这样我们以后就能用该镜像再次创建新的容器了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit docker_tomcat my_tomcat</span><br></pre></td></tr></table></figure>
<p>docker_tomcat是容器名称；my_tomcat是新的镜像名称。<br>2.镜像备份<br>通过以下命令可以将镜像打包为tar文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o my_tomcat.tar my_tomcat</span><br></pre></td></tr></table></figure>
<p>-o输出到的文件<br>3.镜像恢复与备份<br>当我们删除了docker_tomcat镜像后，可以通过以下命令将刚才打包备份的.tar镜像文件恢复成一个Docker镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i my_tomcat.tar</span><br></pre></td></tr></table></figure>
<p>-i输入的文件。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>DevOps - 服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能的HTTP服务器————Nginx</title>
    <url>/2020/01/09/nginx/</url>
    <content><![CDATA[<p><img src="/images/nginx.jpg" alt="nginx"><br>Nginx是一款高性能HTTP服务器、反向代理服务器及电子邮件（IMAP、POP3）代理服务器，官方测试nginx能够支持5万并发连接。<br><strong>Nginx应用场景：</strong><br>1、http服务器。Nginx是一个http服务器，可以独立提供http服务。可以做网页静态服务器。<br>2、虚拟主机。可以实现在一台服务器虚拟出多个网站。<br>3、反向代理，负载均衡。当网站的并发量过大需要配置服务器集群时可以使用Nginx做反向代理。并且多台服务器可以平均分摊负载。</p>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="本文章默认使用的软件："><a href="#本文章默认使用的软件：" class="headerlink" title="本文章默认使用的软件："></a>本文章默认使用的软件：</h4><ul>
<li>CentOS 7</li>
<li>Nginx-1.12.2</li>
<li>JDK 8.0</li>
<li>Tomcat 8</li>
</ul>
<h4 id="开发工具："><a href="#开发工具：" class="headerlink" title="开发工具："></a>开发工具：</h4><ul>
<li>VMware fusion</li>
<li>SecureCRT</li>
</ul>
<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>1、安装gcc的环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure>
<p>2、PCRE（perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>
<p>3、Zlib（zlib提供了很多压缩和解压的方式，nginx使用http包的内容进行gzip）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure>
<p>4、OpenSSL（一个强大的安全套接字层密码库，为nginx支持的https(即在SSL协议上传输http)协议服务）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在本地电脑下载nginx的压缩包（我这里是nginx-1.12.2.tar.gz），然后打开SecureCRT连接服务器，使用命令gz将本地的文件上传到Linux服务器上。</p>
<blockquote>
<p>注：如果在SecureCRT上输入gz显示command not found，是因为Linux虚拟机上没有安装lrsz服务。<br>执行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y indtall lrzsz</span><br></pre></td></tr></table></figure>
<p>然后可以输入rz命令选择要上传的文件。默认上传到当前路径上。</p>
<p><strong>1、解压</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>
<p><strong>2、创建Makefile文件，执行命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd nginx-1.12.2</span></span><br><span class="line">[root@localhost nginx-1.12.2]<span class="comment"># ./configure</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/nginx1.png" alt="nginx"><br>完成后可以看到Makefile文件：<br><img src="/images/nginx2.png" alt="nginx"><br><strong>拓展</strong><br>Makefile是一种配置文件，Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译…。Makefile就像一个Shell脚本一样。</p>
<p><strong>3、编译</strong><br>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx-1.12.2]<span class="comment"># make</span></span><br></pre></td></tr></table></figure>

<p><strong>4、安装</strong><br>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx-1.12.2]<span class="comment"># make install</span></span><br></pre></td></tr></table></figure>
<p>到此，Nginx安装已经完成。</p>
<hr>
<h3 id="Nginx启动与访问"><a href="#Nginx启动与访问" class="headerlink" title="Nginx启动与访问"></a>Nginx启动与访问</h3><p>上面我本编译安装的Nginx其实默认被安装在CentOS7系统的/usr/local/nginx目录。<br><img src="/images/nginx3.png" alt="nginx"></p>
<h4 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx]<span class="comment"># cd sbin</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># ./nginx</span></span><br></pre></td></tr></table></figure>
<p>此时已经启动成功Nginx，可以直接在浏览器上输入虚拟机IP（可通过ip addr命令查看），即可访问到Nginx欢迎界面，如果显示未连接，可以：<br>1、先使用本机的终端工具ping虚拟机IP地址看是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping ip</span><br></pre></td></tr></table></figure>
<p>如果ping成功，请看下一步，如果失败，请检查虚拟机是否联网。<br>2、关闭CentOS7的防火墙，开放80端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># systemctl stop firewalld.service #停止firewall</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># systemctl disable firewalld.service #禁止firewall开机启动</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br></pre></td></tr></table></figure>
<p>一般情况下就能访问到了：<br><img src="/images/nginx4.png" alt="nginx"></p>
<h4 id="查看Nginx进程"><a href="#查看Nginx进程" class="headerlink" title="查看Nginx进程"></a>查看Nginx进程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ps aux|grep nginx</span></span><br></pre></td></tr></table></figure>

<h4 id="关闭Nginx"><a href="#关闭Nginx" class="headerlink" title="关闭Nginx"></a>关闭Nginx</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -s stop</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -s quit</span></span><br></pre></td></tr></table></figure>

<h4 id="重启Nginx"><a href="#重启Nginx" class="headerlink" title="重启Nginx"></a>重启Nginx</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -s reload</span></span><br></pre></td></tr></table></figure>

<h4 id="检查Nginx配置文件是否正确"><a href="#检查Nginx配置文件是否正确" class="headerlink" title="检查Nginx配置文件是否正确"></a>检查Nginx配置文件是否正确</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -t</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="部署静态网站"><a href="#部署静态网站" class="headerlink" title="部署静态网站"></a>部署静态网站</h3><p>经过上面的操作，我们已经正常启动了Nginx，那么如何将我们的静态项目部署到服务器的Nginx上呢？<br>为了模拟操作，我这里只部署一个index.html网页为例：</p>
<p>1、<strong>上传静态网站</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回到根目录下</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># cd ../</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹`my`，视为我们的项目文件夹</span></span><br><span class="line">[root@localhost nginx]<span class="comment"># mkdir my</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件夹`my`下创建一个`index.html`网页</span></span><br><span class="line">[root@localhost nginx]<span class="comment"># cd my</span></span><br><span class="line">[root@localhost my]<span class="comment"># vi index.html</span></span><br></pre></td></tr></table></figure>
<p>写入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Hello Nginx!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>2、<strong>修改Nginx的配置文件</strong><br>修改/usr/local/nginx/conf/nginx.conf文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost my]<span class="comment"># cd ../conf</span></span><br><span class="line">[root@localhost conf]<span class="comment"># vi nginx.conf</span></span><br></pre></td></tr></table></figure>
<p>在http {}这个节点下新创建一个server {}节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 81;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root my;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，我们已经将81端口绑定了/nginx文件夹下的名称为my的项目。重启Nginx，访问：192.168.148.132:81即可以访问到我们刚才新创建的网页：index.html。</p>
<h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p><strong>域名</strong>是由一串用“.”分隔的字符逐层的Internet上某一台计算机或计算机组的名称，用于在数据传输时表示计算机的电子方位。域名是一个IP地址的“面具”。域名的目的是便于记忆和沟通的一组服务器的地址。域名按照<strong>域名系统DNS</strong>的规则流程组成，在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。通常，域名表示互联网协议（IP）资源。<br>一个域名对应一个IP地址，一个IP地址可以被多个域名绑定。<br>为了模拟，我们可以在本地hosts文件中配置域名和IP映射关系，这样就不用走DNS服务器了。<br>因为hosts文件内容不能直接修改，需要把hosts文件拷贝出来然后修改后再替换进去就行了(我这里使用的MacOS系统)。</p>
<p>1、<strong>修改hosts</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /private/etc/hosts ~/Desktop/</span><br><span class="line">vi ~/Desktop/hosts</span><br></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.148.132 www.loonycoder.com</span><br></pre></td></tr></table></figure>
<p>然后替换原来的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp ~/Desktop/hosts /private/etc/</span><br></pre></td></tr></table></figure>

<p>2、<strong>修改Nginx配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># vi /usr/local/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure>
<p>为了模拟效果，我们可以先把之前新增的server {}节点81端口改为80端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root my;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启Nginx：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># cd ../sbin</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -s stop</span></span><br><span class="line">[root@localhost sbin]<span class="comment"># ./nginx</span></span><br></pre></td></tr></table></figure>
<p>访问192.168.148.132发现还是Nginx的Welcome页面，因为nginx.conf默认配置的80端口就是指向Nginx欢迎页，且默认的server_name就是localhost。那么想实现不同的域名访问不同的资源且还必须是80端口，就需要绑定域名：<br>修改nginx.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.loonycoder.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root my;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，很简单，只需要把server_name改为我们要绑定的域名地址就好了，然后重启Nginx，在浏览器上访问&lt;<a href="http://www.loonycoder.com&gt;就展示我们之前创建的index.html，而输入192.168.148.132访问的还是Nginx的欢迎页，这就实现了域名的绑定。多个域名绑定同一个IP地址，但是不同的域名指向了不同的资源地址。" target="_blank" rel="noopener">www.loonycoder.com&gt;就展示我们之前创建的index.html，而输入192.168.148.132访问的还是Nginx的欢迎页，这就实现了域名的绑定。多个域名绑定同一个IP地址，但是不同的域名指向了不同的资源地址。</a></p>
<hr>
<h3 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h3><blockquote>
<p>什么是反向代理？<br>反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
</blockquote>
<blockquote>
<p>正向代理<br><img src="/images/nginx5.png" alt="nginx"><br><strong>正向代理</strong>，主要针对客户端。当用户通过PC向Internet发送请求时，可以通过一个代理服务器来统一处理请求并转发给Internet，比如一个教室的所有学生机都需要通过老师的教师机才能实现联网，那么这个教师机就相当于一个代理服务器，负责将PC的网络请求转发给Internet，然后Internet将相应的数据再通过代理服务器转发给不同的PC。</p>
</blockquote>
<blockquote>
<p>反向代理<br><img src="/images/nginx6.png" alt="nginx"><br><strong>反向代理</strong>的过程则刚好相反，主要针对服务器。当用户通过网络请求不同的资源，而这些资源被分布在不同的服务器上，那么不同的请求就应该指向对应不同的服务器，那么就需要一个中介：反向代理服务器。通过反向代理服务器将不同的资源请求信息发送给不同的服务器，然后服务器将不同的信心都返回给反向代理服务器，最后通过反向代理服务器将这些结果信息展示在Internet上。</p>
</blockquote>
<h4 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h4><p>这里我们以一个非常实用的案例来演示如何配置Nginx的反向代理实现不同的域名访问不同的页面。<br>1、在服务器上安装JDK8和Tomcat8<br>通过rz命令将本地的JDK和Tomcat安装包上传到服务器。因为Tomcat解压即可用，我们这里记录一下如何安装JDK：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar zxvf jdk-8u191-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置JDK环境</span></span><br><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure>
<p>在profile文件的结尾处添加如下环境配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/root/jdk1.8.0_191    </span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<p>:wq!保存并退出，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure>

<p>更新配置。然后输入java -version显示则说明JDK配置成功。<br>解压Tomcat，在其bin目录下执行命令./startup.sh启动Tomcat服务器，然后我们再浏览器上访问：<a href="http://192.168.148.132:8080/" target="_blank" rel="noopener">http://192.168.148.132:8080/</a>显示Tomcat的欢迎页面则配置成功。</p>
<p>2、拷贝项目到Tomcat服务器下<br>为了模拟，我们在tomcat/webapps/ROOT/下创建一个index.html网页：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ROOT]<span class="comment"># vi index.html</span></span><br></pre></td></tr></table></figure>
<p>并写入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello Tomcat!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>保存并退出，再次访问<a href="http://192.168.148.132:8080/" target="_blank" rel="noopener">http://192.168.148.132:8080/</a>发现展示的即是我们刚创建的页面<br><img src="/images/nginx7.png" alt="nginx"></p>
<p>3、配置反向代理<br>之前讲了<strong>反向代理</strong>的概念，那么很实用的一个例子就是，当我们想在购买的阿里云服务器上部署两个项目，一个项目是用Nginx部署的静态网站（占用80端口），另一个项目部署在Tomcat服务器上（占用8080端口）。<br>这时，我们固然是可以通过：ip:8080来访问我们的Web项目的，但是请求路径上显示了端口好久显得很别扭，为此，我们通过Nginx的反向代理就能解决：</p>
<ul>
<li><p>3.1在本地配置一个二级域名映射<br>修改本机的hosts文件，添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.148.132 site.loonycoder.com</span><br></pre></td></tr></table></figure>
<p>这时我们访问&lt;site.loonycoder.com&gt;默认进入nginx的欢迎页，这是正确的。<br>注意：此时的&lt;site.loonycoder.com&gt;是&lt;loonycoder.com&gt;的一个二级子域名。</p>
</li>
<li><p>3.2 修改服务器Nginx的配置文件，添加如下配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream site &#123;</span><br><span class="line">        server 192.168.148.132:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name site.loonycoder.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://site;</span><br><span class="line">            index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，其中server {}节点下的proxy_pass表示反向代理的地址，其中<a href="http://site这个site其实是指向上面upstream" target="_blank" rel="noopener">http://site这个site其实是指向上面upstream</a> site {}节点的site名称，因此要保持两者名称一致。但实际上我们不采用这种方式也能实现反向代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># upstream site &#123;</span></span><br><span class="line"><span class="comment">#         server 192.168.148.132:8080;</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name site.loonycoder.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment"># proxy_pass http://site;</span></span><br><span class="line">            proxy_pass http://192.168.148.132:8080;</span><br><span class="line">            index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>两者的区别就是第一种方式通过指向的方式可以配置更多，必须实现<strong>负载均衡</strong>就需要在upstream site {}节点下配置。</p>
<hr>
<h3 id="Nginx配置负载均衡"><a href="#Nginx配置负载均衡" class="headerlink" title="Nginx配置负载均衡"></a>Nginx配置负载均衡</h3><blockquote>
<p>什么是负载均衡？<br><strong>负载均衡（Load Balance）</strong>，其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。<br><strong>负载均衡</strong> 是建立在现有网络结构上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽，增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。<br>1.<strong>模拟负载均衡</strong>，我们可以提供多个Tomcat服务器，采用不同的端口区分。<br>为了模拟<strong>负载均衡</strong>效果，可以copy 2份虚拟机上的Tomcat服务器，命名为tomcat-2，tomcat-3:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cp ~/apache-tomcat-8.5.33 ~/tomcat-2</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp ~/apache-tomcat-8.5.33 ~/tomcat-3</span></span><br></pre></td></tr></table></figure>
<p>修改端口号分别为8180，8280。我们主要修改/tomcat/conf/server.xml配置文件中的&lt;Server port=”8005”和&lt;Connector port=”8080”这两个节点的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改tomcat-2服务器的`/conf/server.xml`参数</span></span><br><span class="line">&lt;Server port=<span class="string">"8006"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</span><br><span class="line">        &lt;Connector port=<span class="string">"8180"</span> protocol=<span class="string">"HTTP/1.1"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改tomcat-3服务器的`/conf/server.xml`参数</span></span><br><span class="line">&lt;Server port=<span class="string">"8007"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</span><br><span class="line">        &lt;Connector port=<span class="string">"8280"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br></pre></td></tr></table></figure>
<p>如上，我们在虚拟机上配置了三个Tomcat服务器，分别使用8080，8180，8280端口。</p>
<p>2.<strong>配置负载均衡</strong><br>修改Nginx下的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vi /usr/local/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure>
<p>修改之前配置的upstream site {}节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream site &#123;</span><br><span class="line">     server 192.168.148.132:8080;</span><br><span class="line">     server 192.168.148.132:8180;</span><br><span class="line">     server 192.168.148.132:8280;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name site.loonycoder.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://site;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就给Nginx配置了3台服务器，都指向了site.loonycoder.com这个域名地址，那么访问这个地址时同时会访问这三台服务器，也就是三台服务器平均分摊访问压力。<br>为了更好的实现效果，我们可以依次修改tomcat-2和tomcat-3服务器的/webapps/ROOT/index.html网页显示数据，更容易区分每次访问的是哪台服务器。<br>然后运行这三个Tomcat服务器，在浏览器上访问：site.loonycoder.com，多次刷新页面，每次访问的都是不同的页面，且依次是配置负载均衡的三台服务器次序。<br>如果你想让某个服务器承担更大的压力，可以为其设置权重：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream site &#123;</span><br><span class="line">     server 192.168.148.132:8080;</span><br><span class="line">     server 192.168.148.132:8180 weight=2;</span><br><span class="line">     server 192.168.148.132:8280;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>HTTP服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的多表查询</title>
    <url>/2020/01/07/Mybatis-3/</url>
    <content><![CDATA[<h3 id="场景-一对多"><a href="#场景-一对多" class="headerlink" title="场景(一对多)"></a>场景(一对多)</h3><p>用户和账户<br>一个用户可以有多个账户<br>一个账户只能属于一个用户（多个账户也可以属于同一个用户）</p>
<p>需要实现：<br>查询账户时，可以查询到归属的用户信息。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><h5 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h5><p>建立用户表和账户表：让用户表和账户表之间具备一对多的关系（需要在账户表中添加外键）<br>建表语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL auto_increment,</span><br><span class="line">  `username` varchar(32) NOT NULL COMMENT <span class="string">'用户名称'</span>,</span><br><span class="line">  `birthday` datetime default NULL COMMENT <span class="string">'生日'</span>,</span><br><span class="line">  `sex` char(1) default NULL COMMENT <span class="string">'性别'</span>,</span><br><span class="line">  `address` varchar(256) default NULL COMMENT <span class="string">'地址'</span>,</span><br><span class="line">  PRIMARY KEY  (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,<span class="string">'张三'</span>,<span class="string">'2018-02-27 17:47:08'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(2,<span class="string">'李四'</span>,<span class="string">'2018-03-02 15:09:37'</span>,<span class="string">'女'</span>,<span class="string">'深圳'</span>),(3,<span class="string">'王五'</span>,<span class="string">'2018-03-04 11:34:34'</span>,<span class="string">'女'</span>,<span class="string">'上海'</span>),(4,<span class="string">'赵六'</span>,<span class="string">'2018-03-04 12:04:06'</span>,<span class="string">'男'</span>,<span class="string">'成都'</span>),(4,<span class="string">'刘七'</span>,<span class="string">'2018-03-07 17:37:26'</span>,<span class="string">'男'</span>,<span class="string">'西安'</span>),(48,<span class="string">'孙八'</span>,<span class="string">'2018-03-08 11:44:00'</span>,<span class="string">'女'</span>,<span class="string">'杭州'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `account`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `account` (</span><br><span class="line">  `ID` int(11) NOT NULL COMMENT <span class="string">'编号'</span>,</span><br><span class="line">  `UID` int(11) default NULL COMMENT <span class="string">'用户编号'</span>,</span><br><span class="line">  `MONEY` double default NULL COMMENT <span class="string">'金额'</span>,</span><br><span class="line">  PRIMARY KEY  (`ID`),</span><br><span class="line">  KEY `FK_Reference_8` (`UID`),</span><br><span class="line">  CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert  into `account`(`ID`,`UID`,`MONEY`) values (1,1,1000),(2,3,1000),(3,5,2000);</span><br></pre></td></tr></table></figure>

<h5 id="建实体类"><a href="#建实体类" class="headerlink" title="建实体类"></a>建实体类</h5><p>用户实体类和账户实体类：让用户和账户的实体类能体现出一对多的关系<br>由于我们之前新建过用户的实体类，所以我们在这里只新建一个账户实体类即可，和用户实体类一样放在com.loonycoder.domain包下<br>此处在从表实体类中引用主表的对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Account implements Serializable &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private Integer uid;</span><br><span class="line">    private Double money;</span><br><span class="line"></span><br><span class="line">    //从表实体应该包含一个主表实体的对象引用</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    public User <span class="function"><span class="title">getUser</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUser(User user) &#123;</span><br><span class="line">        this.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getUid</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUid(Integer uid) &#123;</span><br><span class="line">        this.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double <span class="function"><span class="title">getMoney</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMoney(Double money) &#123;</span><br><span class="line">        this.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", uid="</span> + uid +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来我们新建一个Account的Mapper接口类，并提供查询所有账户的方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.domain.Account;</span><br><span class="line">import com.loonycoder.domain.AccountUser;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IAccountMapper &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有账户</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    List&lt;Account&gt; selectAll();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有账户，并且包含账户对应的用户下的姓名和地址信息</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    List&lt;AccountUser&gt; selectAccountUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>用户的配置文件和账户的配置文件<br>用户的配置文件用之前的就可以了，我们在此只新建账户的配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IAccountMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--定义封装account和user的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"accountUserMap"</span> <span class="built_in">type</span>=<span class="string">"account"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"aid"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"uid"</span> column=<span class="string">"uid"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"money"</span> column=<span class="string">"money"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;!--一对一的关系映射，配置封装user的内容--&gt;</span><br><span class="line">        &lt;association property=<span class="string">"user"</span> column=<span class="string">"uid"</span> javaType=<span class="string">"user"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/association&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultMap=<span class="string">"accountUserMap"</span>&gt;</span><br><span class="line">        select u.*,a.id as aid,a.uid,a.money from account a,user u <span class="built_in">where</span> u.id = a.uid;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>当然我们还需要修改一下SqlMapConfig.xml中的别名和mapper映射配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line">&lt;!--mybatis的主配置文件--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--引用外部配置文件配置数据源信息，下面的取值部分需要用<span class="variable">$&#123;&#125;</span>方式取值--&gt;</span><br><span class="line">    &lt;properties resource=<span class="string">"jdbcConfig.properties"</span>&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;!--配置别名 <span class="built_in">type</span>属性指定实体类，<span class="built_in">alias</span>指定别名--&gt;</span><br><span class="line">    &lt;typeAliases &gt;</span><br><span class="line">        &lt;!--package标签可以指定具体到某个包下所有类都使用别名，默认别名是类的名字，不区分大小写--&gt;</span><br><span class="line">        &lt;package name=<span class="string">"com.loonycoder.domain"</span>&gt;&lt;/package&gt;</span><br><span class="line">        &lt;!--&lt;typeAlias <span class="built_in">type</span>=<span class="string">"com.loonycoder.domain.User"</span> <span class="built_in">alias</span>=<span class="string">"user"</span>&gt;&lt;/typeAlias&gt;--&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">    &lt;!--配置环境--&gt;</span><br><span class="line">    &lt;environments default=<span class="string">"mysql"</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">"mysql"</span>&gt;</span><br><span class="line">            &lt;!--配置事务--&gt;</span><br><span class="line">            &lt;transactionManager <span class="built_in">type</span>=<span class="string">"JDBC"</span>&gt;&lt;/transactionManager&gt;</span><br><span class="line">            &lt;!--配置数据源（连接池）--&gt;</span><br><span class="line">            &lt;dataSource <span class="built_in">type</span>=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">"driver"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.driver&#125;</span>"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"url"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.url&#125;</span>"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"username"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.username&#125;</span>"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"password"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.password&#125;</span>"</span> /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IUserMapper.xml"</span> /&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IAccountMapper.xml"</span> /&gt;</span><br><span class="line">        &lt;!--&lt;mapper class=<span class="string">"com.loonycoder.dao.IUserMapper"</span> /&gt;--&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h5 id="新建测试类执行"><a href="#新建测试类执行" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">selectAllAccount</span></span>()&#123;</span><br><span class="line">    List&lt;Account&gt; accts = accountMapper.selectAll();</span><br><span class="line">    <span class="keyword">for</span> (Account acct : accts) &#123;</span><br><span class="line">        System.out.println(<span class="string">"每个账户下的用户信息"</span>);</span><br><span class="line">        System.out.println(acct);</span><br><span class="line">        System.out.println(acct.getUser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/images/mybatis1.png" alt="result"></p>
<hr>
<h3 id="场景-多对一"><a href="#场景-多对一" class="headerlink" title="场景(多对一)"></a>场景(多对一)</h3><p>需要实现：</p>
<ul>
<li>查询用户时，可以同时查询出用户下的所有账户信息</li>
</ul>
<h5 id="修改实体类"><a href="#修改实体类" class="headerlink" title="修改实体类"></a>修改实体类</h5><p>我们修改User实体类，让主表包含从表的集合引用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String userName;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private String sex;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    private List&lt;Account&gt; accounts;</span><br><span class="line"></span><br><span class="line">    public List&lt;Account&gt; <span class="function"><span class="title">getAccounts</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class="line">        this.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getUserName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date <span class="function"><span class="title">getBirthday</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getSex</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getAddress</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", userName='"</span> + userName + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                ", birthday=" + birthday +</span></span><br><span class="line"><span class="string">                ", sex='</span><span class="string">" + sex + '\'' +</span></span><br><span class="line"><span class="string">                "</span>, address=<span class="string">'" + address + '</span>\<span class="string">''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><p>User接口类我们不做修改，直接用原来的查询所有用户的方法即可，我们只需要改动映射配置文件。<br>修改IUserMapper.xml内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IUserMapper"</span>&gt;</span><br><span class="line">    &lt;!--配置列名和实体类属性对应关系 <span class="built_in">type</span>属性不区分大小写--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userMap"</span> <span class="built_in">type</span>=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        &lt;!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名--&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!--定义User的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userAccountMap"</span> <span class="built_in">type</span>=<span class="string">"user"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;!--配置user对象中accounts集合的映射--&gt;</span><br><span class="line">        &lt;!--ofType指的是集合的泛型--&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"accounts"</span> ofType=<span class="string">"account"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"id"</span> column=<span class="string">"aid"</span>&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property=<span class="string">"uid"</span> column=<span class="string">"uid"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"money"</span> column=<span class="string">"money"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class="line">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class="line">    &lt;!--此处使用左外连接查询--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultMap=<span class="string">"userAccountMap"</span>&gt;</span><br><span class="line">        select * from user u left outer join account a on u.id = a.uid;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">"saveUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        insert into user (username,sex,birthday,address) values (<span class="comment">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id=<span class="string">"deleteUser"</span> parameterType=<span class="string">"java.lang.Integer"</span>&gt;</span><br><span class="line">        delete from user <span class="built_in">where</span> id = <span class="comment">#&#123;uid&#125;;</span></span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=<span class="string">"updateUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        update user <span class="built_in">set</span> username = <span class="comment">#&#123;userName&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;select id=<span class="string">"selectUserByCondition"</span> resultMap=<span class="string">"userMap"</span> parameterType=<span class="string">"user"</span>&gt;</span><br><span class="line">          select * from user</span><br><span class="line">          &lt;<span class="built_in">where</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"sex != null and sex != '' "</span>&gt;</span><br><span class="line">                and sex = <span class="comment">#&#123;sex&#125;</span></span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">          &lt;/<span class="built_in">where</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h5 id="新建测试类执行-1"><a href="#新建测试类执行-1" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void selectTest() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">    //5.使用代理对象执行方法</span><br><span class="line">    List&lt;User&gt; users= userDao.selectAll();</span><br><span class="line">    <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">        System.out.println(<span class="string">"每个用户下账户的信息："</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(user.getAccounts());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/images/mybatis2.png" alt="result"></p>
<hr>
<h3 id="场景-多对多"><a href="#场景-多对多" class="headerlink" title="场景(多对多)"></a>场景(多对多)</h3><p>用户和角色<br>一个用户有多个角色<br>一个角色有多个用户<br>需要实现：</p>
<ul>
<li>当我们查询用户时，可以同时得到用户的角色信息</li>
<li>当我们查询角色时，可以同时得到角色所属的用户信息</li>
</ul>
<h5 id="新建角色表和中间表"><a href="#新建角色表和中间表" class="headerlink" title="新建角色表和中间表"></a>新建角色表和中间表</h5><p>建表语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `role`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `role` (</span><br><span class="line">  `ID` int(11) NOT NULL COMMENT <span class="string">'编号'</span>,</span><br><span class="line">  `ROLE_NAME` varchar(30) default NULL COMMENT <span class="string">'角色名称'</span>,</span><br><span class="line">  `ROLE_DESC` varchar(60) default NULL COMMENT <span class="string">'角色描述'</span>,</span><br><span class="line">  PRIMARY KEY  (`ID`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert  into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,<span class="string">'董事长'</span>,<span class="string">'管理整个公司'</span>),(2,<span class="string">'总裁'</span>,<span class="string">'管理整个公司'</span>),(3,<span class="string">'部门经理'</span>,<span class="string">'管理某个部门'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `user_role`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user_role` (</span><br><span class="line">  `UID` int(11) NOT NULL COMMENT <span class="string">'用户编号'</span>,</span><br><span class="line">  `RID` int(11) NOT NULL COMMENT <span class="string">'角色编号'</span>,</span><br><span class="line">  PRIMARY KEY  (`UID`,`RID`),</span><br><span class="line">  KEY `FK_Reference_10` (`RID`),</span><br><span class="line">  CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`),</span><br><span class="line">  CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">insert  into `user_role`(`UID`,`RID`) values (1,1),(3,1),(3,2);</span><br></pre></td></tr></table></figure>

<h5 id="新建角色实体类"><a href="#新建角色实体类" class="headerlink" title="新建角色实体类"></a>新建角色实体类</h5><p>此处注意也要让用户和角色体现出多对多关系：需要各自包含对方的一个集合引用。</p>
<p>新建角色实体类：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Role implements Serializable &#123;</span><br><span class="line">    private Integer roleId;</span><br><span class="line">    private String roleName;</span><br><span class="line">    private String roleDesc;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getRoleId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> roleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoleId(Integer roleId) &#123;</span><br><span class="line">        this.roleId = roleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getRoleName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> roleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoleName(String roleName) &#123;</span><br><span class="line">        this.roleName = roleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getRoleDesc</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> roleDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoleDesc(String roleDesc) &#123;</span><br><span class="line">        this.roleDesc = roleDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Role&#123;"</span> +</span><br><span class="line">                <span class="string">"roleId="</span> + roleId +</span><br><span class="line">                <span class="string">", roleName='"</span> + roleName + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                ", roleDesc='</span><span class="string">" + roleDesc + '\'' +</span></span><br><span class="line"><span class="string">                '&#125;';</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="新建实体类接口"><a href="#新建实体类接口" class="headerlink" title="新建实体类接口"></a>新建实体类接口</h5><p>新建RoleMapper接口类：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.domain.Role;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IRoleMapper &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有角色信息</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public List&lt;Role&gt; selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="新建角色实体配置文件"><a href="#新建角色实体配置文件" class="headerlink" title="新建角色实体配置文件"></a>新建角色实体配置文件</h5><p>一、新建IRoleMapper.xml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IRoleMapper"</span>&gt;</span><br><span class="line">    &lt;!--定义role表的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"roleMap"</span> <span class="built_in">type</span>=<span class="string">"role"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"roleId"</span> column=<span class="string">"rid"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"roleName"</span> column=<span class="string">"role_name"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"roleDesc"</span> column=<span class="string">"role_desc"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"users"</span> ofType=<span class="string">"user"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--查询所有角色信息--&gt;</span><br><span class="line">    &lt;!--使用两次左外连接查询--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultMap=<span class="string">"roleMap"</span>&gt;</span><br><span class="line">        select u.*,r.id as rid,r.role_name,r.role_desc from role r</span><br><span class="line">        left outer join user_role ur on r.id = ur.rid</span><br><span class="line">        left outer join user u on u.id = ur.uid</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>二、在SqlMapConfig.xml中添加映射配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IUserMapper.xml"</span> /&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IAccountMapper.xml"</span> /&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IRoleMapper.xml"</span> /&gt;</span><br><span class="line">        &lt;!--&lt;mapper class=<span class="string">"com.loonycoder.dao.IUserMapper"</span> /&gt;--&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<h5 id="新建测试类执行-2"><a href="#新建测试类执行-2" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">selectRoleAll</span></span>()&#123;</span><br><span class="line">    List&lt;Role&gt; roles = roleMapper.selectAll();</span><br><span class="line">    <span class="keyword">for</span> (Role role:roles) &#123;</span><br><span class="line">        System.out.println(<span class="string">"每个角色的用户信息："</span>);</span><br><span class="line">        System.out.println(role);</span><br><span class="line">        System.out.println(role.getUsers());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果-2"><a href="#执行结果-2" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/images/mybatis3.png" alt="result"></p>
<hr>
<h5 id="根据用户查询角色"><a href="#根据用户查询角色" class="headerlink" title="根据用户查询角色"></a>根据用户查询角色</h5><p>同理，我们修改用户实体类，添加多对多的关系映射：一个用户具备多个角色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String userName;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private String sex;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    多对多关系映射：一个用户具备多个角色</span><br><span class="line">    private List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line">    public List&lt;Role&gt; <span class="function"><span class="title">getRoles</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoles(List&lt;Role&gt; roles) &#123;</span><br><span class="line">        this.roles = roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;Account&gt; accounts;</span><br><span class="line"></span><br><span class="line">    public List&lt;Account&gt; <span class="function"><span class="title">getAccounts</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(List&lt;Account&gt; accounts) &#123;</span><br><span class="line">        this.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getUserName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date <span class="function"><span class="title">getBirthday</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getSex</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getAddress</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", userName='"</span> + userName + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                ", birthday=" + birthday +</span></span><br><span class="line"><span class="string">                ", sex='</span><span class="string">" + sex + '\'' +</span></span><br><span class="line"><span class="string">                "</span>, address=<span class="string">'" + address + '</span>\<span class="string">''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，修改用户实体映射配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IUserMapper"</span>&gt;</span><br><span class="line">    &lt;!--配置列名和实体类属性对应关系 <span class="built_in">type</span>属性不区分大小写--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userMap"</span> <span class="built_in">type</span>=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        &lt;!--id标签配置主键，property标签配置实体类属性，column标签配置表的列名--&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!--定义User的resultMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userAccountMap"</span> <span class="built_in">type</span>=<span class="string">"user"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;!--配置user对象中accounts集合的映射--&gt;</span><br><span class="line">        &lt;!--ofType指的是集合的泛型--&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"accounts"</span> ofType=<span class="string">"account"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"id"</span> column=<span class="string">"aid"</span>&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property=<span class="string">"uid"</span> column=<span class="string">"uid"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"money"</span> column=<span class="string">"money"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--配置user的userRoleMap--&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"userRoleMap"</span> <span class="built_in">type</span>=<span class="string">"user"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=<span class="string">"userName"</span> column=<span class="string">"username"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"sex"</span> column=<span class="string">"sex"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"address"</span> column=<span class="string">"address"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">"birthday"</span> column=<span class="string">"birthday"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"roles"</span> ofType=<span class="string">"role"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"roleId"</span> column=<span class="string">"rid"</span>&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result property=<span class="string">"roleName"</span> column=<span class="string">"role_name"</span>&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result property=<span class="string">"roleDesc"</span> column=<span class="string">"role_desc"</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class="line">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class="line">    &lt;!--此处使用左外连接查询--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultMap=<span class="string">"userAccountMap"</span>&gt;</span><br><span class="line">        select * from user u left outer join account a on u.id = a.uid;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"selectUserRoleAll"</span> resultMap=<span class="string">"userRoleMap"</span>&gt;</span><br><span class="line">        select u.*,r.id as rid,r.role_name,r.role_desc from user u</span><br><span class="line">        left outer join user_role ur on u.id = ur.uid</span><br><span class="line">        left outer join role r on r.id = ur.rid</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">"saveUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        insert into user (username,sex,birthday,address) values (<span class="comment">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id=<span class="string">"deleteUser"</span> parameterType=<span class="string">"java.lang.Integer"</span>&gt;</span><br><span class="line">        delete from user <span class="built_in">where</span> id = <span class="comment">#&#123;uid&#125;;</span></span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=<span class="string">"updateUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        update user <span class="built_in">set</span> username = <span class="comment">#&#123;userName&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;select id=<span class="string">"selectUserByCondition"</span> resultMap=<span class="string">"userMap"</span> parameterType=<span class="string">"user"</span>&gt;</span><br><span class="line">          select * from user</span><br><span class="line">          &lt;<span class="built_in">where</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"sex != null and sex != '' "</span>&gt;</span><br><span class="line">                and sex = <span class="comment">#&#123;sex&#125;</span></span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">          &lt;/<span class="built_in">where</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>在UserMapper接口中添加查询方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 查询用户及用户下所有的角色信息</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public List&lt;User&gt; selectUserRoleAll();</span><br></pre></td></tr></table></figure>

<p>新建测试方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">selectUserRoleAll</span></span>()&#123;</span><br><span class="line">    List&lt;User&gt; users = userDao.selectUserRoleAll();</span><br><span class="line">    <span class="keyword">for</span> (User user:users) &#123;</span><br><span class="line">        System.out.println(<span class="string">"每个用户的角色信息："</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(user.getRoles());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：<br><img src="/images/mybatis4.png" alt="result"></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java框架 - 数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的增删改查操作</title>
    <url>/2020/01/06/Mybatis-2/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>基于我们之前创建的Mybatis项目即可，我在此采用的依旧是基于xml的开发方式。</p>
<hr>
<h3 id="Mybatis的查询操作"><a href="#Mybatis的查询操作" class="headerlink" title="Mybatis的查询操作"></a>Mybatis的查询操作</h3><h4 id="在mapper接口中新增查询方法"><a href="#在mapper接口中新增查询方法" class="headerlink" title="在mapper接口中新增查询方法"></a>在mapper接口中新增查询方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.domain.User;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IUserMapper &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询用户</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public List&lt;User&gt; selectAll();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在IUserMapper-xml中添加查询sql语句"><a href="#在IUserMapper-xml中添加查询sql语句" class="headerlink" title="在IUserMapper.xml中添加查询sql语句"></a>在IUserMapper.xml中添加查询sql语句</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!--namespace里面要配置mapper接口的全限定类名--&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IUserMapper"</span>&gt;</span><br><span class="line">    &lt;!--id要保持和方法名一致--&gt;</span><br><span class="line">    &lt;!--resultType指定返回值类型，如果是List类型 配置List的泛型即可--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"selectAll"</span> resultType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        select * from user;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h4 id="新建测试类执行"><a href="#新建测试类执行" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h4><p>由于读取配置文件、创建SqlSessionFactory工厂等步骤复用性较高，我们在这里进行了抽取。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.loonycoder.dao.IUserMapper;</span><br><span class="line">import com.loonycoder.domain.User;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class MybatisTest &#123;</span><br><span class="line"></span><br><span class="line">    private InputStream inputStream;</span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    private SqlSession session;</span><br><span class="line">    private IUserMapper userDao;</span><br><span class="line"></span><br><span class="line">    //before注解代表在测试方法执行前执行</span><br><span class="line">    @Before</span><br><span class="line">    public void init() throws Exception&#123;</span><br><span class="line">        //1.读取配置文件</span><br><span class="line">        inputStream = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        //2.创建SqlSessionFactory工厂</span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class="line">        sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        //3.使用工厂创建SqlSession对象</span><br><span class="line">        session = sqlSessionFactory.openSession();</span><br><span class="line">        //4.使用SqlSession创建dao接口的代理对象</span><br><span class="line">        userDao = session.getMapper(IUserMapper.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //after注解代表在测试方法执行后执行</span><br><span class="line">    @After</span><br><span class="line">    public void destroy() throws Exception&#123;</span><br><span class="line">        //6.释放资源</span><br><span class="line">        session.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void selectTest() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        //5.使用代理对象执行方法</span><br><span class="line">        List&lt;User&gt; users= userDao.selectAll();</span><br><span class="line">        <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="/images/execResult1.png" alt="执行结果"></p>
<hr>
<h3 id="Mybatis的保存操作"><a href="#Mybatis的保存操作" class="headerlink" title="Mybatis的保存操作"></a>Mybatis的保存操作</h3><h4 id="在mapper接口中新增保存方法"><a href="#在mapper接口中新增保存方法" class="headerlink" title="在mapper接口中新增保存方法"></a>在mapper接口中新增保存方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 保存用户</span><br><span class="line"> * @param user</span><br><span class="line"> */</span><br><span class="line">public void saveUser(User user);</span><br></pre></td></tr></table></figure>

<h4 id="在IUserMapper-xml中添加保存sql语句"><a href="#在IUserMapper-xml中添加保存sql语句" class="headerlink" title="在IUserMapper.xml中添加保存sql语句"></a>在IUserMapper.xml中添加保存sql语句</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"saveUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        insert into user (username,sex,birthday,address) values (<span class="comment">#&#123;userName&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;);</span></span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：<br>#{}为mybatis的固定用法，用于取值。如果User实体类中的属性是自动生成的get/set，则直接写属性名称即可。<br>其次，参数一定要一一对应上</strong></p>
<h4 id="新建测试类执行-1"><a href="#新建测试类执行-1" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">insertTest</span></span>()&#123;</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setUserName(<span class="string">"Lisa"</span>);</span><br><span class="line">    user.setBirthday(new Date());</span><br><span class="line">    user.setAddress(<span class="string">"广东"</span>);</span><br><span class="line">    user.setSex(<span class="string">"女"</span>);</span><br><span class="line">    userDao.saveUser(user);</span><br><span class="line">    session.commit();//记得手动提交事务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：一定要手动提交事务，否则虽然不会报错，但是不会入表！！！</strong></p>
<h4 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="/images/execResult2.png" alt="执行结果"></p>
<hr>
<h3 id="Mybatis的删除操作"><a href="#Mybatis的删除操作" class="headerlink" title="Mybatis的删除操作"></a>Mybatis的删除操作</h3><h4 id="在mapper接口中新增删除方法"><a href="#在mapper接口中新增删除方法" class="headerlink" title="在mapper接口中新增删除方法"></a>在mapper接口中新增删除方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 删除用户</span><br><span class="line">    * @param userId</span><br><span class="line">    */</span><br><span class="line">   public void deleteUser(Integer userId);</span><br></pre></td></tr></table></figure>

<h4 id="在IUserMapper-xml中添加删除sql语句"><a href="#在IUserMapper-xml中添加删除sql语句" class="headerlink" title="在IUserMapper.xml中添加删除sql语句"></a>在IUserMapper.xml中添加删除sql语句</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;delete id=<span class="string">"deleteUser"</span> parameterType=<span class="string">"java.lang.Integer"</span>&gt;</span><br><span class="line">        delete from user <span class="built_in">where</span> id = <span class="comment">#&#123;uid&#125;;</span></span><br><span class="line">    &lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：因为该方法只有一个参数，所以我们在sql中标注的uid部分其实是可以随便写的，因为mybatis只会找到这一个参数</strong></p>
<h4 id="新建测试类执行-2"><a href="#新建测试类执行-2" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void <span class="function"><span class="title">deleteTest</span></span>()&#123;</span><br><span class="line">       userDao.deleteUser(53);</span><br><span class="line">       session.commit();//记得手动提交事务</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行结果-2"><a href="#执行结果-2" class="headerlink" title="执行结果"></a>执行结果</h4><p>删除前：<br><img src="/images/execBefore.png" alt="执行结果"><br>删除后：<br><img src="/images/execAfter.png" alt="执行结果"></p>
<hr>
<h3 id="Mybatis的修改操作"><a href="#Mybatis的修改操作" class="headerlink" title="Mybatis的修改操作"></a>Mybatis的修改操作</h3><h4 id="在mapper接口中新增修改方法"><a href="#在mapper接口中新增修改方法" class="headerlink" title="在mapper接口中新增修改方法"></a>在mapper接口中新增修改方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 修改用户</span><br><span class="line"> * @param user</span><br><span class="line"> */</span><br><span class="line">public void updateUser(User user);</span><br></pre></td></tr></table></figure>

<h4 id="在IUserMapper-xml中添加修改sql语句"><a href="#在IUserMapper-xml中添加修改sql语句" class="headerlink" title="在IUserMapper.xml中添加修改sql语句"></a>在IUserMapper.xml中添加修改sql语句</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;update id=<span class="string">"updateUser"</span> parameterType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">    update user <span class="built_in">set</span> username = <span class="comment">#&#123;username&#125;,sex = #&#123;sex&#125;,birthday = #&#123;birthday&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;;</span></span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<h4 id="新建测试类执行-3"><a href="#新建测试类执行-3" class="headerlink" title="新建测试类执行"></a>新建测试类执行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">updateTest</span></span>()&#123;</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setId(41);</span><br><span class="line">    user.setUserName(<span class="string">"张三丰"</span>);</span><br><span class="line">    session.commit();//记得手动提交事务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行结果-3"><a href="#执行结果-3" class="headerlink" title="执行结果"></a>执行结果</h4><p>修改前：<br><img src="/images/execAfter.png" alt="执行结果"><br>修改后：<br><img src="/images/execAfter1.png" alt="执行结果"></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java框架 - 数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis入门及搭建</title>
    <url>/2020/01/03/Mybatis-1/</url>
    <content><![CDATA[<p>上大学的时候自学过一段时间mybatis框架，感觉很好用。<br>但是在工作中并没有用到，于是翻出之前的视频重新复习了一下。</p>
<hr>
<h3 id="Mybatis的配置方式开发"><a href="#Mybatis的配置方式开发" class="headerlink" title="Mybatis的配置方式开发"></a>Mybatis的配置方式开发</h3><h4 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h4><p>因为Mybatis是持久层框架，所以在此之前我们要做一些准备工作，首先我们要在Mysql中建好表并插入数据。<br>建表及导入sql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL auto_increment,</span><br><span class="line">  `username` varchar(32) NOT NULL COMMENT <span class="string">'用户名称'</span>,</span><br><span class="line">  `birthday` datetime default NULL COMMENT <span class="string">'生日'</span>,</span><br><span class="line">  `sex` char(1) default NULL COMMENT <span class="string">'性别'</span>,</span><br><span class="line">  `address` varchar(256) default NULL COMMENT <span class="string">'地址'</span>,</span><br><span class="line">  PRIMARY KEY  (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,<span class="string">'张三'</span>,<span class="string">'2018-02-27 17:47:08'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(2,<span class="string">'李四'</span>,<span class="string">'2018-03-02 15:09:37'</span>,<span class="string">'女'</span>,<span class="string">'深圳'</span>),(3,<span class="string">'王五'</span>,<span class="string">'2018-03-04 11:34:34'</span>,<span class="string">'女'</span>,<span class="string">'成都'</span>),(4,<span class="string">'赵六'</span>,<span class="string">'2018-03-04 12:04:06'</span>,<span class="string">'男'</span>,<span class="string">'上海'</span>),(5,<span class="string">'loonycoder'</span>,<span class="string">'2018-03-07 17:37:26'</span>,<span class="string">'男'</span>,<span class="string">'西安'</span>),(6,<span class="string">'望月'</span>,<span class="string">'2018-03-08 11:44:00'</span>,<span class="string">'女'</span>,<span class="string">'杭州'</span>);</span><br></pre></td></tr></table></figure>

<p>如图：<br><img src="/images/table.png" alt="建表"></p>
<h4 id="二、新建项目"><a href="#二、新建项目" class="headerlink" title="二、新建项目"></a>二、新建项目</h4><p>我们这里要新建一个maven项目。<br><img src="/images/1.png" alt="创建Maven项目"></p>
<p><img src="/images/2.png" alt="创建Maven项目"></p>
<p><img src="/images/3.png" alt="创建Maven项目"></p>
<p>创建完成之后，我们打开pom.xml文件引入依赖。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.loonycoder&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;MybatisDemo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.4&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="三、创建表对象的映射实体类"><a href="#三、创建表对象的映射实体类" class="headerlink" title="三、创建表对象的映射实体类"></a>三、创建表对象的映射实体类</h4><p>因为mybatis是一个ORM（Object Relational Mapping）框架，所以我们要准备一个和表字段一一对应的实体类。</p>
<p><strong>注意</strong>：<br><strong>表中的字段名和实体类中的字段名字一定要一致！</strong><br><strong>实体类一定要实现Serializable接口</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String username;</span><br><span class="line">    private Date birthday;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public Integer <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getUsername</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date <span class="function"><span class="title">getBirthday</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getAddress</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", username='"</span> + username + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                ", birthday=" + birthday +</span></span><br><span class="line"><span class="string">                ", address='</span><span class="string">" + address + '\'' +</span></span><br><span class="line"><span class="string">                '&#125;';</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="四、新建dao接口"><a href="#四、新建dao接口" class="headerlink" title="四、新建dao接口"></a>四、新建dao接口</h4><p>这里直接上代码，我在此新建了一个查询所有的方法，此处记住方法名和返回值类型，后续会用到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.domain.User;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IUserDao &#123;</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="五、创建mybatis的主配置文件"><a href="#五、创建mybatis的主配置文件" class="headerlink" title="五、创建mybatis的主配置文件"></a>五、创建mybatis的主配置文件</h4><p>该配置文件需要放在/resources目录下，配置文件的名称在具有规范性的前提下是随意起的，我这里采用了默认的规范(我发现很多人都这么起)</p>
<p>SqlMapConfig.xml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line">&lt;!--mybatis的主配置文件--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--配置环境--&gt;</span><br><span class="line">    &lt;environments default=<span class="string">"mysql"</span>&gt;</span><br><span class="line">        &lt;!--配置mysql的环境--&gt;</span><br><span class="line">        &lt;environment id=<span class="string">"mysql"</span>&gt;</span><br><span class="line">            &lt;!--配置事务类型--&gt;</span><br><span class="line">            &lt;transactionManager <span class="built_in">type</span>=<span class="string">"JDBC"</span>&gt;&lt;/transactionManager&gt;</span><br><span class="line">            &lt;!--配置数据源(连接池)--&gt;</span><br><span class="line">            &lt;dataSource <span class="built_in">type</span>=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">"driver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/MybatisDemo/"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"password"</span> value=<span class="string">"20141016"</span> /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/loonycoder/dao/IUserDao.xml"</span> /&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>配置数据源的时候，把url、username、password 修改成你自己的数据库链接、用户名和密码即可。</p>
<p>注意：<br><strong>下方的mapper部分的配置我接下来会讲，后续按照你自己配置的路径配置即可。</strong></p>
<hr>
<h4 id="六、配置mapper文件"><a href="#六、配置mapper文件" class="headerlink" title="六、配置mapper文件"></a>六、配置mapper文件</h4><p>前面虽然配置了mybatis主配置文件，但是我们在实际操作中如果存在多个对象的dao接口，主配置文件需要怎么准确找到该接口呢？<br>我们就需要为每个dao配置一个独立的配置文件<br>我习惯上把文件命名成 <strong>xxxMapper.xml</strong>，这里命名成xxxDao.xml是为了方便理解。<br>文件存放目录为/resources目录下，与实体对象dao接口的包同级。<br><img src="/images/mapperxml.png" alt="xml文件配置"></p>
<p>代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!--namespace需要配置dao的全限定类名--&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.loonycoder.dao.IUserDao"</span>&gt;</span><br><span class="line">    &lt;!--配置查询所有--&gt;</span><br><span class="line">    &lt;!--id一定要是方法的名称--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"findAll"</span> resultType=<span class="string">"com.loonycoder.domain.User"</span>&gt;</span><br><span class="line">        select * from user;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="七、引入log4j"><a href="#七、引入log4j" class="headerlink" title="七、引入log4j"></a>七、引入log4j</h4><p>这个是可选操作，为了后期记录日志，我们可以采用log4j去实现。此处只是了解。<br>将log4j.properties文件放在/resources目录下即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set root category priority to INFO and its only appender to CONSOLE.</span></span><br><span class="line"><span class="comment">#log4j.rootCategory=INFO,CONSOLE             debug  info  warn  error  fatal</span></span><br><span class="line">log4j.rootCategory=debug, CONSOLE, LOGFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span></span><br><span class="line">log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE</span><br><span class="line"></span><br><span class="line"><span class="comment"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span></span><br><span class="line">log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n</span><br><span class="line"></span><br><span class="line"><span class="comment"># LOGFILE is set to be a File appender using a PatternLayout.</span></span><br><span class="line">log.appender.LOGFILE=org.apache.log4j.FileAppender</span><br><span class="line">log.appender.LOGFILE.FILE=/usr/gmx/LearnWorkspace</span><br><span class="line">log.appender.LOGFILE.Append=<span class="literal">true</span></span><br><span class="line">log.appender.LOGFILE.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="八、测试案例"><a href="#八、测试案例" class="headerlink" title="八、测试案例"></a>八、测试案例</h4><p>如此，我们的mybatis就搭建完成了，我们接下来测试一下。<br>在/test/java目录下新建一个test类<br>如图：<br><img src="/images/test.png" alt="test类"></p>
<p>代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.loonycoder.dao.IUserDao;</span><br><span class="line">import com.loonycoder.domain.User;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class MybatisTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        //1.读取配置文件</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        //2.创建SqlSessionFactory工厂</span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        //3.使用工厂创建SqlSession对象</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        //4.使用SqlSession创建dao接口的代理对象</span><br><span class="line">        IUserDao userDao = session.getMapper(IUserDao.class);</span><br><span class="line">        //5.使用代理对象执行方法</span><br><span class="line">        List&lt;User&gt; users= userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        //6.释放资源</span><br><span class="line">        session.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/testResult.png" alt="运行结果"></p>
<hr>
<h3 id="Mybaits的注解方式开发"><a href="#Mybaits的注解方式开发" class="headerlink" title="Mybaits的注解方式开发"></a>Mybaits的注解方式开发</h3><p>Mybatis也为我们提供了基于注解的开发方式<br>基于注解开发意味着脱离xml配置，所以我们在上述项目中可以直接移除com/loonycoder/dao/IUserDao.xml文件<br>同时需要修改SqlMapConfig.xml中的映射配置文件部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line">&lt;!--mybatis的主配置文件--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--配置环境--&gt;</span><br><span class="line">    &lt;environments default=<span class="string">"mysql"</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">"mysql"</span>&gt;</span><br><span class="line">            &lt;!--配置事务--&gt;</span><br><span class="line">            &lt;transactionManager <span class="built_in">type</span>=<span class="string">"JDBC"</span>&gt;&lt;/transactionManager&gt;</span><br><span class="line">            &lt;!--配置数据源（连接池）--&gt;</span><br><span class="line">            &lt;dataSource <span class="built_in">type</span>=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">"driver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span> /&gt;</span><br><span class="line">                &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span> /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置映射文件（mapper类的映射文件）--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--此处做了修改，之前的属性是resource，现在改为class，并且指定到dao接口的全限定类名--&gt;</span><br><span class="line">        &lt;mapper class=<span class="string">"com.loonycoder.dao.IUserDao"</span> /&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>同时需要在dao接口的方法上添加注解@Select</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.loonycoder.dao;</span><br><span class="line"></span><br><span class="line">import com.loonycoder.domain.User;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface IUserDao &#123;</span><br><span class="line">    @Select(<span class="string">"select * from user"</span>)</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/testResult.png" alt="运行结果"></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java框架 - 数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件</title>
    <url>/2019/12/12/Vue3/</url>
    <content><![CDATA[<h4 id="Vue创建组件"><a href="#Vue创建组件" class="headerlink" title="Vue创建组件"></a>Vue创建组件</h4><h5 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h5><p>什么是组件？组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样地方功能，就可以去调用对应的组件即可。<br>组件化和模块化的区别：</p>
<ul>
<li>模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的只能单一；</li>
<li>组件化：是从UI界面的角度进行划分的；前端的组件化，方便了UI组件的重用；</li>
</ul>
<h5 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h5><p><strong>方式一</strong><br>1、使用Vue.extend来创建全局的Vue组件<br>2、通过template属性来指定组件要展示的HTML结构<br>3、通过Vue.component()定义全局组件<br>4、在HTML指定位置通过Tag标签的形式应用你的组件，组件的名称即是tag标签的名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	&lt;!-- 组件的名称即为对应tag标签的名称 --&gt;</span><br><span class="line">	&lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	// 创建组件</span><br><span class="line">	var com1 = Vue.extend(&#123;</span><br><span class="line">		template: <span class="string">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	// 使用Vue.component(<span class="string">'组件的名称'</span>, 创建出来的组件模板对象)，定义全局组件</span><br><span class="line">	Vue.component(<span class="string">'mycom1'</span>, com1);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>用Vue.component()定义组件名称的时候有两种命名方式：1、驼峰命名：Xxx；2、xxx。注意，使用驼峰命名时，tag标签不能使用驼峰名称，应将相应的大写字母替换为-加小写字母，例如：Vue.component(‘myCom’, com1)，那么tag标签应为： &lt;my-com&gt; &lt;/my-com&gt;</li>
</ul>
<p><strong>方式二</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 组件的名称即为对应tag标签的名称 --&gt;</span><br><span class="line">&lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">	// 使用Vue.component(<span class="string">'组件的名称'</span>, 创建出来的组件模板对象)，定义全局组件</span><br><span class="line">	Vue.component(<span class="string">'mycom1'</span>, Vue.extend(&#123;</span><br><span class="line">		template: <span class="string">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class="line">	&#125;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>方式二就像是方式一的简化版，但是注意：<br>在template中定义的内容只能存在一个根节点元素，即上面例子中template中不能出现和 &lt;h3&gt;平级的标签。<br>比如下面这种写法就是<strong>错误的</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'mycom1'</span>, Vue.extend(&#123;</span><br><span class="line">	template: <span class="string">'&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;'</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>解决办法就是，外层嵌套一个根标签就行了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'mycom1'</span>, Vue.extend(&#123;</span><br><span class="line">	template: <span class="string">'&lt;div&gt;&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;'</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p><strong>方式三</strong><br>1、JavaScript中仍使用Vue.component来定义全局组件，和方式二相似，但是里面不再是template: ‘HTML结构’了，而是引用一个外部标签的id值，即template:’id’。<br>2、在被Vue实例控制的app外面，定义&lt;template id=”id”&gt;你的HTML结构&lt;/template&gt;<br>这种方式的好处就是是就组件代码都是定义在HTML结构中的，有智能代码提示；而JavaScript中定义组件仅是写一个引用。<br>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	&lt;!-- 页面引用 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">	&lt;!-- 比如仅存在一个根节点元素 --&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;h1&gt;&lt;/h1&gt;&gt;</span><br><span class="line">		&lt;h2&gt;&lt;/h2&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">//JavaScript部分</span><br><span class="line">Vue.component(<span class="string">'mycom'</span>, &#123;</span><br><span class="line">	template: <span class="string">'#tmp'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>定义私</strong>有组件<br>除了上面讲到的定义全局组件，我们也可以定义私有组件，使用components: {}函数。<br>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;tem&gt;&lt;/tem&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">    &lt;h3&gt;这是私有组件&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        tem: &#123;</span><br><span class="line">            template: <span class="string">'#tmp'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="组件元素"><a href="#组件元素" class="headerlink" title="组件元素"></a>组件元素</h5><p><strong>组件的</strong>data<br>在组件中，同样可以有自己的data数据，但是用法和Vue实例中的data用法有所不同：<br>1、组件中的data必须是一个方法，即</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="title">function</span></span>()&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>2、组件中的data方法必须返回一个Object对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">	<span class="built_in">return</span> object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">Vue.component(<span class="string">'mycom1'</span>, Vue.extend(&#123;</span><br><span class="line">	data: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">		<span class="built_in">return</span> &#123;</span><br><span class="line">			msg: <span class="string">'这是组件的data'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	template: <span class="string">'&lt;h3&gt;这是使用Vue.extend 创建的组件-- &#123;&#123;msg&#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>组件的</strong>切换<br>在遇到登录注册表单时，通常我们需要对两个按钮进行切换实现显示不同的表单，那么Vue中的组件切换正符合了这个功能要求。</p>
<p><strong>方式一</strong></p>
<p>可以使用Vue提供的v-if和v-else来实现两个组件间的切换，但是，仅支持切换两个组件</p>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> @click.prevent=<span class="string">"flag=true"</span>&gt;登录&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> @click.prevent=<span class="string">"flag=false"</span>&gt;注册&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">    &lt;login v-if=<span class="string">"flag"</span>&gt;&lt;/login&gt;</span><br><span class="line">    &lt;register v-else=<span class="string">"flag"</span>&gt;&lt;/register&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=<span class="string">"login"</span>&gt;</span><br><span class="line">    &lt;h3&gt;这是登录表单&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=<span class="string">"register"</span>&gt;</span><br><span class="line">	&lt;h3&gt;这是注册表单&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">// 创建登录组件</span><br><span class="line">Vue.component(<span class="string">'login'</span>, &#123;</span><br><span class="line">	template: <span class="string">'#login'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 创建注册组件</span><br><span class="line">Vue.component(<span class="string">'register'</span>, &#123;</span><br><span class="line">	template: <span class="string">'#register'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">    	flag: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>定义flag参数，当flag=true就显示组件，当flar=false就隐藏组件</p>
<p><strong>方式二</strong></p>
<p>Vue提供了component来展示对应名称的组件。其中component是一个占位符，:is属性，可以用来指定要展示的组件名称</p>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> @click.prevent=<span class="string">"comName='login'"</span>&gt;登录&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> @click.prevent=<span class="string">"comName='register'"</span>&gt;注册&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">    &lt;component :is=<span class="string">"comName"</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=<span class="string">"login"</span>&gt;</span><br><span class="line">    &lt;h3&gt;这是登录表单&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=<span class="string">"register"</span>&gt;</span><br><span class="line">	&lt;h3&gt;这是注册表单&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">// 创建登录组件</span><br><span class="line">Vue.component(<span class="string">'login'</span>, &#123;</span><br><span class="line">	template: <span class="string">'#login'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 创建注册组件</span><br><span class="line">Vue.component(<span class="string">'register'</span>, &#123;</span><br><span class="line">	template: <span class="string">'#register'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">    	comName: <span class="string">'login'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>即使用Vue提供的component，它能够实现自动对组件进行展示和隐藏，通过:is=’组件名称’。</p>
<h5 id="父子组件间传值"><a href="#父子组件间传值" class="headerlink" title="父子组件间传值"></a>父子组件间传值</h5><p><strong>父组件</strong>给子组件传值</p>
<p>父组件给子组件传值，即实现在子组件中调用父组件中的methods或是获取父组件中的data.</p>
<p><strong>传参数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1&gt;&lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        	msg: <span class="string">'这是父组件data值'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        	<span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">        		console.log(<span class="string">"这是父组件的show方法"</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">        	com1: &#123;</span><br><span class="line">        		template: <span class="string">'&lt;h2&gt;这是子组件&lt;/h2&gt;'</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>如上，当我们直接在子组件中引用父组件data中定义的msg数据，将上面的修改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">com1: &#123;</span><br><span class="line">	template: <span class="string">'&lt;h2&gt;这是子组件--&#123;&#123;msg&#125;&#125;&lt;/h2&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么就会报错。所以就证实了默认在子组件中不能访问父组件中的data或methods。<br>为了解决子组件获取父组件数据，Vue提供了以下方式获取：</p>
<ul>
<li>1、父组件在引用子组件的时候，通过属性绑定的方式v-bind:，把需要传递给子组件的数据以属性绑定的形式传递到子组件内部，供子组件使用。</li>
<li>2、在子组件中，通过props: []获取到父组件传递过来的数据；这样就完成了父组件向子组件传值</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1 :fatoson=<span class="string">"msg"</span>&gt;&lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        	msg: <span class="string">'这是父组件data值'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">        	com1: &#123;</span><br><span class="line">        		template: <span class="string">'&lt;h2&gt;这是子组件--&#123;&#123;fatoson&#125;&#125;&lt;/h2&gt;'</span>,</span><br><span class="line">        		props: [<span class="string">'fatoson'</span>]</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>如上，我们在子组件实例中使用了v-bind绑定了一个参数fatoson，其值是：msg即在父组件data中定义的值；那么就相当于父组件的一个data数据被Vue绑定到了子组件实例中，且父组件data值的别名是fatoson，那么在子组件中通过props: []属性就能获取到这个别名，然后就实现了父组件向子组件传值。需要注意以下：</p>
<ul>
<li>1、我们可以将为子组件绑定的参数名称是父组件值的别名。即此时msg相当于fatoson。</li>
<li>2、注意命名中若是驼峰命名，在HTML中必须用-替换。</li>
<li>3、注意props是Vue为父组将向子组件传值提供的一个参数，且他是唯一的数组类型的。</li>
<li>4、注意子组件通过props获取到的父组件的值是只读的，即不能修改。</li>
</ul>
<p><strong>传方法</strong><br>上面讲了父组件给子组件传递普通的参数，下面我们将了解到父组件怎样给子组件传递方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1 @open=<span class="string">"show"</span>&gt;&lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">    	&lt;div&gt;</span><br><span class="line">    		&lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class="line">    		&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"myclick"</span> value=<span class="string">"子组件按钮，点击触发父组件方法"</span>/&gt;</span><br><span class="line">    	&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        	msg: <span class="string">'这是父组件data值'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        	<span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">        		console.log(<span class="string">"这是父组件的show方法"</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">        	com1: &#123;</span><br><span class="line">        		template: <span class="string">'#tmp'</span>,</span><br><span class="line">        		props: [<span class="string">'fatoson'</span>],</span><br><span class="line">        		methods: &#123;</span><br><span class="line">        			<span class="function"><span class="title">myclick</span></span>()&#123;</span><br><span class="line">       		 			this.<span class="variable">$emit</span>(<span class="string">'open'</span>);</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>1、这里子组件的template数据引用外部的&lt;template&gt;&lt;/template&gt;中的HTML代码。</li>
<li>2、与传值思路相同，传递方法也需要在子组件实例中使用v-on即@来绑定方法，方法别名@open，方法的值是show是在父组件中定义的方法名。</li>
<li>3、与传值思路相同，传值使用了props来接受传递的参数，那么传方法提供了$emit()元素</li>
</ul>
<p><strong>综合</strong><br>上面讲的父组件向子组件传递方法，那么既然是方法就肯定能传递方法参数。我们只需要在父组件方法中指定值名称即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@子组件接收的方法别名=<span class="string">"父组件中的方法(父组件中的参数值或data)"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1 @open=<span class="string">"show(fatosonval)"</span>&gt;&lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">    	&lt;div&gt;</span><br><span class="line">    		&lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class="line">    		&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"myclick"</span> value=<span class="string">"子组件按钮，点击触发父组件方法"</span>/&gt;</span><br><span class="line">    	&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        	fatosonval: &#123;</span><br><span class="line">        		id: <span class="string">'1'</span>,</span><br><span class="line">        		name: <span class="string">'Loonycoder'</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        	show(data)&#123;</span><br><span class="line">        		console.log(data);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">        	com1: &#123;</span><br><span class="line">        		template: <span class="string">'#tmp'</span>,</span><br><span class="line">        		methods: &#123;</span><br><span class="line">        			<span class="function"><span class="title">myclick</span></span>()&#123;</span><br><span class="line">       		 			this.<span class="variable">$emit</span>(<span class="string">'open'</span>);</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p><strong>子组件</strong>给父组件传值<br>即实现在父组件中调用子组件中的方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1 @open=<span class="string">"show"</span>&gt;&lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">    	&lt;div&gt;</span><br><span class="line">    		&lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class="line">    		&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"myclick"</span> value=<span class="string">"子组件按钮，点击触发父组件方法"</span>/&gt;</span><br><span class="line">    	&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        	fatosonval: null</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        	show(data)&#123;</span><br><span class="line">        		console.log(data);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">        	com1: &#123;</span><br><span class="line">        		template: <span class="string">'#tmp'</span>,</span><br><span class="line">        		<span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">        			<span class="built_in">return</span> &#123;</span><br><span class="line">        				sonval: &#123; name: <span class="string">'Loonycoder'</span>, age: 24 &#125;</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;,</span><br><span class="line">        		methods: &#123;</span><br><span class="line">        			<span class="function"><span class="title">myclick</span></span>()&#123;</span><br><span class="line">       		 			this.<span class="variable">$emit</span>(<span class="string">'open'</span>, this.sonval);</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>之前我们实现父组件向子组件传值的时候，需要在@open()中指定父组件中的data，而子组件给父组件传值的时候就不需要再指定了，而是直接在调用子组件中的open（这是父组件方法的别名），将子组件的值写进$emit(‘方法别名’, data参数)中即可。</p>
<h5 id="Vue获取DOM元素和组件"><a href="#Vue获取DOM元素和组件" class="headerlink" title="Vue获取DOM元素和组件"></a>Vue获取DOM元素和组件</h5><p>首先我们需要明白的就是Vue并不提倡我们操作DOM元素，Vue的宗旨就是让我们只关心业务逻辑。<br>那么通常我们需要获取一个如&lt;h2&gt;&lt;/h2&gt;中的值，采用原生JS通常需要先为tag标签定义一个id属性，然后通过JS代码document.getElementById(‘id’).innterText来获取到&lt;h2&gt;中的文本数据，而Vue也实现了操作原生DOM的功能：</p>
<ul>
<li>在需要获取的HTML标签中指定<code>ref</code>属性，其值可自定义。</li>
<li>在Vue实例中，使用<code>this.$refs.指定的值</code>来获取DOM对象，进行操作。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;h2 ref=<span class="string">"h2"</span>&gt;这是h2的文本数据&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">console.log(this.<span class="variable">$refs</span>.h2.innerText);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>通过$refs还能轻易获取子组件中的data和methods数据</strong><br>首先需要为子组件引用实例定义ref=”com1”属性，然后在Vue实例中通过this.$refs.com1即可获取子组件中的所有对象，即还能获取到子组件中的data和methods<br>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 父组件实例 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;!-- 子组件实例 --&gt;</span><br><span class="line">        &lt;com1 ref=<span class="string">"com1"</span>&gt;&lt;/com1&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"show"</span> value=<span class="string">"获取元素"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h2 ref=<span class="string">"h2"</span>&gt;这是父组件&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;这是子组件&lt;/h2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">                // console.log(this.<span class="variable">$refs</span>.h2.innerText);</span><br><span class="line">                // console.log(this.<span class="variable">$refs</span>.com1); //获取子组件中的所有实例对象</span><br><span class="line">                // console.log(this.<span class="variable">$refs</span>.com1.sonval); //获取子组件中定义的data值</span><br><span class="line">                console.log(this.<span class="variable">$refs</span>.com1.sonshow()); //调用子组件中定义的方法</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 子组件</span><br><span class="line">        components: &#123;</span><br><span class="line">            com1: &#123;</span><br><span class="line">                template: <span class="string">'#tmp'</span>,</span><br><span class="line">                <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">                    <span class="built_in">return</span> &#123;</span><br><span class="line">                        sonval: &#123; name: <span class="string">'Loonycoder'</span>, age: 24 &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    <span class="function"><span class="title">sonshow</span></span>() &#123;</span><br><span class="line">                        console.log(<span class="string">'子组件的方法'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue路由</title>
    <url>/2019/12/12/Vue4/</url>
    <content><![CDATA[<h3 id="Vue路由"><a href="#Vue路由" class="headerlink" title="Vue路由"></a>Vue路由</h3><h4 id="什么是Vue路由？"><a href="#什么是Vue路由？" class="headerlink" title="什么是Vue路由？"></a>什么是Vue路由？</h4><ul>
<li><strong>后端路由：</strong>即请求的URL地址都对应后端的接口，请求URL响应对应的服务器的资源。</li>
<li><strong>前端路由：</strong>对于单页面程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以单页面程序中的页面跳转主要通过hash实现。</li>
</ul>
<h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><h5 id="导入类库"><a href="#导入类库" class="headerlink" title="导入类库"></a>导入类库</h5><p>首先需要导入vue-router组件类库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue-router.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>当导入类库后，window全局对象中就存在了一个路由的构造函数： VueRouter；就像导入Vue类库后存在一个Vue的构造函数一样，我们能够通过new VueRouter的方式实例化路由对象。<br>如果你使用了new VueRouter({});构造函数来实例化了一个路由对象，你会发现浏览器路径中会出现#/路径，这个路径就是前面讲到的URL中的hash，他并不会向后端发送任何请求，而仅仅是作页面跳转，如果你#/后拼接了一个不存在的路径，自然也不会进行跳转，页面也不会发送任何请求。<br><strong>实例：</strong><br><img src="/images/vue15.png" alt="vue"></p>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>上面我们讲到了使用new VueRouter({})的方式实例化一个路由对象，其中包含几个参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 给路由对象创建一个容器，包裹在父组件`app`内</span><br><span class="line">        相当于一个占位符，路由规则匹配到的组件内容就会展示到`&lt;router-view&gt;&lt;/router-view&gt;`中</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- ===============分割线===================== --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- JavaScript --&gt;</span><br><span class="line">//创建login组件</span><br><span class="line">var login = &#123;</span><br><span class="line">    template: <span class="string">'login组件'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建register组件</span><br><span class="line">var register = &#123;</span><br><span class="line">    template: <span class="string">'register组件'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Router实例</span><br><span class="line">var 路由对象名称 = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123; path: <span class="string">'/监听URL路径'</span>, component: login(组件名称) &#125;,</span><br><span class="line">        &#123; path: <span class="string">'/监听URL路径'</span>, component: register(组件名称) &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Vue实例</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">'app'</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    router: 路由对象名称   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>1、routes 表示这个路由对象中的 路由匹配规则，可以存在多个规则（注意：这里是routes而不是routers）</li>
<li>2、属性一：path 表示监听哪个路由连接地址，即你想跳转都哪个路径上，应在这里注册实现跳转到对应的组件上</li>
<li>3、属性二：component 表示如果路由匹配了前面的path，则展示component属性对应的那个组件</li>
<li>4、component的属性值必须是一个组件的模板对象，不能是组件的引用名称</li>
<li>5、经过1-4的步骤基本完成了路由对象的创建，下面要将这个路由对象注入到Vue实例中，使用router: 组件对象名称实现</li>
<li>6、创建对应需要监听的组件，如上我们创建了login和register组件，与之前讲的不同是这里是一个var 组件名称其值是一个组件对象，和之前的Vue.component方式相似，但是这里仅仅是一个组件对象，并没有注册到Vue实例中，因为没有组件名称，所以不能在HTML中使用&lt;login&gt;&lt;/login&gt; ，注意这里的login是组件对象的名称。</li>
</ul>
<p><strong>步骤：</strong></p>
<ul>
<li>1、创建router实例new VueRouter，完成相关属性的定义；</li>
<li>2、将这个路由对象注册到Vue实例中，使用router: 路由对象名称的方式；</li>
<li>3、创建第一步中定义的组件名称对应的组件，直接在&lt;script&gt;中定义var组件对象名称即可，在template中定义具体的HTML视图，或是通过template: ‘#id’引用外部视图也行。</li>
<li>4、在Vue实例控制域app中，创建&lt;router-view&gt;&lt;/router-view&gt;，相当于router容器，你想在页面上展示几个组件就应该在页面中创建几个容器。</li>
</ul>
<p>如上，我们可以写具体的跳转链接了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app&gt;</span></span><br><span class="line"><span class="string">    &lt;a href="</span><span class="comment">#/login"&gt;登录&lt;/a&gt;</span></span><br><span class="line">    &lt;a href=<span class="string">"#/register"</span>&gt;注册&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如上，当我们点击登录或注册，Vue-router就会监听都对应的URL地址，然后在path规则中刚好匹配到规则login，那么就会跳转到对应的组件component: login的login组件中。<br>可能你会疑惑了，为什么这里的href需要写为#/login而不是/login或login，你尝试一下就知道了，因为vue-router监听URL地址是基于hash的，不加#/就会找不到路径。<br>如果你觉得每次都加#/麻烦的话，Vue-router页提供了一个Tag:&lt;router-link to=”URL地址”&gt;&lt;/router-link&gt;，其在浏览器中会被解析为&lt;a&gt;标签。</p>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">        &lt;a href=<span class="string">"#/login"</span>&gt;登录&lt;/a&gt;</span><br><span class="line">        &lt;router-link to=<span class="string">"register"</span>&gt;注册&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue-router.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">        var login = &#123;</span><br><span class="line">            template: <span class="string">'&lt;h2&gt;登录组件&lt;/h2&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var register = &#123;</span><br><span class="line">            template: <span class="string">'&lt;h2&gt;注册组件&lt;/h2&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var routerObj = new VueRouter(&#123;</span><br><span class="line">            routes: [</span><br><span class="line">                &#123; path: <span class="string">'/login'</span>, component: login &#125;,</span><br><span class="line">                &#123; path: <span class="string">'/register'</span>, component: register &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;&#125;,</span><br><span class="line">            methods: &#123;&#125;,</span><br><span class="line">            router: routerObj</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>但是上面的实例中，我们发现默认进入的根路径中仅有一个父组件名称，一般我们的登录页面应该直接显示登录框，所以vue-router提供了重定向的动能{path: ‘’, redirect: ‘’}，即在router: []中监听根路径，如果监听都访问的是根路径就重定向到登录URL就好了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var routerObj = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123; path: <span class="string">'/'</span>, redirect: <span class="string">'/login'</span> &#125;,</span><br><span class="line">        &#123; path: <span class="string">'/login'</span>, component: login &#125;,</span><br><span class="line">        &#123; path: <span class="string">'/register'</span>, component: register &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="路由参数传递"><a href="#路由参数传递" class="headerlink" title="路由参数传递"></a>路由参数传递</h4><p>在进行页面跳转，即路由的时候，我们可能需要在发送URL时传递一些参数，常见的就如<a href="http://www.loonycoder.com/api?id=1&amp;name=&#39;loonycoder&#39;" target="_blank" rel="noopener">http://www.loonycoder.com/api?id=1&amp;name=&#39;loonycoder&#39;</a>这种格式。<br>那么在URL中传递的参数，vue-router提供了一种获取方式：this.$route。<br>那么什么时候能获取到传递的参数呢？ 回顾前面讲到的Vue声明周期函数，那么在自定义组件中自然也存在生命周期函数，所以最早操作组件data和methods中数据的阶段就是created这个声明周期函数的阶段。<br>实例：<br><img src="/images/vue16.png" alt="vue"><br><img src="/images/vue17.png" alt="vue"></p>
<p>上面打印的值中，我们能看到，我们再VueRouter中创建的path匹配规则，实际在HTML中会被渲染为相关的正则表达式，来实现路径的匹配。<br>其次，我们还能发现，在URL中拼接的参数id在this.$route对象的query属性中，我们通过this.$route.query.id即可获得传递的id值：2。</p>
<h4 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><p>路由嵌套，顾名思义即在父级路由内部存在子路由。例如：</p>
<blockquote>
<p>根路径：<a href="http://www.loonycoder.com" target="_blank" rel="noopener">http://www.loonycoder.com</a><br>父级路由地址：<a href="http://www.loonycoder.com/api" target="_blank" rel="noopener">http://www.loonycoder.com/api</a><br>子级路由地址：<a href="http://www.loonycoder.com/api/login" target="_blank" rel="noopener">http://www.loonycoder.com/api/login</a></p>
</blockquote>
<p><strong>实例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;router-link to=<span class="string">"/account"</span>&gt;Account&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;template id=<span class="string">"tmp"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;这是Account组件&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;router-link to=<span class="string">"/account/login"</span>&gt;登录&lt;/router-link&gt;</span><br><span class="line">            &lt;router-link to=<span class="string">"/account/register"</span>&gt;注册&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">            &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue-router.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">        var account = &#123;</span><br><span class="line">            template: <span class="string">'#tmp'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var login = &#123;</span><br><span class="line">            template: <span class="string">'&lt;h2&gt;登录组件&lt;/h2&gt;'</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var register = &#123;</span><br><span class="line">            template: <span class="string">'&lt;h2&gt;注册组件&lt;/h2&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var routerObj = new VueRouter(&#123;</span><br><span class="line">            routes: [</span><br><span class="line">                &#123; </span><br><span class="line">                    path: <span class="string">'/account'</span>, </span><br><span class="line">                    component: account,</span><br><span class="line">                    children: [</span><br><span class="line">                        &#123; path: <span class="string">'login'</span>, component: login &#125;,</span><br><span class="line">                        &#123; path: <span class="string">'register'</span>, component: register &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;&#125;,</span><br><span class="line">            methods: &#123;&#125;,</span><br><span class="line">            router: routerObj</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>如上，我们使用了routes: []中的另外一个属性：children，顾名思义就是表示这个父规则/account下存在一些子规则，且在URL中应该体现出来：<br><img src="/images/vue18.png" alt="vue"></p>
<p><strong>注意：</strong><br>在children中定义的子组件的path规则不能加/，即如上的，直接写path: login即可，这样请求account/login地址时，vue-router会找/account规则下的login规则，且不加/vue-router才会自动将login视为account下的子路径，并自动拼接account/，否则不会自动拼接，那么也无法完成路由的嵌套。</p>
<h4 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h4><p>我们常见的后台开发页面，经常遇到上、左、中的布局方式；那么以前我们可能使用iframe实现页面间的跳转，但是现在我们学习的路由要比其更加的方便好用。<br><strong>命名视图</strong>的思想就是为每一个页面展示的视图都起一个名字，目的是为了为每个&lt;router-view&gt;&lt;/router-view&gt;容器刚好匹配一个指定的视图。使用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view name=<span class="string">"left"</span>&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view name=<span class="string">"main"</span>&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line">routes: [</span><br><span class="line">    &#123; </span><br><span class="line">        path: <span class="string">'/'</span>, components: &#123;</span><br><span class="line">            <span class="string">'default'</span>: header</span><br><span class="line">            <span class="string">'left'</span>: left</span><br><span class="line">            <span class="string">'main'</span>: main</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong><br>其中的path是根路径/，而使用components代替之前的component，目的就是可匹配其下的多个规则；default表示默认的视图组件是header这个组件，即会匹配到第一个&lt;router-view&gt;视图容器中；下面的两个组件会根据name名称需要对应的组件。<br>实现上、左、中的布局：<br><strong>思路：</strong><br>1、我们需要创建三个组件，名称分别为：header、left、main；并且在app中创建三个&lt;router-view&gt;&lt;/router-view&gt;路由容器。<br>2、采用<strong>命名视图</strong>的方式为每个视图都起一个名字：&lt;router-view name=”left”&gt;&lt;/router-view&gt; …<br>3、注册路由实例。<br>实例：<br><img src="/images/vue19.png" alt="vue"><br><img src="/images/vue20.png" alt="vue"></p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue过滤器和Vue-resource</title>
    <url>/2019/12/10/Vue2/</url>
    <content><![CDATA[<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>之前我们学习了Vue的 <strong>vue基本指令</strong> 进阶学习，我们需要了解Vue的过滤器：Vue.js允许你自定义过滤器，可被用作一些常见元素的格式化。过滤器可以用在两个地方：mustache插值和v-bind表达式。<br>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;&#123; 过滤器名称 | <span class="keyword">function</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定义：</strong><br>Vue提供了两种方式创建过滤器：</p>
<ul>
<li>1、全局过滤器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'过滤器名称'</span>, <span class="function"><span class="title">function</span></span>()&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>2、私有过滤器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new Vue()(&#123;</span><br><span class="line">    el: <span class="string">''</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line">        过滤器名称: <span class="function"><span class="title">function</span></span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;&#123;&#123; msg | myFilters(<span class="string">'时光'</span>) &#125;&#125;&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">Vue.filter(<span class="string">'myFilters'</span>, <span class="keyword">function</span>(data, pattern)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pattern == <span class="string">'时光'</span>)&#123;</span><br><span class="line">        var old = data.substring(0,4);</span><br><span class="line">        <span class="built_in">return</span> old + <span class="string">',时光路口。'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong><br>如上：Vue提供的全局过滤器，直接使用Vue调用，而不是定义在Vue实例中</p>
<ul>
<li>Vue.filter()中第一个参数是过滤器名称，第二个参数是function(){}</li>
<li>function(){}中还有两个参数，第一个参数是原始的值，第二个参数是你想给过滤器方法传递的值。</li>
</ul>
<h4 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;&#123;&#123; msg | myFilters(<span class="string">'望月'</span>) &#125;&#125;&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">var vm2 = new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app2'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">'loonycoder！'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line"></span><br><span class="line">        myFilters: <span class="keyword">function</span>(data, pattern) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pattern == <span class="string">'望月'</span>)&#123;</span><br><span class="line">                var old = data.substring(0,4);</span><br><span class="line">                <span class="built_in">return</span> old + <span class="string">',loonycoder'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>私有过滤器和全局过滤器用法基本相同，仅仅是作用于不同而已。</p>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p>在我们搜索商品时，在一些网站中我们直接回车后立即进行搜索，而不是点击搜索按钮才会搜索，那么这个功能怎么实现呢？<br>那么我们就需要了解Vue中提供的<strong>按键修饰符</strong><br>用法： @keyup.按键别名 = “要调用的方法名”</p>
<p><strong>按键别名</strong></p>
<blockquote>
<p>.enter<br>.tab<br>.esc<br>.delete<br>…</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> @keyup.enter=<span class="string">"open"</span>&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">open</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"弹出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义按键修饰符</strong><br>如果Vue提供的按键修饰符不能满足你的需求，你也可以使用Vue提供的自定义按键修饰符来实现，因为每个键盘的按键都对应了一个键盘码值，比如F2对应的键盘码值是：113：<br>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> @keyup.f2=<span class="string">"open"</span>&gt;</span><br><span class="line"></span><br><span class="line">Vue.config.keyCodes.f2 = 113;   </span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">open</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"弹出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取文本焦点"><a href="#获取文本焦点" class="headerlink" title="获取文本焦点"></a>获取文本焦点</h4><p>获取文本焦点使用了focus属性，那么我们需要定义一个v-focus指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">    <span class="built_in">bind</span>: <span class="keyword">function</span>(el) &#123;&#125;,</span><br><span class="line">    inserted: <span class="keyword">function</span>(el) &#123;&#125;,</span><br><span class="line">    updated: <span class="keyword">function</span>(el) &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如上，使用Vue.directive()实现定义全局指令，需要注意以下几点：</p>
<ul>
<li>1、在directive()方法中包含两个参数：<blockquote>
<p>参数1：指令的名称，注意，在定义的时候指令名称不需要加v-前缀，但是在使用的时候需要加v-前缀。<br>参数2：是一个对象，这个对象包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作。</p>
</blockquote>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 使用的时候使用： v-focus</span><br></pre></td></tr></table></figure>

<ul>
<li>2、在directive()函数的第二个参数中（对象）中又包含了三个实例方法：<blockquote>
<p>bind: 当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次；但是需要知道元素绑定了这个指令，若涉及对DOM操作的，并不会立即执行，因为元素不会立即插入到DOM中。所以涉及对元素进行DOM相关操作的，不要定义到这个方法中。<br>inserted: 当元素插入到DOM的时候，会立即执行，并只触发一次。<br>updated: 当VNode更新的时候，会指定updated，可能触发多次。</p>
</blockquote>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">    <span class="built_in">bind</span>: <span class="keyword">function</span>(el) &#123;</span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-focus /&gt;</span><br></pre></td></tr></table></figure>

<p>如上，其中bind函数的第一个参数永远是el，它表示绑定的那个元素，是一个原生的JS对象；这里我们调用了JS的focus方法</p>
<h5 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h5><p>指令定义函数提供了几个钩子函数（可选）：</p>
<blockquote>
<p>bind<br>inserted<br>update<br>componentUpdated: 所在组件的VNode及其孩子的VNode全部更新的时候调用<br>unbind: 只调用一次，指令与元素解除绑定时调用</p>
</blockquote>
<p><strong>钩子函数参数</strong><br>在上面使用directive()函数的时候我们已经介绍了一些常用的钩子函数，那么既然是函数，就可能需要进行传参，那么为了实现钩子函数传参，Vue提供了几个参数属性来实现对钩子函数参数的一些操作：</p>
<ul>
<li>el: 指令所绑定的元素，可以用来直接操作DOM。</li>
<li>binding: 一个对象，包含以下属性：<ul>
<li>name: 指令名，不包含v-前缀</li>
<li>value: 指令的绑定值，如v-focus=”1 + 1”，那么value=2。</li>
<li>expression: 绑定值的字符串形式，如v-focus=”1+1”，那么experssion的值是1+1。</li>
<li>…</li>
</ul>
</li>
<li>…</li>
</ul>
<p><strong>示例：</strong><br>实现在文本框中输入的数据颜色要为蓝色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-color=<span class="string">"'blue'"</span>&gt;</span><br><span class="line"></span><br><span class="line">// 自定义设置颜色的指令</span><br><span class="line">Vue.directive(<span class="string">'color'</span>, &#123;</span><br><span class="line">    <span class="built_in">bind</span>: <span class="keyword">function</span>(el, binding)&#123;</span><br><span class="line">        el.style.color = binding.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中因为设计要获取值的操作，所以使用binding这个对象钩子函数参数来使用接收，那么：<br>1、这个el就表示当前这个input文本框对象<br>2、这个binding就表示v-color=”‘blue’”指令传递的参数blue（因为使用’’单引号即不是字符串）<br>3、binding-value就是获取到v-color指令绑定的参数值是：blue，通过el.style.color表示设置这个文本框样式中的颜色属性</p>
<h5 id="定义私有指令"><a href="#定义私有指令" class="headerlink" title="定义私有指令"></a>定义私有指令</h5><p>使用<strong>私有指令</strong>和<strong>全局指令</strong>的用法基本相同，我们参考上面讲过的<strong>私有过滤器</strong>和<strong>全局过滤器</strong>就能猜想到<strong>私有指令</strong>的用法：<br><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;p v-fontsize=<span class="string">"'50px'"</span>&gt;私有指令&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">''</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    filters: &#123;&#125;,</span><br><span class="line">    directives: &#123;</span><br><span class="line">        <span class="string">'fontsize'</span>: &#123;</span><br><span class="line">            <span class="built_in">bind</span>: <span class="keyword">function</span>(el, binding)&#123;</span><br><span class="line">                el.style.fontSize = binding.value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>自定义指令的简写形式</strong><br>对于仅仅使用bind和update钩子函数的操作，可以进行下列的简写形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;p v-fontsize=<span class="string">"'50px'"</span>&gt;私有指令&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">''</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    filters: &#123;&#125;,</span><br><span class="line">    directives: &#123;</span><br><span class="line">        <span class="string">'fontsize'</span>: <span class="keyword">function</span>(el, binding)&#123;</span><br><span class="line">            el.style.fontSize = binding.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h4><p>实现将列表数据渲染到表格中，并实现添加功能案例（包含上面讲到的所有技术的<strong>实例</strong>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">    table &#123;</span><br><span class="line">        min-height: 25px;</span><br><span class="line">        line-height: 25px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border-collapse: collapse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table,</span><br><span class="line">    table tr th,</span><br><span class="line">    table tr td &#123;</span><br><span class="line">        border: 1px solid <span class="comment">#0094ff;</span></span><br><span class="line">        padding: 11px;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        id:</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"id"</span> v-focus v-color=<span class="string">"'blue'"</span>&gt; username:</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"username"</span> @keyup.enter=<span class="string">"add"</span>&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"添加"</span> @click=<span class="string">"add"</span>&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;th&gt;id&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;name&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;date&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;fun&lt;/th&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/thead&gt;</span><br><span class="line">            &lt;tbody&gt;</span><br><span class="line">                &lt;tr v-for=<span class="string">"user in list"</span> :key=<span class="string">"user.id"</span>&gt;</span><br><span class="line">                    &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;&#123;&#123;user.username&#125;&#125;&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;&#123;&#123;user.time | dataFormat(<span class="string">''</span>) &#125;&#125;&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;&lt;a href=<span class="string">"#"</span> @click=<span class="string">"del(user.id)"</span>&gt;删除&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/tbody&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">        &lt;p&gt;未使用过滤器：&#123;&#123; new Date() &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;使用全局过滤器：&#123;&#123; new Date() | dataFormat(<span class="string">''</span>) &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app2"</span>&gt;</span><br><span class="line">        使用私有过滤器：&#123;&#123; dt | dataFormat(<span class="string">''</span>)&#125;&#125;</span><br><span class="line">        &lt;p v-fontsize=<span class="string">"'50px'"</span>&gt;私有指令&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    // 自定义文本框获取焦点指令</span><br><span class="line">    // Vue.directive()定义全局指令，包含两个参数：</span><br><span class="line">    // 参数1：指令的名称，注意，在定义的时候指令的名称不需要加v-前缀，但是在使用的时候需要加v-focus</span><br><span class="line">    // 参数2：是一个对象，这个对象中包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作</span><br><span class="line">    Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">        // 注意，在下面的函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数是一个原生JS对象</span><br><span class="line">        <span class="built_in">bind</span>: <span class="keyword">function</span>(el) &#123; //每当指令绑定到元素上的时候，会立即执行这个<span class="built_in">bind</span>函数，只执行一次</span><br><span class="line">            // 注意：在元素绑定了指令时，还没有插入到DOM中去，这时候调用focus方法是没有作用的，因为一个元素，只有插入到DOM之后，才能获取焦点</span><br><span class="line">            // el.focus()</span><br><span class="line">        &#125;,</span><br><span class="line">        inserted: <span class="keyword">function</span>(el) &#123; // inserted表示元素插入到DOM中的时候，会执行,触发一次</span><br><span class="line">            el.focus()</span><br><span class="line">        &#125;,</span><br><span class="line">        updated: <span class="keyword">function</span>(el) &#123; // 当VNode更新的是否，会执行updated，可触发多次</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 自定义设置颜色的指令</span><br><span class="line">    Vue.directive(<span class="string">'color'</span>, &#123;</span><br><span class="line">        <span class="built_in">bind</span>: <span class="keyword">function</span>(el, binding) &#123;</span><br><span class="line">            el.style.color = binding.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 自定义按键</span><br><span class="line">    Vue.config.keyCodes.f2 = 113;</span><br><span class="line"></span><br><span class="line">    // 演示私有过滤器</span><br><span class="line">    var vm2 = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app2'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            dt: new Date(),</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">open</span></span>() &#123;</span><br><span class="line">                alert(<span class="string">"弹出"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        filters: &#123;</span><br><span class="line">            dataFormat: <span class="keyword">function</span>(data, pattern) &#123;</span><br><span class="line">                // 获取当前日期</span><br><span class="line">                var dt = new Date(data);</span><br><span class="line"></span><br><span class="line">                // 获取年月日</span><br><span class="line">                var y = dt.getFullYear();</span><br><span class="line">                var m = dt.getMonth() + 1;</span><br><span class="line">                var d = dt.getDate();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pattern.toLowerCase() == <span class="string">'yyyy-mm-dd'</span>) &#123;</span><br><span class="line">                    <span class="built_in">return</span> `<span class="variable">$&#123;y&#125;</span>-<span class="variable">$&#123;m&#125;</span>-<span class="variable">$&#123;d&#125;</span>`;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    var hh = dt.getHours();</span><br><span class="line">                    var mm = dt.getMinutes();</span><br><span class="line">                    var ss = dt.getSeconds();</span><br><span class="line"></span><br><span class="line">                    // es6中提供的 yyyy-mm-dd hh:mm:ss 的简写形式</span><br><span class="line">                    <span class="built_in">return</span> `<span class="variable">$&#123;y&#125;</span>-<span class="variable">$&#123;m&#125;</span>-<span class="variable">$&#123;d&#125;</span> <span class="variable">$&#123;hh&#125;</span>:<span class="variable">$&#123;mm&#125;</span>:<span class="variable">$&#123;ss&#125;</span>` + <span class="string">'--&gt;私有'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 自定义私有指令（简写形式）</span><br><span class="line">        directives: &#123;</span><br><span class="line">            <span class="string">'fontsize'</span>: <span class="keyword">function</span>(el, binding) &#123;</span><br><span class="line">                el.style.fontSize = binding.value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 全局过滤器</span><br><span class="line">    Vue.filter(<span class="string">'dataFormat'</span>, <span class="keyword">function</span>(data, pattern) &#123;</span><br><span class="line">        // 获取当前日期</span><br><span class="line">        var dt = new Date(data);</span><br><span class="line"></span><br><span class="line">        // 获取年月日</span><br><span class="line">        var y = dt.getFullYear();</span><br><span class="line">        var m = dt.getMonth() + 1;</span><br><span class="line">        var d = dt.getDate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.toLowerCase() == <span class="string">'yyyy-mm-dd'</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> `<span class="variable">$&#123;y&#125;</span>-<span class="variable">$&#123;m&#125;</span>-<span class="variable">$&#123;d&#125;</span>`;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var hh = dt.getHours();</span><br><span class="line">            var mm = dt.getMinutes();</span><br><span class="line">            var ss = dt.getSeconds();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> `<span class="variable">$&#123;y&#125;</span>-<span class="variable">$&#123;m&#125;</span>-<span class="variable">$&#123;d&#125;</span> <span class="variable">$&#123;hh&#125;</span>:<span class="variable">$&#123;mm&#125;</span>:<span class="variable">$&#123;ss&#125;</span>`;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建Vue实例</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            id: <span class="string">''</span>,</span><br><span class="line">            username: <span class="string">''</span>,</span><br><span class="line">            list: [</span><br><span class="line">                &#123; id: 1, username: <span class="string">'望月'</span>, time: new Date() &#125;,</span><br><span class="line">                &#123; id: 2, username: <span class="string">'loonycoder'</span>, time: new Date() &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">                var user = &#123; id: this.id, username: this.username, time: new Date() &#125;;</span><br><span class="line">                this.list.push(user);</span><br><span class="line">            &#125;,</span><br><span class="line">            del(id) &#123;</span><br><span class="line">                // some()是操作数组的方法，作用是循环数组，并当<span class="built_in">return</span> <span class="literal">true</span>是就终止循环</span><br><span class="line">                // 其中的user理解为循环list元素的别名，i表示索引</span><br><span class="line">                this.list.some((user, i) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (user.id == id) &#123;</span><br><span class="line">                        this.list.splice(i, 1);</span><br><span class="line">                        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h4><ul>
<li>什么是声明周期：从Vue实例创建、运行、到销毁期间，伴随着发生的事件的过程成为生命周期。</li>
<li>生命周期钩子：就是声明周期事件的别名。</li>
<li>主要的声明周期函数分类</li>
</ul>
<blockquote>
<p>创建期间的声明周期函数：</p>
<ul>
<li>beforeCreate: 实例刚在内存中被创建，此时，还没有初始化好data和methods属性。</li>
<li>created: 实例已经在内存中创建好，此时data和methods已经创建好，但还没有编译模板。</li>
<li>beforeMount: 此时已经完成了模板的编译，但是还没有挂载到页面上。</li>
<li>mounted: 此时，已经将编译好的模板，挂载到了页面指定的容器中。<br>运行期间的声明周期函数:</li>
<li>beforeUpdate: 状态更新之前执行此函数，此时的data数据是最新的，但是此时还没有开始渲染DOM节点</li>
<li>updated: 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据都是最新的，界面已经被重新渲染好了。<br>销毁期间的生命周期函数</li>
<li>beforeDestory: 实例销毁之前调用，在这一步，实例仍然可以使用。</li>
<li>destroyed: Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器都会被移除，所所有的子实例也会被销毁。</li>
</ul>
</blockquote>
<h5 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h5><p>此函数执行的时候，data和methods中的数据还没有初始化。<br><img src="/images/vue7.png" alt="beforeCreate"><br><img src="/images/vue8.png" alt="beforeCreate"></p>
<h5 id="created"><a href="#created" class="headerlink" title="created"></a>created</h5><p>此函数中，data和methods都已经初始化好了，如果需要调用methods中的方法或操作data中的值最早就在created函数中操作。<br><img src="/images/vue9.png" alt="created"><br><img src="/images/vue10.png" alt="created"></p>
<h5 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h5><p>此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去。<br><img src="/images/vue11.png" alt="beforeMount"><br><img src="/images/vue12.png" alt="beforeMount"></p>
<h5 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h5><p>只要执行完了mounted，表示整个Vue实例已经初始化完毕了，此时组件已经进入了运行阶段。<br><img src="/images/vue13.png" alt="mounted"></p>
<h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><p><img src="/images/vue14.png" alt="图示"></p>
<hr>
<h3 id="vue-resource实现请求提交"><a href="#vue-resource实现请求提交" class="headerlink" title="vue-resource实现请求提交"></a>vue-resource实现请求提交</h3><p>作为一个后端开发者，我们需要的数据都应该是从数据库中取出来的，目前JSP页面越来越不常用，而更常用HTML页面，那么就体现出来类似Vue这种框架的好处了。<br>下面我们就了解一下怎样使用Vue实现发送AJAX的请求：</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>首先使用Vue实现发送AJAX请求，我们需要导入一个包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue-resource.js</span><br></pre></td></tr></table></figure>
<p><strong>Methods</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">this.<span class="variable">$http</span>.get(<span class="string">'url'</span>, [options]).<span class="keyword">then</span>(successCallback, errorCallback);</span><br><span class="line"></span><br><span class="line">this.<span class="variable">$http</span>.post(<span class="string">'url'</span>, [body], [options]).<span class="keyword">then</span>(successCallback, errorCallback);</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>this表示的是当前Vue实例对象，而vue-resource.js提供了$http属性用来调用其内置的请求方法，并且vue-resource.js是基于vue.js的。<br>options是指可选的请求参数，就是你发送请求想要传递的参数。</li>
<li>then可以实现发送完请求后，通过其获取请求成功响应的数据</li>
<li>then中包含两个参数successCallback和errorCallback，这两个都是对象，我们可以通过其进行对相应数据的操作。</li>
</ul>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">"getInfo"</span>&gt;点击我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">getInfo</span></span>()&#123;</span><br><span class="line">            this.<span class="variable">$http</span>.get(<span class="string">'url'</span>).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">                console.log(result.body);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong><br>当我们请求成功后，可以通过then来获取请求成功响应的数据，而可以通过.data或.body来获取响应data，而我们通常使用result.body来获取具体响应的参数。注意其中的result =&gt; {}是ES6中的写法。</p>
<h5 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h5><p><strong>注意：</strong> post请求常用于类似提交表单的功能，而对于提交表单，存在一个表单提交格式，默认是：application/x-wwww-form-urlencoded ；而通过Vue发起的post请求，默认没有表单格式，所以，有的服务器就处理不了。<br>那么我们可以通过post方法的第三个参数：{ emulateJSON: true }来设置提交内容类型为普通表单数据格式。</p>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">this.<span class="variable">$http</span>.post(<span class="string">'url'</span>, &#123;&#125;, &#123; emulateJSON: <span class="literal">true</span> &#125;).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">    console.log(result.body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其他请求方法与上面的雷同，具体方法请参考官方文档。</p>
<h4 id="请求接口根域名配置"><a href="#请求接口根域名配置" class="headerlink" title="请求接口根域名配置"></a>请求接口根域名配置</h4><p>由于我们个人的项目可能是部署到本地的Tomcat服务器上的，可能不会涉及请求接口的域名配置，那么我们先看一个案例：<br>发送post请求到服务器接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">        this.<span class="variable">$http</span>.post(<span class="string">'http://tycoding.cn/api/add'</span>, &#123;&#125;, &#123;emulateJSON: <span class="literal">true</span>&#125;).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，当我们发送请求的时候，URL路径需要写上域名地址<a href="http://www.loonycoder.com" target="_blank" rel="noopener">http://www.loonycoder.com</a>，然后才是请求路径/api/add，那么我们每次发送ajax请求都会需要写这个域名地址，就会显得比较麻烦，所以Vue-resource给我们提供了一种设置默认请求<strong>根域名</strong>的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue.http.options.root = <span class="string">'http://www.loonycoder.com'</span>;</span><br></pre></td></tr></table></figure>

<p>如上，就是一个全局的请求根域名配置。</p>
<p><strong>注意</strong><br>仅了解了上面的配置可能请求还会404，那么我们需要知道：</p>
<blockquote>
<p>如果我们通过了全局配置请求接口的根域名，那么每次发送HTTP请求时，请求的URL路径应该以相对域名开头，即前面不能带/： * 如果this.$http.post(‘/xxx’)请求URL带了/，那么Vue就不会启用上面的全局请求根域名配置，就会404.</p>
</blockquote>
<ul>
<li>如果前面不带/即：this.$http.post(‘xxx’)，那么就会启用上面的全局请求根域名配置进行URL的拼接。</li>
</ul>
<h5 id="全局配置表单提交格式选项"><a href="#全局配置表单提交格式选项" class="headerlink" title="全局配置表单提交格式选项"></a>全局配置表单提交格式选项</h5><p>上面讲到了如果使用post请求提交表单，那么你应该指定{emulateJSON: true}参数，那么每次进行post请求都指定又会显得很麻烦，那么vue-resource也给我们提供了一个全局配置的方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue.http.options.emulateJSON = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>这样我们就不需要再post请求中再配置第三个参数了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">        this.<span class="variable">$http</span>.post(<span class="string">'http://tycoding.cn/api/add'</span>, &#123;&#125;).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p>请求后台并即时渲染表格数据的案例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- html段 --&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"username"</span>&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"添加"</span> @click=<span class="string">"add"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;编号&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;用户名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">        &lt;tr v-for=<span class="string">"user in list"</span> :key=<span class="string">"user.id"</span>&gt;</span><br><span class="line">            &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&#123;&#123;user.username&#125;&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;a href=<span class="string">"#"</span> @click.pervent=<span class="string">"del(user.id)"</span>&gt;删除&lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- javascript段 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">// 设置全局根域名</span><br><span class="line">Vue.http.options.root = <span class="string">'http://tycoding.cn/'</span>;</span><br><span class="line"></span><br><span class="line">//设置全局表单提交格式</span><br><span class="line">Vue.http.options.emulateJSON = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">// 实例化Vue</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">''</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        username: <span class="string">''</span>,</span><br><span class="line">        list: []</span><br><span class="line">    &#125;,</span><br><span class="line">    created: &#123;</span><br><span class="line">        // 因为进入列表页面就需要在列表中显示出数据，那么就需要实现加载页面时自动加载findAll方法</span><br><span class="line">        // 而之前我们已经知道了，Vue的声明周期中，最早可以操作methods和data中的数据的阶段是：created生命周期函数阶段。</span><br><span class="line">        // 那么在这里调用findAll方法即可</span><br><span class="line">        this.findAll();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        // 查询所有列表数据</span><br><span class="line">        <span class="function"><span class="title">findAll</span></span>()&#123;</span><br><span class="line">            this.<span class="variable">$http</span>.get(<span class="string">'api/findAll'</span>).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">                this.list = result.body;</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 添加功能</span><br><span class="line">        <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">            this.<span class="variable">$http</span>.post(<span class="string">'api/add'</span>, &#123;username: this.username&#125;).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(result.body.status == 0)&#123;</span><br><span class="line">                    // 如果状态码为0就表示请求成功，这个状态码的值根据实际定</span><br><span class="line">                    // 请求成功，即添加了一条新的数据，那么需要重新刷新列表（不然新数据不能及时的更新到页面上）</span><br><span class="line">                    this.findAll()</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    alert(<span class="string">'添加失败'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        //删除功能</span><br><span class="line">        del(id)&#123;</span><br><span class="line">            this.<span class="variable">$http</span>.get(<span class="string">'api/del'</span> + id).<span class="keyword">then</span>(result =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(result.body.status == 0)&#123;</span><br><span class="line">                    //请求成功</span><br><span class="line">                    //刷新列表</span><br><span class="line">                    this.findAll();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    alert(<span class="string">'删除失败'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如上我们已经完成了常见的几个功能，后面我们将会介绍基于SpringMVC框架，实现与Vue整合并重写增删改查功能。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、首先我们需要配置根域名，且具体的AJAX请求URL不能添加’/‘；如果是基于本地的Tomcat服务器的项目，可能不需要配置根域名，具体视情况而定</li>
<li>2、实现查询所有列表数据功能，思路是：1、发送AJAX请求数据；2、将响应的数据赋值给data中的list集合this.list = result.body。注意响应数据是存放到body中的，具体请F12查看浏览器请求头信息和响应头信息。</li>
<li>3、上面获取了数据库中的列表数据，我们需要渲染到页面上，那么点击进入列表页面，列表页面中应该立即显示数据库中的所有数据，即findAll方法应该在初始化页面的同时自动去调用，并将数据赋值给list列表。而我们之前讲过操作methods和data中参数的最早时机是created声明周期函数阶段，那么我们直接在created函数中调用findAll方法即可实现自动加载。</li>
<li>4、添加功能的思路：<ul>
<li>1、在data中先声明需要添加的参数；</li>
<li>2、在表单中用v-model绑定需要添加的参数；</li>
<li>3、点击添加功能按钮，绑定@click事件，在methods中写对应的方法；</li>
<li>4、发送AJAX请求，并在URL中拼接需要添加的数据（通过this.username）获取绑定的参数；</li>
<li>5、如果是post请求，还需要设置表单提交格式{emulateJSON: true}，而我们使用了全局配置就不需要再在post参数中指定了；</li>
<li>6、如果添加成功，就调用findAll方法重新刷新列表</li>
</ul>
</li>
<li>5、删除功能需要在绑定@click事件的时候将id传入。并且我们需要使用@click&middot;pervent来阻止&lt;a&gt;标签的默认跳转。</li>
<li>6、上面仅是提供演示，具体操作由实际情况而定。</li>
</ul>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Vue</title>
    <url>/2019/11/30/Vue1/</url>
    <content><![CDATA[<h3 id="什么是Vue-js"><a href="#什么是Vue-js" class="headerlink" title="什么是Vue.js"></a>什么是Vue.js</h3><ul>
<li>Vue.js是目前很火的前端框架；与Angualr.js和React.js并称为前端三大主流框架。</li>
<li>Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，</li>
<li>在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。</li>
</ul>
<hr>
<h3 id="后端的MVC和前端的MVVM之间的区别"><a href="#后端的MVC和前端的MVVM之间的区别" class="headerlink" title="后端的MVC和前端的MVVM之间的区别"></a>后端的MVC和前端的MVVM之间的区别</h3><ul>
<li><p>MVC是后端的分层开发概念</p>
</li>
<li><p>MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）</p>
</li>
<li><p>Model： 页面需要展示的数据</p>
</li>
<li><p>View: 视图、HTML</p>
</li>
<li><p>VM: 数据（Model）和视图（View）之间的调度者</p>
</li>
</ul>
<p><strong>图解</strong><br><img src="/images/vue1.png" alt="vue图解"></p>
<hr>
<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;!-- 插值表达式 --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123;     // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'Hello Vue!'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>1、首先需要引入Vue.js<br>2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到<br>3、创建Vue实例，这个实例其实就是MVVM中的vm调度者<br>4、el: 表示当时Vue实例的控制区域；data: 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。<br>5、在指定Vue实例区域下，展示我们已经声明的元素msg，使用：即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）</p>
<hr>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h4><p>在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在vue.js还没有加载完毕时，视图层不会将识别为Vue中的插值表达式，而是作为字符串显示到页面上。<br>为了解决这个问题，Vue.js提供了v-cloak指令，可以解决插值表达式闪烁的问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;p v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong></p>
<p>解决插值表达式闪烁问题，除了v-cloak指令，Vue还提供了v-text指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;p v-text=<span class="string">"msg"</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>v-cloak与v-text的区别</strong><br>v-text默认会覆盖掉元素中原有的内容<br>v-cloak不会覆盖掉原有的内容<br><img src="/images/vue2.png" alt="vue2"></p>
<h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h4><p><strong>在上面，我们了解了v-text输出Vue元素，但是如果我们需要显示的数据是一段HTML代码，v-text和都将无能为力，<br>为此，Vue提供了专门渲染HTML数据的指令：v-html</strong></p>
<p><img src="/images/vue3.png" alt="vue3"></p>
<p>上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用）这样可以吗？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"msg"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。<br>为了解决上述问题，Vue提供了v-bind:指令来绑定一些HTML属性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> v-bind:value=<span class="string">"msg"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如上，被v-bind:绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外v-bind:还有一个简易写法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"msg"</span> /&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> v-bind:value=<span class="string">"msg"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> :value=<span class="string">"msg"</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'戳我'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>效果如图：<br><img src="/images/vue4.png" alt="vue4"></p>
<h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h4><p>Vue提供了事件绑定机制的指令：v-on:；用其我们可以用来绑定一些常见的触发事件：click、mouseover …</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> :value=<span class="string">"msg"</span> v-on:click=<span class="string">"show"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> :value=<span class="string">"msg"</span> v-on:mouseover=<span class="string">"show"</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'戳我'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            show: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                alert(<span class="string">"hello"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>其中methods是Vue内置的对象，用于存放一些自定义的方法函数</p>
<p><strong>拓展</strong></p>
<p>使用js内置的函数setInterval(定时器)，实现跑马灯效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"开始"</span> @click=<span class="string">"action"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"停止"</span> @click=<span class="string">"stop"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'嘻嘻，哈哈'</span>,</span><br><span class="line">            intervalId: null</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">action</span></span>()&#123;</span><br><span class="line">                <span class="keyword">if</span>(this.intervalId != null) <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">                // 定时器</span><br><span class="line">                this.intervalId = setInterval(() =&gt; &#123;</span><br><span class="line">                    // 截取首字符</span><br><span class="line">                    var start = this.msg.substring(0, 1);</span><br><span class="line">                    // 截取第一个字符后的所有字符</span><br><span class="line">                    var end = this.msg.substring(1);</span><br><span class="line">                    // 将后面的字符拼接到前面，实现循环的效果</span><br><span class="line">                    this.msg = end + start;</span><br><span class="line">                &#125;,400)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">                // 停止定时器</span><br><span class="line">                clearInterval(this.intervalId)</span><br><span class="line">                // 每次清除定时器后需要将intervalId重新设置为null</span><br><span class="line">                this.intervalId = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>1、v-on:也有简写形式：@，用法如上。<br>2、在视图层取VM中的数据我们可以使用或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：this.数据属性名（其中的this表示当前VM实例对象）。<br>3、methodName:function(){}在ES6中有一个简便的写法：methodName(){}。 4、setInterval()和clearInterval()是js中内置的函数，用法如上。<br>5、正常我们调用函数会写：name(function(){})，而ES6也提供了一个方式：methodName(() =&gt; {})，这种用法的好处就解决了this指向问题，因为如果元素定义在了函数内部，那么其中的this就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的=&gt;。</p>
<p>效果如图：<br><img src="/images/vue5.png" alt="vue5"></p>
<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><blockquote>
<p>.stop 阻止冒泡<br>.prevent 阻止默认事件<br>.capture 添加时间侦听器时使用时间捕获模式<br>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调<br>.once 事件只触发一次</p>
</blockquote>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div @click=<span class="string">"divClick"</span>&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"戳我"</span> @click.stop=<span class="string">"btnClick"</span>&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"戳我"</span> @click.prevent=<span class="string">"btnClick"</span>&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'嘻嘻，哈哈'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">divClick</span></span>() &#123;</span><br><span class="line">                console.log(<span class="string">"这是div的点击事件"</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">btnClick</span></span>() &#123;</span><br><span class="line">                console.log(<span class="string">"这是btn的点击事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><ul>
<li>唯一的双向绑定指令：v-model</li>
<li>单向绑定指令：v-bing</li>
</ul>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"msg"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            msg: <span class="string">'hello!'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Vue中的样式"><a href="#Vue中的样式" class="headerlink" title="Vue中的样式"></a>Vue中的样式</h3><h4 id="外联样式"><a href="#外联样式" class="headerlink" title="外联样式"></a>外联样式</h4><ul>
<li><p>数组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;h2 :class=<span class="string">"['italic','color']"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>
<p>其中的italic、color是自定义的类名，需在外部定义CSS样式</p>
</li>
<li><p>数组中嵌套对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;h2 :class=<span class="string">"['italic',&#123;'color': flag&#125;]"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>
<p>其中的flag是Vue绑定的变量，在data进行声明</p>
</li>
<li><p>直接使用对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;h2 :class=<span class="string">"&#123;italic:true, color:flag&#125;"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .italic &#123;</span><br><span class="line">        font-style: italic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .color &#123;</span><br><span class="line">        color: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;h2 :class=<span class="string">"['italic','color']"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line">    &lt;h2 :class=<span class="string">"['italic', &#123;'color':flag&#125;]"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line">    &lt;h2 :class=<span class="string">"&#123;italic:false, color:flag&#125;"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            flag: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><ul>
<li><p>将样式对象定义到data中，并在:style中引用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;h2 :style=<span class="string">"styleObj"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    styleObj: &#123; <span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'font-weight'</span>: <span class="string">'200px'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在:style中通过数组，引用多个data上的样式对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;h2 :style=<span class="string">"[styleObj, styleObj2]"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    styleObj: &#123; <span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'font-weight'</span>: <span class="string">'200px'</span>&#125;,</span><br><span class="line">    styleObj2: &#123; <span class="string">'font-style'</span>: <span class="string">'italic'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;h2 :style=<span class="string">"styleObj"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line">    &lt;h2 :style=<span class="string">"[styleObj, styleObj2]"</span>&gt;LoonyCoder&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            styleObj: &#123; <span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'font-weight'</span>: <span class="string">'200px'</span> &#125;,</span><br><span class="line">            styleObj2: &#123; <span class="string">'font-style'</span>: <span class="string">'italic'</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><p>Vue提供了遍历集合、数组的指令：v-for；用法: v-for=”别名 in 集合名”</p>
<h4 id="迭代数组"><a href="#迭代数组" class="headerlink" title="迭代数组"></a>迭代数组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;p v-for=<span class="string">"item, i in list"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    list: [1,2,3,4]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其中的i是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义</strong></p>
<h4 id="迭代对象数组"><a href="#迭代对象数组" class="headerlink" title="迭代对象数组"></a>迭代对象数组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;p v-for=<span class="string">"item in list2"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    list2: [</span><br><span class="line">            &#123; id:1, name: <span class="string">'嘻嘻'</span> &#125;,</span><br><span class="line">            &#123; id:2, name: <span class="string">'哈哈'</span> &#125;</span><br><span class="line">        ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代对象数组，通过 的方式，这个属性名就是对象数组中定义的元素属性名</strong></p>
<h4 id="迭代对象"><a href="#迭代对象" class="headerlink" title="迭代对象"></a>迭代对象</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;p v-for=<span class="string">"(val, key) in user"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">            id: 1,</span><br><span class="line">            name: <span class="string">'LoonyCoder'</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代对象，迭代得到的是对象的value值和key值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。</strong></p>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p v-for=<span class="string">"item, i in list"</span>&gt;索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p v-for=<span class="string">"item in list2"</span>&gt;id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p v-for=<span class="string">"(val, key) in user"</span>&gt;键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            list: [1,2,3,4], </span><br><span class="line">            list2: [</span><br><span class="line">                &#123; id:1, name: <span class="string">'嘻嘻'</span> &#125;,</span><br><span class="line">                &#123; id:2, name: <span class="string">'哈哈'</span> &#125;</span><br><span class="line">            ],</span><br><span class="line">            user: &#123;</span><br><span class="line">                id: 1,</span><br><span class="line">                name: <span class="string">'LoonyCoder'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在vue2.0+版本里，当使用v-for渲染数据，必须制定对应的key值（这里的key是一个属性，不是前面迭代的key值）。</p>
<p><strong>用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;p v-for=<span class="string">"item in user"</span> :key=<span class="string">"item.id"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>其中:key就说明了key属性必须是通过v-bind绑定的元素，而:key=””中指定的值必须是string/number类型的值，比如此处使用的是item.id中ID是number值，并且是唯一的。<br><strong>目的：</strong><br>避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。</p>
<h4 id="v-show和v-if"><a href="#v-show和v-if" class="headerlink" title="v-show和v-if"></a>v-show和v-if</h4><p>Vue提供了两个指令来实现元素显示状态的切换：v-if v-show<br><strong>区别</strong></p>
<ul>
<li>v-if的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。</li>
<li>v-show的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的display:none样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。</li>
</ul>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- Vue实例的控制区域 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"flag=!flag"</span> value=<span class="string">"toggle"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h3 v-if=<span class="string">"flag"</span>&gt;这是v-if控制的元素&lt;/h3&gt;</span><br><span class="line">    &lt;h3 v-show=<span class="string">"flag"</span>&gt;这是v-show控制的元素&lt;/h3&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- js部分 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"../lib/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>, // element的简写，表示我们当前new的这个Vue实例的区域</span><br><span class="line">        data: &#123; // data中存放的是el中需要的数据</span><br><span class="line">            flag: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下：<br><img src="/images/vue6.png" alt="vue6"></p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro会话管理</title>
    <url>/2019/11/19/Shiro/</url>
    <content><![CDATA[<h3 id="Shiro在线会话管理"><a href="#Shiro在线会话管理" class="headerlink" title="Shiro在线会话管理"></a>Shiro在线会话管理</h3><p>参考文章：</p>
<ul>
<li><a href="https://www.iteye.com/blog/jinnianshilongnian-2047643" target="_blank" rel="noopener">跟我学Shrio-在线会话</a></li>
<li><a href="https://mrbird.cc/Spring-Boot-Shiro%20session.html" target="_blank" rel="noopener">Spring Boot Shiro在线会话管理</a></li>
</ul>
<p>实现效果预览：<br><img src="/images/shiro1.png" alt="实现效果预览"></p>
<p>Shiro提供一个对象org.apache.shiro.session.mgt.eis.SessionDAO，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。</p>
<p><img src="/images/shiro2.png" alt="目录"></p>
<p>下面我们实现两个功能：</p>
<ul>
<li>获取在线会话列表</li>
<li>实现强制下线功能</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><h5 id="ShiroConfig"><a href="#ShiroConfig" class="headerlink" title="ShiroConfig"></a>ShiroConfig</h5><p>这里我使用的是Redis来储存Shiro的Session信息，修改SessionDAO配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RedisSessionDAO <span class="function"><span class="title">redisSessionDAO</span></span>() &#123;</span><br><span class="line">    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();</span><br><span class="line">    redisSessionDAO.setRedisManager(redisManager());</span><br><span class="line">    <span class="built_in">return</span> redisSessionDAO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ConfigurationProperties(prefix = <span class="string">"redis.shiro"</span>)</span><br><span class="line">public RedisManager <span class="function"><span class="title">redisManager</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new RedisManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还需要将SessionDAO注入到SessionManager中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SessionManager <span class="function"><span class="title">sessionManager</span></span>() &#123;</span><br><span class="line">    DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager();</span><br><span class="line">    defaultWebSessionManager.setCacheManager(cacheManager());</span><br><span class="line">    defaultWebSessionManager.setSessionDAO(sessionDAO());</span><br><span class="line">    <span class="built_in">return</span> sessionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将SessionManager注入到SecurityManager中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SecurityManager <span class="function"><span class="title">securityManager</span></span>() &#123;</span><br><span class="line">    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class="line">    securityManager.setRealm(realm());</span><br><span class="line"></span><br><span class="line">    //自定义sessionManager</span><br><span class="line">    securityManager.setSessionManager(sessionManager());</span><br><span class="line">    //自定义缓存实现</span><br><span class="line">    securityManager.setCacheManager(cacheManager());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> securityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取在线会话列表"><a href="#获取在线会话列表" class="headerlink" title="获取在线会话列表"></a>获取在线会话列表</h4><h5 id="OnlineUser-java"><a href="#OnlineUser-java" class="headerlink" title="OnlineUser.java"></a>OnlineUser.java</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class OnlineUser implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private String id; //sessionId</span><br><span class="line"></span><br><span class="line">    private String uid; //用户ID</span><br><span class="line"></span><br><span class="line">    private String username; //用户名</span><br><span class="line"></span><br><span class="line">    private String host; //主机地址</span><br><span class="line"></span><br><span class="line">    private String address; //地理位置</span><br><span class="line"></span><br><span class="line">    @DateTimeFormat(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    @JsonFormat(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    private Date startTime; //用户开始访问时间</span><br><span class="line"></span><br><span class="line">    @DateTimeFormat(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    @JsonFormat(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    private Date endTime; //用户最后访问时间</span><br><span class="line"></span><br><span class="line">    private Long timeout; //超时时间</span><br><span class="line"></span><br><span class="line">    private String status; //状态</span><br><span class="line"></span><br><span class="line">    public void setHost(String host) &#123;</span><br><span class="line">        this.host = host.equals(<span class="string">"0:0:0:0:0:0:0:1"</span>) ? <span class="string">"127.0.0.1"</span> : host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>编写获取在线会话列表的service层实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public List&lt;OnlineUser&gt; <span class="function"><span class="title">list</span></span>() &#123;</span><br><span class="line">    List&lt;OnlineUser&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    Collection&lt;Session&gt; sessions = sessionDAO.getActiveSessions(); //获取在线会话的集合</span><br><span class="line">    <span class="keyword">for</span> (Session session : sessions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (session != null) &#123;</span><br><span class="line">            OnlineUser onlineUser = new OnlineUser();</span><br><span class="line">            SimplePrincipalCollection principalCollection;</span><br><span class="line">            User user;</span><br><span class="line">            //判断此session是否还在登录状态</span><br><span class="line">            <span class="keyword">if</span> (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) &#123;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                //如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据</span><br><span class="line">                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);</span><br><span class="line">                user = (User) principalCollection.getPrimaryPrincipal();</span><br><span class="line">                onlineUser.setUid(user.getId().toString());</span><br><span class="line">                onlineUser.setUsername(user.getUsername());</span><br><span class="line">            &#125;</span><br><span class="line">            onlineUser.setId(session.getId().toString());</span><br><span class="line">            onlineUser.setHost(session.getHost());</span><br><span class="line">            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));</span><br><span class="line">            onlineUser.setStartTime(session.getStartTimestamp());</span><br><span class="line">            onlineUser.setEndTime(session.getLastAccessTime());</span><br><span class="line">            long timeout = session.getTimeout();</span><br><span class="line">            onlineUser.setTimeout(timeout);</span><br><span class="line">            onlineUser.setStatus(timeout == 0L ? <span class="string">"0"</span> : <span class="string">"1"</span>); //0在线 1下线</span><br><span class="line">            list.add(onlineUser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getActiveSessions()将获取到所有有效的Session集合，通过DefaultSubjectContext.PRINCIPALS_SESSION_KEY可以判断当前系统Subject中的session key和sessions列表中的session是否匹配，不匹配则session无效。<br>session.getHost()顾名思义就是获取Host主机地址即IP地址。<br>AddressUtil.getAddress(session.getHost())是通过IP地址查询其详细的地理位置，使用了ip2region开源库。</p>
<h5 id="根据IP查询地址位置"><a href="#根据IP查询地址位置" class="headerlink" title="根据IP查询地址位置"></a>根据IP查询地址位置</h5><p>开源地址：<a href="https://github.com/lionsoul2014/ip2region" target="_blank" rel="noopener">https://github.com/lionsoul2014/ip2region</a><br>引入ip2region的依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.lionsoul&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ip2region&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>拷贝ip2region.db文件（开源仓库中找）到项目的resources/config/下<br>参考官方实例代码写工具类AddressUtil.java<br>官方实例：<a href="https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java" target="_blank" rel="noopener">https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class AddressUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static String getAddress(String ip) &#123;</span><br><span class="line">        //db</span><br><span class="line">        String dbPath = AddressUtil.class.getResource(<span class="string">"/config/ip2region.db"</span>).getPath();</span><br><span class="line"></span><br><span class="line">        File file = new File(dbPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            throw new GlobalException(<span class="string">"缺少 ip2region.db库"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int algorithm = DbSearcher.BTREE_ALGORITHM; //B-tree</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            DbConfig config = new DbConfig();</span><br><span class="line">            DbSearcher searcher = new DbSearcher(config, file.getPath());</span><br><span class="line">            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            //define the method</span><br><span class="line">            Method method = null;</span><br><span class="line">            switch (algorithm) &#123;</span><br><span class="line">                <span class="keyword">case</span> DbSearcher.BTREE_ALGORITHM:</span><br><span class="line">                    method = searcher.getClass().getMethod(<span class="string">"btreeSearch"</span>, String.class);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DbSearcher.BINARY_ALGORITHM:</span><br><span class="line">                    method = searcher.getClass().getMethod(<span class="string">"binarySearch"</span>, String.class);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DbSearcher.MEMORY_ALGORITYM:</span><br><span class="line">                    method = searcher.getClass().getMethod(<span class="string">"memorySearch"</span>, String.class);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DataBlock dataBlock = null;</span><br><span class="line">            <span class="keyword">if</span> (!Util.isIpAddress(ip)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Error: Invalid ip address"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dataBlock = (DataBlock) method.invoke(searcher, ip);</span><br><span class="line">            reader.close();</span><br><span class="line">            searcher.close();</span><br><span class="line">            <span class="built_in">return</span> dataBlock.getRegion();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结"><a href="#结" class="headerlink" title="结"></a>结</h5><p>当前端请求/online/list接口时，将List<OnlineUser>结合数据返回给前端渲染即可。</p>
<h4 id="实现强制下线功能"><a href="#实现强制下线功能" class="headerlink" title="实现强制下线功能"></a>实现强制下线功能</h4><h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@GetMapping(<span class="string">"/forceLogout"</span>)</span><br><span class="line">public ResponseCode forceLogout(String id) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        sessionService.forceLogout(id);</span><br><span class="line">        <span class="built_in">return</span> ResponseCode.SUCCESS();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="built_in">return</span> ResponseCode.ERROR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个id是sessionID</p>
<h5 id="service实现"><a href="#service实现" class="headerlink" title="service实现"></a>service实现</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void forceLogout(String id) &#123;</span><br><span class="line">    Session session = sessionDAO.readSession(id);</span><br><span class="line">    session.setTimeout(0L);</span><br><span class="line">    session.stop();</span><br><span class="line">    sessionDAO.delete(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>权限框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（二）</title>
    <url>/2019/11/16/JavaBasic2/</url>
    <content><![CDATA[<p>###对象与类</p>
<h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>比如Student s = new Student()实例化一个对象，其实经历了如下几个过程：<br>将Student.class加载到内存中<br>在栈内存中给s开辟内存空间。<br>在堆内存给Student类申请一个内存空间。<br>给成员变量进行默认初始化，0 null false…<br>自定义给成员变量初始化赋值<br>初始化完毕，把堆内存地址赋值给栈内存的s变量</p>
<h4 id="Main方法剖析"><a href="#Main方法剖析" class="headerlink" title="Main方法剖析"></a>Main方法剖析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>public: 公共的，访问权限最大，因为main方法是被JVM调用的。</li>
<li>static：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。</li>
<li>void: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。</li>
<li>main: 常见的方法入口，很多语言的入口方法都是main方法。</li>
<li>String[] args: 字符串数组，是作为命令行参数调用的。</li>
</ul>
<h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><p><strong>static关键字特点：（可以修饰成员变量，也可修饰成员方法）</strong></p>
<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>被类中的所有对象共享</li>
<li>可直接通过类名调用</li>
</ul>
<p><strong>拓展</strong></p>
<p>静态方法中没有this关键字，因为this代表当前方法对象，但static优于对象存在，所以在对象还未创建完毕static修饰的方法就被调用，此时this代表的对象还未创建。</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String底层定义为public final class String，说明String是常量，一旦被创建就不能修改。可以查看如Integer LongString这些类的源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public final class Integer &#123;&#125;</span><br><span class="line">public final class Long &#123;&#125;</span><br><span class="line">public final class String &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这些<strong>基本类型</strong>，在初始化值、赋值时都是先从<strong>常量池</strong>中取数据，如果常量池中没有该数据，就new对象初始化为新数据。<br>比如常见的一个面试题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"ab"</span>;</span><br><span class="line">s = <span class="string">"abc"</span>;</span><br><span class="line">String ss = <span class="string">"ab"</span>;</span><br><span class="line">ss = new String(<span class="string">"ab"</span>);</span><br></pre></td></tr></table></figure>

<p>这个s和ss各自创建了几个对象？答案：s创建两个对象；ss创建一个对象。因为s的常量池中有值ab，而重新赋值s = “abc”这个abc在s的常量池中不存在，所以new String()创建了一个新对象。ss同理分析。可以通过如下方式验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">String ss = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(ss.hashCode());</span><br><span class="line">ss = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(ss.hashCode());</span><br></pre></td></tr></table></figure>
<p><a href="/images/String1.png">stack</a></p>
<h5 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h5><p>String是不可变的字符串，StringBuffer是线程安全的可变字符串，用StringBuffer做字符串的拼接可以避免资源的浪费，因为String每次拼接新的字符串都是创建一个新的String对象。</p>
<p><strong>String转换为StringBuffer</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//方式一</span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">StringBuffer sb = new StringBuffer(s);</span><br><span class="line">//方式二</span><br><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">sb.append(s);</span><br></pre></td></tr></table></figure>

<p><strong>StringBuffer转换成String</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//方式一</span><br><span class="line">StringBuffer sb = new StringBuffer(<span class="string">"hello"</span>);</span><br><span class="line">String s = new String(sb);</span><br><span class="line">//方式二</span><br><span class="line">String s = sb.toString();</span><br></pre></td></tr></table></figure>

<h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><blockquote>
<p>String, StringBuffer, StringBuilder 的区别？</p>
</blockquote>
<ul>
<li>String的内容不可变，StringBuffer和StringBuilder的内容都可变。</li>
<li>StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。</li>
</ul>
<blockquote>
<p>StringBuffer和数组的区别？</p>
</blockquote>
<ul>
<li>二者都是一个容器，装其他数据</li>
<li>但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。</li>
</ul>
<blockquote>
<p>String和StringBuffer作为参数传递</p>
</blockquote>
<ul>
<li>String可理解为特殊的引用类型，和基本类型一样，参数传递不会改变原数据内容。</li>
<li>StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class StringBufferDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = <span class="string">"hello"</span>;</span><br><span class="line">        String s2 = <span class="string">"world"</span>;</span><br><span class="line">        System.out.println(s1 + <span class="string">"---"</span> + s2);// hello---world</span><br><span class="line">        change(s1, s2);</span><br><span class="line">        System.out.println(s1 + <span class="string">"---"</span> + s2);// hello---world</span><br><span class="line"></span><br><span class="line">        StringBuffer sb1 = new StringBuffer(<span class="string">"hello"</span>);</span><br><span class="line">        StringBuffer sb2 = new StringBuffer(<span class="string">"world"</span>);</span><br><span class="line">        System.out.println(sb1 + <span class="string">"---"</span> + sb2);// hello---world</span><br><span class="line">        change(sb1, sb2);</span><br><span class="line">        System.out.println(sb1 + <span class="string">"---"</span> + sb2);// hello---worldworld</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(StringBuffer sb1, StringBuffer sb2) &#123;</span><br><span class="line">        sb1 = sb2;</span><br><span class="line">        sb2.append(sb1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(String s1, String s2) &#123;</span><br><span class="line">        s1 = s2;</span><br><span class="line">        s2 = s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java中的参数传递：</p>
<ul>
<li>基本类型：形式参数的改变对实际参数没有影响。</li>
<li>引用类型：形式参数的改变直接影响实际参数。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Demo01_Object &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = 20;</span><br><span class="line">        change(a, b);</span><br><span class="line">        System.out.println(<span class="string">"main: a:"</span> + a + <span class="string">", b:"</span> + b); //10, 20</span><br><span class="line">        int[] arr = &#123;1, 2, 3&#125;;</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(<span class="string">"main: "</span> + arr[0]); //2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void change(int a, int b) &#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = a + b;</span><br><span class="line">        System.out.println(<span class="string">"change: a:"</span> + a + <span class="string">", b:"</span> + b); //20, 40</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void change(int[] arr) &#123;</span><br><span class="line">        arr[0] = arr[1];</span><br><span class="line">        System.out.println(<span class="string">"change"</span> + arr[0]); //2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引入概念</strong>：<br>在Java中<strong>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。所有的Java对象都储存在堆内存中</strong>。例如：Date t = new Date()其中的t就是一个对象变量，new Date()是在堆内存中开辟了一个空间，而t指向new Date()的堆内存地址。<br>因此，在上述代码中a b都是基本类型，而int[]是一个引用类型，那<strong>基本类型形式参数改变对实际参数没有影响；对象类型形式参数改变直接影响实际参数。</strong></p>
<p><a href="/images/stack.png">stack</a></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>Java程序语言总是采用按值调用</strong>，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。</li>
<li>一个方法可以改变一个对象的引用状态</li>
<li>一个方法不能让对象参数引用一个新对象</li>
</ul>
<p>比如：下列是无意义的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void swap(Employee x, Employee y) &#123;</span><br><span class="line">    Employee temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用swap(e1, e2)时并不会改变e1和e2的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</p>
<ul>
<li><strong>基本类型</strong>（包括Integer String Long）传递的参数是参数<strong>值</strong>的拷贝</li>
</ul>
<p>特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如IntgerCache LongCache，如果常量池中没有就重新new对象，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s = <span class="string">"123"</span>;</span><br><span class="line">    System.out.println(<span class="string">"main: "</span> + s.hashCode()); //48690</span><br><span class="line">    change(s);</span><br><span class="line">    change2(s);</span><br><span class="line">&#125;</span><br><span class="line">private static void change(String s) &#123;</span><br><span class="line">    s = <span class="string">"123"</span>;</span><br><span class="line">    System.out.println(<span class="string">"change: "</span> + s.hashCode()); //48690</span><br><span class="line">&#125;</span><br><span class="line">private static change2(String s) &#123;</span><br><span class="line">    s = <span class="string">"456"</span>;</span><br><span class="line">    System.out.println(<span class="string">"change2: "</span> + s.hashCode()); //51669</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>引用类型</strong>传递的参数是原对象在<strong>堆内存的地址</strong>的拷贝</li>
</ul>
<p>对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。</p>
<h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><p>成员变量和局部变量的区别：</p>
<ul>
<li>在类中的位置不同：<ul>
<li>成员变量：在类中方法外</li>
<li>局部变量：在方法定义中或方法声明上</li>
</ul>
</li>
<li>在内存中的位置不同：<ul>
<li>成员变量：在堆内存</li>
<li>局部变量：在栈内存</li>
</ul>
</li>
<li>声明周期不同：<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失。</li>
<li>局部变量：随着方法的调用而存在，随着方法调用完毕而消失</li>
</ul>
</li>
<li>初始化值不同：<ul>
<li>成员变量：有默认初始化值</li>
<li>局部变量：没有默认初始化值，必须定义、赋值后才能使用</li>
</ul>
</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>在Java中，当需要调用构造方法时，<strong>若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义</strong>。举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Demo2_Construct &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo2Student student = new Demo2Student();</span><br><span class="line">        student.show();</span><br><span class="line">        // Demo2School school = new Demo2School(); //error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo2Student &#123;</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"this student show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo2School &#123;</span><br><span class="line">    private int size = 1000;</span><br><span class="line">    public Demo2School(int size) &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>final可以修改类、方法、变量。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>final可以修饰类，该类不能被继承。</li>
<li>final可以修饰方法，该方法不能被重写。</li>
<li>final可以修饰变量，该变量不能被重新赋值。</li>
</ul>
<p><strong>面试题</strong>：final修饰局部变量的问题</p>
<ul>
<li>基本类型：被final修饰的基本类型的值不能被改变</li>
<li>引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。</li>
</ul>
<p><strong>初始化时机</strong><br>被final修饰的变量必须在构造方法完毕前被初始化，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    final int WIDTH = 12;</span><br><span class="line">    //final int HEIGHT; //error</span><br><span class="line">    final int AREA;</span><br><span class="line">    &#123;</span><br><span class="line">        AREA = 120;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>1、Java支持单继承不支持多继承，但Java支持多层继承<br>2、子类只能继承父类非私有成员（成员变量、成员方法）<br>3、子类不能继承父类的构造方法，但可以通过super关键字访问父类的构造方法。</p>
<h5 id="子类和父类的关系"><a href="#子类和父类的关系" class="headerlink" title="子类和父类的关系"></a>子类和父类的关系</h5><p><strong>子类中的所有构造方法都默认访问父类的无参构造方法</strong>。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是super()。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Demo04_Extends &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo04Son son = new Demo04Son();</span><br><span class="line">        son.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo04Son extends Demo04Parent&#123;</span><br><span class="line">    private int num = 10;</span><br><span class="line">    public <span class="function"><span class="title">Demo04Son</span></span>() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        int num = 100;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(this.num);</span><br><span class="line">        System.out.println(super.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo04Parent &#123;</span><br><span class="line">    public int num = 1;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">Demo04Parent</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"这是父类的无参构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="this-super"><a href="#this-super" class="headerlink" title="this-super"></a>this-super</h5><p>this和super关键字的区别和使用场景？<br>区别：</p>
<ul>
<li>this: 代表当前类的对象引用</li>
<li>super: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）<br>场景：</li>
<li>this.成员变量/方法</li>
<li>super.成员变量/方法</li>
<li>this(…) super(…)</li>
</ul>
<h5 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Demo04_Extends2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo04Zi zi = new Demo04Zi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Demo04Fu &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(<span class="string">"Fu 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Fu 构造代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="function"><span class="title">Demo04Fu</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Fu 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Demo04Zi extends Demo04Fu&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(<span class="string">"Zi 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Zi 构造代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="function"><span class="title">Demo04Zi</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Zi 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fu 静态代码块</span><br><span class="line">Zi 静态代码块</span><br><span class="line">Fu 构造代码块</span><br><span class="line">Fu 构造方法</span><br><span class="line">Zi 构造代码块</span><br><span class="line">Zi 构造方法</span><br></pre></td></tr></table></figure>

<h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p><strong>调用对象方法的执行过程：</strong><br><a href="/images/DomaticBind.png">DomaticBind</a><br>1.编译器首先查看对象的声明类型和方法名。如调用change(a)方法，由于存在多个change()方法，JVM会先列举该类以及其超类中访问属性为public且名为change的方法。<br>2.接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个方法表<strong>（method table）</strong>，JVM会直接从这个方法表中寻找名为change的方法中存在一个与提供的参数类型匹配的方法，这个过程称为<strong>重载解析</strong>。<br>3.如果是private、static、final方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为<strong>静态绑定</strong>。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现<strong>动态绑定</strong>。<br>4.当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。</p>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接(int) double这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。</p>
<ul>
<li><strong>向上转型</strong>：将一个子类的引用赋值给一个超类变量。</li>
<li><strong>向下转型</strong>：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>只能在继承层次内进行类型转换。</li>
<li>在将超类转换成子类之前，应该使用instanceof进行检查。</li>
</ul>
<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。</p>
<ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类可以访问内部类的成员，必须创建对象</li>
<li>直接访问内部类的成员：Outer.Inner in = new Outer().new Inner()</li>
</ul>
<p><strong>局部内部类</strong><br>局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。</p>
<blockquote>
<p>局部内部类访问局部变量注意事项?<br>​局部内部类访问局部变量必须用final修饰。因为<strong>局部内部类的声明周期比局部变量长</strong>，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class InnerClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer();</span><br><span class="line">        outer.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        int num2 = 10;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            private void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">                System.out.println(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = new Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时调用不会报错，但并没有加final修饰。这个类编译后会生成InnerClass.class和Outer.class两个文件，我们来看下Outer.class:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    <span class="function"><span class="title">Outer</span></span>() &#123;&#125;</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        final int num2 = 10;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            <span class="function"><span class="title">Inner</span></span>() &#123;&#125;</span><br><span class="line">            private void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">                System.out.println(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = new Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的num2被自动加上了final修饰（这是因为JDK1.8的原因），所以如果你再添上num2 = 1000就会报错。</p>
<blockquote>
<p>解决办法<br>上面说过了应该将num2用final修饰。其原因就是Inner类的生命周期要比num2的声明周期长，当show()方法调用完毕后num2就已经消失了，但此时Inner类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用final修饰，这个变量成为常量，在初始化内部类的时候，final num2就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（一）</title>
    <url>/2019/11/14/JavaBasic1/</url>
    <content><![CDATA[<p>记录一些Java基础的知识点，为了自己查阅资料的时候方便一些。</p>
<hr>
<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="JDK和JRE的区别？"><a href="#JDK和JRE的区别？" class="headerlink" title="JDK和JRE的区别？"></a>JDK和JRE的区别？</h4><p>1、jre即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库<br>2、jdk是Java开发工具包，例如：tools.jar</p>
<hr>
<h4 id="和-equals的区别"><a href="#和-equals的区别" class="headerlink" title="== 和 equals的区别"></a>== 和 equals的区别</h4><p>1、==是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址<br>2、equals是超类Object就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。equals方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。<br>Object类equals方法源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    <span class="built_in">return</span> (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，举个栗子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class EqualsTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User a = new User();</span><br><span class="line">        User b = new User();</span><br><span class="line">        System.out.println(a == b); //<span class="literal">false</span></span><br><span class="line">        System.out.println(a.equals(b)); //<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (this == o) <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o instanceof User)) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="built_in">return</span> age == user.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int <span class="function"><span class="title">hashCode</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> Objects.hash(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="两个对象的hashCode-相同，则equals-一定为true？"><a href="#两个对象的hashCode-相同，则equals-一定为true？" class="headerlink" title="两个对象的hashCode()相同，则equals()一定为true？"></a>两个对象的hashCode()相同，则equals()一定为true？</h4><p><strong>如果两个对象相等(equals()为true)，那么他们的hashCode()一定相同</strong><br><strong>如果两个对象的hashCode()相同，他们的equals()方法不一定相同</strong></p>
<p>JVM虚拟机通过hashCode()方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过hashCode()获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用equals()与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用equals()方法比较的次数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class EqualsTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User a = new User();</span><br><span class="line">        User b = new User();</span><br><span class="line">        System.out.println(a == b); //<span class="literal">false</span></span><br><span class="line">        System.out.println(a.equals(b)); //<span class="literal">false</span></span><br><span class="line">        System.out.println(a.hashCode() == b.hashCode()); //<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h4><p>可修饰类、类属性、类方法。<br>1、被final修饰的类不能被继承<br>2、final修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class FinalTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final User USER = new User();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User u2 = new User();</span><br><span class="line">//        user = u2; // ERROR</span><br><span class="line">        USER.age = 23;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    int age = 12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。</p>
<hr>
<h4 id="String属于基本数据类型吗？"><a href="#String属于基本数据类型吗？" class="headerlink" title="String属于基本数据类型吗？"></a>String属于基本数据类型吗？</h4><p><strong>不，String属于特殊的引用类型</strong></p>
<p>Java中基本数据类型有：int、short、long、char、boolean、float、double、byte</p>
<p>1、String是特殊的引用类型并且是final的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。<br>2、String s = “a”; s += “b”;，这段代码执行前后，字符串常量池中将出现a和ab两个字符串常量，而原本s变量的引用指向了常量池中ab。<br>3、String s = new String(“ab”)，这段代码一共创建了几个对象？一个或两个。如果字符串常量池中有了ab这个字符串(比如在此之前已经使用了String str = “ab”)，那么新的s对象引用其实仅仅是指向了字符串常量中的ab，并没有创建新的字符串对象。但是，每次调用new都会在堆内存开辟空间，创建一个String对象，这是肯定的。</p>
<p>栗子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = <span class="string">"abc"</span>;</span><br><span class="line">        String b = <span class="string">"abc"</span>;</span><br><span class="line">        String c = new String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(a == b); //<span class="literal">true</span></span><br><span class="line">        System.out.println(a.equals(b)); //<span class="literal">true</span></span><br><span class="line">        System.out.println(a.equals(c)); //<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>String和StringBuffer和StringBuilder的区别</strong><br>1、String是不可变字符串，StringBuffer和StringBuilder是可变字符串。如果经常改变字符串的原始数据，最好使用StringBuffer代替。<br>2、String默认重写了equals方法和hashCode()方法；而StringBuffer没有重写equals方法，使用new StringBuffer(“”)会直接在堆内存中开辟空间储存对象。因此将StringBuffer对象储存仅Java集合中可能会出现问题。<br>3、StringBuffer是线程安全的，效率低；StringBuilder是线程不安全的，效率高。</p>
<hr>
<h4 id="static关键字？是否可覆盖？"><a href="#static关键字？是否可覆盖？" class="headerlink" title="static关键字？是否可覆盖？"></a>static关键字？是否可覆盖？</h4><p>static关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。</p>
<p>static标记的方法只能访问static变量或方法<br>非static标记的方法可以访问static或非static标记的变量或方法</p>
<hr>
<h4 id="自动拆、装箱"><a href="#自动拆、装箱" class="headerlink" title="自动拆、装箱"></a>自动拆、装箱</h4><p>因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。<br>具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Char</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<p>栗子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer i1 = 100;</span><br><span class="line">    Integer i2 = 100;</span><br><span class="line">    Integer i3 = 200;</span><br><span class="line">    Integer i4 = 200;</span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>Java中实现基本数据类型和引用类型之间的拆装箱一般都是用过valueOf()方法实现的。例如我们看下Integer类的valueOf()方法源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="built_in">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="built_in">return</span> new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：当声明一个新的整数型变量，编译时通过Integer类的valueOf()进行拆装箱计算，这个方法会首先比较这个整数值是否在IntegerCache的范围内，如果在就返回IntegerCache类中的数值；如果不在就直接new Integer。那么我们看下IntegerCache类源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, 127);</span><br><span class="line">                // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        <span class="keyword">for</span>(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">IntegerCache</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在[-128, 127]之间，就直接返回IntegerCache中储存的常量值，否则就直接new一个新的Integer来保存这个常量值。所以上面才会出现false的结果。<br>同理：其他的数据类型例如：long、short等都具有对应的LongCache、ShortCache等类。</p>
<hr>
<h4 id="Overriding和Overloaded"><a href="#Overriding和Overloaded" class="headerlink" title="Overriding和Overloaded"></a>Overriding和Overloaded</h4><p>方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。<br>Overriding: 子类中定义了和父类中名称、参数列表相同的方法<br>Overloaded: 方法名相同，参数列表不同</p>
<hr>
<h4 id="Java支持多继承吗？"><a href="#Java支持多继承吗？" class="headerlink" title="Java支持多继承吗？"></a>Java支持多继承吗？</h4><p>不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过多层继承实现。<br>类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。<br>从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。</p>
<hr>
<h4 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h4><ul>
<li>接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )</li>
<li>类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )</li>
<li>抽象类可以是不提供接口方法实现的情况下实现接口</li>
<li>接口中声明的变量默认都是final的；但抽象类可以包含非final的变量</li>
<li>接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public</li>
<li>接口是绝对抽象的，不可以被实例化；</li>
</ul>
<hr>
<h4 id="引用传递和值传递"><a href="#引用传递和值传递" class="headerlink" title="引用传递和值传递"></a>引用传递和值传递</h4><p><strong>Java中采用值传递的方式</strong><br>栗子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class TransferTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 1;</span><br><span class="line">        Integer b = 2;</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        int[] arr = &#123;1, 2&#125;;</span><br><span class="line">        swap(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr) &#123;</span><br><span class="line">        arr[0] = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int a, Integer b) &#123;</span><br><span class="line">        a = 10;</span><br><span class="line">        b = 20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。<br>所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。</p>
<hr>
<h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><p><img src="http://cdn.tycoding.cn/20180127210359151.png" alt="IO流"></p>
<p><strong>1、Java中有几种类型的流？</strong><br>字符流和字节流。字节流继承InputStream和OutputStream；字符流继承自InputStreamReader和OutputStreamWriter。</p>
<p><strong>2、谈谈Java IO中的方法阻塞</strong><br>Java中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。</p>
<p><strong>3、字符流和字节流的区别？</strong><br>数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。<br>而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。<br>字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。</p>
<p><strong>4、NIO</strong><br>传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read()等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept()时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。<br>而对于NIO，它是非阻塞式，核心类：</p>
<ul>
<li>Buffer： 为所有的原始类型提供Buffer缓冲支持</li>
<li>Charset： 字符集编码解码解决方案</li>
<li>Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接。</li>
</ul>
<hr>
<h4 id="说说List、Set、Map三者的区别"><a href="#说说List、Set、Map三者的区别" class="headerlink" title="说说List、Set、Map三者的区别"></a>说说List、Set、Map三者的区别</h4><ul>
<li>List: List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素</li>
<li>Set: 不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素</li>
<li>Map: 使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。</li>
</ul>
<hr>
<h4 id="Array和ArrayList有什么区别？"><a href="#Array和ArrayList有什么区别？" class="headerlink" title="Array和ArrayList有什么区别？"></a>Array和ArrayList有什么区别？</h4><ul>
<li>Array可以包含基本类型和对象类型；ArrayList只能包含对象类型</li>
<li>Array大小是固定的；ArrayList大小是动态变化的</li>
<li>ArrayList提供了诸如addAll()、removeAll()、iterator()方法等</li>
<li>对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。</li>
</ul>
<hr>
<h4 id="ArrayList和LinkedList的区别？"><a href="#ArrayList和LinkedList的区别？" class="headerlink" title="ArrayList和LinkedList的区别？"></a>ArrayList和LinkedList的区别？</h4><p>1、<strong>是否保证线程安全</strong>： ArrayList和LinkedList都是不同步的，也就是不保证线程安全<br>2、<strong>底层数据结构</strong>： ArrayList底层使用的是Object数组；LinkedList底层使用的是 双向链表 结构<br>3、<strong>插入和删除是否受元素位置影响？</strong> ArrayList采用数组储存，所以插入和删除元素都受元素位置的影响；LinkedList 采用链表储存，所以插入、删除元素都不受元素位置影响。<br>4、<strong>是否支持快速随机访问？</strong> LinkedList因为使用链表储存，无法通过元素索引快速访问；而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。<br>5、<strong>内存空间占用</strong>： ArrayList的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而LinkedList的空间花费体现在他的每一个元素都需要消耗比ArrayList更多的空间（因为要储存直接后继和直接前驱以及数据）。</p>
<hr>
<p><strong>什么是迭代器</strong><br><em>Iterator</em>接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法<em>iterator()</em>。迭代器在迭代的过程中可以删除底层集合的元素。</p>
<p><strong>Iterator和ListIterator的区别？</strong></p>
<ul>
<li>Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List</li>
<li>Iterator对集合只能向前遍历（next()）；而*ListIterator可以向前遍历（next()），也可以向后遍历（previous()）</li>
<li>ListIterator实现了Iterator接口</li>
</ul>
<p><strong>RandomAccess接口</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//ArrayList</span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">//RandomAccess</span><br><span class="line">public interface RandomAccess &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//LinkedList</span><br><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>源码中ArrayList类实现了RandomAccess接口，LinkedList类中却没有实现这个接口，但是RandomAccess接口中却什么也没有定义。可以看RandomAccess接口上的注释：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that</span><br><span class="line"> * they support fast (generally constant time) random access.  The primary</span><br><span class="line"> * purpose of this interface is to allow generic algorithms to alter their</span><br><span class="line"> * behavior to provide good performance when applied to either random or</span><br><span class="line"> * sequential access lists.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看Collections类中的binarySearch方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt;</span><br><span class="line">int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="built_in">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt;</span><br><span class="line">int indexedBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = list.size()-1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">        Comparable&lt;? super T&gt; midVal = list.get(mid);</span><br><span class="line">        int cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; 0)</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; 0)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> mid; // key found</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -(low + 1);  // key not found</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt;</span><br><span class="line">int iteratorBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</span><br><span class="line">&#123;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = list.size()-1;</span><br><span class="line">    ListIterator&lt;? extends Comparable&lt;? super T&gt;&gt; i = list.listIterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        int mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line">        Comparable&lt;? super T&gt; midVal = get(i, mid);</span><br><span class="line">        int cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; 0)</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; 0)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> mid; // key found</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -(low + 1);  // key not found</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binarySearch()方法是从List中查找指定元素，其中首先判断传入的List时候实现了RandomAccess接口，如果实现了就调用indexedBinarySearch()方法，否则就调用iteratorBinarySearch()方法。再看这两个方法的源码：<br>如果传入的List实现了RandomAccess接口，采用普通for循环遍历<br>若传入的List未实现RandomAccess接口，采用iterator遍历</p>
<p><strong>链表</strong></p>
<p><strong>链表（Linked List）</strong>由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针</p>
<blockquote>
<p>单向链表<br>单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。</p>
</blockquote>
<ul>
<li><p>单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找<br><img src="http://cdn.tycoding.cn/1120165-20171207161602113-1451349858.png" alt="单向链表"></p>
</li>
<li><p>单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可<br><img src="http://cdn.tycoding.cn/1120165-20171207162758425-142549066.png" alt="单向链表"></p>
</li>
<li><p>删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可<br><img src="http://cdn.tycoding.cn/1120165-20171207162815925-341262498.png" alt="单向链表"></p>
</li>
</ul>
<blockquote>
<p>双向链表<br><strong>双向链表</strong> 包含两个指针，prev指向前一个节点，next指向后一个节点。<br><img src="http://cdn.tycoding.cn/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p>
</blockquote>
<blockquote>
<p>双向循环链表<br><strong>双向循环链表</strong> 最后一个节点的<em>next</em>指向<em>head</em>，而<em>head</em>的<em>prev</em>指向最后一个节点，形成一个环。<br><img src="http://cdn.tycoding.cn/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表"></p>
</blockquote>
<hr>
<h4 id="ArrayList和Vector和LinkedList的区别？"><a href="#ArrayList和Vector和LinkedList的区别？" class="headerlink" title="ArrayList和Vector和LinkedList的区别？"></a>ArrayList和Vector和LinkedList的区别？</h4><ul>
<li><strong>ArrayList</strong>: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高</li>
<li><strong>Vector</strong>: 底层数据结构是数组，查询快，增删慢。线程安全，效率低</li>
<li><strong>LinkedList</strong>: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高</li>
</ul>
<hr>
<h4 id="谈谈ArrayList的扩容机制"><a href="#谈谈ArrayList的扩容机制" class="headerlink" title="谈谈ArrayList的扩容机制"></a>谈谈ArrayList的扩容机制</h4><p>Java中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，ArrayList的出现就解决了这一问题。<br>ArrayList的扩容机制表现在add()方法上，先看add()方法的源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取最小容量</span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="built_in">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否需要扩容</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当向ArrayList对象中添加新元素时，首先会调用ensureCapacityInternal(size)方法，size为最小扩容量；ensureCapacityInternal()方法会首先调用calculateCapacity来确定需要的最小容量；最后调用ensureExplicitCapacity()方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用grow()方法扩容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // 获取ArrayList中elementDaata数组的长度</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    // 扩容至原来的1.5倍</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    // 判断新的数组容量够不够</span><br><span class="line">    // 够了就直接使用这个长度创建新数组</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        // 不够就将数组的长度设置为需要的长度</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    // 检查此时的最大值是否溢出</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // 调用Arrays.copyOf()将elementData数组数据拷贝到新数组</span><br><span class="line">    // 并将elementData指向新数组newCapacity的内存地址</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>： ArrayList扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。</p>
<hr>
<h4 id="HashMap和HashTable的区别？"><a href="#HashMap和HashTable的区别？" class="headerlink" title="HashMap和HashTable的区别？"></a>HashMap和HashTable的区别？</h4><p>1、HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度<br>2、线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰。<br>3、效率: HashMap线程不安全效率高，HashTable线程安全效率低。<br>3、对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null<br>5、底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制。</p>
<hr>
<h4 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别?"></a>HashMap和HashSet区别?</h4><p><strong>HashSet底层采用HashMap实现</strong><br>HashMap|HashSet<br>:–|:–<br>实现了Map接口|实现了Set接口<br>储存键值堆|仅储存对象<br>调用put()向Map中添加元素|调用add()向Set中添加元素<br>HashMap使用Key计算HashCode|HashSet使用成员对象来计算hashCode值，对于两个对象来说，hashCode可能相同，所以用equals判断对象的相等性</p>
<hr>
<h4 id="HashSet如何检查重复？"><a href="#HashSet如何检查重复？" class="headerlink" title="HashSet如何检查重复？"></a>HashSet如何检查重复？</h4><p>在前面讲hashCode和equals时就提到了，HashSet集合同样适用。向HashSet中存入一个元素，HashSet首先会根据对象的hashCode值判断当期集合中此hashCode对应的位置有没有值，如果没有就直接添加，如果有就再调用equals方法比较两个对象是否相同，相同就不再储存（保证了Set集合不重复的特性），否则就散列到其他位置储存。</p>
<hr>
<h4 id="HashMap底层实现？"><a href="#HashMap底层实现？" class="headerlink" title="HashMap底层实现？"></a>HashMap底层实现？</h4><p>Map在Java中的实现由很多，HashMap便是其中之一，随着JDK版本的更新，HashMap的实现也在不断更新：</p>
<ul>
<li>&lt;=JDK1.7: Table数组 + Entry链表</li>
<li><blockquote>
<p>=JDK1.8: Table数组 + Entry链表/红黑树</p>
</blockquote>
</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p><strong>Hash（哈希、散列）</strong>，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。<br>Hash函数的一种实现：<br>直接取余法： f(x) = x mod max<br>位运算法： f(x) = x &amp; max<br>HashMap采用 位运算法，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">7 &amp; 33 = 1</span><br><span class="line">    </span><br><span class="line">    000111</span><br><span class="line">  &amp; 100001</span><br><span class="line">  --------</span><br><span class="line">    000001 = 1</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h4><p>假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到HashMap集合中，若将多个K-V数据存入put，HashMap根据元素key计算到对应的hashCode值，如果计算得到多个不同的key对应的hashCode值相同（即要储存到同一位置），此时这种现象就称为 Hash冲突。<br>HashMap默认采用了 链地址法 解决Hash冲突问题，即通过类似单链表的方式将 冲突的元素 串起来，搜索时遍历这个链表即可。注意： 如果冲突的Hash越来越多，这个链就会越来越长。</p>
<hr>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src="http://cdn.tycoding.cn/8db4a3bdfb238da1a1c4431d2b6e075c_hd.png" alt="hash冲突与实现原理"><br>这里我们需要了解两个名词：<br>Table: 哈希桶数组（哈希表），存放Node元素，底层是一个Node[] table<br>Node: 节点元素，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（K-V）<br>HashMap内部的一些关键属性需要了解：<br>DEFAULT_INITIAL_CAPACITY: Tabale数组的初始化长度，默认是1 &lt;&lt; 4，2^4 = 16<br>MAXIMUM_CAPACITY: Table数组最高长度，默认为1 &lt;&lt; 30，2^30 = 1073741824<br>DEFAULT_LOAD_FACTOR: 负载因子，当总元素数 &gt; 数组长度 * 负载因子时，Table数组将扩容，默认是0.75<br>TREEIFY_THRESHOLD: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8<br>UNTREEIFY_THRESHOLD: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6<br>MIN_TREEIFY_CAPACITY: 最小树化阀值，当Table中所有元素超过该值，才会进行树化<br>size: 当前HashMap实际存在的键值对数量<br>threshold: HashMap所能容纳的最大数据量的Node（键值对）个数。Node[] table初始化长度length是16，loadFactor负载因子默认是0.75，threshold = length * loadFactor<br>loadFactor: 负载因子，默认是0.17<br>modCount: 记录HashMap内部结构发生变化的次数<br>HashMap内部存在一个NodeTable数组，这个数组的初始化长度是DEFAULT_INITIAL_CAPACITY，他是一个单向链表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int <span class="built_in">hash</span>; //key的Hash值</span><br><span class="line">    final K key; //key</span><br><span class="line">    V value; //value</span><br><span class="line">    Node&lt;K,V&gt; next; //下一个节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考单链表的结构，Table中每个Node节点包含两个部分，Node元素作为节点的header，next指向下一个节点。<strong>这种链式结构的存在正是为了解决Hash冲突</strong></p>
<p>栗子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">"loonycoder"</span>, <span class="string">"18"</span>);</span><br></pre></td></tr></table></figure>
<p>HashMap将根据”loonycoder”这个Key得到其hashCode值，然后经过Hash算法定位到其在HashMap储存的位置，如果两个不同的key定位到了同一个位置，此时就发生了Hash冲突。<br>在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过TREEIFY_THRESHOLD阀值后，会将链表转换为红黑树的实现TreeNode:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">    boolean red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发生<strong>Hash冲突</strong>时，根据HashMap默认采用的 <strong>链地址法</strong>，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。但是 随着Hash冲突越来越多，这个<strong>链将越来越长</strong>，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。<br><img src="http://cdn.tycoding.cn/JDK1.8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="地址链法"></p>
<p><strong>总结</strong><br>到此，我们总结一下HashMap的实现原理：</p>
<ul>
<li>HashMap根据key的hashCode值存储元素。put新元素会遍历链表，根据新元素的key计算hashCode得到散列位置，如果该位置有值再调用equals判断value是否相同，相同就散列到其他位置储存。</li>
<li>HashMap在put新元素时如果遇到key对应的hashCode相同，可能会产生Hash冲突问题。HashMap的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。</li>
<li>如果发生Hash冲突的元素很多，这个 <strong>链</strong> 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（TreeNode）存储元素。</li>
</ul>
<hr>
<h4 id="Collection和Collections的区别？"><a href="#Collection和Collections的区别？" class="headerlink" title="Collection和Collections的区别？"></a>Collection和Collections的区别？</h4><ul>
<li>Collection是集合类的上级接口，继承他的接口主要有Set和List</li>
<li>Collections仅是针对集合类封装的一个工具类，在java.util包下</li>
</ul>
<hr>
<h4 id="Comparable和Comparator的区别？"><a href="#Comparable和Comparator的区别？" class="headerlink" title="Comparable和Comparator的区别？"></a>Comparable和Comparator的区别？</h4><ul>
<li>Comparable接口来自java.lang包，提供compareTo(Object obj) 方法排序</li>
<li>Comparator接口来自java.util包，提供compare(Object obj1, Object obj2)方法排序<br>当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。</li>
</ul>
<h4 id="Java集合框架总结"><a href="#Java集合框架总结" class="headerlink" title="Java集合框架总结"></a>Java集合框架总结</h4><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p><img src="http://cdn.tycoding.cn/QQ20190623-181246.png" alt="Collection"></p>
<p><strong>List</strong></p>
<p>ArrayList: Object数组，线程不安全，查询快，增删慢，效率高<br>Vector: Object数组，线程安全，查询快，增删慢，效率低<br>LinkedList: 双向链表，线程不安全，查询慢，增删快，效率高</p>
<p><strong>Set</strong></p>
<p>HashSet: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素<br>LinkedHashSet: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现<br>TreeSet 有序、唯一，红黑树</p>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p><img src="http://cdn.tycoding.cn/QQ20190623-181259.png" alt="Map"></p>
<ul>
<li>HashMap: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。</li>
<li>LinkedHashMap: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li>
<li>HashTable: 数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题<br>TreeMap: 红黑树</li>
</ul>
<hr>
<h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h3><h4 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h4><ul>
<li>进程是程序的一次执行过程，是系统运行程序的基本单位</li>
<li>线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，<br>在Java中，启用一个main方法就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。</li>
</ul>
<hr>
<h4 id="从JVM角度分析进程和线程的关系？"><a href="#从JVM角度分析进程和线程的关系？" class="headerlink" title="从JVM角度分析进程和线程的关系？"></a>从JVM角度分析进程和线程的关系？</h4><p>根据JVM的内存划分，对于线程而言：多个线程共享进程的堆、方法区资源，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。</p>
<p>也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。</p>
<h5 id="为什么方法区和堆是线程共享区？"><a href="#为什么方法区和堆是线程共享区？" class="headerlink" title="为什么方法区和堆是线程共享区？"></a>为什么方法区和堆是线程共享区？</h5><ul>
<li><strong>方法区（Method Area）</strong> 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 运行时常量池 ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。</li>
<li><strong>堆（Heap）</strong> 堆内存储存了对象实例（比如new关键字创建的实例对象），它是JVM中内存区最大的一块区域。<br>所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。</li>
</ul>
<h5 id="为什么虚拟机栈和本地方法栈是线程独占区？"><a href="#为什么虚拟机栈和本地方法栈是线程独占区？" class="headerlink" title="为什么虚拟机栈和本地方法栈是线程独占区？"></a>为什么虚拟机栈和本地方法栈是线程独占区？</h5><ul>
<li><strong>虚拟机栈</strong>： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。</li>
<li><strong>本地方法栈</strong>： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。</li>
</ul>
<h5 id="程序计数器是什么？"><a href="#程序计数器是什么？" class="headerlink" title="程序计数器是什么？"></a>程序计数器是什么？</h5><p><strong>程序计数器（Program Counter Register）</strong>：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。</p>
<hr>
<h4 id="说说并行和并发的区别？"><a href="#说说并行和并发的区别？" class="headerlink" title="说说并行和并发的区别？"></a>说说并行和并发的区别？</h4><ul>
<li><strong>并行</strong>： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>
<li><strong>并发</strong>： 单位时间内，多个任务同时执行。</li>
</ul>
<hr>
<h4 id="使用多线程可能带来什么问题？"><a href="#使用多线程可能带来什么问题？" class="headerlink" title="使用多线程可能带来什么问题？"></a>使用多线程可能带来什么问题？</h4><p>并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题</p>
<hr>
<h4 id="说说线程的生命周期和状态？"><a href="#说说线程的生命周期和状态？" class="headerlink" title="说说线程的生命周期和状态？"></a>说说线程的生命周期和状态？</h4><table>
<thead>
<tr>
<th align="left">状态名称</th>
<th align="left">状态说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">new</td>
<td align="left">初始状态，线程被创建，但还没有调用start()方法</td>
</tr>
<tr>
<td align="left">runnable</td>
<td align="left">运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”</td>
</tr>
<tr>
<td align="left">blocked</td>
<td align="left">阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td align="left">waiting</td>
<td align="left">等待状态，线程需要等待当前线程或其他线程执行完成</td>
</tr>
<tr>
<td align="left">time_waiting</td>
<td align="left">超时等待状态，他可以实现在指定时间后自动返回</td>
</tr>
<tr>
<td align="left">terminated</td>
<td align="left">终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<p>对应，程序会因为不同代码的执行产生不同的状态，如下图：<br><img src="http://cdn.tycoding.cn/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="线程图"><br>如上，线程创建后将进入NEW（初始）状态，调用start()开始运行，当线程执行wait()方法后，线程将进入WAITING（等待）状态，可以通过wait(long)或join(long)等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED（阻塞）状态。</p>
<hr>
<h4 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h4><p>简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用<strong>随机分配时间片并轮转</strong>的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 <strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<hr>
<h4 id="什么是死锁？如何避免"><a href="#什么是死锁？如何避免" class="headerlink" title="什么是死锁？如何避免?"></a>什么是死锁？如何避免?</h4><p>举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。<br><img src="http://cdn.tycoding.cn/2019-4%E6%AD%BB%E9%94%811.png" alt="死锁"><br>栗子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    private static Object resource1 = new Object();//资源 1</span><br><span class="line">    private static Object resource2 = new Object();//资源 2</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                synchronized (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                synchronized (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure>
<p>线程1以resource1作为同步监视器，即可以轻松获取resource1同时也锁定了resource1，此时调用sleep让线程1等待1秒钟；此时线程2开始执行，他以resource2作为同步监视器同时也锁定了resource2，此时调用sleep让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取resource2时发现resource2已经被线程2锁定了，同理线程2结束等待后想要获取resource1时发现resource1已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。<br>因此产生死锁需要具备以下四个条件：</p>
<p>1、互斥条件：该资源任意一个时刻只能由一个线程占用<br>2、请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放<br>3、不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源<br>4、循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。</p>
<p>避免死锁就要破坏这四个条件中任意一个：<br>1、破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥<br>2、破坏请求与保持条件：一次性申请所有资源<br>3、破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用</p>
<p>解决方案: 修改线程2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    synchronized (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">        synchronized (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"线程 2"</span>).start();</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 1,5,main]get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="说说sleep-方法和wait-方法的区别？"><a href="#说说sleep-方法和wait-方法的区别？" class="headerlink" title="说说sleep()方法和wait()方法的区别？"></a>说说sleep()方法和wait()方法的区别？</h4><p>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong></p>
<ul>
<li>两者都可以暂停线程的执行</li>
<li>wait()通常用于线程间交互/通信，sleep()通常用户暂停执行</li>
<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>
</ul>
<hr>
<h4 id="调用start-方法会执行run-方法，为什么不能直接调用run-方法？"><a href="#调用start-方法会执行run-方法，为什么不能直接调用run-方法？" class="headerlink" title="调用start()方法会执行run()方法，为什么不能直接调用run()方法？"></a>调用start()方法会执行run()方法，为什么不能直接调用run()方法？</h4><p>new一个Thread，线程进入了新建状态；调用start()方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这才是真正的多线程工作。而直接执行run()方法，会吧run()方法当做一个main线程下的一个普通方法去执行，并不会在某个线程中执行他。<br><strong>总结：调用start方法可以启动线程并使线程进入就绪状态，而run()方法只是Thread的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行</strong></p>
<hr>
<h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><p>synchronized关键字解决多个线程之间访问资源的同步性，synchronized关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。<br>synchronized关键字最主要的三种使用方式：</p>
<ul>
<li><p><strong>修饰实例方法</strong>： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象</span><br><span class="line">public synchronized void <span class="function"><span class="title">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>修饰静态方法</strong>： 给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)</span><br><span class="line">public synchronized static void <span class="function"><span class="title">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
